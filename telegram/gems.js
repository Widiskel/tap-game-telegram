/*! For license information please see main.1fc1151c.js.LICENSE.txt */
(() => {
  var e = {
      503: function (e, t, n) {
        var r;
        !(function (s, i) {
          "use strict";
          var o = "function",
            a = "undefined",
            c = "object",
            l = "string",
            u = "model",
            d = "name",
            h = "type",
            p = "vendor",
            f = "version",
            m = "architecture",
            g = "console",
            v = "mobile",
            y = "tablet",
            b = "smarttv",
            w = "wearable",
            S = "embedded",
            _ = "Amazon",
            E = "Apple",
            A = "ASUS",
            T = "BlackBerry",
            P = "Browser",
            I = "Chrome",
            C = "Firefox",
            k = "Google",
            O = "Huawei",
            x = "LG",
            N = "Microsoft",
            R = "Motorola",
            D = "Opera",
            M = "Samsung",
            j = "Sharp",
            L = "Sony",
            U = "Xiaomi",
            F = "Zebra",
            B = "Facebook",
            V = function (e) {
              for (var t = {}, n = 0; n < e.length; n++)
                t[e[n].toUpperCase()] = e[n];
              return t;
            },
            q = function (e, t) {
              return typeof e === l && -1 !== H(t).indexOf(H(e));
            },
            H = function (e) {
              return e.toLowerCase();
            },
            W = function (e, t) {
              if (typeof e === l)
                return (
                  (e = e.replace(/^\s\s*/, "")),
                  typeof t === a ? e : e.substring(0, 350)
                );
            },
            K = function (e, t) {
              for (var n, r, s, a, l, u, d = 0; d < t.length && !l; ) {
                var h = t[d],
                  p = t[d + 1];
                for (n = r = 0; n < h.length && !l; )
                  if ((l = h[n++].exec(e)))
                    for (s = 0; s < p.length; s++)
                      (u = l[++r]),
                        typeof (a = p[s]) === c && a.length > 0
                          ? 2 === a.length
                            ? typeof a[1] == o
                              ? (this[a[0]] = a[1].call(this, u))
                              : (this[a[0]] = a[1])
                            : 3 === a.length
                            ? typeof a[1] !== o || (a[1].exec && a[1].test)
                              ? (this[a[0]] = u ? u.replace(a[1], a[2]) : i)
                              : (this[a[0]] = u ? a[1].call(this, u, a[2]) : i)
                            : 4 === a.length &&
                              (this[a[0]] = u
                                ? a[3].call(this, u.replace(a[1], a[2]))
                                : i)
                          : (this[a] = u || i);
                d += 2;
              }
            },
            z = function (e, t) {
              for (var n in t)
                if (typeof t[n] === c && t[n].length > 0) {
                  for (var r = 0; r < t[n].length; r++)
                    if (q(t[n][r], e)) return "?" === n ? i : n;
                } else if (q(t[n], e)) return "?" === n ? i : n;
              return e;
            },
            G = {
              ME: "4.90",
              "NT 3.11": "NT3.51",
              "NT 4.0": "NT4.0",
              2e3: "NT 5.0",
              XP: ["NT 5.1", "NT 5.2"],
              Vista: "NT 6.0",
              7: "NT 6.1",
              8: "NT 6.2",
              8.1: "NT 6.3",
              10: ["NT 6.4", "NT 10.0"],
              RT: "ARM",
            },
            J = {
              browser: [
                [/\b(?:crmo|crios)\/([\w\.]+)/i],
                [f, [d, "Chrome"]],
                [/edg(?:e|ios|a)?\/([\w\.]+)/i],
                [f, [d, "Edge"]],
                [
                  /(opera mini)\/([-\w\.]+)/i,
                  /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                  /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i,
                ],
                [d, f],
                [/opios[\/ ]+([\w\.]+)/i],
                [f, [d, D + " Mini"]],
                [/\bopr\/([\w\.]+)/i],
                [f, [d, D]],
                [
                  /(kindle)\/([\w\.]+)/i,
                  /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                  /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                  /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                  /(?:ms|\()(ie) ([\w\.]+)/i,
                  /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                  /(weibo)__([\d\.]+)/i,
                ],
                [d, f],
                [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
                [f, [d, "UC" + P]],
                [
                  /microm.+\bqbcore\/([\w\.]+)/i,
                  /\bqbcore\/([\w\.]+).+microm/i,
                ],
                [f, [d, "WeChat(Win) Desktop"]],
                [/micromessenger\/([\w\.]+)/i],
                [f, [d, "WeChat"]],
                [/konqueror\/([\w\.]+)/i],
                [f, [d, "Konqueror"]],
                [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
                [f, [d, "IE"]],
                [/yabrowser\/([\w\.]+)/i],
                [f, [d, "Yandex"]],
                [/(avast|avg)\/([\w\.]+)/i],
                [[d, /(.+)/, "$1 Secure " + P], f],
                [/\bfocus\/([\w\.]+)/i],
                [f, [d, C + " Focus"]],
                [/\bopt\/([\w\.]+)/i],
                [f, [d, D + " Touch"]],
                [/coc_coc\w+\/([\w\.]+)/i],
                [f, [d, "Coc Coc"]],
                [/dolfin\/([\w\.]+)/i],
                [f, [d, "Dolphin"]],
                [/coast\/([\w\.]+)/i],
                [f, [d, D + " Coast"]],
                [/miuibrowser\/([\w\.]+)/i],
                [f, [d, "MIUI " + P]],
                [/fxios\/([-\w\.]+)/i],
                [f, [d, C]],
                [/\bqihu|(qi?ho?o?|360)browser/i],
                [[d, "360 " + P]],
                [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],
                [[d, /(.+)/, "$1 " + P], f],
                [/(comodo_dragon)\/([\w\.]+)/i],
                [[d, /_/g, " "], f],
                [
                  /(electron)\/([\w\.]+) safari/i,
                  /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                  /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i,
                ],
                [d, f],
                [
                  /(metasr)[\/ ]?([\w\.]+)/i,
                  /(lbbrowser)/i,
                  /\[(linkedin)app\]/i,
                ],
                [d],
                [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
                [[d, B], f],
                [
                  /safari (line)\/([\w\.]+)/i,
                  /\b(line)\/([\w\.]+)\/iab/i,
                  /(chromium|instagram)[\/ ]([-\w\.]+)/i,
                ],
                [d, f],
                [/\bgsa\/([\w\.]+) .*safari\//i],
                [f, [d, "GSA"]],
                [/headlesschrome(?:\/([\w\.]+)| )/i],
                [f, [d, I + " Headless"]],
                [/ wv\).+(chrome)\/([\w\.]+)/i],
                [[d, I + " WebView"], f],
                [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
                [f, [d, "Android " + P]],
                [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
                [d, f],
                [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
                [f, [d, "Mobile Safari"]],
                [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
                [f, d],
                [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
                [
                  d,
                  [
                    f,
                    z,
                    {
                      "1.0": "/8",
                      1.2: "/1",
                      1.3: "/3",
                      "2.0": "/412",
                      "2.0.2": "/416",
                      "2.0.3": "/417",
                      "2.0.4": "/419",
                      "?": "/",
                    },
                  ],
                ],
                [/(webkit|khtml)\/([\w\.]+)/i],
                [d, f],
                [/(navigator|netscape\d?)\/([-\w\.]+)/i],
                [[d, "Netscape"], f],
                [/mobile vr; rv:([\w\.]+)\).+firefox/i],
                [f, [d, C + " Reality"]],
                [
                  /ekiohf.+(flow)\/([\w\.]+)/i,
                  /(swiftfox)/i,
                  /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                  /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                  /(firefox)\/([\w\.]+)/i,
                  /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                  /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                  /(links) \(([\w\.]+)/i,
                ],
                [d, f],
                [/(cobalt)\/([\w\.]+)/i],
                [d, [f, /master.|lts./, ""]],
              ],
              cpu: [
                [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
                [[m, "amd64"]],
                [/(ia32(?=;))/i],
                [[m, H]],
                [/((?:i[346]|x)86)[;\)]/i],
                [[m, "ia32"]],
                [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
                [[m, "arm64"]],
                [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
                [[m, "armhf"]],
                [/windows (ce|mobile); ppc;/i],
                [[m, "arm"]],
                [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
                [[m, /ower/, "", H]],
                [/(sun4\w)[;\)]/i],
                [[m, "sparc"]],
                [
                  /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i,
                ],
                [[m, H]],
              ],
              device: [
                [
                  /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i,
                ],
                [u, [p, M], [h, y]],
                [
                  /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
                  /samsung[- ]([-\w]+)/i,
                  /sec-(sgh\w+)/i,
                ],
                [u, [p, M], [h, v]],
                [/((ipod|iphone)\d+,\d+)/i],
                [u, [p, E], [h, v]],
                [/(ipad\d+,\d+)/i],
                [u, [p, E], [h, y]],
                [/\((ip(?:hone|od)[\w ]*);/i],
                [u, [p, E], [h, v]],
                [
                  /\((ipad);[-\w\),; ]+apple/i,
                  /applecoremedia\/[\w\.]+ \((ipad)/i,
                  /\b(ipad)\d\d?,\d\d?[;\]].+ios/i,
                ],
                [u, [p, E], [h, y]],
                [/(macintosh);/i],
                [u, [p, E]],
                [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
                [u, [p, O], [h, y]],
                [
                  /(?:huawei|honor)([-\w ]+)[;\)]/i,
                  /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i,
                ],
                [u, [p, O], [h, v]],
                [
                  /\b(poco[\w ]+)(?: bui|\))/i,
                  /\b; (\w+) build\/hm\1/i,
                  /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                  /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                  /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i,
                ],
                [
                  [u, /_/g, " "],
                  [p, U],
                  [h, v],
                ],
                [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
                [
                  [u, /_/g, " "],
                  [p, U],
                  [h, y],
                ],
                [
                  /; (\w+) bui.+ oppo/i,
                  /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i,
                ],
                [u, [p, "OPPO"], [h, v]],
                [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
                [u, [p, "Vivo"], [h, v]],
                [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
                [u, [p, "Realme"], [h, v]],
                [
                  /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                  /\bmot(?:orola)?[- ](\w*)/i,
                  /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i,
                ],
                [u, [p, R], [h, v]],
                [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
                [u, [p, R], [h, y]],
                [
                  /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i,
                ],
                [u, [p, x], [h, y]],
                [
                  /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                  /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                  /\blg-?([\d\w]+) bui/i,
                ],
                [u, [p, x], [h, v]],
                [
                  /(ideatab[-\w ]+)/i,
                  /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i,
                ],
                [u, [p, "Lenovo"], [h, y]],
                [
                  /(?:maemo|nokia).*(n900|lumia \d+)/i,
                  /nokia[-_ ]?([-\w\.]*)/i,
                ],
                [
                  [u, /_/g, " "],
                  [p, "Nokia"],
                  [h, v],
                ],
                [/(pixel c)\b/i],
                [u, [p, k], [h, y]],
                [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
                [u, [p, k], [h, v]],
                [
                  /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i,
                ],
                [u, [p, L], [h, v]],
                [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
                [
                  [u, "Xperia Tablet"],
                  [p, L],
                  [h, y],
                ],
                [
                  / (kb2005|in20[12]5|be20[12][59])\b/i,
                  /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i,
                ],
                [u, [p, "OnePlus"], [h, v]],
                [
                  /(alexa)webm/i,
                  /(kf[a-z]{2}wi)( bui|\))/i,
                  /(kf[a-z]+)( bui|\)).+silk\//i,
                ],
                [u, [p, _], [h, y]],
                [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
                [
                  [u, /(.+)/g, "Fire Phone $1"],
                  [p, _],
                  [h, v],
                ],
                [/(playbook);[-\w\),; ]+(rim)/i],
                [u, p, [h, y]],
                [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
                [u, [p, T], [h, v]],
                [
                  /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i,
                ],
                [u, [p, A], [h, y]],
                [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
                [u, [p, A], [h, v]],
                [/(nexus 9)/i],
                [u, [p, "HTC"], [h, y]],
                [
                  /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                  /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                  /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i,
                ],
                [p, [u, /_/g, " "], [h, v]],
                [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
                [u, [p, "Acer"], [h, y]],
                [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
                [u, [p, "Meizu"], [h, v]],
                [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
                [u, [p, j], [h, v]],
                [
                  /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                  /(hp) ([\w ]+\w)/i,
                  /(asus)-?(\w+)/i,
                  /(microsoft); (lumia[\w ]+)/i,
                  /(lenovo)[-_ ]?([-\w]+)/i,
                  /(jolla)/i,
                  /(oppo) ?([\w ]+) bui/i,
                ],
                [p, u, [h, v]],
                [
                  /(archos) (gamepad2?)/i,
                  /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                  /(kindle)\/([\w\.]+)/i,
                  /(nook)[\w ]+build\/(\w+)/i,
                  /(dell) (strea[kpr\d ]*[\dko])/i,
                  /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                  /(trinity)[- ]*(t\d{3}) bui/i,
                  /(gigaset)[- ]+(q\w{1,9}) bui/i,
                  /(vodafone) ([\w ]+)(?:\)| bui)/i,
                ],
                [p, u, [h, y]],
                [/(surface duo)/i],
                [u, [p, N], [h, y]],
                [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
                [u, [p, "Fairphone"], [h, v]],
                [/(u304aa)/i],
                [u, [p, "AT&T"], [h, v]],
                [/\bsie-(\w*)/i],
                [u, [p, "Siemens"], [h, v]],
                [/\b(rct\w+) b/i],
                [u, [p, "RCA"], [h, y]],
                [/\b(venue[\d ]{2,7}) b/i],
                [u, [p, "Dell"], [h, y]],
                [/\b(q(?:mv|ta)\w+) b/i],
                [u, [p, "Verizon"], [h, y]],
                [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
                [u, [p, "Barnes & Noble"], [h, y]],
                [/\b(tm\d{3}\w+) b/i],
                [u, [p, "NuVision"], [h, y]],
                [/\b(k88) b/i],
                [u, [p, "ZTE"], [h, y]],
                [/\b(nx\d{3}j) b/i],
                [u, [p, "ZTE"], [h, v]],
                [/\b(gen\d{3}) b.+49h/i],
                [u, [p, "Swiss"], [h, v]],
                [/\b(zur\d{3}) b/i],
                [u, [p, "Swiss"], [h, y]],
                [/\b((zeki)?tb.*\b) b/i],
                [u, [p, "Zeki"], [h, y]],
                [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
                [[p, "Dragon Touch"], u, [h, y]],
                [/\b(ns-?\w{0,9}) b/i],
                [u, [p, "Insignia"], [h, y]],
                [/\b((nxa|next)-?\w{0,9}) b/i],
                [u, [p, "NextBook"], [h, y]],
                [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
                [[p, "Voice"], u, [h, v]],
                [/\b(lvtel\-)?(v1[12]) b/i],
                [[p, "LvTel"], u, [h, v]],
                [/\b(ph-1) /i],
                [u, [p, "Essential"], [h, v]],
                [/\b(v(100md|700na|7011|917g).*\b) b/i],
                [u, [p, "Envizen"], [h, y]],
                [/\b(trio[-\w\. ]+) b/i],
                [u, [p, "MachSpeed"], [h, y]],
                [/\btu_(1491) b/i],
                [u, [p, "Rotor"], [h, y]],
                [/(shield[\w ]+) b/i],
                [u, [p, "Nvidia"], [h, y]],
                [/(sprint) (\w+)/i],
                [p, u, [h, v]],
                [/(kin\.[onetw]{3})/i],
                [
                  [u, /\./g, " "],
                  [p, N],
                  [h, v],
                ],
                [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
                [u, [p, F], [h, y]],
                [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
                [u, [p, F], [h, v]],
                [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
                [p, u, [h, g]],
                [/droid.+; (shield) bui/i],
                [u, [p, "Nvidia"], [h, g]],
                [/(playstation [345portablevi]+)/i],
                [u, [p, L], [h, g]],
                [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
                [u, [p, N], [h, g]],
                [/smart-tv.+(samsung)/i],
                [p, [h, b]],
                [/hbbtv.+maple;(\d+)/i],
                [
                  [u, /^/, "SmartTV"],
                  [p, M],
                  [h, b],
                ],
                [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
                [
                  [p, x],
                  [h, b],
                ],
                [/(apple) ?tv/i],
                [p, [u, E + " TV"], [h, b]],
                [/crkey/i],
                [
                  [u, I + "cast"],
                  [p, k],
                  [h, b],
                ],
                [/droid.+aft(\w)( bui|\))/i],
                [u, [p, _], [h, b]],
                [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
                [u, [p, j], [h, b]],
                [/(bravia[\w ]+)( bui|\))/i],
                [u, [p, L], [h, b]],
                [/(mitv-\w{5}) bui/i],
                [u, [p, U], [h, b]],
                [
                  /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                  /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i,
                ],
                [
                  [p, W],
                  [u, W],
                  [h, b],
                ],
                [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
                [[h, b]],
                [/((pebble))app/i],
                [p, u, [h, w]],
                [/droid.+; (glass) \d/i],
                [u, [p, k], [h, w]],
                [/droid.+; (wt63?0{2,3})\)/i],
                [u, [p, F], [h, w]],
                [/(quest( 2)?)/i],
                [u, [p, B], [h, w]],
                [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
                [p, [h, S]],
                [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
                [u, [h, v]],
                [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
                [u, [h, y]],
                [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
                [[h, y]],
                [
                  /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i,
                ],
                [[h, v]],
                [/(android[-\w\. ]{0,9});.+buil/i],
                [u, [p, "Generic"]],
              ],
              engine: [
                [/windows.+ edge\/([\w\.]+)/i],
                [f, [d, "EdgeHTML"]],
                [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
                [f, [d, "Blink"]],
                [
                  /(presto)\/([\w\.]+)/i,
                  /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                  /ekioh(flow)\/([\w\.]+)/i,
                  /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                  /(icab)[\/ ]([23]\.[\d\.]+)/i,
                ],
                [d, f],
                [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
                [f, d],
              ],
              os: [
                [/microsoft (windows) (vista|xp)/i],
                [d, f],
                [
                  /(windows) nt 6\.2; (arm)/i,
                  /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                  /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
                ],
                [d, [f, z, G]],
                [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
                [
                  [d, "Windows"],
                  [f, z, G],
                ],
                [
                  /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                  /cfnetwork\/.+darwin/i,
                ],
                [
                  [f, /_/g, "."],
                  [d, "iOS"],
                ],
                [
                  /(mac os x) ?([\w\. ]*)/i,
                  /(macintosh|mac_powerpc\b)(?!.+haiku)/i,
                ],
                [
                  [d, "Mac OS"],
                  [f, /_/g, "."],
                ],
                [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
                [f, d],
                [
                  /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                  /(blackberry)\w*\/([\w\.]*)/i,
                  /(tizen|kaios)[\/ ]([\w\.]+)/i,
                  /\((series40);/i,
                ],
                [d, f],
                [/\(bb(10);/i],
                [f, [d, T]],
                [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
                [f, [d, "Symbian"]],
                [
                  /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i,
                ],
                [f, [d, C + " OS"]],
                [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
                [f, [d, "webOS"]],
                [/crkey\/([\d\.]+)/i],
                [f, [d, I + "cast"]],
                [/(cros) [\w]+ ([\w\.]+\w)/i],
                [[d, "Chromium OS"], f],
                [
                  /(nintendo|playstation) ([wids345portablevuch]+)/i,
                  /(xbox); +xbox ([^\);]+)/i,
                  /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                  /(mint)[\/\(\) ]?(\w*)/i,
                  /(mageia|vectorlinux)[; ]/i,
                  /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                  /(hurd|linux) ?([\w\.]*)/i,
                  /(gnu) ?([\w\.]*)/i,
                  /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                  /(haiku) (\w+)/i,
                ],
                [d, f],
                [/(sunos) ?([\w\.\d]*)/i],
                [[d, "Solaris"], f],
                [
                  /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                  /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                  /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
                  /(unix) ?([\w\.]*)/i,
                ],
                [d, f],
              ],
            },
            Q = function (e, t) {
              if ((typeof e === c && ((t = e), (e = i)), !(this instanceof Q)))
                return new Q(e, t).getResult();
              var n =
                  e ||
                  (typeof s !== a && s.navigator && s.navigator.userAgent
                    ? s.navigator.userAgent
                    : ""),
                r = t
                  ? (function (e, t) {
                      var n = {};
                      for (var r in e)
                        t[r] && t[r].length % 2 === 0
                          ? (n[r] = t[r].concat(e[r]))
                          : (n[r] = e[r]);
                      return n;
                    })(J, t)
                  : J;
              return (
                (this.getBrowser = function () {
                  var e,
                    t = {};
                  return (
                    (t[d] = i),
                    (t[f] = i),
                    K.call(t, n, r.browser),
                    (t.major =
                      typeof (e = t.version) === l
                        ? e.replace(/[^\d\.]/g, "").split(".")[0]
                        : i),
                    t
                  );
                }),
                (this.getCPU = function () {
                  var e = {};
                  return (e[m] = i), K.call(e, n, r.cpu), e;
                }),
                (this.getDevice = function () {
                  var e = {};
                  return (
                    (e[p] = i),
                    (e[u] = i),
                    (e[h] = i),
                    K.call(e, n, r.device),
                    e
                  );
                }),
                (this.getEngine = function () {
                  var e = {};
                  return (e[d] = i), (e[f] = i), K.call(e, n, r.engine), e;
                }),
                (this.getOS = function () {
                  var e = {};
                  return (e[d] = i), (e[f] = i), K.call(e, n, r.os), e;
                }),
                (this.getResult = function () {
                  return {
                    ua: this.getUA(),
                    browser: this.getBrowser(),
                    engine: this.getEngine(),
                    os: this.getOS(),
                    device: this.getDevice(),
                    cpu: this.getCPU(),
                  };
                }),
                (this.getUA = function () {
                  return n;
                }),
                (this.setUA = function (e) {
                  return (
                    (n = typeof e === l && e.length > 350 ? W(e, 350) : e), this
                  );
                }),
                this.setUA(n),
                this
              );
            };
          (Q.VERSION = "0.7.33"),
            (Q.BROWSER = V([d, f, "major"])),
            (Q.CPU = V([m])),
            (Q.DEVICE = V([u, p, h, g, v, b, y, w, S])),
            (Q.ENGINE = Q.OS = V([d, f])),
            typeof t !== a
              ? (e.exports && (t = e.exports = Q), (t.UAParser = Q))
              : n.amdO
              ? (r = function () {
                  return Q;
                }.call(t, n, t, e)) === i || (e.exports = r)
              : typeof s !== a && (s.UAParser = Q);
          var Y = typeof s !== a && (s.jQuery || s.Zepto);
          if (Y && !Y.ua) {
            var X = new Q();
            (Y.ua = X.getResult()),
              (Y.ua.get = function () {
                return X.getUA();
              }),
              (Y.ua.set = function (e) {
                X.setUA(e);
                var t = X.getResult();
                for (var n in t) Y.ua[n] = t[n];
              });
          }
        })("object" === typeof window ? window : this);
      },
      274: (e, t, n) => {
        var r = n(757),
          s = "";
        "undefined" !== typeof navigator && (s = navigator.userAgent);
        var i = "";
        "undefined" !== typeof document && (i = document.referrer),
          (e.exports = r(s, i));
      },
      757: (e) => {
        e.exports = function (e, t) {
          var n,
            r,
            s,
            i,
            o,
            a,
            c = !1;
          function l(t) {
            var n = new RegExp(t + "[^\\d._;]+[\\d._]+"),
              r = e.match(n);
            return r
              ? r[0].substring(t.length + 1).replace(/_/g, ".")
              : "x.x.x";
          }
          var u = !1,
            d = !1,
            h = !1;
          try {
            var p,
              f = {
                Linux: "Android",
                iPhone: "iPhone OS",
                iPad: "iPhone OS",
                iPod: "iPhone OS",
                Windows: "Windows",
                Macintosh: "Mac OS X",
                Android: "Android",
                X11: "Linux",
                "SMART-TV": "Linux",
                compatible: "Windows",
                connectpro: "Windows",
                osmeta: "iPhone OS",
              },
              m = e.split(/; | \(|\) /),
              g = 0;
            do {
              if (g >= m.length) break;
              var v = m[g++],
                y = v.indexOf(" ");
              s = f[(p = -1 === y ? v : v.substring(0, y))];
            } while (!s);
            if (s) {
              i = l({ iPad: "OS", osmeta: "osmeta" }[p] || s);
            } else (s = "UNKNOWN"), (i = "x.x.x");
            var b,
              w = [
                "Trident",
                "Edge",
                "Firefox",
                "Chrome",
                "Safari",
                "AppleWebKit",
              ],
              S = 0;
            do {
              if (S >= w.length) break;
              o = w[S++];
              var _ = new RegExp(o + "/[\\d.]+"),
                E = e.match(_);
              E && (b = E[0]);
            } while (!b);
            if (
              (b
                ? (a = b.substring(b.indexOf("/") + 1))
                : ((o = "UNKNOWN"), (a = "x.x.x")),
              "Trident" === o)
            ) {
              o = "Internet Explorer";
              var A = a.substring(0, a.indexOf("."));
              a = Math.min(11, parseInt(A) + 4) + ".0";
            }
            d = "Android" === s;
            var T = (u = "iPhone OS" === s) || d;
            if (e.match("FBAN")) {
              var P = new RegExp("FBAN/[^ ;]+"),
                I = e.match(P);
              (n = I ? I[0].substring(5) : "UNKNOWN"),
                (r = l("FBAV")),
                "MessengerForiOS" === n
                  ? (n = "MESSENGER")
                  : ("x.x.x" === i && (i = l("FBSV")),
                    "FBIOS" === n
                      ? ((s = "iPhone OS"), (u = !0))
                      : "FB4A" === n
                      ? ((s = "Android"), (d = !0))
                      : "FBWinPhone" === n &&
                        ((s = "Windows"),
                        (i = l("FBSV")),
                        (u = !1),
                        (d = !1),
                        (h = !0)),
                    n.match(/^FB/) && (n = "FACEBOOK"));
            } else
              T && e.match(" Line/")
                ? ((n = "LINE"), (r = l("Line")))
                : -1 !== t.indexOf("www.messenger.com")
                ? ((n = "MESSENGER"), (r = "x.x.x"))
                : -1 !== t.indexOf(".facebook.com")
                ? ((n = "FACEBOOK"), (r = "x.x.x"))
                : ((n = "UNKNOWN"), (r = "x.x.x"));
          } catch (C) {
            (c = !0),
              (s = "UNKNOWN"),
              (i = "x.x.x"),
              (o = "UNKNOWN"),
              (a = "x.x.x"),
              (n = "UNKNOWN"),
              (r = "x.x.x"),
              (u = !1),
              (d = !1),
              (h = !1);
          }
          return {
            string: e,
            referrer: t,
            parsingFailed: c,
            isMobile: u || d || h,
            os: {
              name: s,
              version: i,
              major: i.split(".")[0],
              isIOS: u,
              isAndroid: d,
              isWindowsPhone: h,
            },
            browser: { name: o, version: a, major: a.split(".")[0] },
            app: { name: n, version: r, major: r.split(".")[0] },
          };
        };
      },
      79: function (e, t, n) {
        var r;
        !(function (s) {
          "use strict";
          function i(e, t) {
            var n = (65535 & e) + (65535 & t);
            return (((e >> 16) + (t >> 16) + (n >> 16)) << 16) | (65535 & n);
          }
          function o(e, t, n, r, s, o) {
            return i(
              ((a = i(i(t, e), i(r, o))) << (c = s)) | (a >>> (32 - c)),
              n
            );
            var a, c;
          }
          function a(e, t, n, r, s, i, a) {
            return o((t & n) | (~t & r), e, t, s, i, a);
          }
          function c(e, t, n, r, s, i, a) {
            return o((t & r) | (n & ~r), e, t, s, i, a);
          }
          function l(e, t, n, r, s, i, a) {
            return o(t ^ n ^ r, e, t, s, i, a);
          }
          function u(e, t, n, r, s, i, a) {
            return o(n ^ (t | ~r), e, t, s, i, a);
          }
          function d(e, t) {
            var n, r, s, o, d;
            (e[t >> 5] |= 128 << t % 32), (e[14 + (((t + 64) >>> 9) << 4)] = t);
            var h = 1732584193,
              p = -271733879,
              f = -1732584194,
              m = 271733878;
            for (n = 0; n < e.length; n += 16)
              (r = h),
                (s = p),
                (o = f),
                (d = m),
                (h = a(h, p, f, m, e[n], 7, -680876936)),
                (m = a(m, h, p, f, e[n + 1], 12, -389564586)),
                (f = a(f, m, h, p, e[n + 2], 17, 606105819)),
                (p = a(p, f, m, h, e[n + 3], 22, -1044525330)),
                (h = a(h, p, f, m, e[n + 4], 7, -176418897)),
                (m = a(m, h, p, f, e[n + 5], 12, 1200080426)),
                (f = a(f, m, h, p, e[n + 6], 17, -1473231341)),
                (p = a(p, f, m, h, e[n + 7], 22, -45705983)),
                (h = a(h, p, f, m, e[n + 8], 7, 1770035416)),
                (m = a(m, h, p, f, e[n + 9], 12, -1958414417)),
                (f = a(f, m, h, p, e[n + 10], 17, -42063)),
                (p = a(p, f, m, h, e[n + 11], 22, -1990404162)),
                (h = a(h, p, f, m, e[n + 12], 7, 1804603682)),
                (m = a(m, h, p, f, e[n + 13], 12, -40341101)),
                (f = a(f, m, h, p, e[n + 14], 17, -1502002290)),
                (h = c(
                  h,
                  (p = a(p, f, m, h, e[n + 15], 22, 1236535329)),
                  f,
                  m,
                  e[n + 1],
                  5,
                  -165796510
                )),
                (m = c(m, h, p, f, e[n + 6], 9, -1069501632)),
                (f = c(f, m, h, p, e[n + 11], 14, 643717713)),
                (p = c(p, f, m, h, e[n], 20, -373897302)),
                (h = c(h, p, f, m, e[n + 5], 5, -701558691)),
                (m = c(m, h, p, f, e[n + 10], 9, 38016083)),
                (f = c(f, m, h, p, e[n + 15], 14, -660478335)),
                (p = c(p, f, m, h, e[n + 4], 20, -405537848)),
                (h = c(h, p, f, m, e[n + 9], 5, 568446438)),
                (m = c(m, h, p, f, e[n + 14], 9, -1019803690)),
                (f = c(f, m, h, p, e[n + 3], 14, -187363961)),
                (p = c(p, f, m, h, e[n + 8], 20, 1163531501)),
                (h = c(h, p, f, m, e[n + 13], 5, -1444681467)),
                (m = c(m, h, p, f, e[n + 2], 9, -51403784)),
                (f = c(f, m, h, p, e[n + 7], 14, 1735328473)),
                (h = l(
                  h,
                  (p = c(p, f, m, h, e[n + 12], 20, -1926607734)),
                  f,
                  m,
                  e[n + 5],
                  4,
                  -378558
                )),
                (m = l(m, h, p, f, e[n + 8], 11, -2022574463)),
                (f = l(f, m, h, p, e[n + 11], 16, 1839030562)),
                (p = l(p, f, m, h, e[n + 14], 23, -35309556)),
                (h = l(h, p, f, m, e[n + 1], 4, -1530992060)),
                (m = l(m, h, p, f, e[n + 4], 11, 1272893353)),
                (f = l(f, m, h, p, e[n + 7], 16, -155497632)),
                (p = l(p, f, m, h, e[n + 10], 23, -1094730640)),
                (h = l(h, p, f, m, e[n + 13], 4, 681279174)),
                (m = l(m, h, p, f, e[n], 11, -358537222)),
                (f = l(f, m, h, p, e[n + 3], 16, -722521979)),
                (p = l(p, f, m, h, e[n + 6], 23, 76029189)),
                (h = l(h, p, f, m, e[n + 9], 4, -640364487)),
                (m = l(m, h, p, f, e[n + 12], 11, -421815835)),
                (f = l(f, m, h, p, e[n + 15], 16, 530742520)),
                (h = u(
                  h,
                  (p = l(p, f, m, h, e[n + 2], 23, -995338651)),
                  f,
                  m,
                  e[n],
                  6,
                  -198630844
                )),
                (m = u(m, h, p, f, e[n + 7], 10, 1126891415)),
                (f = u(f, m, h, p, e[n + 14], 15, -1416354905)),
                (p = u(p, f, m, h, e[n + 5], 21, -57434055)),
                (h = u(h, p, f, m, e[n + 12], 6, 1700485571)),
                (m = u(m, h, p, f, e[n + 3], 10, -1894986606)),
                (f = u(f, m, h, p, e[n + 10], 15, -1051523)),
                (p = u(p, f, m, h, e[n + 1], 21, -2054922799)),
                (h = u(h, p, f, m, e[n + 8], 6, 1873313359)),
                (m = u(m, h, p, f, e[n + 15], 10, -30611744)),
                (f = u(f, m, h, p, e[n + 6], 15, -1560198380)),
                (p = u(p, f, m, h, e[n + 13], 21, 1309151649)),
                (h = u(h, p, f, m, e[n + 4], 6, -145523070)),
                (m = u(m, h, p, f, e[n + 11], 10, -1120210379)),
                (f = u(f, m, h, p, e[n + 2], 15, 718787259)),
                (p = u(p, f, m, h, e[n + 9], 21, -343485551)),
                (h = i(h, r)),
                (p = i(p, s)),
                (f = i(f, o)),
                (m = i(m, d));
            return [h, p, f, m];
          }
          function h(e) {
            var t,
              n = "",
              r = 32 * e.length;
            for (t = 0; t < r; t += 8)
              n += String.fromCharCode((e[t >> 5] >>> t % 32) & 255);
            return n;
          }
          function p(e) {
            var t,
              n = [];
            for (n[(e.length >> 2) - 1] = void 0, t = 0; t < n.length; t += 1)
              n[t] = 0;
            var r = 8 * e.length;
            for (t = 0; t < r; t += 8)
              n[t >> 5] |= (255 & e.charCodeAt(t / 8)) << t % 32;
            return n;
          }
          function f(e) {
            var t,
              n,
              r = "0123456789abcdef",
              s = "";
            for (n = 0; n < e.length; n += 1)
              (t = e.charCodeAt(n)),
                (s += r.charAt((t >>> 4) & 15) + r.charAt(15 & t));
            return s;
          }
          function m(e) {
            return unescape(encodeURIComponent(e));
          }
          function g(e) {
            return (function (e) {
              return h(d(p(e), 8 * e.length));
            })(m(e));
          }
          function v(e, t) {
            return (function (e, t) {
              var n,
                r,
                s = p(e),
                i = [],
                o = [];
              for (
                i[15] = o[15] = void 0,
                  s.length > 16 && (s = d(s, 8 * e.length)),
                  n = 0;
                n < 16;
                n += 1
              )
                (i[n] = 909522486 ^ s[n]), (o[n] = 1549556828 ^ s[n]);
              return (
                (r = d(i.concat(p(t)), 512 + 8 * t.length)),
                h(d(o.concat(r), 640))
              );
            })(m(e), m(t));
          }
          function y(e, t, n) {
            return t ? (n ? v(t, e) : f(v(t, e))) : n ? g(e) : f(g(e));
          }
          void 0 ===
            (r = function () {
              return y;
            }.call(t, n, t, e)) || (e.exports = r);
        })();
      },
      424: (e, t, n) => {
        "use strict";
        const r =
            "undefined" !== typeof self
              ? self
              : "undefined" !== typeof window
              ? window
              : "undefined" !== typeof n.g
              ? n.g
              : void 0,
          s = (e) => async (t, n) => {
            "string" === typeof t && (t = new r.TextEncoder().encode(t)),
              (n = { outputFormat: "hex", ...n });
            const s = await r.crypto.subtle.digest(e, t);
            return "hex" === n.outputFormat
              ? ((e) => {
                  const t = new DataView(e);
                  let n = "";
                  for (let r = 0; r < t.byteLength; r += 4)
                    n += t.getUint32(r).toString(16).padStart(8, "0");
                  return n;
                })(s)
              : s;
          };
        s("SHA-1"), (t.sc = s("SHA-256")), s("SHA-384"), s("SHA-512");
      },
      122: (e) => {
        "use strict";
        e.exports = function e(t, n) {
          if (t === n) return !0;
          if (t && n && "object" == typeof t && "object" == typeof n) {
            if (t.constructor !== n.constructor) return !1;
            var r, s, i;
            if (Array.isArray(t)) {
              if ((r = t.length) != n.length) return !1;
              for (s = r; 0 !== s--; ) if (!e(t[s], n[s])) return !1;
              return !0;
            }
            if (t.constructor === RegExp)
              return t.source === n.source && t.flags === n.flags;
            if (t.valueOf !== Object.prototype.valueOf)
              return t.valueOf() === n.valueOf();
            if (t.toString !== Object.prototype.toString)
              return t.toString() === n.toString();
            if ((r = (i = Object.keys(t)).length) !== Object.keys(n).length)
              return !1;
            for (s = r; 0 !== s--; )
              if (!Object.prototype.hasOwnProperty.call(n, i[s])) return !1;
            for (s = r; 0 !== s--; ) {
              var o = i[s];
              if (!e(t[o], n[o])) return !1;
            }
            return !0;
          }
          return t !== t && n !== n;
        };
      },
      167: (e, t, n) => {
        n(953), (e.exports = self.fetch.bind(self));
      },
      151: function (e, t, n) {
        var r;
        "undefined" != typeof self && self,
          (e.exports =
            ((r = n(43)),
            (function (e) {
              var t = {};
              function n(r) {
                if (t[r]) return t[r].exports;
                var s = (t[r] = { i: r, l: !1, exports: {} });
                return (
                  e[r].call(s.exports, s, s.exports, n), (s.l = !0), s.exports
                );
              }
              return (
                (n.m = e),
                (n.c = t),
                (n.d = function (e, t, r) {
                  n.o(e, t) ||
                    Object.defineProperty(e, t, { enumerable: !0, get: r });
                }),
                (n.r = function (e) {
                  "undefined" != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(e, Symbol.toStringTag, {
                      value: "Module",
                    }),
                    Object.defineProperty(e, "__esModule", { value: !0 });
                }),
                (n.t = function (e, t) {
                  if ((1 & t && (e = n(e)), 8 & t)) return e;
                  if (4 & t && "object" == typeof e && e && e.__esModule)
                    return e;
                  var r = Object.create(null);
                  if (
                    (n.r(r),
                    Object.defineProperty(r, "default", {
                      enumerable: !0,
                      value: e,
                    }),
                    2 & t && "string" != typeof e)
                  )
                    for (var s in e)
                      n.d(
                        r,
                        s,
                        function (t) {
                          return e[t];
                        }.bind(null, s)
                      );
                  return r;
                }),
                (n.n = function (e) {
                  var t =
                    e && e.__esModule
                      ? function () {
                          return e.default;
                        }
                      : function () {
                          return e;
                        };
                  return n.d(t, "a", t), t;
                }),
                (n.o = function (e, t) {
                  return Object.prototype.hasOwnProperty.call(e, t);
                }),
                (n.p = ""),
                n((n.s = 2))
              );
            })([
              function (e, t) {
                e.exports = r;
              },
              function (e, t, n) {
                "use strict";
                var r = {
                  linear: function (e, t, n, r) {
                    return ((n - t) * e) / r + t;
                  },
                  easeInQuad: function (e, t, n, r) {
                    return (n - t) * (e /= r) * e + t;
                  },
                  easeOutQuad: function (e, t, n, r) {
                    return -(n - t) * (e /= r) * (e - 2) + t;
                  },
                  easeInOutQuad: function (e, t, n, r) {
                    var s = n - t;
                    return (e /= r / 2) < 1
                      ? (s / 2) * e * e + t
                      : (-s / 2) * (--e * (e - 2) - 1) + t;
                  },
                  easeInCubic: function (e, t, n, r) {
                    return (n - t) * (e /= r) * e * e + t;
                  },
                  easeOutCubic: function (e, t, n, r) {
                    return (n - t) * ((e = e / r - 1) * e * e + 1) + t;
                  },
                  easeInOutCubic: function (e, t, n, r) {
                    var s = n - t;
                    return (e /= r / 2) < 1
                      ? (s / 2) * e * e * e + t
                      : (s / 2) * ((e -= 2) * e * e + 2) + t;
                  },
                  easeInQuart: function (e, t, n, r) {
                    return (n - t) * (e /= r) * e * e * e + t;
                  },
                  easeOutQuart: function (e, t, n, r) {
                    return -(n - t) * ((e = e / r - 1) * e * e * e - 1) + t;
                  },
                  easeInOutQuart: function (e, t, n, r) {
                    var s = n - t;
                    return (e /= r / 2) < 1
                      ? (s / 2) * e * e * e * e + t
                      : (-s / 2) * ((e -= 2) * e * e * e - 2) + t;
                  },
                  easeInQuint: function (e, t, n, r) {
                    return (n - t) * (e /= r) * e * e * e * e + t;
                  },
                  easeOutQuint: function (e, t, n, r) {
                    return (n - t) * ((e = e / r - 1) * e * e * e * e + 1) + t;
                  },
                  easeInOutQuint: function (e, t, n, r) {
                    var s = n - t;
                    return (e /= r / 2) < 1
                      ? (s / 2) * e * e * e * e * e + t
                      : (s / 2) * ((e -= 2) * e * e * e * e + 2) + t;
                  },
                  easeInSine: function (e, t, n, r) {
                    var s = n - t;
                    return -s * Math.cos((e / r) * (Math.PI / 2)) + s + t;
                  },
                  easeOutSine: function (e, t, n, r) {
                    return (n - t) * Math.sin((e / r) * (Math.PI / 2)) + t;
                  },
                  easeInOutSine: function (e, t, n, r) {
                    return (
                      (-(n - t) / 2) * (Math.cos((Math.PI * e) / r) - 1) + t
                    );
                  },
                  easeInExpo: function (e, t, n, r) {
                    return 0 == e
                      ? t
                      : (n - t) * Math.pow(2, 10 * (e / r - 1)) + t;
                  },
                  easeOutExpo: function (e, t, n, r) {
                    var s = n - t;
                    return e == r
                      ? t + s
                      : s * (1 - Math.pow(2, (-10 * e) / r)) + t;
                  },
                  easeInOutExpo: function (e, t, n, r) {
                    var s = n - t;
                    return 0 === e
                      ? t
                      : e === r
                      ? t + s
                      : (e /= r / 2) < 1
                      ? (s / 2) * Math.pow(2, 10 * (e - 1)) + t
                      : (s / 2) * (2 - Math.pow(2, -10 * --e)) + t;
                  },
                  easeInCirc: function (e, t, n, r) {
                    return -(n - t) * (Math.sqrt(1 - (e /= r) * e) - 1) + t;
                  },
                  easeOutCirc: function (e, t, n, r) {
                    return (n - t) * Math.sqrt(1 - (e = e / r - 1) * e) + t;
                  },
                  easeInOutCirc: function (e, t, n, r) {
                    var s = n - t;
                    return (e /= r / 2) < 1
                      ? (-s / 2) * (Math.sqrt(1 - e * e) - 1) + t
                      : (s / 2) * (Math.sqrt(1 - (e -= 2) * e) + 1) + t;
                  },
                  easeInElastic: function (e, t, n, r) {
                    var s,
                      i,
                      o,
                      a = n - t;
                    return (
                      (o = 1.70158),
                      0 === e
                        ? t
                        : 1 == (e /= r)
                        ? t + a
                        : ((i = 0) || (i = 0.3 * r),
                          (s = a) < Math.abs(a)
                            ? ((s = a), (o = i / 4))
                            : (o = (i / (2 * Math.PI)) * Math.asin(a / s)),
                          -s *
                            Math.pow(2, 10 * (e -= 1)) *
                            Math.sin(((e * r - o) * (2 * Math.PI)) / i) +
                            t)
                    );
                  },
                  easeOutElastic: function (e, t, n, r) {
                    var s,
                      i,
                      o,
                      a = n - t;
                    return (
                      (o = 1.70158),
                      0 === e
                        ? t
                        : 1 == (e /= r)
                        ? t + a
                        : ((i = 0) || (i = 0.3 * r),
                          (s = a) < Math.abs(a)
                            ? ((s = a), (o = i / 4))
                            : (o = (i / (2 * Math.PI)) * Math.asin(a / s)),
                          s *
                            Math.pow(2, -10 * e) *
                            Math.sin(((e * r - o) * (2 * Math.PI)) / i) +
                            a +
                            t)
                    );
                  },
                  easeInOutElastic: function (e, t, n, r) {
                    var s,
                      i,
                      o,
                      a = n - t;
                    return (
                      (o = 1.70158),
                      0 === e
                        ? t
                        : 2 == (e /= r / 2)
                        ? t + a
                        : ((i = 0) || (i = r * (0.3 * 1.5)),
                          (s = a) < Math.abs(a)
                            ? ((s = a), (o = i / 4))
                            : (o = (i / (2 * Math.PI)) * Math.asin(a / s)),
                          e < 1
                            ? s *
                                Math.pow(2, 10 * (e -= 1)) *
                                Math.sin(((e * r - o) * (2 * Math.PI)) / i) *
                                -0.5 +
                              t
                            : s *
                                Math.pow(2, -10 * (e -= 1)) *
                                Math.sin(((e * r - o) * (2 * Math.PI)) / i) *
                                0.5 +
                              a +
                              t)
                    );
                  },
                  easeInBack: function (e, t, n, r, s) {
                    return (
                      void 0 === s && (s = 1.70158),
                      (n - t) * (e /= r) * e * ((s + 1) * e - s) + t
                    );
                  },
                  easeOutBack: function (e, t, n, r, s) {
                    return (
                      void 0 === s && (s = 1.70158),
                      (n - t) * ((e = e / r - 1) * e * ((s + 1) * e + s) + 1) +
                        t
                    );
                  },
                  easeInOutBack: function (e, t, n, r, s) {
                    var i = n - t;
                    return (
                      void 0 === s && (s = 1.70158),
                      (e /= r / 2) < 1
                        ? (i / 2) * (e * e * ((1 + (s *= 1.525)) * e - s)) + t
                        : (i / 2) *
                            ((e -= 2) * e * ((1 + (s *= 1.525)) * e + s) + 2) +
                          t
                    );
                  },
                  easeInBounce: function (e, t, n, s) {
                    var i = n - t;
                    return i - r.easeOutBounce(s - e, 0, i, s) + t;
                  },
                  easeOutBounce: function (e, t, n, r) {
                    var s = n - t;
                    return (e /= r) < 1 / 2.75
                      ? s * (7.5625 * e * e) + t
                      : e < 2 / 2.75
                      ? s * (7.5625 * (e -= 1.5 / 2.75) * e + 0.75) + t
                      : e < 2.5 / 2.75
                      ? s * (7.5625 * (e -= 2.25 / 2.75) * e + 0.9375) + t
                      : s * (7.5625 * (e -= 2.625 / 2.75) * e + 0.984375) + t;
                  },
                  easeInOutBounce: function (e, t, n, s) {
                    var i = n - t;
                    return e < s / 2
                      ? 0.5 * r.easeInBounce(2 * e, 0, i, s) + t
                      : 0.5 * r.easeOutBounce(2 * e - s, 0, i, s) + 0.5 * i + t;
                  },
                };
                e.exports = r;
              },
              function (e, t, n) {
                e.exports = n(3);
              },
              function (e, t, n) {
                "use strict";
                n.r(t),
                  n.d(t, "ReactConfetti", function () {
                    return B;
                  });
                var r,
                  s,
                  i = n(0),
                  o = n.n(i),
                  a = n(1),
                  c = n.n(a);
                function l(e, t) {
                  return e + Math.random() * (t - e);
                }
                function u(e, t) {
                  for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    (r.enumerable = r.enumerable || !1),
                      (r.configurable = !0),
                      "value" in r && (r.writable = !0),
                      Object.defineProperty(e, r.key, r);
                  }
                }
                function d(e, t, n) {
                  return (
                    t in e
                      ? Object.defineProperty(e, t, {
                          value: n,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                        })
                      : (e[t] = n),
                    e
                  );
                }
                !(function (e) {
                  (e[(e.Circle = 0)] = "Circle"),
                    (e[(e.Square = 1)] = "Square"),
                    (e[(e.Strip = 2)] = "Strip");
                })(r || (r = {})),
                  (function (e) {
                    (e[(e.Positive = 1)] = "Positive"),
                      (e[(e.Negative = -1)] = "Negative");
                  })(s || (s = {}));
                var h = (function () {
                  function e(t, n, r, i) {
                    !(function (e, t) {
                      if (!(e instanceof t))
                        throw new TypeError(
                          "Cannot call a class as a function"
                        );
                    })(this, e),
                      d(this, "context", void 0),
                      d(this, "radius", void 0),
                      d(this, "x", void 0),
                      d(this, "y", void 0),
                      d(this, "w", void 0),
                      d(this, "h", void 0),
                      d(this, "vx", void 0),
                      d(this, "vy", void 0),
                      d(this, "shape", void 0),
                      d(this, "angle", void 0),
                      d(this, "angularSpin", void 0),
                      d(this, "color", void 0),
                      d(this, "rotateY", void 0),
                      d(this, "rotationDirection", void 0),
                      d(this, "getOptions", void 0),
                      (this.getOptions = n);
                    var o,
                      a,
                      c = this.getOptions(),
                      u = c.colors,
                      h = c.initialVelocityX,
                      p = c.initialVelocityY;
                    (this.context = t),
                      (this.x = r),
                      (this.y = i),
                      (this.w = l(5, 20)),
                      (this.h = l(5, 20)),
                      (this.radius = l(5, 10)),
                      (this.vx =
                        "number" == typeof h ? l(-h, h) : l(h.min, h.max)),
                      (this.vy =
                        "number" == typeof p ? l(-p, 0) : l(p.min, p.max)),
                      (this.shape =
                        ((o = 0),
                        (a = 2),
                        Math.floor(o + Math.random() * (a - o + 1)))),
                      (this.angle = (l(0, 360) * Math.PI) / 180),
                      (this.angularSpin = l(-0.2, 0.2)),
                      (this.color = u[Math.floor(Math.random() * u.length)]),
                      (this.rotateY = l(0, 1)),
                      (this.rotationDirection = l(0, 1)
                        ? s.Positive
                        : s.Negative);
                  }
                  var t, n, i;
                  return (
                    (t = e),
                    (n = [
                      {
                        key: "update",
                        value: function () {
                          var e = this.getOptions(),
                            t = e.gravity,
                            n = e.wind,
                            i = e.friction,
                            o = e.opacity,
                            a = e.drawShape;
                          (this.x += this.vx),
                            (this.y += this.vy),
                            (this.vy += t),
                            (this.vx += n),
                            (this.vx *= i),
                            (this.vy *= i),
                            this.rotateY >= 1 &&
                            this.rotationDirection === s.Positive
                              ? (this.rotationDirection = s.Negative)
                              : this.rotateY <= -1 &&
                                this.rotationDirection === s.Negative &&
                                (this.rotationDirection = s.Positive);
                          var c = 0.1 * this.rotationDirection;
                          if (
                            ((this.rotateY += c),
                            (this.angle += this.angularSpin),
                            this.context.save(),
                            this.context.translate(this.x, this.y),
                            this.context.rotate(this.angle),
                            this.context.scale(1, this.rotateY),
                            this.context.rotate(this.angle),
                            this.context.beginPath(),
                            (this.context.fillStyle = this.color),
                            (this.context.strokeStyle = this.color),
                            (this.context.globalAlpha = o),
                            (this.context.lineCap = "round"),
                            (this.context.lineWidth = 2),
                            a && "function" == typeof a)
                          )
                            a.call(this, this.context);
                          else
                            switch (this.shape) {
                              case r.Circle:
                                this.context.beginPath(),
                                  this.context.arc(
                                    0,
                                    0,
                                    this.radius,
                                    0,
                                    2 * Math.PI
                                  ),
                                  this.context.fill();
                                break;
                              case r.Square:
                                this.context.fillRect(
                                  -this.w / 2,
                                  -this.h / 2,
                                  this.w,
                                  this.h
                                );
                                break;
                              case r.Strip:
                                this.context.fillRect(
                                  -this.w / 6,
                                  -this.h / 2,
                                  this.w / 3,
                                  this.h
                                );
                            }
                          this.context.closePath(), this.context.restore();
                        },
                      },
                    ]) && u(t.prototype, n),
                    i && u(t, i),
                    e
                  );
                })();
                function p(e, t, n) {
                  return (
                    t in e
                      ? Object.defineProperty(e, t, {
                          value: n,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                        })
                      : (e[t] = n),
                    e
                  );
                }
                var f = function e(t, n) {
                  var r = this;
                  !(function (e, t) {
                    if (!(e instanceof t))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, e),
                    p(this, "canvas", void 0),
                    p(this, "context", void 0),
                    p(this, "getOptions", void 0),
                    p(this, "x", 0),
                    p(this, "y", 0),
                    p(this, "w", 0),
                    p(this, "h", 0),
                    p(this, "lastNumberOfPieces", 0),
                    p(this, "tweenInitTime", Date.now()),
                    p(this, "particles", []),
                    p(this, "particlesGenerated", 0),
                    p(this, "removeParticleAt", function (e) {
                      r.particles.splice(e, 1);
                    }),
                    p(this, "getParticle", function () {
                      var e = l(r.x, r.w + r.x),
                        t = l(r.y, r.h + r.y);
                      return new h(r.context, r.getOptions, e, t);
                    }),
                    p(this, "animate", function () {
                      var e = r.canvas,
                        t = r.context,
                        n = r.particlesGenerated,
                        s = r.lastNumberOfPieces,
                        i = r.getOptions(),
                        o = i.run,
                        a = i.recycle,
                        c = i.numberOfPieces,
                        l = i.debug,
                        u = i.tweenFunction,
                        d = i.tweenDuration;
                      if (!o) return !1;
                      var h = r.particles.length,
                        p = a ? h : n,
                        f = Date.now();
                      if (p < c) {
                        s !== c &&
                          ((r.tweenInitTime = f), (r.lastNumberOfPieces = c));
                        for (
                          var m = r.tweenInitTime,
                            g = u(f - m > d ? d : Math.max(0, f - m), p, c, d),
                            v = Math.round(g - p),
                            y = 0;
                          y < v;
                          y++
                        )
                          r.particles.push(r.getParticle());
                        r.particlesGenerated += v;
                      }
                      return (
                        l &&
                          ((t.font = "12px sans-serif"),
                          (t.fillStyle = "#333"),
                          (t.textAlign = "right"),
                          t.fillText(
                            "Particles: ".concat(h),
                            e.width - 10,
                            e.height - 20
                          )),
                        r.particles.forEach(function (t, n) {
                          t.update(),
                            (t.y > e.height ||
                              t.y < -100 ||
                              t.x > e.width + 100 ||
                              t.x < -100) &&
                              (a && p <= c
                                ? (r.particles[n] = r.getParticle())
                                : r.removeParticleAt(n));
                        }),
                        h > 0 || p < c
                      );
                    }),
                    (this.canvas = t);
                  var s = this.canvas.getContext("2d");
                  if (!s) throw new Error("Could not get canvas context");
                  (this.context = s), (this.getOptions = n);
                };
                function m(e, t) {
                  var n = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t &&
                      (r = r.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable;
                      })),
                      n.push.apply(n, r);
                  }
                  return n;
                }
                function g(e) {
                  for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2
                      ? m(Object(n), !0).forEach(function (t) {
                          y(e, t, n[t]);
                        })
                      : Object.getOwnPropertyDescriptors
                      ? Object.defineProperties(
                          e,
                          Object.getOwnPropertyDescriptors(n)
                        )
                      : m(Object(n)).forEach(function (t) {
                          Object.defineProperty(
                            e,
                            t,
                            Object.getOwnPropertyDescriptor(n, t)
                          );
                        });
                  }
                  return e;
                }
                function v(e, t) {
                  for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    (r.enumerable = r.enumerable || !1),
                      (r.configurable = !0),
                      "value" in r && (r.writable = !0),
                      Object.defineProperty(e, r.key, r);
                  }
                }
                function y(e, t, n) {
                  return (
                    t in e
                      ? Object.defineProperty(e, t, {
                          value: n,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                        })
                      : (e[t] = n),
                    e
                  );
                }
                var b = {
                    width:
                      "undefined" != typeof window ? window.innerWidth : 300,
                    height:
                      "undefined" != typeof window ? window.innerHeight : 200,
                    numberOfPieces: 200,
                    friction: 0.99,
                    wind: 0,
                    gravity: 0.1,
                    initialVelocityX: 4,
                    initialVelocityY: 10,
                    colors: [
                      "#f44336",
                      "#e91e63",
                      "#9c27b0",
                      "#673ab7",
                      "#3f51b5",
                      "#2196f3",
                      "#03a9f4",
                      "#00bcd4",
                      "#009688",
                      "#4CAF50",
                      "#8BC34A",
                      "#CDDC39",
                      "#FFEB3B",
                      "#FFC107",
                      "#FF9800",
                      "#FF5722",
                      "#795548",
                    ],
                    opacity: 1,
                    debug: !1,
                    tweenFunction: c.a.easeInOutQuad,
                    tweenDuration: 5e3,
                    recycle: !0,
                    run: !0,
                  },
                  w = (function () {
                    function e(t, n) {
                      var r = this;
                      !(function (e, t) {
                        if (!(e instanceof t))
                          throw new TypeError(
                            "Cannot call a class as a function"
                          );
                      })(this, e),
                        y(this, "canvas", void 0),
                        y(this, "context", void 0),
                        y(this, "_options", void 0),
                        y(this, "generator", void 0),
                        y(this, "rafId", void 0),
                        y(this, "setOptionsWithDefaults", function (e) {
                          var t = {
                            confettiSource: {
                              x: 0,
                              y: 0,
                              w: r.canvas.width,
                              h: 0,
                            },
                          };
                          (r._options = g(g(g({}, t), b), e)),
                            Object.assign(r, e.confettiSource);
                        }),
                        y(this, "update", function () {
                          var e = r.options,
                            t = e.run,
                            n = e.onConfettiComplete,
                            s = r.canvas,
                            i = r.context;
                          t &&
                            ((i.fillStyle = "white"),
                            i.clearRect(0, 0, s.width, s.height)),
                            r.generator.animate()
                              ? (r.rafId = requestAnimationFrame(r.update))
                              : (n &&
                                  "function" == typeof n &&
                                  r.generator.particlesGenerated > 0 &&
                                  n.call(r, r),
                                (r._options.run = !1));
                        }),
                        y(this, "reset", function () {
                          r.generator &&
                            r.generator.particlesGenerated > 0 &&
                            ((r.generator.particlesGenerated = 0),
                            (r.generator.particles = []),
                            (r.generator.lastNumberOfPieces = 0));
                        }),
                        y(this, "stop", function () {
                          (r.options = { run: !1 }),
                            r.rafId &&
                              (cancelAnimationFrame(r.rafId),
                              (r.rafId = void 0));
                        }),
                        (this.canvas = t);
                      var s = this.canvas.getContext("2d");
                      if (!s) throw new Error("Could not get canvas context");
                      (this.context = s),
                        (this.generator = new f(this.canvas, function () {
                          return r.options;
                        })),
                        (this.options = n),
                        this.update();
                    }
                    var t, n, r;
                    return (
                      (t = e),
                      (n = [
                        {
                          key: "options",
                          get: function () {
                            return this._options;
                          },
                          set: function (e) {
                            var t = this._options && this._options.run,
                              n = this._options && this._options.recycle;
                            this.setOptionsWithDefaults(e),
                              this.generator &&
                                (Object.assign(
                                  this.generator,
                                  this.options.confettiSource
                                ),
                                "boolean" == typeof e.recycle &&
                                  e.recycle &&
                                  !1 === n &&
                                  (this.generator.lastNumberOfPieces =
                                    this.generator.particles.length)),
                              "boolean" == typeof e.run &&
                                e.run &&
                                !1 === t &&
                                this.update();
                          },
                        },
                      ]) && v(t.prototype, n),
                      r && v(t, r),
                      e
                    );
                  })();
                function S(e) {
                  return (
                    (function (e) {
                      if (Array.isArray(e)) return C(e);
                    })(e) ||
                    (function (e) {
                      if (
                        "undefined" != typeof Symbol &&
                        Symbol.iterator in Object(e)
                      )
                        return Array.from(e);
                    })(e) ||
                    I(e) ||
                    (function () {
                      throw new TypeError(
                        "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                      );
                    })()
                  );
                }
                function _(e) {
                  return (_ =
                    "function" == typeof Symbol &&
                    "symbol" == typeof Symbol.iterator
                      ? function (e) {
                          return typeof e;
                        }
                      : function (e) {
                          return e &&
                            "function" == typeof Symbol &&
                            e.constructor === Symbol &&
                            e !== Symbol.prototype
                            ? "symbol"
                            : typeof e;
                        })(e);
                }
                function E() {
                  return (E =
                    Object.assign ||
                    function (e) {
                      for (var t = 1; t < arguments.length; t++) {
                        var n = arguments[t];
                        for (var r in n)
                          Object.prototype.hasOwnProperty.call(n, r) &&
                            (e[r] = n[r]);
                      }
                      return e;
                    }).apply(this, arguments);
                }
                function A(e, t) {
                  var n = Object.keys(e);
                  if (Object.getOwnPropertySymbols) {
                    var r = Object.getOwnPropertySymbols(e);
                    t &&
                      (r = r.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable;
                      })),
                      n.push.apply(n, r);
                  }
                  return n;
                }
                function T(e) {
                  for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2
                      ? A(Object(n), !0).forEach(function (t) {
                          j(e, t, n[t]);
                        })
                      : Object.getOwnPropertyDescriptors
                      ? Object.defineProperties(
                          e,
                          Object.getOwnPropertyDescriptors(n)
                        )
                      : A(Object(n)).forEach(function (t) {
                          Object.defineProperty(
                            e,
                            t,
                            Object.getOwnPropertyDescriptor(n, t)
                          );
                        });
                  }
                  return e;
                }
                function P(e, t) {
                  return (
                    (function (e) {
                      if (Array.isArray(e)) return e;
                    })(e) ||
                    (function (e, t) {
                      if (
                        "undefined" != typeof Symbol &&
                        Symbol.iterator in Object(e)
                      ) {
                        var n = [],
                          r = !0,
                          s = !1,
                          i = void 0;
                        try {
                          for (
                            var o, a = e[Symbol.iterator]();
                            !(r = (o = a.next()).done) &&
                            (n.push(o.value), !t || n.length !== t);
                            r = !0
                          );
                        } catch (e) {
                          (s = !0), (i = e);
                        } finally {
                          try {
                            r || null == a.return || a.return();
                          } finally {
                            if (s) throw i;
                          }
                        }
                        return n;
                      }
                    })(e, t) ||
                    I(e, t) ||
                    (function () {
                      throw new TypeError(
                        "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                      );
                    })()
                  );
                }
                function I(e, t) {
                  if (e) {
                    if ("string" == typeof e) return C(e, t);
                    var n = Object.prototype.toString.call(e).slice(8, -1);
                    return (
                      "Object" === n &&
                        e.constructor &&
                        (n = e.constructor.name),
                      "Map" === n || "Set" === n
                        ? Array.from(e)
                        : "Arguments" === n ||
                          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
                        ? C(e, t)
                        : void 0
                    );
                  }
                }
                function C(e, t) {
                  (null == t || t > e.length) && (t = e.length);
                  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
                  return r;
                }
                function k(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                }
                function O(e, t) {
                  for (var n = 0; n < t.length; n++) {
                    var r = t[n];
                    (r.enumerable = r.enumerable || !1),
                      (r.configurable = !0),
                      "value" in r && (r.writable = !0),
                      Object.defineProperty(e, r.key, r);
                  }
                }
                function x(e, t) {
                  return (x =
                    Object.setPrototypeOf ||
                    function (e, t) {
                      return (e.__proto__ = t), e;
                    })(e, t);
                }
                function N(e) {
                  var t = (function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct)
                      return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                      return (
                        Date.prototype.toString.call(
                          Reflect.construct(Date, [], function () {})
                        ),
                        !0
                      );
                    } catch (e) {
                      return !1;
                    }
                  })();
                  return function () {
                    var n,
                      r = M(e);
                    if (t) {
                      var s = M(this).constructor;
                      n = Reflect.construct(r, arguments, s);
                    } else n = r.apply(this, arguments);
                    return R(this, n);
                  };
                }
                function R(e, t) {
                  return !t || ("object" !== _(t) && "function" != typeof t)
                    ? D(e)
                    : t;
                }
                function D(e) {
                  if (void 0 === e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return e;
                }
                function M(e) {
                  return (M = Object.setPrototypeOf
                    ? Object.getPrototypeOf
                    : function (e) {
                        return e.__proto__ || Object.getPrototypeOf(e);
                      })(e);
                }
                function j(e, t, n) {
                  return (
                    t in e
                      ? Object.defineProperty(e, t, {
                          value: n,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0,
                        })
                      : (e[t] = n),
                    e
                  );
                }
                var L = o.a.createRef(),
                  U = (function (e) {
                    !(function (e, t) {
                      if ("function" != typeof t && null !== t)
                        throw new TypeError(
                          "Super expression must either be null or a function"
                        );
                      (e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                          value: e,
                          writable: !0,
                          configurable: !0,
                        },
                      })),
                        t && x(e, t);
                    })(i, e);
                    var t,
                      n,
                      r,
                      s = N(i);
                    function i(e) {
                      var t;
                      k(this, i);
                      for (
                        var n = arguments.length,
                          r = new Array(n > 1 ? n - 1 : 0),
                          a = 1;
                        a < n;
                        a++
                      )
                        r[a - 1] = arguments[a];
                      return (
                        j(
                          D((t = s.call.apply(s, [this, e].concat(r)))),
                          "canvas",
                          o.a.createRef()
                        ),
                        j(D(t), "confetti", void 0),
                        (t.canvas = e.canvasRef || L),
                        t
                      );
                    }
                    return (
                      (t = i),
                      (n = [
                        {
                          key: "componentDidMount",
                          value: function () {
                            if (this.canvas.current) {
                              var e = F(this.props)[0];
                              this.confetti = new w(this.canvas.current, e);
                            }
                          },
                        },
                        {
                          key: "componentDidUpdate",
                          value: function () {
                            var e = F(this.props)[0];
                            this.confetti && (this.confetti.options = e);
                          },
                        },
                        {
                          key: "componentWillUnmount",
                          value: function () {
                            this.confetti && this.confetti.stop(),
                              (this.confetti = void 0);
                          },
                        },
                        {
                          key: "render",
                          value: function () {
                            var e = P(F(this.props), 2),
                              t = e[0],
                              n = e[1],
                              r = T(
                                {
                                  zIndex: 2,
                                  position: "absolute",
                                  pointerEvents: "none",
                                  top: 0,
                                  left: 0,
                                  bottom: 0,
                                  right: 0,
                                },
                                n.style
                              );
                            return o.a.createElement(
                              "canvas",
                              E(
                                {
                                  width: t.width,
                                  height: t.height,
                                  ref: this.canvas,
                                },
                                n,
                                { style: r }
                              )
                            );
                          },
                        },
                      ]) && O(t.prototype, n),
                      r && O(t, r),
                      i
                    );
                  })(i.Component);
                function F(e) {
                  var t = {},
                    n = {},
                    r = [].concat(S(Object.keys(b)), [
                      "confettiSource",
                      "drawShape",
                      "onConfettiComplete",
                    ]),
                    s = ["canvasRef"];
                  for (var i in e) {
                    var o = e[i];
                    r.includes(i)
                      ? (t[i] = o)
                      : s.includes(i)
                      ? (s[i] = o)
                      : (n[i] = o);
                  }
                  return [t, n, {}];
                }
                j(U, "defaultProps", T({}, b)),
                  j(U, "displayName", "ReactConfetti");
                var B = o.a.forwardRef(function (e, t) {
                  return o.a.createElement(U, E({ canvasRef: t }, e));
                });
                t.default = B;
              },
            ]).default));
      },
      730: (e, t, n) => {
        "use strict";
        var r = n(43),
          s = n(853);
        function i(e) {
          for (
            var t =
                "https://reactjs.org/docs/error-decoder.html?invariant=" + e,
              n = 1;
            n < arguments.length;
            n++
          )
            t += "&args[]=" + encodeURIComponent(arguments[n]);
          return (
            "Minified React error #" +
            e +
            "; visit " +
            t +
            " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
          );
        }
        var o = new Set(),
          a = {};
        function c(e, t) {
          l(e, t), l(e + "Capture", t);
        }
        function l(e, t) {
          for (a[e] = t, e = 0; e < t.length; e++) o.add(t[e]);
        }
        var u = !(
            "undefined" === typeof window ||
            "undefined" === typeof window.document ||
            "undefined" === typeof window.document.createElement
          ),
          d = Object.prototype.hasOwnProperty,
          h =
            /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
          p = {},
          f = {};
        function m(e, t, n, r, s, i, o) {
          (this.acceptsBooleans = 2 === t || 3 === t || 4 === t),
            (this.attributeName = r),
            (this.attributeNamespace = s),
            (this.mustUseProperty = n),
            (this.propertyName = e),
            (this.type = t),
            (this.sanitizeURL = i),
            (this.removeEmptyString = o);
        }
        var g = {};
        "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
          .split(" ")
          .forEach(function (e) {
            g[e] = new m(e, 0, !1, e, null, !1, !1);
          }),
          [
            ["acceptCharset", "accept-charset"],
            ["className", "class"],
            ["htmlFor", "for"],
            ["httpEquiv", "http-equiv"],
          ].forEach(function (e) {
            var t = e[0];
            g[t] = new m(t, 1, !1, e[1], null, !1, !1);
          }),
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(
            function (e) {
              g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1);
            }
          ),
          [
            "autoReverse",
            "externalResourcesRequired",
            "focusable",
            "preserveAlpha",
          ].forEach(function (e) {
            g[e] = new m(e, 2, !1, e, null, !1, !1);
          }),
          "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
            .split(" ")
            .forEach(function (e) {
              g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1);
            }),
          ["checked", "multiple", "muted", "selected"].forEach(function (e) {
            g[e] = new m(e, 3, !0, e, null, !1, !1);
          }),
          ["capture", "download"].forEach(function (e) {
            g[e] = new m(e, 4, !1, e, null, !1, !1);
          }),
          ["cols", "rows", "size", "span"].forEach(function (e) {
            g[e] = new m(e, 6, !1, e, null, !1, !1);
          }),
          ["rowSpan", "start"].forEach(function (e) {
            g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1);
          });
        var v = /[\-:]([a-z])/g;
        function y(e) {
          return e[1].toUpperCase();
        }
        function b(e, t, n, r) {
          var s = g.hasOwnProperty(t) ? g[t] : null;
          (null !== s
            ? 0 !== s.type
            : r ||
              !(2 < t.length) ||
              ("o" !== t[0] && "O" !== t[0]) ||
              ("n" !== t[1] && "N" !== t[1])) &&
            ((function (e, t, n, r) {
              if (
                null === t ||
                "undefined" === typeof t ||
                (function (e, t, n, r) {
                  if (null !== n && 0 === n.type) return !1;
                  switch (typeof t) {
                    case "function":
                    case "symbol":
                      return !0;
                    case "boolean":
                      return (
                        !r &&
                        (null !== n
                          ? !n.acceptsBooleans
                          : "data-" !== (e = e.toLowerCase().slice(0, 5)) &&
                            "aria-" !== e)
                      );
                    default:
                      return !1;
                  }
                })(e, t, n, r)
              )
                return !0;
              if (r) return !1;
              if (null !== n)
                switch (n.type) {
                  case 3:
                    return !t;
                  case 4:
                    return !1 === t;
                  case 5:
                    return isNaN(t);
                  case 6:
                    return isNaN(t) || 1 > t;
                }
              return !1;
            })(t, n, s, r) && (n = null),
            r || null === s
              ? (function (e) {
                  return (
                    !!d.call(f, e) ||
                    (!d.call(p, e) &&
                      (h.test(e) ? (f[e] = !0) : ((p[e] = !0), !1)))
                  );
                })(t) &&
                (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
              : s.mustUseProperty
              ? (e[s.propertyName] = null === n ? 3 !== s.type && "" : n)
              : ((t = s.attributeName),
                (r = s.attributeNamespace),
                null === n
                  ? e.removeAttribute(t)
                  : ((n =
                      3 === (s = s.type) || (4 === s && !0 === n)
                        ? ""
                        : "" + n),
                    r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))));
        }
        "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
          .split(" ")
          .forEach(function (e) {
            var t = e.replace(v, y);
            g[t] = new m(t, 1, !1, e, null, !1, !1);
          }),
          "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
            .split(" ")
            .forEach(function (e) {
              var t = e.replace(v, y);
              g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
            }),
          ["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
            var t = e.replace(v, y);
            g[t] = new m(
              t,
              1,
              !1,
              e,
              "http://www.w3.org/XML/1998/namespace",
              !1,
              !1
            );
          }),
          ["tabIndex", "crossOrigin"].forEach(function (e) {
            g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1);
          }),
          (g.xlinkHref = new m(
            "xlinkHref",
            1,
            !1,
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            !0,
            !1
          )),
          ["src", "href", "action", "formAction"].forEach(function (e) {
            g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0);
          });
        var w = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
          S = Symbol.for("react.element"),
          _ = Symbol.for("react.portal"),
          E = Symbol.for("react.fragment"),
          A = Symbol.for("react.strict_mode"),
          T = Symbol.for("react.profiler"),
          P = Symbol.for("react.provider"),
          I = Symbol.for("react.context"),
          C = Symbol.for("react.forward_ref"),
          k = Symbol.for("react.suspense"),
          O = Symbol.for("react.suspense_list"),
          x = Symbol.for("react.memo"),
          N = Symbol.for("react.lazy");
        Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
        var R = Symbol.for("react.offscreen");
        Symbol.for("react.legacy_hidden"),
          Symbol.for("react.cache"),
          Symbol.for("react.tracing_marker");
        var D = Symbol.iterator;
        function M(e) {
          return null === e || "object" !== typeof e
            ? null
            : "function" === typeof (e = (D && e[D]) || e["@@iterator"])
            ? e
            : null;
        }
        var j,
          L = Object.assign;
        function U(e) {
          if (void 0 === j)
            try {
              throw Error();
            } catch (n) {
              var t = n.stack.trim().match(/\n( *(at )?)/);
              j = (t && t[1]) || "";
            }
          return "\n" + j + e;
        }
        var F = !1;
        function B(e, t) {
          if (!e || F) return "";
          F = !0;
          var n = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          try {
            if (t)
              if (
                ((t = function () {
                  throw Error();
                }),
                Object.defineProperty(t.prototype, "props", {
                  set: function () {
                    throw Error();
                  },
                }),
                "object" === typeof Reflect && Reflect.construct)
              ) {
                try {
                  Reflect.construct(t, []);
                } catch (l) {
                  var r = l;
                }
                Reflect.construct(e, [], t);
              } else {
                try {
                  t.call();
                } catch (l) {
                  r = l;
                }
                e.call(t.prototype);
              }
            else {
              try {
                throw Error();
              } catch (l) {
                r = l;
              }
              e();
            }
          } catch (l) {
            if (l && r && "string" === typeof l.stack) {
              for (
                var s = l.stack.split("\n"),
                  i = r.stack.split("\n"),
                  o = s.length - 1,
                  a = i.length - 1;
                1 <= o && 0 <= a && s[o] !== i[a];

              )
                a--;
              for (; 1 <= o && 0 <= a; o--, a--)
                if (s[o] !== i[a]) {
                  if (1 !== o || 1 !== a)
                    do {
                      if ((o--, 0 > --a || s[o] !== i[a])) {
                        var c = "\n" + s[o].replace(" at new ", " at ");
                        return (
                          e.displayName &&
                            c.includes("<anonymous>") &&
                            (c = c.replace("<anonymous>", e.displayName)),
                          c
                        );
                      }
                    } while (1 <= o && 0 <= a);
                  break;
                }
            }
          } finally {
            (F = !1), (Error.prepareStackTrace = n);
          }
          return (e = e ? e.displayName || e.name : "") ? U(e) : "";
        }
        function V(e) {
          switch (e.tag) {
            case 5:
              return U(e.type);
            case 16:
              return U("Lazy");
            case 13:
              return U("Suspense");
            case 19:
              return U("SuspenseList");
            case 0:
            case 2:
            case 15:
              return (e = B(e.type, !1));
            case 11:
              return (e = B(e.type.render, !1));
            case 1:
              return (e = B(e.type, !0));
            default:
              return "";
          }
        }
        function q(e) {
          if (null == e) return null;
          if ("function" === typeof e) return e.displayName || e.name || null;
          if ("string" === typeof e) return e;
          switch (e) {
            case E:
              return "Fragment";
            case _:
              return "Portal";
            case T:
              return "Profiler";
            case A:
              return "StrictMode";
            case k:
              return "Suspense";
            case O:
              return "SuspenseList";
          }
          if ("object" === typeof e)
            switch (e.$$typeof) {
              case I:
                return (e.displayName || "Context") + ".Consumer";
              case P:
                return (e._context.displayName || "Context") + ".Provider";
              case C:
                var t = e.render;
                return (
                  (e = e.displayName) ||
                    (e =
                      "" !== (e = t.displayName || t.name || "")
                        ? "ForwardRef(" + e + ")"
                        : "ForwardRef"),
                  e
                );
              case x:
                return null !== (t = e.displayName || null)
                  ? t
                  : q(e.type) || "Memo";
              case N:
                (t = e._payload), (e = e._init);
                try {
                  return q(e(t));
                } catch (n) {}
            }
          return null;
        }
        function H(e) {
          var t = e.type;
          switch (e.tag) {
            case 24:
              return "Cache";
            case 9:
              return (t.displayName || "Context") + ".Consumer";
            case 10:
              return (t._context.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return (
                (e = (e = t.render).displayName || e.name || ""),
                t.displayName ||
                  ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef")
              );
            case 7:
              return "Fragment";
            case 5:
              return t;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return q(t);
            case 8:
              return t === A ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
              if ("function" === typeof t)
                return t.displayName || t.name || null;
              if ("string" === typeof t) return t;
          }
          return null;
        }
        function W(e) {
          switch (typeof e) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
            case "object":
              return e;
            default:
              return "";
          }
        }
        function K(e) {
          var t = e.type;
          return (
            (e = e.nodeName) &&
            "input" === e.toLowerCase() &&
            ("checkbox" === t || "radio" === t)
          );
        }
        function z(e) {
          e._valueTracker ||
            (e._valueTracker = (function (e) {
              var t = K(e) ? "checked" : "value",
                n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
                r = "" + e[t];
              if (
                !e.hasOwnProperty(t) &&
                "undefined" !== typeof n &&
                "function" === typeof n.get &&
                "function" === typeof n.set
              ) {
                var s = n.get,
                  i = n.set;
                return (
                  Object.defineProperty(e, t, {
                    configurable: !0,
                    get: function () {
                      return s.call(this);
                    },
                    set: function (e) {
                      (r = "" + e), i.call(this, e);
                    },
                  }),
                  Object.defineProperty(e, t, { enumerable: n.enumerable }),
                  {
                    getValue: function () {
                      return r;
                    },
                    setValue: function (e) {
                      r = "" + e;
                    },
                    stopTracking: function () {
                      (e._valueTracker = null), delete e[t];
                    },
                  }
                );
              }
            })(e));
        }
        function G(e) {
          if (!e) return !1;
          var t = e._valueTracker;
          if (!t) return !0;
          var n = t.getValue(),
            r = "";
          return (
            e && (r = K(e) ? (e.checked ? "true" : "false") : e.value),
            (e = r) !== n && (t.setValue(e), !0)
          );
        }
        function J(e) {
          if (
            "undefined" ===
            typeof (e =
              e || ("undefined" !== typeof document ? document : void 0))
          )
            return null;
          try {
            return e.activeElement || e.body;
          } catch (t) {
            return e.body;
          }
        }
        function Q(e, t) {
          var n = t.checked;
          return L({}, t, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: null != n ? n : e._wrapperState.initialChecked,
          });
        }
        function Y(e, t) {
          var n = null == t.defaultValue ? "" : t.defaultValue,
            r = null != t.checked ? t.checked : t.defaultChecked;
          (n = W(null != t.value ? t.value : n)),
            (e._wrapperState = {
              initialChecked: r,
              initialValue: n,
              controlled:
                "checkbox" === t.type || "radio" === t.type
                  ? null != t.checked
                  : null != t.value,
            });
        }
        function X(e, t) {
          null != (t = t.checked) && b(e, "checked", t, !1);
        }
        function Z(e, t) {
          X(e, t);
          var n = W(t.value),
            r = t.type;
          if (null != n)
            "number" === r
              ? ((0 === n && "" === e.value) || e.value != n) &&
                (e.value = "" + n)
              : e.value !== "" + n && (e.value = "" + n);
          else if ("submit" === r || "reset" === r)
            return void e.removeAttribute("value");
          t.hasOwnProperty("value")
            ? ee(e, t.type, n)
            : t.hasOwnProperty("defaultValue") &&
              ee(e, t.type, W(t.defaultValue)),
            null == t.checked &&
              null != t.defaultChecked &&
              (e.defaultChecked = !!t.defaultChecked);
        }
        function $(e, t, n) {
          if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
            var r = t.type;
            if (
              !(
                ("submit" !== r && "reset" !== r) ||
                (void 0 !== t.value && null !== t.value)
              )
            )
              return;
            (t = "" + e._wrapperState.initialValue),
              n || t === e.value || (e.value = t),
              (e.defaultValue = t);
          }
          "" !== (n = e.name) && (e.name = ""),
            (e.defaultChecked = !!e._wrapperState.initialChecked),
            "" !== n && (e.name = n);
        }
        function ee(e, t, n) {
          ("number" === t && J(e.ownerDocument) === e) ||
            (null == n
              ? (e.defaultValue = "" + e._wrapperState.initialValue)
              : e.defaultValue !== "" + n && (e.defaultValue = "" + n));
        }
        var te = Array.isArray;
        function ne(e, t, n, r) {
          if (((e = e.options), t)) {
            t = {};
            for (var s = 0; s < n.length; s++) t["$" + n[s]] = !0;
            for (n = 0; n < e.length; n++)
              (s = t.hasOwnProperty("$" + e[n].value)),
                e[n].selected !== s && (e[n].selected = s),
                s && r && (e[n].defaultSelected = !0);
          } else {
            for (n = "" + W(n), t = null, s = 0; s < e.length; s++) {
              if (e[s].value === n)
                return (
                  (e[s].selected = !0), void (r && (e[s].defaultSelected = !0))
                );
              null !== t || e[s].disabled || (t = e[s]);
            }
            null !== t && (t.selected = !0);
          }
        }
        function re(e, t) {
          if (null != t.dangerouslySetInnerHTML) throw Error(i(91));
          return L({}, t, {
            value: void 0,
            defaultValue: void 0,
            children: "" + e._wrapperState.initialValue,
          });
        }
        function se(e, t) {
          var n = t.value;
          if (null == n) {
            if (((n = t.children), (t = t.defaultValue), null != n)) {
              if (null != t) throw Error(i(92));
              if (te(n)) {
                if (1 < n.length) throw Error(i(93));
                n = n[0];
              }
              t = n;
            }
            null == t && (t = ""), (n = t);
          }
          e._wrapperState = { initialValue: W(n) };
        }
        function ie(e, t) {
          var n = W(t.value),
            r = W(t.defaultValue);
          null != n &&
            ((n = "" + n) !== e.value && (e.value = n),
            null == t.defaultValue &&
              e.defaultValue !== n &&
              (e.defaultValue = n)),
            null != r && (e.defaultValue = "" + r);
        }
        function oe(e) {
          var t = e.textContent;
          t === e._wrapperState.initialValue &&
            "" !== t &&
            null !== t &&
            (e.value = t);
        }
        function ae(e) {
          switch (e) {
            case "svg":
              return "http://www.w3.org/2000/svg";
            case "math":
              return "http://www.w3.org/1998/Math/MathML";
            default:
              return "http://www.w3.org/1999/xhtml";
          }
        }
        function ce(e, t) {
          return null == e || "http://www.w3.org/1999/xhtml" === e
            ? ae(t)
            : "http://www.w3.org/2000/svg" === e && "foreignObject" === t
            ? "http://www.w3.org/1999/xhtml"
            : e;
        }
        var le,
          ue,
          de =
            ((ue = function (e, t) {
              if (
                "http://www.w3.org/2000/svg" !== e.namespaceURI ||
                "innerHTML" in e
              )
                e.innerHTML = t;
              else {
                for (
                  (le = le || document.createElement("div")).innerHTML =
                    "<svg>" + t.valueOf().toString() + "</svg>",
                    t = le.firstChild;
                  e.firstChild;

                )
                  e.removeChild(e.firstChild);
                for (; t.firstChild; ) e.appendChild(t.firstChild);
              }
            }),
            "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction
              ? function (e, t, n, r) {
                  MSApp.execUnsafeLocalFunction(function () {
                    return ue(e, t);
                  });
                }
              : ue);
        function he(e, t) {
          if (t) {
            var n = e.firstChild;
            if (n && n === e.lastChild && 3 === n.nodeType)
              return void (n.nodeValue = t);
          }
          e.textContent = t;
        }
        var pe = {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridArea: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0,
          },
          fe = ["Webkit", "ms", "Moz", "O"];
        function me(e, t, n) {
          return null == t || "boolean" === typeof t || "" === t
            ? ""
            : n ||
              "number" !== typeof t ||
              0 === t ||
              (pe.hasOwnProperty(e) && pe[e])
            ? ("" + t).trim()
            : t + "px";
        }
        function ge(e, t) {
          for (var n in ((e = e.style), t))
            if (t.hasOwnProperty(n)) {
              var r = 0 === n.indexOf("--"),
                s = me(n, t[n], r);
              "float" === n && (n = "cssFloat"),
                r ? e.setProperty(n, s) : (e[n] = s);
            }
        }
        Object.keys(pe).forEach(function (e) {
          fe.forEach(function (t) {
            (t = t + e.charAt(0).toUpperCase() + e.substring(1)),
              (pe[t] = pe[e]);
          });
        });
        var ve = L(
          { menuitem: !0 },
          {
            area: !0,
            base: !0,
            br: !0,
            col: !0,
            embed: !0,
            hr: !0,
            img: !0,
            input: !0,
            keygen: !0,
            link: !0,
            meta: !0,
            param: !0,
            source: !0,
            track: !0,
            wbr: !0,
          }
        );
        function ye(e, t) {
          if (t) {
            if (
              ve[e] &&
              (null != t.children || null != t.dangerouslySetInnerHTML)
            )
              throw Error(i(137, e));
            if (null != t.dangerouslySetInnerHTML) {
              if (null != t.children) throw Error(i(60));
              if (
                "object" !== typeof t.dangerouslySetInnerHTML ||
                !("__html" in t.dangerouslySetInnerHTML)
              )
                throw Error(i(61));
            }
            if (null != t.style && "object" !== typeof t.style)
              throw Error(i(62));
          }
        }
        function be(e, t) {
          if (-1 === e.indexOf("-")) return "string" === typeof t.is;
          switch (e) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return !1;
            default:
              return !0;
          }
        }
        var we = null;
        function Se(e) {
          return (
            (e = e.target || e.srcElement || window).correspondingUseElement &&
              (e = e.correspondingUseElement),
            3 === e.nodeType ? e.parentNode : e
          );
        }
        var _e = null,
          Ee = null,
          Ae = null;
        function Te(e) {
          if ((e = bs(e))) {
            if ("function" !== typeof _e) throw Error(i(280));
            var t = e.stateNode;
            t && ((t = Ss(t)), _e(e.stateNode, e.type, t));
          }
        }
        function Pe(e) {
          Ee ? (Ae ? Ae.push(e) : (Ae = [e])) : (Ee = e);
        }
        function Ie() {
          if (Ee) {
            var e = Ee,
              t = Ae;
            if (((Ae = Ee = null), Te(e), t))
              for (e = 0; e < t.length; e++) Te(t[e]);
          }
        }
        function Ce(e, t) {
          return e(t);
        }
        function ke() {}
        var Oe = !1;
        function xe(e, t, n) {
          if (Oe) return e(t, n);
          Oe = !0;
          try {
            return Ce(e, t, n);
          } finally {
            (Oe = !1), (null !== Ee || null !== Ae) && (ke(), Ie());
          }
        }
        function Ne(e, t) {
          var n = e.stateNode;
          if (null === n) return null;
          var r = Ss(n);
          if (null === r) return null;
          n = r[t];
          e: switch (t) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (r = !r.disabled) ||
                (r = !(
                  "button" === (e = e.type) ||
                  "input" === e ||
                  "select" === e ||
                  "textarea" === e
                )),
                (e = !r);
              break e;
            default:
              e = !1;
          }
          if (e) return null;
          if (n && "function" !== typeof n) throw Error(i(231, t, typeof n));
          return n;
        }
        var Re = !1;
        if (u)
          try {
            var De = {};
            Object.defineProperty(De, "passive", {
              get: function () {
                Re = !0;
              },
            }),
              window.addEventListener("test", De, De),
              window.removeEventListener("test", De, De);
          } catch (ue) {
            Re = !1;
          }
        function Me(e, t, n, r, s, i, o, a, c) {
          var l = Array.prototype.slice.call(arguments, 3);
          try {
            t.apply(n, l);
          } catch (u) {
            this.onError(u);
          }
        }
        var je = !1,
          Le = null,
          Ue = !1,
          Fe = null,
          Be = {
            onError: function (e) {
              (je = !0), (Le = e);
            },
          };
        function Ve(e, t, n, r, s, i, o, a, c) {
          (je = !1), (Le = null), Me.apply(Be, arguments);
        }
        function qe(e) {
          var t = e,
            n = e;
          if (e.alternate) for (; t.return; ) t = t.return;
          else {
            e = t;
            do {
              0 !== (4098 & (t = e).flags) && (n = t.return), (e = t.return);
            } while (e);
          }
          return 3 === t.tag ? n : null;
        }
        function He(e) {
          if (13 === e.tag) {
            var t = e.memoizedState;
            if (
              (null === t &&
                null !== (e = e.alternate) &&
                (t = e.memoizedState),
              null !== t)
            )
              return t.dehydrated;
          }
          return null;
        }
        function We(e) {
          if (qe(e) !== e) throw Error(i(188));
        }
        function Ke(e) {
          return null !==
            (e = (function (e) {
              var t = e.alternate;
              if (!t) {
                if (null === (t = qe(e))) throw Error(i(188));
                return t !== e ? null : e;
              }
              for (var n = e, r = t; ; ) {
                var s = n.return;
                if (null === s) break;
                var o = s.alternate;
                if (null === o) {
                  if (null !== (r = s.return)) {
                    n = r;
                    continue;
                  }
                  break;
                }
                if (s.child === o.child) {
                  for (o = s.child; o; ) {
                    if (o === n) return We(s), e;
                    if (o === r) return We(s), t;
                    o = o.sibling;
                  }
                  throw Error(i(188));
                }
                if (n.return !== r.return) (n = s), (r = o);
                else {
                  for (var a = !1, c = s.child; c; ) {
                    if (c === n) {
                      (a = !0), (n = s), (r = o);
                      break;
                    }
                    if (c === r) {
                      (a = !0), (r = s), (n = o);
                      break;
                    }
                    c = c.sibling;
                  }
                  if (!a) {
                    for (c = o.child; c; ) {
                      if (c === n) {
                        (a = !0), (n = o), (r = s);
                        break;
                      }
                      if (c === r) {
                        (a = !0), (r = o), (n = s);
                        break;
                      }
                      c = c.sibling;
                    }
                    if (!a) throw Error(i(189));
                  }
                }
                if (n.alternate !== r) throw Error(i(190));
              }
              if (3 !== n.tag) throw Error(i(188));
              return n.stateNode.current === n ? e : t;
            })(e))
            ? ze(e)
            : null;
        }
        function ze(e) {
          if (5 === e.tag || 6 === e.tag) return e;
          for (e = e.child; null !== e; ) {
            var t = ze(e);
            if (null !== t) return t;
            e = e.sibling;
          }
          return null;
        }
        var Ge = s.unstable_scheduleCallback,
          Je = s.unstable_cancelCallback,
          Qe = s.unstable_shouldYield,
          Ye = s.unstable_requestPaint,
          Xe = s.unstable_now,
          Ze = s.unstable_getCurrentPriorityLevel,
          $e = s.unstable_ImmediatePriority,
          et = s.unstable_UserBlockingPriority,
          tt = s.unstable_NormalPriority,
          nt = s.unstable_LowPriority,
          rt = s.unstable_IdlePriority,
          st = null,
          it = null;
        var ot = Math.clz32
            ? Math.clz32
            : function (e) {
                return (e >>>= 0), 0 === e ? 32 : (31 - ((at(e) / ct) | 0)) | 0;
              },
          at = Math.log,
          ct = Math.LN2;
        var lt = 64,
          ut = 4194304;
        function dt(e) {
          switch (e & -e) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return 4194240 & e;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              return 130023424 & e;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 1073741824;
            default:
              return e;
          }
        }
        function ht(e, t) {
          var n = e.pendingLanes;
          if (0 === n) return 0;
          var r = 0,
            s = e.suspendedLanes,
            i = e.pingedLanes,
            o = 268435455 & n;
          if (0 !== o) {
            var a = o & ~s;
            0 !== a ? (r = dt(a)) : 0 !== (i &= o) && (r = dt(i));
          } else 0 !== (o = n & ~s) ? (r = dt(o)) : 0 !== i && (r = dt(i));
          if (0 === r) return 0;
          if (
            0 !== t &&
            t !== r &&
            0 === (t & s) &&
            ((s = r & -r) >= (i = t & -t) || (16 === s && 0 !== (4194240 & i)))
          )
            return t;
          if ((0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes)))
            for (e = e.entanglements, t &= r; 0 < t; )
              (s = 1 << (n = 31 - ot(t))), (r |= e[n]), (t &= ~s);
          return r;
        }
        function pt(e, t) {
          switch (e) {
            case 1:
            case 2:
            case 4:
              return t + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return t + 5e3;
            default:
              return -1;
          }
        }
        function ft(e) {
          return 0 !== (e = -1073741825 & e.pendingLanes)
            ? e
            : 1073741824 & e
            ? 1073741824
            : 0;
        }
        function mt() {
          var e = lt;
          return 0 === (4194240 & (lt <<= 1)) && (lt = 64), e;
        }
        function gt(e) {
          for (var t = [], n = 0; 31 > n; n++) t.push(e);
          return t;
        }
        function vt(e, t, n) {
          (e.pendingLanes |= t),
            536870912 !== t && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
            ((e = e.eventTimes)[(t = 31 - ot(t))] = n);
        }
        function yt(e, t) {
          var n = (e.entangledLanes |= t);
          for (e = e.entanglements; n; ) {
            var r = 31 - ot(n),
              s = 1 << r;
            (s & t) | (e[r] & t) && (e[r] |= t), (n &= ~s);
          }
        }
        var bt = 0;
        function wt(e) {
          return 1 < (e &= -e)
            ? 4 < e
              ? 0 !== (268435455 & e)
                ? 16
                : 536870912
              : 4
            : 1;
        }
        var St,
          _t,
          Et,
          At,
          Tt,
          Pt = !1,
          It = [],
          Ct = null,
          kt = null,
          Ot = null,
          xt = new Map(),
          Nt = new Map(),
          Rt = [],
          Dt =
            "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
              " "
            );
        function Mt(e, t) {
          switch (e) {
            case "focusin":
            case "focusout":
              Ct = null;
              break;
            case "dragenter":
            case "dragleave":
              kt = null;
              break;
            case "mouseover":
            case "mouseout":
              Ot = null;
              break;
            case "pointerover":
            case "pointerout":
              xt.delete(t.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              Nt.delete(t.pointerId);
          }
        }
        function jt(e, t, n, r, s, i) {
          return null === e || e.nativeEvent !== i
            ? ((e = {
                blockedOn: t,
                domEventName: n,
                eventSystemFlags: r,
                nativeEvent: i,
                targetContainers: [s],
              }),
              null !== t && null !== (t = bs(t)) && _t(t),
              e)
            : ((e.eventSystemFlags |= r),
              (t = e.targetContainers),
              null !== s && -1 === t.indexOf(s) && t.push(s),
              e);
        }
        function Lt(e) {
          var t = ys(e.target);
          if (null !== t) {
            var n = qe(t);
            if (null !== n)
              if (13 === (t = n.tag)) {
                if (null !== (t = He(n)))
                  return (
                    (e.blockedOn = t),
                    void Tt(e.priority, function () {
                      Et(n);
                    })
                  );
              } else if (
                3 === t &&
                n.stateNode.current.memoizedState.isDehydrated
              )
                return void (e.blockedOn =
                  3 === n.tag ? n.stateNode.containerInfo : null);
          }
          e.blockedOn = null;
        }
        function Ut(e) {
          if (null !== e.blockedOn) return !1;
          for (var t = e.targetContainers; 0 < t.length; ) {
            var n = Qt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
            if (null !== n)
              return null !== (t = bs(n)) && _t(t), (e.blockedOn = n), !1;
            var r = new (n = e.nativeEvent).constructor(n.type, n);
            (we = r), n.target.dispatchEvent(r), (we = null), t.shift();
          }
          return !0;
        }
        function Ft(e, t, n) {
          Ut(e) && n.delete(t);
        }
        function Bt() {
          (Pt = !1),
            null !== Ct && Ut(Ct) && (Ct = null),
            null !== kt && Ut(kt) && (kt = null),
            null !== Ot && Ut(Ot) && (Ot = null),
            xt.forEach(Ft),
            Nt.forEach(Ft);
        }
        function Vt(e, t) {
          e.blockedOn === t &&
            ((e.blockedOn = null),
            Pt ||
              ((Pt = !0),
              s.unstable_scheduleCallback(s.unstable_NormalPriority, Bt)));
        }
        function qt(e) {
          function t(t) {
            return Vt(t, e);
          }
          if (0 < It.length) {
            Vt(It[0], e);
            for (var n = 1; n < It.length; n++) {
              var r = It[n];
              r.blockedOn === e && (r.blockedOn = null);
            }
          }
          for (
            null !== Ct && Vt(Ct, e),
              null !== kt && Vt(kt, e),
              null !== Ot && Vt(Ot, e),
              xt.forEach(t),
              Nt.forEach(t),
              n = 0;
            n < Rt.length;
            n++
          )
            (r = Rt[n]).blockedOn === e && (r.blockedOn = null);
          for (; 0 < Rt.length && null === (n = Rt[0]).blockedOn; )
            Lt(n), null === n.blockedOn && Rt.shift();
        }
        var Ht = w.ReactCurrentBatchConfig,
          Wt = !0;
        function Kt(e, t, n, r) {
          var s = bt,
            i = Ht.transition;
          Ht.transition = null;
          try {
            (bt = 1), Gt(e, t, n, r);
          } finally {
            (bt = s), (Ht.transition = i);
          }
        }
        function zt(e, t, n, r) {
          var s = bt,
            i = Ht.transition;
          Ht.transition = null;
          try {
            (bt = 4), Gt(e, t, n, r);
          } finally {
            (bt = s), (Ht.transition = i);
          }
        }
        function Gt(e, t, n, r) {
          if (Wt) {
            var s = Qt(e, t, n, r);
            if (null === s) Wr(e, t, r, Jt, n), Mt(e, r);
            else if (
              (function (e, t, n, r, s) {
                switch (t) {
                  case "focusin":
                    return (Ct = jt(Ct, e, t, n, r, s)), !0;
                  case "dragenter":
                    return (kt = jt(kt, e, t, n, r, s)), !0;
                  case "mouseover":
                    return (Ot = jt(Ot, e, t, n, r, s)), !0;
                  case "pointerover":
                    var i = s.pointerId;
                    return xt.set(i, jt(xt.get(i) || null, e, t, n, r, s)), !0;
                  case "gotpointercapture":
                    return (
                      (i = s.pointerId),
                      Nt.set(i, jt(Nt.get(i) || null, e, t, n, r, s)),
                      !0
                    );
                }
                return !1;
              })(s, e, t, n, r)
            )
              r.stopPropagation();
            else if ((Mt(e, r), 4 & t && -1 < Dt.indexOf(e))) {
              for (; null !== s; ) {
                var i = bs(s);
                if (
                  (null !== i && St(i),
                  null === (i = Qt(e, t, n, r)) && Wr(e, t, r, Jt, n),
                  i === s)
                )
                  break;
                s = i;
              }
              null !== s && r.stopPropagation();
            } else Wr(e, t, r, null, n);
          }
        }
        var Jt = null;
        function Qt(e, t, n, r) {
          if (((Jt = null), null !== (e = ys((e = Se(r))))))
            if (null === (t = qe(e))) e = null;
            else if (13 === (n = t.tag)) {
              if (null !== (e = He(t))) return e;
              e = null;
            } else if (3 === n) {
              if (t.stateNode.current.memoizedState.isDehydrated)
                return 3 === t.tag ? t.stateNode.containerInfo : null;
              e = null;
            } else t !== e && (e = null);
          return (Jt = e), null;
        }
        function Yt(e) {
          switch (e) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return 1;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return 4;
            case "message":
              switch (Ze()) {
                case $e:
                  return 1;
                case et:
                  return 4;
                case tt:
                case nt:
                  return 16;
                case rt:
                  return 536870912;
                default:
                  return 16;
              }
            default:
              return 16;
          }
        }
        var Xt = null,
          Zt = null,
          $t = null;
        function en() {
          if ($t) return $t;
          var e,
            t,
            n = Zt,
            r = n.length,
            s = "value" in Xt ? Xt.value : Xt.textContent,
            i = s.length;
          for (e = 0; e < r && n[e] === s[e]; e++);
          var o = r - e;
          for (t = 1; t <= o && n[r - t] === s[i - t]; t++);
          return ($t = s.slice(e, 1 < t ? 1 - t : void 0));
        }
        function tn(e) {
          var t = e.keyCode;
          return (
            "charCode" in e
              ? 0 === (e = e.charCode) && 13 === t && (e = 13)
              : (e = t),
            10 === e && (e = 13),
            32 <= e || 13 === e ? e : 0
          );
        }
        function nn() {
          return !0;
        }
        function rn() {
          return !1;
        }
        function sn(e) {
          function t(t, n, r, s, i) {
            for (var o in ((this._reactName = t),
            (this._targetInst = r),
            (this.type = n),
            (this.nativeEvent = s),
            (this.target = i),
            (this.currentTarget = null),
            e))
              e.hasOwnProperty(o) && ((t = e[o]), (this[o] = t ? t(s) : s[o]));
            return (
              (this.isDefaultPrevented = (
                null != s.defaultPrevented
                  ? s.defaultPrevented
                  : !1 === s.returnValue
              )
                ? nn
                : rn),
              (this.isPropagationStopped = rn),
              this
            );
          }
          return (
            L(t.prototype, {
              preventDefault: function () {
                this.defaultPrevented = !0;
                var e = this.nativeEvent;
                e &&
                  (e.preventDefault
                    ? e.preventDefault()
                    : "unknown" !== typeof e.returnValue &&
                      (e.returnValue = !1),
                  (this.isDefaultPrevented = nn));
              },
              stopPropagation: function () {
                var e = this.nativeEvent;
                e &&
                  (e.stopPropagation
                    ? e.stopPropagation()
                    : "unknown" !== typeof e.cancelBubble &&
                      (e.cancelBubble = !0),
                  (this.isPropagationStopped = nn));
              },
              persist: function () {},
              isPersistent: nn,
            }),
            t
          );
        }
        var on,
          an,
          cn,
          ln = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function (e) {
              return e.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0,
          },
          un = sn(ln),
          dn = L({}, ln, { view: 0, detail: 0 }),
          hn = sn(dn),
          pn = L({}, dn, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: Tn,
            button: 0,
            buttons: 0,
            relatedTarget: function (e) {
              return void 0 === e.relatedTarget
                ? e.fromElement === e.srcElement
                  ? e.toElement
                  : e.fromElement
                : e.relatedTarget;
            },
            movementX: function (e) {
              return "movementX" in e
                ? e.movementX
                : (e !== cn &&
                    (cn && "mousemove" === e.type
                      ? ((on = e.screenX - cn.screenX),
                        (an = e.screenY - cn.screenY))
                      : (an = on = 0),
                    (cn = e)),
                  on);
            },
            movementY: function (e) {
              return "movementY" in e ? e.movementY : an;
            },
          }),
          fn = sn(pn),
          mn = sn(L({}, pn, { dataTransfer: 0 })),
          gn = sn(L({}, dn, { relatedTarget: 0 })),
          vn = sn(
            L({}, ln, { animationName: 0, elapsedTime: 0, pseudoElement: 0 })
          ),
          yn = L({}, ln, {
            clipboardData: function (e) {
              return "clipboardData" in e
                ? e.clipboardData
                : window.clipboardData;
            },
          }),
          bn = sn(yn),
          wn = sn(L({}, ln, { data: 0 })),
          Sn = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified",
          },
          _n = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta",
          },
          En = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey",
          };
        function An(e) {
          var t = this.nativeEvent;
          return t.getModifierState
            ? t.getModifierState(e)
            : !!(e = En[e]) && !!t[e];
        }
        function Tn() {
          return An;
        }
        var Pn = L({}, dn, {
            key: function (e) {
              if (e.key) {
                var t = Sn[e.key] || e.key;
                if ("Unidentified" !== t) return t;
              }
              return "keypress" === e.type
                ? 13 === (e = tn(e))
                  ? "Enter"
                  : String.fromCharCode(e)
                : "keydown" === e.type || "keyup" === e.type
                ? _n[e.keyCode] || "Unidentified"
                : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: Tn,
            charCode: function (e) {
              return "keypress" === e.type ? tn(e) : 0;
            },
            keyCode: function (e) {
              return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0;
            },
            which: function (e) {
              return "keypress" === e.type
                ? tn(e)
                : "keydown" === e.type || "keyup" === e.type
                ? e.keyCode
                : 0;
            },
          }),
          In = sn(Pn),
          Cn = sn(
            L({}, pn, {
              pointerId: 0,
              width: 0,
              height: 0,
              pressure: 0,
              tangentialPressure: 0,
              tiltX: 0,
              tiltY: 0,
              twist: 0,
              pointerType: 0,
              isPrimary: 0,
            })
          ),
          kn = sn(
            L({}, dn, {
              touches: 0,
              targetTouches: 0,
              changedTouches: 0,
              altKey: 0,
              metaKey: 0,
              ctrlKey: 0,
              shiftKey: 0,
              getModifierState: Tn,
            })
          ),
          On = sn(
            L({}, ln, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 })
          ),
          xn = L({}, pn, {
            deltaX: function (e) {
              return "deltaX" in e
                ? e.deltaX
                : "wheelDeltaX" in e
                ? -e.wheelDeltaX
                : 0;
            },
            deltaY: function (e) {
              return "deltaY" in e
                ? e.deltaY
                : "wheelDeltaY" in e
                ? -e.wheelDeltaY
                : "wheelDelta" in e
                ? -e.wheelDelta
                : 0;
            },
            deltaZ: 0,
            deltaMode: 0,
          }),
          Nn = sn(xn),
          Rn = [9, 13, 27, 32],
          Dn = u && "CompositionEvent" in window,
          Mn = null;
        u && "documentMode" in document && (Mn = document.documentMode);
        var jn = u && "TextEvent" in window && !Mn,
          Ln = u && (!Dn || (Mn && 8 < Mn && 11 >= Mn)),
          Un = String.fromCharCode(32),
          Fn = !1;
        function Bn(e, t) {
          switch (e) {
            case "keyup":
              return -1 !== Rn.indexOf(t.keyCode);
            case "keydown":
              return 229 !== t.keyCode;
            case "keypress":
            case "mousedown":
            case "focusout":
              return !0;
            default:
              return !1;
          }
        }
        function Vn(e) {
          return "object" === typeof (e = e.detail) && "data" in e
            ? e.data
            : null;
        }
        var qn = !1;
        var Hn = {
          color: !0,
          date: !0,
          datetime: !0,
          "datetime-local": !0,
          email: !0,
          month: !0,
          number: !0,
          password: !0,
          range: !0,
          search: !0,
          tel: !0,
          text: !0,
          time: !0,
          url: !0,
          week: !0,
        };
        function Wn(e) {
          var t = e && e.nodeName && e.nodeName.toLowerCase();
          return "input" === t ? !!Hn[e.type] : "textarea" === t;
        }
        function Kn(e, t, n, r) {
          Pe(r),
            0 < (t = zr(t, "onChange")).length &&
              ((n = new un("onChange", "change", null, n, r)),
              e.push({ event: n, listeners: t }));
        }
        var zn = null,
          Gn = null;
        function Jn(e) {
          Ur(e, 0);
        }
        function Qn(e) {
          if (G(ws(e))) return e;
        }
        function Yn(e, t) {
          if ("change" === e) return t;
        }
        var Xn = !1;
        if (u) {
          var Zn;
          if (u) {
            var $n = "oninput" in document;
            if (!$n) {
              var er = document.createElement("div");
              er.setAttribute("oninput", "return;"),
                ($n = "function" === typeof er.oninput);
            }
            Zn = $n;
          } else Zn = !1;
          Xn = Zn && (!document.documentMode || 9 < document.documentMode);
        }
        function tr() {
          zn && (zn.detachEvent("onpropertychange", nr), (Gn = zn = null));
        }
        function nr(e) {
          if ("value" === e.propertyName && Qn(Gn)) {
            var t = [];
            Kn(t, Gn, e, Se(e)), xe(Jn, t);
          }
        }
        function rr(e, t, n) {
          "focusin" === e
            ? (tr(), (Gn = n), (zn = t).attachEvent("onpropertychange", nr))
            : "focusout" === e && tr();
        }
        function sr(e) {
          if ("selectionchange" === e || "keyup" === e || "keydown" === e)
            return Qn(Gn);
        }
        function ir(e, t) {
          if ("click" === e) return Qn(t);
        }
        function or(e, t) {
          if ("input" === e || "change" === e) return Qn(t);
        }
        var ar =
          "function" === typeof Object.is
            ? Object.is
            : function (e, t) {
                return (
                  (e === t && (0 !== e || 1 / e === 1 / t)) ||
                  (e !== e && t !== t)
                );
              };
        function cr(e, t) {
          if (ar(e, t)) return !0;
          if (
            "object" !== typeof e ||
            null === e ||
            "object" !== typeof t ||
            null === t
          )
            return !1;
          var n = Object.keys(e),
            r = Object.keys(t);
          if (n.length !== r.length) return !1;
          for (r = 0; r < n.length; r++) {
            var s = n[r];
            if (!d.call(t, s) || !ar(e[s], t[s])) return !1;
          }
          return !0;
        }
        function lr(e) {
          for (; e && e.firstChild; ) e = e.firstChild;
          return e;
        }
        function ur(e, t) {
          var n,
            r = lr(e);
          for (e = 0; r; ) {
            if (3 === r.nodeType) {
              if (((n = e + r.textContent.length), e <= t && n >= t))
                return { node: r, offset: t - e };
              e = n;
            }
            e: {
              for (; r; ) {
                if (r.nextSibling) {
                  r = r.nextSibling;
                  break e;
                }
                r = r.parentNode;
              }
              r = void 0;
            }
            r = lr(r);
          }
        }
        function dr(e, t) {
          return (
            !(!e || !t) &&
            (e === t ||
              ((!e || 3 !== e.nodeType) &&
                (t && 3 === t.nodeType
                  ? dr(e, t.parentNode)
                  : "contains" in e
                  ? e.contains(t)
                  : !!e.compareDocumentPosition &&
                    !!(16 & e.compareDocumentPosition(t)))))
          );
        }
        function hr() {
          for (var e = window, t = J(); t instanceof e.HTMLIFrameElement; ) {
            try {
              var n = "string" === typeof t.contentWindow.location.href;
            } catch (r) {
              n = !1;
            }
            if (!n) break;
            t = J((e = t.contentWindow).document);
          }
          return t;
        }
        function pr(e) {
          var t = e && e.nodeName && e.nodeName.toLowerCase();
          return (
            t &&
            (("input" === t &&
              ("text" === e.type ||
                "search" === e.type ||
                "tel" === e.type ||
                "url" === e.type ||
                "password" === e.type)) ||
              "textarea" === t ||
              "true" === e.contentEditable)
          );
        }
        function fr(e) {
          var t = hr(),
            n = e.focusedElem,
            r = e.selectionRange;
          if (
            t !== n &&
            n &&
            n.ownerDocument &&
            dr(n.ownerDocument.documentElement, n)
          ) {
            if (null !== r && pr(n))
              if (
                ((t = r.start),
                void 0 === (e = r.end) && (e = t),
                "selectionStart" in n)
              )
                (n.selectionStart = t),
                  (n.selectionEnd = Math.min(e, n.value.length));
              else if (
                (e =
                  ((t = n.ownerDocument || document) && t.defaultView) ||
                  window).getSelection
              ) {
                e = e.getSelection();
                var s = n.textContent.length,
                  i = Math.min(r.start, s);
                (r = void 0 === r.end ? i : Math.min(r.end, s)),
                  !e.extend && i > r && ((s = r), (r = i), (i = s)),
                  (s = ur(n, i));
                var o = ur(n, r);
                s &&
                  o &&
                  (1 !== e.rangeCount ||
                    e.anchorNode !== s.node ||
                    e.anchorOffset !== s.offset ||
                    e.focusNode !== o.node ||
                    e.focusOffset !== o.offset) &&
                  ((t = t.createRange()).setStart(s.node, s.offset),
                  e.removeAllRanges(),
                  i > r
                    ? (e.addRange(t), e.extend(o.node, o.offset))
                    : (t.setEnd(o.node, o.offset), e.addRange(t)));
              }
            for (t = [], e = n; (e = e.parentNode); )
              1 === e.nodeType &&
                t.push({ element: e, left: e.scrollLeft, top: e.scrollTop });
            for (
              "function" === typeof n.focus && n.focus(), n = 0;
              n < t.length;
              n++
            )
              ((e = t[n]).element.scrollLeft = e.left),
                (e.element.scrollTop = e.top);
          }
        }
        var mr = u && "documentMode" in document && 11 >= document.documentMode,
          gr = null,
          vr = null,
          yr = null,
          br = !1;
        function wr(e, t, n) {
          var r =
            n.window === n
              ? n.document
              : 9 === n.nodeType
              ? n
              : n.ownerDocument;
          br ||
            null == gr ||
            gr !== J(r) ||
            ("selectionStart" in (r = gr) && pr(r)
              ? (r = { start: r.selectionStart, end: r.selectionEnd })
              : (r = {
                  anchorNode: (r = (
                    (r.ownerDocument && r.ownerDocument.defaultView) ||
                    window
                  ).getSelection()).anchorNode,
                  anchorOffset: r.anchorOffset,
                  focusNode: r.focusNode,
                  focusOffset: r.focusOffset,
                }),
            (yr && cr(yr, r)) ||
              ((yr = r),
              0 < (r = zr(vr, "onSelect")).length &&
                ((t = new un("onSelect", "select", null, t, n)),
                e.push({ event: t, listeners: r }),
                (t.target = gr))));
        }
        function Sr(e, t) {
          var n = {};
          return (
            (n[e.toLowerCase()] = t.toLowerCase()),
            (n["Webkit" + e] = "webkit" + t),
            (n["Moz" + e] = "moz" + t),
            n
          );
        }
        var _r = {
            animationend: Sr("Animation", "AnimationEnd"),
            animationiteration: Sr("Animation", "AnimationIteration"),
            animationstart: Sr("Animation", "AnimationStart"),
            transitionend: Sr("Transition", "TransitionEnd"),
          },
          Er = {},
          Ar = {};
        function Tr(e) {
          if (Er[e]) return Er[e];
          if (!_r[e]) return e;
          var t,
            n = _r[e];
          for (t in n)
            if (n.hasOwnProperty(t) && t in Ar) return (Er[e] = n[t]);
          return e;
        }
        u &&
          ((Ar = document.createElement("div").style),
          "AnimationEvent" in window ||
            (delete _r.animationend.animation,
            delete _r.animationiteration.animation,
            delete _r.animationstart.animation),
          "TransitionEvent" in window || delete _r.transitionend.transition);
        var Pr = Tr("animationend"),
          Ir = Tr("animationiteration"),
          Cr = Tr("animationstart"),
          kr = Tr("transitionend"),
          Or = new Map(),
          xr =
            "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
              " "
            );
        function Nr(e, t) {
          Or.set(e, t), c(t, [e]);
        }
        for (var Rr = 0; Rr < xr.length; Rr++) {
          var Dr = xr[Rr];
          Nr(Dr.toLowerCase(), "on" + (Dr[0].toUpperCase() + Dr.slice(1)));
        }
        Nr(Pr, "onAnimationEnd"),
          Nr(Ir, "onAnimationIteration"),
          Nr(Cr, "onAnimationStart"),
          Nr("dblclick", "onDoubleClick"),
          Nr("focusin", "onFocus"),
          Nr("focusout", "onBlur"),
          Nr(kr, "onTransitionEnd"),
          l("onMouseEnter", ["mouseout", "mouseover"]),
          l("onMouseLeave", ["mouseout", "mouseover"]),
          l("onPointerEnter", ["pointerout", "pointerover"]),
          l("onPointerLeave", ["pointerout", "pointerover"]),
          c(
            "onChange",
            "change click focusin focusout input keydown keyup selectionchange".split(
              " "
            )
          ),
          c(
            "onSelect",
            "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
              " "
            )
          ),
          c("onBeforeInput", [
            "compositionend",
            "keypress",
            "textInput",
            "paste",
          ]),
          c(
            "onCompositionEnd",
            "compositionend focusout keydown keypress keyup mousedown".split(
              " "
            )
          ),
          c(
            "onCompositionStart",
            "compositionstart focusout keydown keypress keyup mousedown".split(
              " "
            )
          ),
          c(
            "onCompositionUpdate",
            "compositionupdate focusout keydown keypress keyup mousedown".split(
              " "
            )
          );
        var Mr =
            "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
              " "
            ),
          jr = new Set(
            "cancel close invalid load scroll toggle".split(" ").concat(Mr)
          );
        function Lr(e, t, n) {
          var r = e.type || "unknown-event";
          (e.currentTarget = n),
            (function (e, t, n, r, s, o, a, c, l) {
              if ((Ve.apply(this, arguments), je)) {
                if (!je) throw Error(i(198));
                var u = Le;
                (je = !1), (Le = null), Ue || ((Ue = !0), (Fe = u));
              }
            })(r, t, void 0, e),
            (e.currentTarget = null);
        }
        function Ur(e, t) {
          t = 0 !== (4 & t);
          for (var n = 0; n < e.length; n++) {
            var r = e[n],
              s = r.event;
            r = r.listeners;
            e: {
              var i = void 0;
              if (t)
                for (var o = r.length - 1; 0 <= o; o--) {
                  var a = r[o],
                    c = a.instance,
                    l = a.currentTarget;
                  if (((a = a.listener), c !== i && s.isPropagationStopped()))
                    break e;
                  Lr(s, a, l), (i = c);
                }
              else
                for (o = 0; o < r.length; o++) {
                  if (
                    ((c = (a = r[o]).instance),
                    (l = a.currentTarget),
                    (a = a.listener),
                    c !== i && s.isPropagationStopped())
                  )
                    break e;
                  Lr(s, a, l), (i = c);
                }
            }
          }
          if (Ue) throw ((e = Fe), (Ue = !1), (Fe = null), e);
        }
        function Fr(e, t) {
          var n = t[ms];
          void 0 === n && (n = t[ms] = new Set());
          var r = e + "__bubble";
          n.has(r) || (Hr(t, e, 2, !1), n.add(r));
        }
        function Br(e, t, n) {
          var r = 0;
          t && (r |= 4), Hr(n, e, r, t);
        }
        var Vr = "_reactListening" + Math.random().toString(36).slice(2);
        function qr(e) {
          if (!e[Vr]) {
            (e[Vr] = !0),
              o.forEach(function (t) {
                "selectionchange" !== t &&
                  (jr.has(t) || Br(t, !1, e), Br(t, !0, e));
              });
            var t = 9 === e.nodeType ? e : e.ownerDocument;
            null === t || t[Vr] || ((t[Vr] = !0), Br("selectionchange", !1, t));
          }
        }
        function Hr(e, t, n, r) {
          switch (Yt(t)) {
            case 1:
              var s = Kt;
              break;
            case 4:
              s = zt;
              break;
            default:
              s = Gt;
          }
          (n = s.bind(null, t, n, e)),
            (s = void 0),
            !Re ||
              ("touchstart" !== t && "touchmove" !== t && "wheel" !== t) ||
              (s = !0),
            r
              ? void 0 !== s
                ? e.addEventListener(t, n, { capture: !0, passive: s })
                : e.addEventListener(t, n, !0)
              : void 0 !== s
              ? e.addEventListener(t, n, { passive: s })
              : e.addEventListener(t, n, !1);
        }
        function Wr(e, t, n, r, s) {
          var i = r;
          if (0 === (1 & t) && 0 === (2 & t) && null !== r)
            e: for (;;) {
              if (null === r) return;
              var o = r.tag;
              if (3 === o || 4 === o) {
                var a = r.stateNode.containerInfo;
                if (a === s || (8 === a.nodeType && a.parentNode === s)) break;
                if (4 === o)
                  for (o = r.return; null !== o; ) {
                    var c = o.tag;
                    if (
                      (3 === c || 4 === c) &&
                      ((c = o.stateNode.containerInfo) === s ||
                        (8 === c.nodeType && c.parentNode === s))
                    )
                      return;
                    o = o.return;
                  }
                for (; null !== a; ) {
                  if (null === (o = ys(a))) return;
                  if (5 === (c = o.tag) || 6 === c) {
                    r = i = o;
                    continue e;
                  }
                  a = a.parentNode;
                }
              }
              r = r.return;
            }
          xe(function () {
            var r = i,
              s = Se(n),
              o = [];
            e: {
              var a = Or.get(e);
              if (void 0 !== a) {
                var c = un,
                  l = e;
                switch (e) {
                  case "keypress":
                    if (0 === tn(n)) break e;
                  case "keydown":
                  case "keyup":
                    c = In;
                    break;
                  case "focusin":
                    (l = "focus"), (c = gn);
                    break;
                  case "focusout":
                    (l = "blur"), (c = gn);
                    break;
                  case "beforeblur":
                  case "afterblur":
                    c = gn;
                    break;
                  case "click":
                    if (2 === n.button) break e;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    c = fn;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    c = mn;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    c = kn;
                    break;
                  case Pr:
                  case Ir:
                  case Cr:
                    c = vn;
                    break;
                  case kr:
                    c = On;
                    break;
                  case "scroll":
                    c = hn;
                    break;
                  case "wheel":
                    c = Nn;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    c = bn;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    c = Cn;
                }
                var u = 0 !== (4 & t),
                  d = !u && "scroll" === e,
                  h = u ? (null !== a ? a + "Capture" : null) : a;
                u = [];
                for (var p, f = r; null !== f; ) {
                  var m = (p = f).stateNode;
                  if (
                    (5 === p.tag &&
                      null !== m &&
                      ((p = m),
                      null !== h &&
                        null != (m = Ne(f, h)) &&
                        u.push(Kr(f, m, p))),
                    d)
                  )
                    break;
                  f = f.return;
                }
                0 < u.length &&
                  ((a = new c(a, l, null, n, s)),
                  o.push({ event: a, listeners: u }));
              }
            }
            if (0 === (7 & t)) {
              if (
                ((c = "mouseout" === e || "pointerout" === e),
                (!(a = "mouseover" === e || "pointerover" === e) ||
                  n === we ||
                  !(l = n.relatedTarget || n.fromElement) ||
                  (!ys(l) && !l[fs])) &&
                  (c || a) &&
                  ((a =
                    s.window === s
                      ? s
                      : (a = s.ownerDocument)
                      ? a.defaultView || a.parentWindow
                      : window),
                  c
                    ? ((c = r),
                      null !==
                        (l = (l = n.relatedTarget || n.toElement)
                          ? ys(l)
                          : null) &&
                        (l !== (d = qe(l)) || (5 !== l.tag && 6 !== l.tag)) &&
                        (l = null))
                    : ((c = null), (l = r)),
                  c !== l))
              ) {
                if (
                  ((u = fn),
                  (m = "onMouseLeave"),
                  (h = "onMouseEnter"),
                  (f = "mouse"),
                  ("pointerout" !== e && "pointerover" !== e) ||
                    ((u = Cn),
                    (m = "onPointerLeave"),
                    (h = "onPointerEnter"),
                    (f = "pointer")),
                  (d = null == c ? a : ws(c)),
                  (p = null == l ? a : ws(l)),
                  ((a = new u(m, f + "leave", c, n, s)).target = d),
                  (a.relatedTarget = p),
                  (m = null),
                  ys(s) === r &&
                    (((u = new u(h, f + "enter", l, n, s)).target = p),
                    (u.relatedTarget = d),
                    (m = u)),
                  (d = m),
                  c && l)
                )
                  e: {
                    for (h = l, f = 0, p = u = c; p; p = Gr(p)) f++;
                    for (p = 0, m = h; m; m = Gr(m)) p++;
                    for (; 0 < f - p; ) (u = Gr(u)), f--;
                    for (; 0 < p - f; ) (h = Gr(h)), p--;
                    for (; f--; ) {
                      if (u === h || (null !== h && u === h.alternate)) break e;
                      (u = Gr(u)), (h = Gr(h));
                    }
                    u = null;
                  }
                else u = null;
                null !== c && Jr(o, a, c, u, !1),
                  null !== l && null !== d && Jr(o, d, l, u, !0);
              }
              if (
                "select" ===
                  (c =
                    (a = r ? ws(r) : window).nodeName &&
                    a.nodeName.toLowerCase()) ||
                ("input" === c && "file" === a.type)
              )
                var g = Yn;
              else if (Wn(a))
                if (Xn) g = or;
                else {
                  g = sr;
                  var v = rr;
                }
              else
                (c = a.nodeName) &&
                  "input" === c.toLowerCase() &&
                  ("checkbox" === a.type || "radio" === a.type) &&
                  (g = ir);
              switch (
                (g && (g = g(e, r))
                  ? Kn(o, g, n, s)
                  : (v && v(e, a, r),
                    "focusout" === e &&
                      (v = a._wrapperState) &&
                      v.controlled &&
                      "number" === a.type &&
                      ee(a, "number", a.value)),
                (v = r ? ws(r) : window),
                e)
              ) {
                case "focusin":
                  (Wn(v) || "true" === v.contentEditable) &&
                    ((gr = v), (vr = r), (yr = null));
                  break;
                case "focusout":
                  yr = vr = gr = null;
                  break;
                case "mousedown":
                  br = !0;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  (br = !1), wr(o, n, s);
                  break;
                case "selectionchange":
                  if (mr) break;
                case "keydown":
                case "keyup":
                  wr(o, n, s);
              }
              var y;
              if (Dn)
                e: {
                  switch (e) {
                    case "compositionstart":
                      var b = "onCompositionStart";
                      break e;
                    case "compositionend":
                      b = "onCompositionEnd";
                      break e;
                    case "compositionupdate":
                      b = "onCompositionUpdate";
                      break e;
                  }
                  b = void 0;
                }
              else
                qn
                  ? Bn(e, n) && (b = "onCompositionEnd")
                  : "keydown" === e &&
                    229 === n.keyCode &&
                    (b = "onCompositionStart");
              b &&
                (Ln &&
                  "ko" !== n.locale &&
                  (qn || "onCompositionStart" !== b
                    ? "onCompositionEnd" === b && qn && (y = en())
                    : ((Zt = "value" in (Xt = s) ? Xt.value : Xt.textContent),
                      (qn = !0))),
                0 < (v = zr(r, b)).length &&
                  ((b = new wn(b, e, null, n, s)),
                  o.push({ event: b, listeners: v }),
                  y ? (b.data = y) : null !== (y = Vn(n)) && (b.data = y))),
                (y = jn
                  ? (function (e, t) {
                      switch (e) {
                        case "compositionend":
                          return Vn(t);
                        case "keypress":
                          return 32 !== t.which ? null : ((Fn = !0), Un);
                        case "textInput":
                          return (e = t.data) === Un && Fn ? null : e;
                        default:
                          return null;
                      }
                    })(e, n)
                  : (function (e, t) {
                      if (qn)
                        return "compositionend" === e || (!Dn && Bn(e, t))
                          ? ((e = en()), ($t = Zt = Xt = null), (qn = !1), e)
                          : null;
                      switch (e) {
                        case "paste":
                        default:
                          return null;
                        case "keypress":
                          if (
                            !(t.ctrlKey || t.altKey || t.metaKey) ||
                            (t.ctrlKey && t.altKey)
                          ) {
                            if (t.char && 1 < t.char.length) return t.char;
                            if (t.which) return String.fromCharCode(t.which);
                          }
                          return null;
                        case "compositionend":
                          return Ln && "ko" !== t.locale ? null : t.data;
                      }
                    })(e, n)) &&
                  0 < (r = zr(r, "onBeforeInput")).length &&
                  ((s = new wn("onBeforeInput", "beforeinput", null, n, s)),
                  o.push({ event: s, listeners: r }),
                  (s.data = y));
            }
            Ur(o, t);
          });
        }
        function Kr(e, t, n) {
          return { instance: e, listener: t, currentTarget: n };
        }
        function zr(e, t) {
          for (var n = t + "Capture", r = []; null !== e; ) {
            var s = e,
              i = s.stateNode;
            5 === s.tag &&
              null !== i &&
              ((s = i),
              null != (i = Ne(e, n)) && r.unshift(Kr(e, i, s)),
              null != (i = Ne(e, t)) && r.push(Kr(e, i, s))),
              (e = e.return);
          }
          return r;
        }
        function Gr(e) {
          if (null === e) return null;
          do {
            e = e.return;
          } while (e && 5 !== e.tag);
          return e || null;
        }
        function Jr(e, t, n, r, s) {
          for (var i = t._reactName, o = []; null !== n && n !== r; ) {
            var a = n,
              c = a.alternate,
              l = a.stateNode;
            if (null !== c && c === r) break;
            5 === a.tag &&
              null !== l &&
              ((a = l),
              s
                ? null != (c = Ne(n, i)) && o.unshift(Kr(n, c, a))
                : s || (null != (c = Ne(n, i)) && o.push(Kr(n, c, a)))),
              (n = n.return);
          }
          0 !== o.length && e.push({ event: t, listeners: o });
        }
        var Qr = /\r\n?/g,
          Yr = /\u0000|\uFFFD/g;
        function Xr(e) {
          return ("string" === typeof e ? e : "" + e)
            .replace(Qr, "\n")
            .replace(Yr, "");
        }
        function Zr(e, t, n) {
          if (((t = Xr(t)), Xr(e) !== t && n)) throw Error(i(425));
        }
        function $r() {}
        var es = null,
          ts = null;
        function ns(e, t) {
          return (
            "textarea" === e ||
            "noscript" === e ||
            "string" === typeof t.children ||
            "number" === typeof t.children ||
            ("object" === typeof t.dangerouslySetInnerHTML &&
              null !== t.dangerouslySetInnerHTML &&
              null != t.dangerouslySetInnerHTML.__html)
          );
        }
        var rs = "function" === typeof setTimeout ? setTimeout : void 0,
          ss = "function" === typeof clearTimeout ? clearTimeout : void 0,
          is = "function" === typeof Promise ? Promise : void 0,
          os =
            "function" === typeof queueMicrotask
              ? queueMicrotask
              : "undefined" !== typeof is
              ? function (e) {
                  return is.resolve(null).then(e).catch(as);
                }
              : rs;
        function as(e) {
          setTimeout(function () {
            throw e;
          });
        }
        function cs(e, t) {
          var n = t,
            r = 0;
          do {
            var s = n.nextSibling;
            if ((e.removeChild(n), s && 8 === s.nodeType))
              if ("/$" === (n = s.data)) {
                if (0 === r) return e.removeChild(s), void qt(t);
                r--;
              } else ("$" !== n && "$?" !== n && "$!" !== n) || r++;
            n = s;
          } while (n);
          qt(t);
        }
        function ls(e) {
          for (; null != e; e = e.nextSibling) {
            var t = e.nodeType;
            if (1 === t || 3 === t) break;
            if (8 === t) {
              if ("$" === (t = e.data) || "$!" === t || "$?" === t) break;
              if ("/$" === t) return null;
            }
          }
          return e;
        }
        function us(e) {
          e = e.previousSibling;
          for (var t = 0; e; ) {
            if (8 === e.nodeType) {
              var n = e.data;
              if ("$" === n || "$!" === n || "$?" === n) {
                if (0 === t) return e;
                t--;
              } else "/$" === n && t++;
            }
            e = e.previousSibling;
          }
          return null;
        }
        var ds = Math.random().toString(36).slice(2),
          hs = "__reactFiber$" + ds,
          ps = "__reactProps$" + ds,
          fs = "__reactContainer$" + ds,
          ms = "__reactEvents$" + ds,
          gs = "__reactListeners$" + ds,
          vs = "__reactHandles$" + ds;
        function ys(e) {
          var t = e[hs];
          if (t) return t;
          for (var n = e.parentNode; n; ) {
            if ((t = n[fs] || n[hs])) {
              if (
                ((n = t.alternate),
                null !== t.child || (null !== n && null !== n.child))
              )
                for (e = us(e); null !== e; ) {
                  if ((n = e[hs])) return n;
                  e = us(e);
                }
              return t;
            }
            n = (e = n).parentNode;
          }
          return null;
        }
        function bs(e) {
          return !(e = e[hs] || e[fs]) ||
            (5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag)
            ? null
            : e;
        }
        function ws(e) {
          if (5 === e.tag || 6 === e.tag) return e.stateNode;
          throw Error(i(33));
        }
        function Ss(e) {
          return e[ps] || null;
        }
        var _s = [],
          Es = -1;
        function As(e) {
          return { current: e };
        }
        function Ts(e) {
          0 > Es || ((e.current = _s[Es]), (_s[Es] = null), Es--);
        }
        function Ps(e, t) {
          Es++, (_s[Es] = e.current), (e.current = t);
        }
        var Is = {},
          Cs = As(Is),
          ks = As(!1),
          Os = Is;
        function xs(e, t) {
          var n = e.type.contextTypes;
          if (!n) return Is;
          var r = e.stateNode;
          if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
            return r.__reactInternalMemoizedMaskedChildContext;
          var s,
            i = {};
          for (s in n) i[s] = t[s];
          return (
            r &&
              (((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext =
                t),
              (e.__reactInternalMemoizedMaskedChildContext = i)),
            i
          );
        }
        function Ns(e) {
          return null !== (e = e.childContextTypes) && void 0 !== e;
        }
        function Rs() {
          Ts(ks), Ts(Cs);
        }
        function Ds(e, t, n) {
          if (Cs.current !== Is) throw Error(i(168));
          Ps(Cs, t), Ps(ks, n);
        }
        function Ms(e, t, n) {
          var r = e.stateNode;
          if (
            ((t = t.childContextTypes), "function" !== typeof r.getChildContext)
          )
            return n;
          for (var s in (r = r.getChildContext()))
            if (!(s in t)) throw Error(i(108, H(e) || "Unknown", s));
          return L({}, n, r);
        }
        function js(e) {
          return (
            (e =
              ((e = e.stateNode) &&
                e.__reactInternalMemoizedMergedChildContext) ||
              Is),
            (Os = Cs.current),
            Ps(Cs, e),
            Ps(ks, ks.current),
            !0
          );
        }
        function Ls(e, t, n) {
          var r = e.stateNode;
          if (!r) throw Error(i(169));
          n
            ? ((e = Ms(e, t, Os)),
              (r.__reactInternalMemoizedMergedChildContext = e),
              Ts(ks),
              Ts(Cs),
              Ps(Cs, e))
            : Ts(ks),
            Ps(ks, n);
        }
        var Us = null,
          Fs = !1,
          Bs = !1;
        function Vs(e) {
          null === Us ? (Us = [e]) : Us.push(e);
        }
        function qs() {
          if (!Bs && null !== Us) {
            Bs = !0;
            var e = 0,
              t = bt;
            try {
              var n = Us;
              for (bt = 1; e < n.length; e++) {
                var r = n[e];
                do {
                  r = r(!0);
                } while (null !== r);
              }
              (Us = null), (Fs = !1);
            } catch (s) {
              throw (null !== Us && (Us = Us.slice(e + 1)), Ge($e, qs), s);
            } finally {
              (bt = t), (Bs = !1);
            }
          }
          return null;
        }
        var Hs = [],
          Ws = 0,
          Ks = null,
          zs = 0,
          Gs = [],
          Js = 0,
          Qs = null,
          Ys = 1,
          Xs = "";
        function Zs(e, t) {
          (Hs[Ws++] = zs), (Hs[Ws++] = Ks), (Ks = e), (zs = t);
        }
        function $s(e, t, n) {
          (Gs[Js++] = Ys), (Gs[Js++] = Xs), (Gs[Js++] = Qs), (Qs = e);
          var r = Ys;
          e = Xs;
          var s = 32 - ot(r) - 1;
          (r &= ~(1 << s)), (n += 1);
          var i = 32 - ot(t) + s;
          if (30 < i) {
            var o = s - (s % 5);
            (i = (r & ((1 << o) - 1)).toString(32)),
              (r >>= o),
              (s -= o),
              (Ys = (1 << (32 - ot(t) + s)) | (n << s) | r),
              (Xs = i + e);
          } else (Ys = (1 << i) | (n << s) | r), (Xs = e);
        }
        function ei(e) {
          null !== e.return && (Zs(e, 1), $s(e, 1, 0));
        }
        function ti(e) {
          for (; e === Ks; )
            (Ks = Hs[--Ws]), (Hs[Ws] = null), (zs = Hs[--Ws]), (Hs[Ws] = null);
          for (; e === Qs; )
            (Qs = Gs[--Js]),
              (Gs[Js] = null),
              (Xs = Gs[--Js]),
              (Gs[Js] = null),
              (Ys = Gs[--Js]),
              (Gs[Js] = null);
        }
        var ni = null,
          ri = null,
          si = !1,
          ii = null;
        function oi(e, t) {
          var n = xl(5, null, null, 0);
          (n.elementType = "DELETED"),
            (n.stateNode = t),
            (n.return = e),
            null === (t = e.deletions)
              ? ((e.deletions = [n]), (e.flags |= 16))
              : t.push(n);
        }
        function ai(e, t) {
          switch (e.tag) {
            case 5:
              var n = e.type;
              return (
                null !==
                  (t =
                    1 !== t.nodeType ||
                    n.toLowerCase() !== t.nodeName.toLowerCase()
                      ? null
                      : t) &&
                ((e.stateNode = t), (ni = e), (ri = ls(t.firstChild)), !0)
              );
            case 6:
              return (
                null !==
                  (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) &&
                ((e.stateNode = t), (ni = e), (ri = null), !0)
              );
            case 13:
              return (
                null !== (t = 8 !== t.nodeType ? null : t) &&
                ((n = null !== Qs ? { id: Ys, overflow: Xs } : null),
                (e.memoizedState = {
                  dehydrated: t,
                  treeContext: n,
                  retryLane: 1073741824,
                }),
                ((n = xl(18, null, null, 0)).stateNode = t),
                (n.return = e),
                (e.child = n),
                (ni = e),
                (ri = null),
                !0)
              );
            default:
              return !1;
          }
        }
        function ci(e) {
          return 0 !== (1 & e.mode) && 0 === (128 & e.flags);
        }
        function li(e) {
          if (si) {
            var t = ri;
            if (t) {
              var n = t;
              if (!ai(e, t)) {
                if (ci(e)) throw Error(i(418));
                t = ls(n.nextSibling);
                var r = ni;
                t && ai(e, t)
                  ? oi(r, n)
                  : ((e.flags = (-4097 & e.flags) | 2), (si = !1), (ni = e));
              }
            } else {
              if (ci(e)) throw Error(i(418));
              (e.flags = (-4097 & e.flags) | 2), (si = !1), (ni = e);
            }
          }
        }
        function ui(e) {
          for (
            e = e.return;
            null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;

          )
            e = e.return;
          ni = e;
        }
        function di(e) {
          if (e !== ni) return !1;
          if (!si) return ui(e), (si = !0), !1;
          var t;
          if (
            ((t = 3 !== e.tag) &&
              !(t = 5 !== e.tag) &&
              (t =
                "head" !== (t = e.type) &&
                "body" !== t &&
                !ns(e.type, e.memoizedProps)),
            t && (t = ri))
          ) {
            if (ci(e)) throw (hi(), Error(i(418)));
            for (; t; ) oi(e, t), (t = ls(t.nextSibling));
          }
          if ((ui(e), 13 === e.tag)) {
            if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null))
              throw Error(i(317));
            e: {
              for (e = e.nextSibling, t = 0; e; ) {
                if (8 === e.nodeType) {
                  var n = e.data;
                  if ("/$" === n) {
                    if (0 === t) {
                      ri = ls(e.nextSibling);
                      break e;
                    }
                    t--;
                  } else ("$" !== n && "$!" !== n && "$?" !== n) || t++;
                }
                e = e.nextSibling;
              }
              ri = null;
            }
          } else ri = ni ? ls(e.stateNode.nextSibling) : null;
          return !0;
        }
        function hi() {
          for (var e = ri; e; ) e = ls(e.nextSibling);
        }
        function pi() {
          (ri = ni = null), (si = !1);
        }
        function fi(e) {
          null === ii ? (ii = [e]) : ii.push(e);
        }
        var mi = w.ReactCurrentBatchConfig;
        function gi(e, t, n) {
          if (
            null !== (e = n.ref) &&
            "function" !== typeof e &&
            "object" !== typeof e
          ) {
            if (n._owner) {
              if ((n = n._owner)) {
                if (1 !== n.tag) throw Error(i(309));
                var r = n.stateNode;
              }
              if (!r) throw Error(i(147, e));
              var s = r,
                o = "" + e;
              return null !== t &&
                null !== t.ref &&
                "function" === typeof t.ref &&
                t.ref._stringRef === o
                ? t.ref
                : ((t = function (e) {
                    var t = s.refs;
                    null === e ? delete t[o] : (t[o] = e);
                  }),
                  (t._stringRef = o),
                  t);
            }
            if ("string" !== typeof e) throw Error(i(284));
            if (!n._owner) throw Error(i(290, e));
          }
          return e;
        }
        function vi(e, t) {
          throw (
            ((e = Object.prototype.toString.call(t)),
            Error(
              i(
                31,
                "[object Object]" === e
                  ? "object with keys {" + Object.keys(t).join(", ") + "}"
                  : e
              )
            ))
          );
        }
        function yi(e) {
          return (0, e._init)(e._payload);
        }
        function bi(e) {
          function t(t, n) {
            if (e) {
              var r = t.deletions;
              null === r ? ((t.deletions = [n]), (t.flags |= 16)) : r.push(n);
            }
          }
          function n(n, r) {
            if (!e) return null;
            for (; null !== r; ) t(n, r), (r = r.sibling);
            return null;
          }
          function r(e, t) {
            for (e = new Map(); null !== t; )
              null !== t.key ? e.set(t.key, t) : e.set(t.index, t),
                (t = t.sibling);
            return e;
          }
          function s(e, t) {
            return ((e = Rl(e, t)).index = 0), (e.sibling = null), e;
          }
          function o(t, n, r) {
            return (
              (t.index = r),
              e
                ? null !== (r = t.alternate)
                  ? (r = r.index) < n
                    ? ((t.flags |= 2), n)
                    : r
                  : ((t.flags |= 2), n)
                : ((t.flags |= 1048576), n)
            );
          }
          function a(t) {
            return e && null === t.alternate && (t.flags |= 2), t;
          }
          function c(e, t, n, r) {
            return null === t || 6 !== t.tag
              ? (((t = Ll(n, e.mode, r)).return = e), t)
              : (((t = s(t, n)).return = e), t);
          }
          function l(e, t, n, r) {
            var i = n.type;
            return i === E
              ? d(e, t, n.props.children, r, n.key)
              : null !== t &&
                (t.elementType === i ||
                  ("object" === typeof i &&
                    null !== i &&
                    i.$$typeof === N &&
                    yi(i) === t.type))
              ? (((r = s(t, n.props)).ref = gi(e, t, n)), (r.return = e), r)
              : (((r = Dl(n.type, n.key, n.props, null, e.mode, r)).ref = gi(
                  e,
                  t,
                  n
                )),
                (r.return = e),
                r);
          }
          function u(e, t, n, r) {
            return null === t ||
              4 !== t.tag ||
              t.stateNode.containerInfo !== n.containerInfo ||
              t.stateNode.implementation !== n.implementation
              ? (((t = Ul(n, e.mode, r)).return = e), t)
              : (((t = s(t, n.children || [])).return = e), t);
          }
          function d(e, t, n, r, i) {
            return null === t || 7 !== t.tag
              ? (((t = Ml(n, e.mode, r, i)).return = e), t)
              : (((t = s(t, n)).return = e), t);
          }
          function h(e, t, n) {
            if (("string" === typeof t && "" !== t) || "number" === typeof t)
              return ((t = Ll("" + t, e.mode, n)).return = e), t;
            if ("object" === typeof t && null !== t) {
              switch (t.$$typeof) {
                case S:
                  return (
                    ((n = Dl(t.type, t.key, t.props, null, e.mode, n)).ref = gi(
                      e,
                      null,
                      t
                    )),
                    (n.return = e),
                    n
                  );
                case _:
                  return ((t = Ul(t, e.mode, n)).return = e), t;
                case N:
                  return h(e, (0, t._init)(t._payload), n);
              }
              if (te(t) || M(t))
                return ((t = Ml(t, e.mode, n, null)).return = e), t;
              vi(e, t);
            }
            return null;
          }
          function p(e, t, n, r) {
            var s = null !== t ? t.key : null;
            if (("string" === typeof n && "" !== n) || "number" === typeof n)
              return null !== s ? null : c(e, t, "" + n, r);
            if ("object" === typeof n && null !== n) {
              switch (n.$$typeof) {
                case S:
                  return n.key === s ? l(e, t, n, r) : null;
                case _:
                  return n.key === s ? u(e, t, n, r) : null;
                case N:
                  return p(e, t, (s = n._init)(n._payload), r);
              }
              if (te(n) || M(n)) return null !== s ? null : d(e, t, n, r, null);
              vi(e, n);
            }
            return null;
          }
          function f(e, t, n, r, s) {
            if (("string" === typeof r && "" !== r) || "number" === typeof r)
              return c(t, (e = e.get(n) || null), "" + r, s);
            if ("object" === typeof r && null !== r) {
              switch (r.$$typeof) {
                case S:
                  return l(
                    t,
                    (e = e.get(null === r.key ? n : r.key) || null),
                    r,
                    s
                  );
                case _:
                  return u(
                    t,
                    (e = e.get(null === r.key ? n : r.key) || null),
                    r,
                    s
                  );
                case N:
                  return f(e, t, n, (0, r._init)(r._payload), s);
              }
              if (te(r) || M(r))
                return d(t, (e = e.get(n) || null), r, s, null);
              vi(t, r);
            }
            return null;
          }
          function m(s, i, a, c) {
            for (
              var l = null, u = null, d = i, m = (i = 0), g = null;
              null !== d && m < a.length;
              m++
            ) {
              d.index > m ? ((g = d), (d = null)) : (g = d.sibling);
              var v = p(s, d, a[m], c);
              if (null === v) {
                null === d && (d = g);
                break;
              }
              e && d && null === v.alternate && t(s, d),
                (i = o(v, i, m)),
                null === u ? (l = v) : (u.sibling = v),
                (u = v),
                (d = g);
            }
            if (m === a.length) return n(s, d), si && Zs(s, m), l;
            if (null === d) {
              for (; m < a.length; m++)
                null !== (d = h(s, a[m], c)) &&
                  ((i = o(d, i, m)),
                  null === u ? (l = d) : (u.sibling = d),
                  (u = d));
              return si && Zs(s, m), l;
            }
            for (d = r(s, d); m < a.length; m++)
              null !== (g = f(d, s, m, a[m], c)) &&
                (e &&
                  null !== g.alternate &&
                  d.delete(null === g.key ? m : g.key),
                (i = o(g, i, m)),
                null === u ? (l = g) : (u.sibling = g),
                (u = g));
            return (
              e &&
                d.forEach(function (e) {
                  return t(s, e);
                }),
              si && Zs(s, m),
              l
            );
          }
          function g(s, a, c, l) {
            var u = M(c);
            if ("function" !== typeof u) throw Error(i(150));
            if (null == (c = u.call(c))) throw Error(i(151));
            for (
              var d = (u = null), m = a, g = (a = 0), v = null, y = c.next();
              null !== m && !y.done;
              g++, y = c.next()
            ) {
              m.index > g ? ((v = m), (m = null)) : (v = m.sibling);
              var b = p(s, m, y.value, l);
              if (null === b) {
                null === m && (m = v);
                break;
              }
              e && m && null === b.alternate && t(s, m),
                (a = o(b, a, g)),
                null === d ? (u = b) : (d.sibling = b),
                (d = b),
                (m = v);
            }
            if (y.done) return n(s, m), si && Zs(s, g), u;
            if (null === m) {
              for (; !y.done; g++, y = c.next())
                null !== (y = h(s, y.value, l)) &&
                  ((a = o(y, a, g)),
                  null === d ? (u = y) : (d.sibling = y),
                  (d = y));
              return si && Zs(s, g), u;
            }
            for (m = r(s, m); !y.done; g++, y = c.next())
              null !== (y = f(m, s, g, y.value, l)) &&
                (e &&
                  null !== y.alternate &&
                  m.delete(null === y.key ? g : y.key),
                (a = o(y, a, g)),
                null === d ? (u = y) : (d.sibling = y),
                (d = y));
            return (
              e &&
                m.forEach(function (e) {
                  return t(s, e);
                }),
              si && Zs(s, g),
              u
            );
          }
          return function e(r, i, o, c) {
            if (
              ("object" === typeof o &&
                null !== o &&
                o.type === E &&
                null === o.key &&
                (o = o.props.children),
              "object" === typeof o && null !== o)
            ) {
              switch (o.$$typeof) {
                case S:
                  e: {
                    for (var l = o.key, u = i; null !== u; ) {
                      if (u.key === l) {
                        if ((l = o.type) === E) {
                          if (7 === u.tag) {
                            n(r, u.sibling),
                              ((i = s(u, o.props.children)).return = r),
                              (r = i);
                            break e;
                          }
                        } else if (
                          u.elementType === l ||
                          ("object" === typeof l &&
                            null !== l &&
                            l.$$typeof === N &&
                            yi(l) === u.type)
                        ) {
                          n(r, u.sibling),
                            ((i = s(u, o.props)).ref = gi(r, u, o)),
                            (i.return = r),
                            (r = i);
                          break e;
                        }
                        n(r, u);
                        break;
                      }
                      t(r, u), (u = u.sibling);
                    }
                    o.type === E
                      ? (((i = Ml(o.props.children, r.mode, c, o.key)).return =
                          r),
                        (r = i))
                      : (((c = Dl(
                          o.type,
                          o.key,
                          o.props,
                          null,
                          r.mode,
                          c
                        )).ref = gi(r, i, o)),
                        (c.return = r),
                        (r = c));
                  }
                  return a(r);
                case _:
                  e: {
                    for (u = o.key; null !== i; ) {
                      if (i.key === u) {
                        if (
                          4 === i.tag &&
                          i.stateNode.containerInfo === o.containerInfo &&
                          i.stateNode.implementation === o.implementation
                        ) {
                          n(r, i.sibling),
                            ((i = s(i, o.children || [])).return = r),
                            (r = i);
                          break e;
                        }
                        n(r, i);
                        break;
                      }
                      t(r, i), (i = i.sibling);
                    }
                    ((i = Ul(o, r.mode, c)).return = r), (r = i);
                  }
                  return a(r);
                case N:
                  return e(r, i, (u = o._init)(o._payload), c);
              }
              if (te(o)) return m(r, i, o, c);
              if (M(o)) return g(r, i, o, c);
              vi(r, o);
            }
            return ("string" === typeof o && "" !== o) || "number" === typeof o
              ? ((o = "" + o),
                null !== i && 6 === i.tag
                  ? (n(r, i.sibling), ((i = s(i, o)).return = r), (r = i))
                  : (n(r, i), ((i = Ll(o, r.mode, c)).return = r), (r = i)),
                a(r))
              : n(r, i);
          };
        }
        var wi = bi(!0),
          Si = bi(!1),
          _i = As(null),
          Ei = null,
          Ai = null,
          Ti = null;
        function Pi() {
          Ti = Ai = Ei = null;
        }
        function Ii(e) {
          var t = _i.current;
          Ts(_i), (e._currentValue = t);
        }
        function Ci(e, t, n) {
          for (; null !== e; ) {
            var r = e.alternate;
            if (
              ((e.childLanes & t) !== t
                ? ((e.childLanes |= t), null !== r && (r.childLanes |= t))
                : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t),
              e === n)
            )
              break;
            e = e.return;
          }
        }
        function ki(e, t) {
          (Ei = e),
            (Ti = Ai = null),
            null !== (e = e.dependencies) &&
              null !== e.firstContext &&
              (0 !== (e.lanes & t) && (ba = !0), (e.firstContext = null));
        }
        function Oi(e) {
          var t = e._currentValue;
          if (Ti !== e)
            if (
              ((e = { context: e, memoizedValue: t, next: null }), null === Ai)
            ) {
              if (null === Ei) throw Error(i(308));
              (Ai = e), (Ei.dependencies = { lanes: 0, firstContext: e });
            } else Ai = Ai.next = e;
          return t;
        }
        var xi = null;
        function Ni(e) {
          null === xi ? (xi = [e]) : xi.push(e);
        }
        function Ri(e, t, n, r) {
          var s = t.interleaved;
          return (
            null === s
              ? ((n.next = n), Ni(t))
              : ((n.next = s.next), (s.next = n)),
            (t.interleaved = n),
            Di(e, r)
          );
        }
        function Di(e, t) {
          e.lanes |= t;
          var n = e.alternate;
          for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e; )
            (e.childLanes |= t),
              null !== (n = e.alternate) && (n.childLanes |= t),
              (n = e),
              (e = e.return);
          return 3 === n.tag ? n.stateNode : null;
        }
        var Mi = !1;
        function ji(e) {
          e.updateQueue = {
            baseState: e.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, interleaved: null, lanes: 0 },
            effects: null,
          };
        }
        function Li(e, t) {
          (e = e.updateQueue),
            t.updateQueue === e &&
              (t.updateQueue = {
                baseState: e.baseState,
                firstBaseUpdate: e.firstBaseUpdate,
                lastBaseUpdate: e.lastBaseUpdate,
                shared: e.shared,
                effects: e.effects,
              });
        }
        function Ui(e, t) {
          return {
            eventTime: e,
            lane: t,
            tag: 0,
            payload: null,
            callback: null,
            next: null,
          };
        }
        function Fi(e, t, n) {
          var r = e.updateQueue;
          if (null === r) return null;
          if (((r = r.shared), 0 !== (2 & Cc))) {
            var s = r.pending;
            return (
              null === s ? (t.next = t) : ((t.next = s.next), (s.next = t)),
              (r.pending = t),
              Di(e, n)
            );
          }
          return (
            null === (s = r.interleaved)
              ? ((t.next = t), Ni(r))
              : ((t.next = s.next), (s.next = t)),
            (r.interleaved = t),
            Di(e, n)
          );
        }
        function Bi(e, t, n) {
          if (
            null !== (t = t.updateQueue) &&
            ((t = t.shared), 0 !== (4194240 & n))
          ) {
            var r = t.lanes;
            (n |= r &= e.pendingLanes), (t.lanes = n), yt(e, n);
          }
        }
        function Vi(e, t) {
          var n = e.updateQueue,
            r = e.alternate;
          if (null !== r && n === (r = r.updateQueue)) {
            var s = null,
              i = null;
            if (null !== (n = n.firstBaseUpdate)) {
              do {
                var o = {
                  eventTime: n.eventTime,
                  lane: n.lane,
                  tag: n.tag,
                  payload: n.payload,
                  callback: n.callback,
                  next: null,
                };
                null === i ? (s = i = o) : (i = i.next = o), (n = n.next);
              } while (null !== n);
              null === i ? (s = i = t) : (i = i.next = t);
            } else s = i = t;
            return (
              (n = {
                baseState: r.baseState,
                firstBaseUpdate: s,
                lastBaseUpdate: i,
                shared: r.shared,
                effects: r.effects,
              }),
              void (e.updateQueue = n)
            );
          }
          null === (e = n.lastBaseUpdate)
            ? (n.firstBaseUpdate = t)
            : (e.next = t),
            (n.lastBaseUpdate = t);
        }
        function qi(e, t, n, r) {
          var s = e.updateQueue;
          Mi = !1;
          var i = s.firstBaseUpdate,
            o = s.lastBaseUpdate,
            a = s.shared.pending;
          if (null !== a) {
            s.shared.pending = null;
            var c = a,
              l = c.next;
            (c.next = null), null === o ? (i = l) : (o.next = l), (o = c);
            var u = e.alternate;
            null !== u &&
              (a = (u = u.updateQueue).lastBaseUpdate) !== o &&
              (null === a ? (u.firstBaseUpdate = l) : (a.next = l),
              (u.lastBaseUpdate = c));
          }
          if (null !== i) {
            var d = s.baseState;
            for (o = 0, u = l = c = null, a = i; ; ) {
              var h = a.lane,
                p = a.eventTime;
              if ((r & h) === h) {
                null !== u &&
                  (u = u.next =
                    {
                      eventTime: p,
                      lane: 0,
                      tag: a.tag,
                      payload: a.payload,
                      callback: a.callback,
                      next: null,
                    });
                e: {
                  var f = e,
                    m = a;
                  switch (((h = t), (p = n), m.tag)) {
                    case 1:
                      if ("function" === typeof (f = m.payload)) {
                        d = f.call(p, d, h);
                        break e;
                      }
                      d = f;
                      break e;
                    case 3:
                      f.flags = (-65537 & f.flags) | 128;
                    case 0:
                      if (
                        null ===
                          (h =
                            "function" === typeof (f = m.payload)
                              ? f.call(p, d, h)
                              : f) ||
                        void 0 === h
                      )
                        break e;
                      d = L({}, d, h);
                      break e;
                    case 2:
                      Mi = !0;
                  }
                }
                null !== a.callback &&
                  0 !== a.lane &&
                  ((e.flags |= 64),
                  null === (h = s.effects) ? (s.effects = [a]) : h.push(a));
              } else
                (p = {
                  eventTime: p,
                  lane: h,
                  tag: a.tag,
                  payload: a.payload,
                  callback: a.callback,
                  next: null,
                }),
                  null === u ? ((l = u = p), (c = d)) : (u = u.next = p),
                  (o |= h);
              if (null === (a = a.next)) {
                if (null === (a = s.shared.pending)) break;
                (a = (h = a).next),
                  (h.next = null),
                  (s.lastBaseUpdate = h),
                  (s.shared.pending = null);
              }
            }
            if (
              (null === u && (c = d),
              (s.baseState = c),
              (s.firstBaseUpdate = l),
              (s.lastBaseUpdate = u),
              null !== (t = s.shared.interleaved))
            ) {
              s = t;
              do {
                (o |= s.lane), (s = s.next);
              } while (s !== t);
            } else null === i && (s.shared.lanes = 0);
            (jc |= o), (e.lanes = o), (e.memoizedState = d);
          }
        }
        function Hi(e, t, n) {
          if (((e = t.effects), (t.effects = null), null !== e))
            for (t = 0; t < e.length; t++) {
              var r = e[t],
                s = r.callback;
              if (null !== s) {
                if (((r.callback = null), (r = n), "function" !== typeof s))
                  throw Error(i(191, s));
                s.call(r);
              }
            }
        }
        var Wi = {},
          Ki = As(Wi),
          zi = As(Wi),
          Gi = As(Wi);
        function Ji(e) {
          if (e === Wi) throw Error(i(174));
          return e;
        }
        function Qi(e, t) {
          switch ((Ps(Gi, t), Ps(zi, e), Ps(Ki, Wi), (e = t.nodeType))) {
            case 9:
            case 11:
              t = (t = t.documentElement) ? t.namespaceURI : ce(null, "");
              break;
            default:
              t = ce(
                (t = (e = 8 === e ? t.parentNode : t).namespaceURI || null),
                (e = e.tagName)
              );
          }
          Ts(Ki), Ps(Ki, t);
        }
        function Yi() {
          Ts(Ki), Ts(zi), Ts(Gi);
        }
        function Xi(e) {
          Ji(Gi.current);
          var t = Ji(Ki.current),
            n = ce(t, e.type);
          t !== n && (Ps(zi, e), Ps(Ki, n));
        }
        function Zi(e) {
          zi.current === e && (Ts(Ki), Ts(zi));
        }
        var $i = As(0);
        function eo(e) {
          for (var t = e; null !== t; ) {
            if (13 === t.tag) {
              var n = t.memoizedState;
              if (
                null !== n &&
                (null === (n = n.dehydrated) ||
                  "$?" === n.data ||
                  "$!" === n.data)
              )
                return t;
            } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
              if (0 !== (128 & t.flags)) return t;
            } else if (null !== t.child) {
              (t.child.return = t), (t = t.child);
              continue;
            }
            if (t === e) break;
            for (; null === t.sibling; ) {
              if (null === t.return || t.return === e) return null;
              t = t.return;
            }
            (t.sibling.return = t.return), (t = t.sibling);
          }
          return null;
        }
        var to = [];
        function no() {
          for (var e = 0; e < to.length; e++)
            to[e]._workInProgressVersionPrimary = null;
          to.length = 0;
        }
        var ro = w.ReactCurrentDispatcher,
          so = w.ReactCurrentBatchConfig,
          io = 0,
          oo = null,
          ao = null,
          co = null,
          lo = !1,
          uo = !1,
          ho = 0,
          po = 0;
        function fo() {
          throw Error(i(321));
        }
        function mo(e, t) {
          if (null === t) return !1;
          for (var n = 0; n < t.length && n < e.length; n++)
            if (!ar(e[n], t[n])) return !1;
          return !0;
        }
        function go(e, t, n, r, s, o) {
          if (
            ((io = o),
            (oo = t),
            (t.memoizedState = null),
            (t.updateQueue = null),
            (t.lanes = 0),
            (ro.current = null === e || null === e.memoizedState ? $o : ea),
            (e = n(r, s)),
            uo)
          ) {
            o = 0;
            do {
              if (((uo = !1), (ho = 0), 25 <= o)) throw Error(i(301));
              (o += 1),
                (co = ao = null),
                (t.updateQueue = null),
                (ro.current = ta),
                (e = n(r, s));
            } while (uo);
          }
          if (
            ((ro.current = Zo),
            (t = null !== ao && null !== ao.next),
            (io = 0),
            (co = ao = oo = null),
            (lo = !1),
            t)
          )
            throw Error(i(300));
          return e;
        }
        function vo() {
          var e = 0 !== ho;
          return (ho = 0), e;
        }
        function yo() {
          var e = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null,
          };
          return (
            null === co ? (oo.memoizedState = co = e) : (co = co.next = e), co
          );
        }
        function bo() {
          if (null === ao) {
            var e = oo.alternate;
            e = null !== e ? e.memoizedState : null;
          } else e = ao.next;
          var t = null === co ? oo.memoizedState : co.next;
          if (null !== t) (co = t), (ao = e);
          else {
            if (null === e) throw Error(i(310));
            (e = {
              memoizedState: (ao = e).memoizedState,
              baseState: ao.baseState,
              baseQueue: ao.baseQueue,
              queue: ao.queue,
              next: null,
            }),
              null === co ? (oo.memoizedState = co = e) : (co = co.next = e);
          }
          return co;
        }
        function wo(e, t) {
          return "function" === typeof t ? t(e) : t;
        }
        function So(e) {
          var t = bo(),
            n = t.queue;
          if (null === n) throw Error(i(311));
          n.lastRenderedReducer = e;
          var r = ao,
            s = r.baseQueue,
            o = n.pending;
          if (null !== o) {
            if (null !== s) {
              var a = s.next;
              (s.next = o.next), (o.next = a);
            }
            (r.baseQueue = s = o), (n.pending = null);
          }
          if (null !== s) {
            (o = s.next), (r = r.baseState);
            var c = (a = null),
              l = null,
              u = o;
            do {
              var d = u.lane;
              if ((io & d) === d)
                null !== l &&
                  (l = l.next =
                    {
                      lane: 0,
                      action: u.action,
                      hasEagerState: u.hasEagerState,
                      eagerState: u.eagerState,
                      next: null,
                    }),
                  (r = u.hasEagerState ? u.eagerState : e(r, u.action));
              else {
                var h = {
                  lane: d,
                  action: u.action,
                  hasEagerState: u.hasEagerState,
                  eagerState: u.eagerState,
                  next: null,
                };
                null === l ? ((c = l = h), (a = r)) : (l = l.next = h),
                  (oo.lanes |= d),
                  (jc |= d);
              }
              u = u.next;
            } while (null !== u && u !== o);
            null === l ? (a = r) : (l.next = c),
              ar(r, t.memoizedState) || (ba = !0),
              (t.memoizedState = r),
              (t.baseState = a),
              (t.baseQueue = l),
              (n.lastRenderedState = r);
          }
          if (null !== (e = n.interleaved)) {
            s = e;
            do {
              (o = s.lane), (oo.lanes |= o), (jc |= o), (s = s.next);
            } while (s !== e);
          } else null === s && (n.lanes = 0);
          return [t.memoizedState, n.dispatch];
        }
        function _o(e) {
          var t = bo(),
            n = t.queue;
          if (null === n) throw Error(i(311));
          n.lastRenderedReducer = e;
          var r = n.dispatch,
            s = n.pending,
            o = t.memoizedState;
          if (null !== s) {
            n.pending = null;
            var a = (s = s.next);
            do {
              (o = e(o, a.action)), (a = a.next);
            } while (a !== s);
            ar(o, t.memoizedState) || (ba = !0),
              (t.memoizedState = o),
              null === t.baseQueue && (t.baseState = o),
              (n.lastRenderedState = o);
          }
          return [o, r];
        }
        function Eo() {}
        function Ao(e, t) {
          var n = oo,
            r = bo(),
            s = t(),
            o = !ar(r.memoizedState, s);
          if (
            (o && ((r.memoizedState = s), (ba = !0)),
            (r = r.queue),
            jo(Io.bind(null, n, r, e), [e]),
            r.getSnapshot !== t ||
              o ||
              (null !== co && 1 & co.memoizedState.tag))
          ) {
            if (
              ((n.flags |= 2048),
              xo(9, Po.bind(null, n, r, s, t), void 0, null),
              null === kc)
            )
              throw Error(i(349));
            0 !== (30 & io) || To(n, t, s);
          }
          return s;
        }
        function To(e, t, n) {
          (e.flags |= 16384),
            (e = { getSnapshot: t, value: n }),
            null === (t = oo.updateQueue)
              ? ((t = { lastEffect: null, stores: null }),
                (oo.updateQueue = t),
                (t.stores = [e]))
              : null === (n = t.stores)
              ? (t.stores = [e])
              : n.push(e);
        }
        function Po(e, t, n, r) {
          (t.value = n), (t.getSnapshot = r), Co(t) && ko(e);
        }
        function Io(e, t, n) {
          return n(function () {
            Co(t) && ko(e);
          });
        }
        function Co(e) {
          var t = e.getSnapshot;
          e = e.value;
          try {
            var n = t();
            return !ar(e, n);
          } catch (r) {
            return !0;
          }
        }
        function ko(e) {
          var t = Di(e, 1);
          null !== t && nl(t, e, 1, -1);
        }
        function Oo(e) {
          var t = yo();
          return (
            "function" === typeof e && (e = e()),
            (t.memoizedState = t.baseState = e),
            (e = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: wo,
              lastRenderedState: e,
            }),
            (t.queue = e),
            (e = e.dispatch = Jo.bind(null, oo, e)),
            [t.memoizedState, e]
          );
        }
        function xo(e, t, n, r) {
          return (
            (e = { tag: e, create: t, destroy: n, deps: r, next: null }),
            null === (t = oo.updateQueue)
              ? ((t = { lastEffect: null, stores: null }),
                (oo.updateQueue = t),
                (t.lastEffect = e.next = e))
              : null === (n = t.lastEffect)
              ? (t.lastEffect = e.next = e)
              : ((r = n.next), (n.next = e), (e.next = r), (t.lastEffect = e)),
            e
          );
        }
        function No() {
          return bo().memoizedState;
        }
        function Ro(e, t, n, r) {
          var s = yo();
          (oo.flags |= e),
            (s.memoizedState = xo(1 | t, n, void 0, void 0 === r ? null : r));
        }
        function Do(e, t, n, r) {
          var s = bo();
          r = void 0 === r ? null : r;
          var i = void 0;
          if (null !== ao) {
            var o = ao.memoizedState;
            if (((i = o.destroy), null !== r && mo(r, o.deps)))
              return void (s.memoizedState = xo(t, n, i, r));
          }
          (oo.flags |= e), (s.memoizedState = xo(1 | t, n, i, r));
        }
        function Mo(e, t) {
          return Ro(8390656, 8, e, t);
        }
        function jo(e, t) {
          return Do(2048, 8, e, t);
        }
        function Lo(e, t) {
          return Do(4, 2, e, t);
        }
        function Uo(e, t) {
          return Do(4, 4, e, t);
        }
        function Fo(e, t) {
          return "function" === typeof t
            ? ((e = e()),
              t(e),
              function () {
                t(null);
              })
            : null !== t && void 0 !== t
            ? ((e = e()),
              (t.current = e),
              function () {
                t.current = null;
              })
            : void 0;
        }
        function Bo(e, t, n) {
          return (
            (n = null !== n && void 0 !== n ? n.concat([e]) : null),
            Do(4, 4, Fo.bind(null, t, e), n)
          );
        }
        function Vo() {}
        function qo(e, t) {
          var n = bo();
          t = void 0 === t ? null : t;
          var r = n.memoizedState;
          return null !== r && null !== t && mo(t, r[1])
            ? r[0]
            : ((n.memoizedState = [e, t]), e);
        }
        function Ho(e, t) {
          var n = bo();
          t = void 0 === t ? null : t;
          var r = n.memoizedState;
          return null !== r && null !== t && mo(t, r[1])
            ? r[0]
            : ((e = e()), (n.memoizedState = [e, t]), e);
        }
        function Wo(e, t, n) {
          return 0 === (21 & io)
            ? (e.baseState && ((e.baseState = !1), (ba = !0)),
              (e.memoizedState = n))
            : (ar(n, t) ||
                ((n = mt()), (oo.lanes |= n), (jc |= n), (e.baseState = !0)),
              t);
        }
        function Ko(e, t) {
          var n = bt;
          (bt = 0 !== n && 4 > n ? n : 4), e(!0);
          var r = so.transition;
          so.transition = {};
          try {
            e(!1), t();
          } finally {
            (bt = n), (so.transition = r);
          }
        }
        function zo() {
          return bo().memoizedState;
        }
        function Go(e, t, n) {
          var r = tl(e);
          if (
            ((n = {
              lane: r,
              action: n,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            }),
            Qo(e))
          )
            Yo(t, n);
          else if (null !== (n = Ri(e, t, n, r))) {
            nl(n, e, r, el()), Xo(n, t, r);
          }
        }
        function Jo(e, t, n) {
          var r = tl(e),
            s = {
              lane: r,
              action: n,
              hasEagerState: !1,
              eagerState: null,
              next: null,
            };
          if (Qo(e)) Yo(t, s);
          else {
            var i = e.alternate;
            if (
              0 === e.lanes &&
              (null === i || 0 === i.lanes) &&
              null !== (i = t.lastRenderedReducer)
            )
              try {
                var o = t.lastRenderedState,
                  a = i(o, n);
                if (((s.hasEagerState = !0), (s.eagerState = a), ar(a, o))) {
                  var c = t.interleaved;
                  return (
                    null === c
                      ? ((s.next = s), Ni(t))
                      : ((s.next = c.next), (c.next = s)),
                    void (t.interleaved = s)
                  );
                }
              } catch (l) {}
            null !== (n = Ri(e, t, s, r)) &&
              (nl(n, e, r, (s = el())), Xo(n, t, r));
          }
        }
        function Qo(e) {
          var t = e.alternate;
          return e === oo || (null !== t && t === oo);
        }
        function Yo(e, t) {
          uo = lo = !0;
          var n = e.pending;
          null === n ? (t.next = t) : ((t.next = n.next), (n.next = t)),
            (e.pending = t);
        }
        function Xo(e, t, n) {
          if (0 !== (4194240 & n)) {
            var r = t.lanes;
            (n |= r &= e.pendingLanes), (t.lanes = n), yt(e, n);
          }
        }
        var Zo = {
            readContext: Oi,
            useCallback: fo,
            useContext: fo,
            useEffect: fo,
            useImperativeHandle: fo,
            useInsertionEffect: fo,
            useLayoutEffect: fo,
            useMemo: fo,
            useReducer: fo,
            useRef: fo,
            useState: fo,
            useDebugValue: fo,
            useDeferredValue: fo,
            useTransition: fo,
            useMutableSource: fo,
            useSyncExternalStore: fo,
            useId: fo,
            unstable_isNewReconciler: !1,
          },
          $o = {
            readContext: Oi,
            useCallback: function (e, t) {
              return (yo().memoizedState = [e, void 0 === t ? null : t]), e;
            },
            useContext: Oi,
            useEffect: Mo,
            useImperativeHandle: function (e, t, n) {
              return (
                (n = null !== n && void 0 !== n ? n.concat([e]) : null),
                Ro(4194308, 4, Fo.bind(null, t, e), n)
              );
            },
            useLayoutEffect: function (e, t) {
              return Ro(4194308, 4, e, t);
            },
            useInsertionEffect: function (e, t) {
              return Ro(4, 2, e, t);
            },
            useMemo: function (e, t) {
              var n = yo();
              return (
                (t = void 0 === t ? null : t),
                (e = e()),
                (n.memoizedState = [e, t]),
                e
              );
            },
            useReducer: function (e, t, n) {
              var r = yo();
              return (
                (t = void 0 !== n ? n(t) : t),
                (r.memoizedState = r.baseState = t),
                (e = {
                  pending: null,
                  interleaved: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: e,
                  lastRenderedState: t,
                }),
                (r.queue = e),
                (e = e.dispatch = Go.bind(null, oo, e)),
                [r.memoizedState, e]
              );
            },
            useRef: function (e) {
              return (e = { current: e }), (yo().memoizedState = e);
            },
            useState: Oo,
            useDebugValue: Vo,
            useDeferredValue: function (e) {
              return (yo().memoizedState = e);
            },
            useTransition: function () {
              var e = Oo(!1),
                t = e[0];
              return (
                (e = Ko.bind(null, e[1])), (yo().memoizedState = e), [t, e]
              );
            },
            useMutableSource: function () {},
            useSyncExternalStore: function (e, t, n) {
              var r = oo,
                s = yo();
              if (si) {
                if (void 0 === n) throw Error(i(407));
                n = n();
              } else {
                if (((n = t()), null === kc)) throw Error(i(349));
                0 !== (30 & io) || To(r, t, n);
              }
              s.memoizedState = n;
              var o = { value: n, getSnapshot: t };
              return (
                (s.queue = o),
                Mo(Io.bind(null, r, o, e), [e]),
                (r.flags |= 2048),
                xo(9, Po.bind(null, r, o, n, t), void 0, null),
                n
              );
            },
            useId: function () {
              var e = yo(),
                t = kc.identifierPrefix;
              if (si) {
                var n = Xs;
                (t =
                  ":" +
                  t +
                  "R" +
                  (n = (Ys & ~(1 << (32 - ot(Ys) - 1))).toString(32) + n)),
                  0 < (n = ho++) && (t += "H" + n.toString(32)),
                  (t += ":");
              } else t = ":" + t + "r" + (n = po++).toString(32) + ":";
              return (e.memoizedState = t);
            },
            unstable_isNewReconciler: !1,
          },
          ea = {
            readContext: Oi,
            useCallback: qo,
            useContext: Oi,
            useEffect: jo,
            useImperativeHandle: Bo,
            useInsertionEffect: Lo,
            useLayoutEffect: Uo,
            useMemo: Ho,
            useReducer: So,
            useRef: No,
            useState: function () {
              return So(wo);
            },
            useDebugValue: Vo,
            useDeferredValue: function (e) {
              return Wo(bo(), ao.memoizedState, e);
            },
            useTransition: function () {
              return [So(wo)[0], bo().memoizedState];
            },
            useMutableSource: Eo,
            useSyncExternalStore: Ao,
            useId: zo,
            unstable_isNewReconciler: !1,
          },
          ta = {
            readContext: Oi,
            useCallback: qo,
            useContext: Oi,
            useEffect: jo,
            useImperativeHandle: Bo,
            useInsertionEffect: Lo,
            useLayoutEffect: Uo,
            useMemo: Ho,
            useReducer: _o,
            useRef: No,
            useState: function () {
              return _o(wo);
            },
            useDebugValue: Vo,
            useDeferredValue: function (e) {
              var t = bo();
              return null === ao
                ? (t.memoizedState = e)
                : Wo(t, ao.memoizedState, e);
            },
            useTransition: function () {
              return [_o(wo)[0], bo().memoizedState];
            },
            useMutableSource: Eo,
            useSyncExternalStore: Ao,
            useId: zo,
            unstable_isNewReconciler: !1,
          };
        function na(e, t) {
          if (e && e.defaultProps) {
            for (var n in ((t = L({}, t)), (e = e.defaultProps)))
              void 0 === t[n] && (t[n] = e[n]);
            return t;
          }
          return t;
        }
        function ra(e, t, n, r) {
          (n =
            null === (n = n(r, (t = e.memoizedState))) || void 0 === n
              ? t
              : L({}, t, n)),
            (e.memoizedState = n),
            0 === e.lanes && (e.updateQueue.baseState = n);
        }
        var sa = {
          isMounted: function (e) {
            return !!(e = e._reactInternals) && qe(e) === e;
          },
          enqueueSetState: function (e, t, n) {
            e = e._reactInternals;
            var r = el(),
              s = tl(e),
              i = Ui(r, s);
            (i.payload = t),
              void 0 !== n && null !== n && (i.callback = n),
              null !== (t = Fi(e, i, s)) && (nl(t, e, s, r), Bi(t, e, s));
          },
          enqueueReplaceState: function (e, t, n) {
            e = e._reactInternals;
            var r = el(),
              s = tl(e),
              i = Ui(r, s);
            (i.tag = 1),
              (i.payload = t),
              void 0 !== n && null !== n && (i.callback = n),
              null !== (t = Fi(e, i, s)) && (nl(t, e, s, r), Bi(t, e, s));
          },
          enqueueForceUpdate: function (e, t) {
            e = e._reactInternals;
            var n = el(),
              r = tl(e),
              s = Ui(n, r);
            (s.tag = 2),
              void 0 !== t && null !== t && (s.callback = t),
              null !== (t = Fi(e, s, r)) && (nl(t, e, r, n), Bi(t, e, r));
          },
        };
        function ia(e, t, n, r, s, i, o) {
          return "function" === typeof (e = e.stateNode).shouldComponentUpdate
            ? e.shouldComponentUpdate(r, i, o)
            : !t.prototype ||
                !t.prototype.isPureReactComponent ||
                !cr(n, r) ||
                !cr(s, i);
        }
        function oa(e, t, n) {
          var r = !1,
            s = Is,
            i = t.contextType;
          return (
            "object" === typeof i && null !== i
              ? (i = Oi(i))
              : ((s = Ns(t) ? Os : Cs.current),
                (i = (r = null !== (r = t.contextTypes) && void 0 !== r)
                  ? xs(e, s)
                  : Is)),
            (t = new t(n, i)),
            (e.memoizedState =
              null !== t.state && void 0 !== t.state ? t.state : null),
            (t.updater = sa),
            (e.stateNode = t),
            (t._reactInternals = e),
            r &&
              (((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext =
                s),
              (e.__reactInternalMemoizedMaskedChildContext = i)),
            t
          );
        }
        function aa(e, t, n, r) {
          (e = t.state),
            "function" === typeof t.componentWillReceiveProps &&
              t.componentWillReceiveProps(n, r),
            "function" === typeof t.UNSAFE_componentWillReceiveProps &&
              t.UNSAFE_componentWillReceiveProps(n, r),
            t.state !== e && sa.enqueueReplaceState(t, t.state, null);
        }
        function ca(e, t, n, r) {
          var s = e.stateNode;
          (s.props = n), (s.state = e.memoizedState), (s.refs = {}), ji(e);
          var i = t.contextType;
          "object" === typeof i && null !== i
            ? (s.context = Oi(i))
            : ((i = Ns(t) ? Os : Cs.current), (s.context = xs(e, i))),
            (s.state = e.memoizedState),
            "function" === typeof (i = t.getDerivedStateFromProps) &&
              (ra(e, t, i, n), (s.state = e.memoizedState)),
            "function" === typeof t.getDerivedStateFromProps ||
              "function" === typeof s.getSnapshotBeforeUpdate ||
              ("function" !== typeof s.UNSAFE_componentWillMount &&
                "function" !== typeof s.componentWillMount) ||
              ((t = s.state),
              "function" === typeof s.componentWillMount &&
                s.componentWillMount(),
              "function" === typeof s.UNSAFE_componentWillMount &&
                s.UNSAFE_componentWillMount(),
              t !== s.state && sa.enqueueReplaceState(s, s.state, null),
              qi(e, n, s, r),
              (s.state = e.memoizedState)),
            "function" === typeof s.componentDidMount && (e.flags |= 4194308);
        }
        function la(e, t) {
          try {
            var n = "",
              r = t;
            do {
              (n += V(r)), (r = r.return);
            } while (r);
            var s = n;
          } catch (i) {
            s = "\nError generating stack: " + i.message + "\n" + i.stack;
          }
          return { value: e, source: t, stack: s, digest: null };
        }
        function ua(e, t, n) {
          return {
            value: e,
            source: null,
            stack: null != n ? n : null,
            digest: null != t ? t : null,
          };
        }
        function da(e, t) {
          try {
            console.error(t.value);
          } catch (n) {
            setTimeout(function () {
              throw n;
            });
          }
        }
        var ha = "function" === typeof WeakMap ? WeakMap : Map;
        function pa(e, t, n) {
          ((n = Ui(-1, n)).tag = 3), (n.payload = { element: null });
          var r = t.value;
          return (
            (n.callback = function () {
              Wc || ((Wc = !0), (Kc = r)), da(0, t);
            }),
            n
          );
        }
        function fa(e, t, n) {
          (n = Ui(-1, n)).tag = 3;
          var r = e.type.getDerivedStateFromError;
          if ("function" === typeof r) {
            var s = t.value;
            (n.payload = function () {
              return r(s);
            }),
              (n.callback = function () {
                da(0, t);
              });
          }
          var i = e.stateNode;
          return (
            null !== i &&
              "function" === typeof i.componentDidCatch &&
              (n.callback = function () {
                da(0, t),
                  "function" !== typeof r &&
                    (null === zc ? (zc = new Set([this])) : zc.add(this));
                var e = t.stack;
                this.componentDidCatch(t.value, {
                  componentStack: null !== e ? e : "",
                });
              }),
            n
          );
        }
        function ma(e, t, n) {
          var r = e.pingCache;
          if (null === r) {
            r = e.pingCache = new ha();
            var s = new Set();
            r.set(t, s);
          } else void 0 === (s = r.get(t)) && ((s = new Set()), r.set(t, s));
          s.has(n) || (s.add(n), (e = Tl.bind(null, e, t, n)), t.then(e, e));
        }
        function ga(e) {
          do {
            var t;
            if (
              ((t = 13 === e.tag) &&
                (t = null === (t = e.memoizedState) || null !== t.dehydrated),
              t)
            )
              return e;
            e = e.return;
          } while (null !== e);
          return null;
        }
        function va(e, t, n, r, s) {
          return 0 === (1 & e.mode)
            ? (e === t
                ? (e.flags |= 65536)
                : ((e.flags |= 128),
                  (n.flags |= 131072),
                  (n.flags &= -52805),
                  1 === n.tag &&
                    (null === n.alternate
                      ? (n.tag = 17)
                      : (((t = Ui(-1, 1)).tag = 2), Fi(n, t, 1))),
                  (n.lanes |= 1)),
              e)
            : ((e.flags |= 65536), (e.lanes = s), e);
        }
        var ya = w.ReactCurrentOwner,
          ba = !1;
        function wa(e, t, n, r) {
          t.child = null === e ? Si(t, null, n, r) : wi(t, e.child, n, r);
        }
        function Sa(e, t, n, r, s) {
          n = n.render;
          var i = t.ref;
          return (
            ki(t, s),
            (r = go(e, t, n, r, i, s)),
            (n = vo()),
            null === e || ba
              ? (si && n && ei(t), (t.flags |= 1), wa(e, t, r, s), t.child)
              : ((t.updateQueue = e.updateQueue),
                (t.flags &= -2053),
                (e.lanes &= ~s),
                Wa(e, t, s))
          );
        }
        function _a(e, t, n, r, s) {
          if (null === e) {
            var i = n.type;
            return "function" !== typeof i ||
              Nl(i) ||
              void 0 !== i.defaultProps ||
              null !== n.compare ||
              void 0 !== n.defaultProps
              ? (((e = Dl(n.type, null, r, t, t.mode, s)).ref = t.ref),
                (e.return = t),
                (t.child = e))
              : ((t.tag = 15), (t.type = i), Ea(e, t, i, r, s));
          }
          if (((i = e.child), 0 === (e.lanes & s))) {
            var o = i.memoizedProps;
            if (
              (n = null !== (n = n.compare) ? n : cr)(o, r) &&
              e.ref === t.ref
            )
              return Wa(e, t, s);
          }
          return (
            (t.flags |= 1),
            ((e = Rl(i, r)).ref = t.ref),
            (e.return = t),
            (t.child = e)
          );
        }
        function Ea(e, t, n, r, s) {
          if (null !== e) {
            var i = e.memoizedProps;
            if (cr(i, r) && e.ref === t.ref) {
              if (((ba = !1), (t.pendingProps = r = i), 0 === (e.lanes & s)))
                return (t.lanes = e.lanes), Wa(e, t, s);
              0 !== (131072 & e.flags) && (ba = !0);
            }
          }
          return Pa(e, t, n, r, s);
        }
        function Aa(e, t, n) {
          var r = t.pendingProps,
            s = r.children,
            i = null !== e ? e.memoizedState : null;
          if ("hidden" === r.mode)
            if (0 === (1 & t.mode))
              (t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null,
              }),
                Ps(Rc, Nc),
                (Nc |= n);
            else {
              if (0 === (1073741824 & n))
                return (
                  (e = null !== i ? i.baseLanes | n : n),
                  (t.lanes = t.childLanes = 1073741824),
                  (t.memoizedState = {
                    baseLanes: e,
                    cachePool: null,
                    transitions: null,
                  }),
                  (t.updateQueue = null),
                  Ps(Rc, Nc),
                  (Nc |= e),
                  null
                );
              (t.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null,
              }),
                (r = null !== i ? i.baseLanes : n),
                Ps(Rc, Nc),
                (Nc |= r);
            }
          else
            null !== i
              ? ((r = i.baseLanes | n), (t.memoizedState = null))
              : (r = n),
              Ps(Rc, Nc),
              (Nc |= r);
          return wa(e, t, s, n), t.child;
        }
        function Ta(e, t) {
          var n = t.ref;
          ((null === e && null !== n) || (null !== e && e.ref !== n)) &&
            ((t.flags |= 512), (t.flags |= 2097152));
        }
        function Pa(e, t, n, r, s) {
          var i = Ns(n) ? Os : Cs.current;
          return (
            (i = xs(t, i)),
            ki(t, s),
            (n = go(e, t, n, r, i, s)),
            (r = vo()),
            null === e || ba
              ? (si && r && ei(t), (t.flags |= 1), wa(e, t, n, s), t.child)
              : ((t.updateQueue = e.updateQueue),
                (t.flags &= -2053),
                (e.lanes &= ~s),
                Wa(e, t, s))
          );
        }
        function Ia(e, t, n, r, s) {
          if (Ns(n)) {
            var i = !0;
            js(t);
          } else i = !1;
          if ((ki(t, s), null === t.stateNode))
            Ha(e, t), oa(t, n, r), ca(t, n, r, s), (r = !0);
          else if (null === e) {
            var o = t.stateNode,
              a = t.memoizedProps;
            o.props = a;
            var c = o.context,
              l = n.contextType;
            "object" === typeof l && null !== l
              ? (l = Oi(l))
              : (l = xs(t, (l = Ns(n) ? Os : Cs.current)));
            var u = n.getDerivedStateFromProps,
              d =
                "function" === typeof u ||
                "function" === typeof o.getSnapshotBeforeUpdate;
            d ||
              ("function" !== typeof o.UNSAFE_componentWillReceiveProps &&
                "function" !== typeof o.componentWillReceiveProps) ||
              ((a !== r || c !== l) && aa(t, o, r, l)),
              (Mi = !1);
            var h = t.memoizedState;
            (o.state = h),
              qi(t, r, o, s),
              (c = t.memoizedState),
              a !== r || h !== c || ks.current || Mi
                ? ("function" === typeof u &&
                    (ra(t, n, u, r), (c = t.memoizedState)),
                  (a = Mi || ia(t, n, a, r, h, c, l))
                    ? (d ||
                        ("function" !== typeof o.UNSAFE_componentWillMount &&
                          "function" !== typeof o.componentWillMount) ||
                        ("function" === typeof o.componentWillMount &&
                          o.componentWillMount(),
                        "function" === typeof o.UNSAFE_componentWillMount &&
                          o.UNSAFE_componentWillMount()),
                      "function" === typeof o.componentDidMount &&
                        (t.flags |= 4194308))
                    : ("function" === typeof o.componentDidMount &&
                        (t.flags |= 4194308),
                      (t.memoizedProps = r),
                      (t.memoizedState = c)),
                  (o.props = r),
                  (o.state = c),
                  (o.context = l),
                  (r = a))
                : ("function" === typeof o.componentDidMount &&
                    (t.flags |= 4194308),
                  (r = !1));
          } else {
            (o = t.stateNode),
              Li(e, t),
              (a = t.memoizedProps),
              (l = t.type === t.elementType ? a : na(t.type, a)),
              (o.props = l),
              (d = t.pendingProps),
              (h = o.context),
              "object" === typeof (c = n.contextType) && null !== c
                ? (c = Oi(c))
                : (c = xs(t, (c = Ns(n) ? Os : Cs.current)));
            var p = n.getDerivedStateFromProps;
            (u =
              "function" === typeof p ||
              "function" === typeof o.getSnapshotBeforeUpdate) ||
              ("function" !== typeof o.UNSAFE_componentWillReceiveProps &&
                "function" !== typeof o.componentWillReceiveProps) ||
              ((a !== d || h !== c) && aa(t, o, r, c)),
              (Mi = !1),
              (h = t.memoizedState),
              (o.state = h),
              qi(t, r, o, s);
            var f = t.memoizedState;
            a !== d || h !== f || ks.current || Mi
              ? ("function" === typeof p &&
                  (ra(t, n, p, r), (f = t.memoizedState)),
                (l = Mi || ia(t, n, l, r, h, f, c) || !1)
                  ? (u ||
                      ("function" !== typeof o.UNSAFE_componentWillUpdate &&
                        "function" !== typeof o.componentWillUpdate) ||
                      ("function" === typeof o.componentWillUpdate &&
                        o.componentWillUpdate(r, f, c),
                      "function" === typeof o.UNSAFE_componentWillUpdate &&
                        o.UNSAFE_componentWillUpdate(r, f, c)),
                    "function" === typeof o.componentDidUpdate &&
                      (t.flags |= 4),
                    "function" === typeof o.getSnapshotBeforeUpdate &&
                      (t.flags |= 1024))
                  : ("function" !== typeof o.componentDidUpdate ||
                      (a === e.memoizedProps && h === e.memoizedState) ||
                      (t.flags |= 4),
                    "function" !== typeof o.getSnapshotBeforeUpdate ||
                      (a === e.memoizedProps && h === e.memoizedState) ||
                      (t.flags |= 1024),
                    (t.memoizedProps = r),
                    (t.memoizedState = f)),
                (o.props = r),
                (o.state = f),
                (o.context = c),
                (r = l))
              : ("function" !== typeof o.componentDidUpdate ||
                  (a === e.memoizedProps && h === e.memoizedState) ||
                  (t.flags |= 4),
                "function" !== typeof o.getSnapshotBeforeUpdate ||
                  (a === e.memoizedProps && h === e.memoizedState) ||
                  (t.flags |= 1024),
                (r = !1));
          }
          return Ca(e, t, n, r, i, s);
        }
        function Ca(e, t, n, r, s, i) {
          Ta(e, t);
          var o = 0 !== (128 & t.flags);
          if (!r && !o) return s && Ls(t, n, !1), Wa(e, t, i);
          (r = t.stateNode), (ya.current = t);
          var a =
            o && "function" !== typeof n.getDerivedStateFromError
              ? null
              : r.render();
          return (
            (t.flags |= 1),
            null !== e && o
              ? ((t.child = wi(t, e.child, null, i)),
                (t.child = wi(t, null, a, i)))
              : wa(e, t, a, i),
            (t.memoizedState = r.state),
            s && Ls(t, n, !0),
            t.child
          );
        }
        function ka(e) {
          var t = e.stateNode;
          t.pendingContext
            ? Ds(0, t.pendingContext, t.pendingContext !== t.context)
            : t.context && Ds(0, t.context, !1),
            Qi(e, t.containerInfo);
        }
        function Oa(e, t, n, r, s) {
          return pi(), fi(s), (t.flags |= 256), wa(e, t, n, r), t.child;
        }
        var xa,
          Na,
          Ra,
          Da,
          Ma = { dehydrated: null, treeContext: null, retryLane: 0 };
        function ja(e) {
          return { baseLanes: e, cachePool: null, transitions: null };
        }
        function La(e, t, n) {
          var r,
            s = t.pendingProps,
            o = $i.current,
            a = !1,
            c = 0 !== (128 & t.flags);
          if (
            ((r = c) ||
              (r = (null === e || null !== e.memoizedState) && 0 !== (2 & o)),
            r
              ? ((a = !0), (t.flags &= -129))
              : (null !== e && null === e.memoizedState) || (o |= 1),
            Ps($i, 1 & o),
            null === e)
          )
            return (
              li(t),
              null !== (e = t.memoizedState) && null !== (e = e.dehydrated)
                ? (0 === (1 & t.mode)
                    ? (t.lanes = 1)
                    : "$!" === e.data
                    ? (t.lanes = 8)
                    : (t.lanes = 1073741824),
                  null)
                : ((c = s.children),
                  (e = s.fallback),
                  a
                    ? ((s = t.mode),
                      (a = t.child),
                      (c = { mode: "hidden", children: c }),
                      0 === (1 & s) && null !== a
                        ? ((a.childLanes = 0), (a.pendingProps = c))
                        : (a = jl(c, s, 0, null)),
                      (e = Ml(e, s, n, null)),
                      (a.return = t),
                      (e.return = t),
                      (a.sibling = e),
                      (t.child = a),
                      (t.child.memoizedState = ja(n)),
                      (t.memoizedState = Ma),
                      e)
                    : Ua(t, c))
            );
          if (null !== (o = e.memoizedState) && null !== (r = o.dehydrated))
            return (function (e, t, n, r, s, o, a) {
              if (n)
                return 256 & t.flags
                  ? ((t.flags &= -257), Fa(e, t, a, (r = ua(Error(i(422))))))
                  : null !== t.memoizedState
                  ? ((t.child = e.child), (t.flags |= 128), null)
                  : ((o = r.fallback),
                    (s = t.mode),
                    (r = jl(
                      { mode: "visible", children: r.children },
                      s,
                      0,
                      null
                    )),
                    ((o = Ml(o, s, a, null)).flags |= 2),
                    (r.return = t),
                    (o.return = t),
                    (r.sibling = o),
                    (t.child = r),
                    0 !== (1 & t.mode) && wi(t, e.child, null, a),
                    (t.child.memoizedState = ja(a)),
                    (t.memoizedState = Ma),
                    o);
              if (0 === (1 & t.mode)) return Fa(e, t, a, null);
              if ("$!" === s.data) {
                if ((r = s.nextSibling && s.nextSibling.dataset))
                  var c = r.dgst;
                return (
                  (r = c), Fa(e, t, a, (r = ua((o = Error(i(419))), r, void 0)))
                );
              }
              if (((c = 0 !== (a & e.childLanes)), ba || c)) {
                if (null !== (r = kc)) {
                  switch (a & -a) {
                    case 4:
                      s = 2;
                      break;
                    case 16:
                      s = 8;
                      break;
                    case 64:
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                    case 67108864:
                      s = 32;
                      break;
                    case 536870912:
                      s = 268435456;
                      break;
                    default:
                      s = 0;
                  }
                  0 !== (s = 0 !== (s & (r.suspendedLanes | a)) ? 0 : s) &&
                    s !== o.retryLane &&
                    ((o.retryLane = s), Di(e, s), nl(r, e, s, -1));
                }
                return ml(), Fa(e, t, a, (r = ua(Error(i(421)))));
              }
              return "$?" === s.data
                ? ((t.flags |= 128),
                  (t.child = e.child),
                  (t = Il.bind(null, e)),
                  (s._reactRetry = t),
                  null)
                : ((e = o.treeContext),
                  (ri = ls(s.nextSibling)),
                  (ni = t),
                  (si = !0),
                  (ii = null),
                  null !== e &&
                    ((Gs[Js++] = Ys),
                    (Gs[Js++] = Xs),
                    (Gs[Js++] = Qs),
                    (Ys = e.id),
                    (Xs = e.overflow),
                    (Qs = t)),
                  (t = Ua(t, r.children)),
                  (t.flags |= 4096),
                  t);
            })(e, t, c, s, r, o, n);
          if (a) {
            (a = s.fallback), (c = t.mode), (r = (o = e.child).sibling);
            var l = { mode: "hidden", children: s.children };
            return (
              0 === (1 & c) && t.child !== o
                ? (((s = t.child).childLanes = 0),
                  (s.pendingProps = l),
                  (t.deletions = null))
                : ((s = Rl(o, l)).subtreeFlags = 14680064 & o.subtreeFlags),
              null !== r
                ? (a = Rl(r, a))
                : ((a = Ml(a, c, n, null)).flags |= 2),
              (a.return = t),
              (s.return = t),
              (s.sibling = a),
              (t.child = s),
              (s = a),
              (a = t.child),
              (c =
                null === (c = e.child.memoizedState)
                  ? ja(n)
                  : {
                      baseLanes: c.baseLanes | n,
                      cachePool: null,
                      transitions: c.transitions,
                    }),
              (a.memoizedState = c),
              (a.childLanes = e.childLanes & ~n),
              (t.memoizedState = Ma),
              s
            );
          }
          return (
            (e = (a = e.child).sibling),
            (s = Rl(a, { mode: "visible", children: s.children })),
            0 === (1 & t.mode) && (s.lanes = n),
            (s.return = t),
            (s.sibling = null),
            null !== e &&
              (null === (n = t.deletions)
                ? ((t.deletions = [e]), (t.flags |= 16))
                : n.push(e)),
            (t.child = s),
            (t.memoizedState = null),
            s
          );
        }
        function Ua(e, t) {
          return (
            ((t = jl(
              { mode: "visible", children: t },
              e.mode,
              0,
              null
            )).return = e),
            (e.child = t)
          );
        }
        function Fa(e, t, n, r) {
          return (
            null !== r && fi(r),
            wi(t, e.child, null, n),
            ((e = Ua(t, t.pendingProps.children)).flags |= 2),
            (t.memoizedState = null),
            e
          );
        }
        function Ba(e, t, n) {
          e.lanes |= t;
          var r = e.alternate;
          null !== r && (r.lanes |= t), Ci(e.return, t, n);
        }
        function Va(e, t, n, r, s) {
          var i = e.memoizedState;
          null === i
            ? (e.memoizedState = {
                isBackwards: t,
                rendering: null,
                renderingStartTime: 0,
                last: r,
                tail: n,
                tailMode: s,
              })
            : ((i.isBackwards = t),
              (i.rendering = null),
              (i.renderingStartTime = 0),
              (i.last = r),
              (i.tail = n),
              (i.tailMode = s));
        }
        function qa(e, t, n) {
          var r = t.pendingProps,
            s = r.revealOrder,
            i = r.tail;
          if ((wa(e, t, r.children, n), 0 !== (2 & (r = $i.current))))
            (r = (1 & r) | 2), (t.flags |= 128);
          else {
            if (null !== e && 0 !== (128 & e.flags))
              e: for (e = t.child; null !== e; ) {
                if (13 === e.tag) null !== e.memoizedState && Ba(e, n, t);
                else if (19 === e.tag) Ba(e, n, t);
                else if (null !== e.child) {
                  (e.child.return = e), (e = e.child);
                  continue;
                }
                if (e === t) break e;
                for (; null === e.sibling; ) {
                  if (null === e.return || e.return === t) break e;
                  e = e.return;
                }
                (e.sibling.return = e.return), (e = e.sibling);
              }
            r &= 1;
          }
          if ((Ps($i, r), 0 === (1 & t.mode))) t.memoizedState = null;
          else
            switch (s) {
              case "forwards":
                for (n = t.child, s = null; null !== n; )
                  null !== (e = n.alternate) && null === eo(e) && (s = n),
                    (n = n.sibling);
                null === (n = s)
                  ? ((s = t.child), (t.child = null))
                  : ((s = n.sibling), (n.sibling = null)),
                  Va(t, !1, s, n, i);
                break;
              case "backwards":
                for (n = null, s = t.child, t.child = null; null !== s; ) {
                  if (null !== (e = s.alternate) && null === eo(e)) {
                    t.child = s;
                    break;
                  }
                  (e = s.sibling), (s.sibling = n), (n = s), (s = e);
                }
                Va(t, !0, n, null, i);
                break;
              case "together":
                Va(t, !1, null, null, void 0);
                break;
              default:
                t.memoizedState = null;
            }
          return t.child;
        }
        function Ha(e, t) {
          0 === (1 & t.mode) &&
            null !== e &&
            ((e.alternate = null), (t.alternate = null), (t.flags |= 2));
        }
        function Wa(e, t, n) {
          if (
            (null !== e && (t.dependencies = e.dependencies),
            (jc |= t.lanes),
            0 === (n & t.childLanes))
          )
            return null;
          if (null !== e && t.child !== e.child) throw Error(i(153));
          if (null !== t.child) {
            for (
              n = Rl((e = t.child), e.pendingProps), t.child = n, n.return = t;
              null !== e.sibling;

            )
              (e = e.sibling),
                ((n = n.sibling = Rl(e, e.pendingProps)).return = t);
            n.sibling = null;
          }
          return t.child;
        }
        function Ka(e, t) {
          if (!si)
            switch (e.tailMode) {
              case "hidden":
                t = e.tail;
                for (var n = null; null !== t; )
                  null !== t.alternate && (n = t), (t = t.sibling);
                null === n ? (e.tail = null) : (n.sibling = null);
                break;
              case "collapsed":
                n = e.tail;
                for (var r = null; null !== n; )
                  null !== n.alternate && (r = n), (n = n.sibling);
                null === r
                  ? t || null === e.tail
                    ? (e.tail = null)
                    : (e.tail.sibling = null)
                  : (r.sibling = null);
            }
        }
        function za(e) {
          var t = null !== e.alternate && e.alternate.child === e.child,
            n = 0,
            r = 0;
          if (t)
            for (var s = e.child; null !== s; )
              (n |= s.lanes | s.childLanes),
                (r |= 14680064 & s.subtreeFlags),
                (r |= 14680064 & s.flags),
                (s.return = e),
                (s = s.sibling);
          else
            for (s = e.child; null !== s; )
              (n |= s.lanes | s.childLanes),
                (r |= s.subtreeFlags),
                (r |= s.flags),
                (s.return = e),
                (s = s.sibling);
          return (e.subtreeFlags |= r), (e.childLanes = n), t;
        }
        function Ga(e, t, n) {
          var r = t.pendingProps;
          switch ((ti(t), t.tag)) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return za(t), null;
            case 1:
            case 17:
              return Ns(t.type) && Rs(), za(t), null;
            case 3:
              return (
                (r = t.stateNode),
                Yi(),
                Ts(ks),
                Ts(Cs),
                no(),
                r.pendingContext &&
                  ((r.context = r.pendingContext), (r.pendingContext = null)),
                (null !== e && null !== e.child) ||
                  (di(t)
                    ? (t.flags |= 4)
                    : null === e ||
                      (e.memoizedState.isDehydrated && 0 === (256 & t.flags)) ||
                      ((t.flags |= 1024),
                      null !== ii && (ol(ii), (ii = null)))),
                Na(e, t),
                za(t),
                null
              );
            case 5:
              Zi(t);
              var s = Ji(Gi.current);
              if (((n = t.type), null !== e && null != t.stateNode))
                Ra(e, t, n, r, s),
                  e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152));
              else {
                if (!r) {
                  if (null === t.stateNode) throw Error(i(166));
                  return za(t), null;
                }
                if (((e = Ji(Ki.current)), di(t))) {
                  (r = t.stateNode), (n = t.type);
                  var o = t.memoizedProps;
                  switch (
                    ((r[hs] = t), (r[ps] = o), (e = 0 !== (1 & t.mode)), n)
                  ) {
                    case "dialog":
                      Fr("cancel", r), Fr("close", r);
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      Fr("load", r);
                      break;
                    case "video":
                    case "audio":
                      for (s = 0; s < Mr.length; s++) Fr(Mr[s], r);
                      break;
                    case "source":
                      Fr("error", r);
                      break;
                    case "img":
                    case "image":
                    case "link":
                      Fr("error", r), Fr("load", r);
                      break;
                    case "details":
                      Fr("toggle", r);
                      break;
                    case "input":
                      Y(r, o), Fr("invalid", r);
                      break;
                    case "select":
                      (r._wrapperState = { wasMultiple: !!o.multiple }),
                        Fr("invalid", r);
                      break;
                    case "textarea":
                      se(r, o), Fr("invalid", r);
                  }
                  for (var c in (ye(n, o), (s = null), o))
                    if (o.hasOwnProperty(c)) {
                      var l = o[c];
                      "children" === c
                        ? "string" === typeof l
                          ? r.textContent !== l &&
                            (!0 !== o.suppressHydrationWarning &&
                              Zr(r.textContent, l, e),
                            (s = ["children", l]))
                          : "number" === typeof l &&
                            r.textContent !== "" + l &&
                            (!0 !== o.suppressHydrationWarning &&
                              Zr(r.textContent, l, e),
                            (s = ["children", "" + l]))
                        : a.hasOwnProperty(c) &&
                          null != l &&
                          "onScroll" === c &&
                          Fr("scroll", r);
                    }
                  switch (n) {
                    case "input":
                      z(r), $(r, o, !0);
                      break;
                    case "textarea":
                      z(r), oe(r);
                      break;
                    case "select":
                    case "option":
                      break;
                    default:
                      "function" === typeof o.onClick && (r.onclick = $r);
                  }
                  (r = s), (t.updateQueue = r), null !== r && (t.flags |= 4);
                } else {
                  (c = 9 === s.nodeType ? s : s.ownerDocument),
                    "http://www.w3.org/1999/xhtml" === e && (e = ae(n)),
                    "http://www.w3.org/1999/xhtml" === e
                      ? "script" === n
                        ? (((e = c.createElement("div")).innerHTML =
                            "<script></script>"),
                          (e = e.removeChild(e.firstChild)))
                        : "string" === typeof r.is
                        ? (e = c.createElement(n, { is: r.is }))
                        : ((e = c.createElement(n)),
                          "select" === n &&
                            ((c = e),
                            r.multiple
                              ? (c.multiple = !0)
                              : r.size && (c.size = r.size)))
                      : (e = c.createElementNS(e, n)),
                    (e[hs] = t),
                    (e[ps] = r),
                    xa(e, t, !1, !1),
                    (t.stateNode = e);
                  e: {
                    switch (((c = be(n, r)), n)) {
                      case "dialog":
                        Fr("cancel", e), Fr("close", e), (s = r);
                        break;
                      case "iframe":
                      case "object":
                      case "embed":
                        Fr("load", e), (s = r);
                        break;
                      case "video":
                      case "audio":
                        for (s = 0; s < Mr.length; s++) Fr(Mr[s], e);
                        s = r;
                        break;
                      case "source":
                        Fr("error", e), (s = r);
                        break;
                      case "img":
                      case "image":
                      case "link":
                        Fr("error", e), Fr("load", e), (s = r);
                        break;
                      case "details":
                        Fr("toggle", e), (s = r);
                        break;
                      case "input":
                        Y(e, r), (s = Q(e, r)), Fr("invalid", e);
                        break;
                      case "option":
                      default:
                        s = r;
                        break;
                      case "select":
                        (e._wrapperState = { wasMultiple: !!r.multiple }),
                          (s = L({}, r, { value: void 0 })),
                          Fr("invalid", e);
                        break;
                      case "textarea":
                        se(e, r), (s = re(e, r)), Fr("invalid", e);
                    }
                    for (o in (ye(n, s), (l = s)))
                      if (l.hasOwnProperty(o)) {
                        var u = l[o];
                        "style" === o
                          ? ge(e, u)
                          : "dangerouslySetInnerHTML" === o
                          ? null != (u = u ? u.__html : void 0) && de(e, u)
                          : "children" === o
                          ? "string" === typeof u
                            ? ("textarea" !== n || "" !== u) && he(e, u)
                            : "number" === typeof u && he(e, "" + u)
                          : "suppressContentEditableWarning" !== o &&
                            "suppressHydrationWarning" !== o &&
                            "autoFocus" !== o &&
                            (a.hasOwnProperty(o)
                              ? null != u && "onScroll" === o && Fr("scroll", e)
                              : null != u && b(e, o, u, c));
                      }
                    switch (n) {
                      case "input":
                        z(e), $(e, r, !1);
                        break;
                      case "textarea":
                        z(e), oe(e);
                        break;
                      case "option":
                        null != r.value &&
                          e.setAttribute("value", "" + W(r.value));
                        break;
                      case "select":
                        (e.multiple = !!r.multiple),
                          null != (o = r.value)
                            ? ne(e, !!r.multiple, o, !1)
                            : null != r.defaultValue &&
                              ne(e, !!r.multiple, r.defaultValue, !0);
                        break;
                      default:
                        "function" === typeof s.onClick && (e.onclick = $r);
                    }
                    switch (n) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        r = !!r.autoFocus;
                        break e;
                      case "img":
                        r = !0;
                        break e;
                      default:
                        r = !1;
                    }
                  }
                  r && (t.flags |= 4);
                }
                null !== t.ref && ((t.flags |= 512), (t.flags |= 2097152));
              }
              return za(t), null;
            case 6:
              if (e && null != t.stateNode) Da(e, t, e.memoizedProps, r);
              else {
                if ("string" !== typeof r && null === t.stateNode)
                  throw Error(i(166));
                if (((n = Ji(Gi.current)), Ji(Ki.current), di(t))) {
                  if (
                    ((r = t.stateNode),
                    (n = t.memoizedProps),
                    (r[hs] = t),
                    (o = r.nodeValue !== n) && null !== (e = ni))
                  )
                    switch (e.tag) {
                      case 3:
                        Zr(r.nodeValue, n, 0 !== (1 & e.mode));
                        break;
                      case 5:
                        !0 !== e.memoizedProps.suppressHydrationWarning &&
                          Zr(r.nodeValue, n, 0 !== (1 & e.mode));
                    }
                  o && (t.flags |= 4);
                } else
                  ((r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(
                    r
                  ))[hs] = t),
                    (t.stateNode = r);
              }
              return za(t), null;
            case 13:
              if (
                (Ts($i),
                (r = t.memoizedState),
                null === e ||
                  (null !== e.memoizedState &&
                    null !== e.memoizedState.dehydrated))
              ) {
                if (
                  si &&
                  null !== ri &&
                  0 !== (1 & t.mode) &&
                  0 === (128 & t.flags)
                )
                  hi(), pi(), (t.flags |= 98560), (o = !1);
                else if (((o = di(t)), null !== r && null !== r.dehydrated)) {
                  if (null === e) {
                    if (!o) throw Error(i(318));
                    if (
                      !(o =
                        null !== (o = t.memoizedState) ? o.dehydrated : null)
                    )
                      throw Error(i(317));
                    o[hs] = t;
                  } else
                    pi(),
                      0 === (128 & t.flags) && (t.memoizedState = null),
                      (t.flags |= 4);
                  za(t), (o = !1);
                } else null !== ii && (ol(ii), (ii = null)), (o = !0);
                if (!o) return 65536 & t.flags ? t : null;
              }
              return 0 !== (128 & t.flags)
                ? ((t.lanes = n), t)
                : ((r = null !== r) !==
                    (null !== e && null !== e.memoizedState) &&
                    r &&
                    ((t.child.flags |= 8192),
                    0 !== (1 & t.mode) &&
                      (null === e || 0 !== (1 & $i.current)
                        ? 0 === Dc && (Dc = 3)
                        : ml())),
                  null !== t.updateQueue && (t.flags |= 4),
                  za(t),
                  null);
            case 4:
              return (
                Yi(),
                Na(e, t),
                null === e && qr(t.stateNode.containerInfo),
                za(t),
                null
              );
            case 10:
              return Ii(t.type._context), za(t), null;
            case 19:
              if ((Ts($i), null === (o = t.memoizedState))) return za(t), null;
              if (((r = 0 !== (128 & t.flags)), null === (c = o.rendering)))
                if (r) Ka(o, !1);
                else {
                  if (0 !== Dc || (null !== e && 0 !== (128 & e.flags)))
                    for (e = t.child; null !== e; ) {
                      if (null !== (c = eo(e))) {
                        for (
                          t.flags |= 128,
                            Ka(o, !1),
                            null !== (r = c.updateQueue) &&
                              ((t.updateQueue = r), (t.flags |= 4)),
                            t.subtreeFlags = 0,
                            r = n,
                            n = t.child;
                          null !== n;

                        )
                          (e = r),
                            ((o = n).flags &= 14680066),
                            null === (c = o.alternate)
                              ? ((o.childLanes = 0),
                                (o.lanes = e),
                                (o.child = null),
                                (o.subtreeFlags = 0),
                                (o.memoizedProps = null),
                                (o.memoizedState = null),
                                (o.updateQueue = null),
                                (o.dependencies = null),
                                (o.stateNode = null))
                              : ((o.childLanes = c.childLanes),
                                (o.lanes = c.lanes),
                                (o.child = c.child),
                                (o.subtreeFlags = 0),
                                (o.deletions = null),
                                (o.memoizedProps = c.memoizedProps),
                                (o.memoizedState = c.memoizedState),
                                (o.updateQueue = c.updateQueue),
                                (o.type = c.type),
                                (e = c.dependencies),
                                (o.dependencies =
                                  null === e
                                    ? null
                                    : {
                                        lanes: e.lanes,
                                        firstContext: e.firstContext,
                                      })),
                            (n = n.sibling);
                        return Ps($i, (1 & $i.current) | 2), t.child;
                      }
                      e = e.sibling;
                    }
                  null !== o.tail &&
                    Xe() > qc &&
                    ((t.flags |= 128),
                    (r = !0),
                    Ka(o, !1),
                    (t.lanes = 4194304));
                }
              else {
                if (!r)
                  if (null !== (e = eo(c))) {
                    if (
                      ((t.flags |= 128),
                      (r = !0),
                      null !== (n = e.updateQueue) &&
                        ((t.updateQueue = n), (t.flags |= 4)),
                      Ka(o, !0),
                      null === o.tail &&
                        "hidden" === o.tailMode &&
                        !c.alternate &&
                        !si)
                    )
                      return za(t), null;
                  } else
                    2 * Xe() - o.renderingStartTime > qc &&
                      1073741824 !== n &&
                      ((t.flags |= 128),
                      (r = !0),
                      Ka(o, !1),
                      (t.lanes = 4194304));
                o.isBackwards
                  ? ((c.sibling = t.child), (t.child = c))
                  : (null !== (n = o.last) ? (n.sibling = c) : (t.child = c),
                    (o.last = c));
              }
              return null !== o.tail
                ? ((t = o.tail),
                  (o.rendering = t),
                  (o.tail = t.sibling),
                  (o.renderingStartTime = Xe()),
                  (t.sibling = null),
                  (n = $i.current),
                  Ps($i, r ? (1 & n) | 2 : 1 & n),
                  t)
                : (za(t), null);
            case 22:
            case 23:
              return (
                dl(),
                (r = null !== t.memoizedState),
                null !== e &&
                  (null !== e.memoizedState) !== r &&
                  (t.flags |= 8192),
                r && 0 !== (1 & t.mode)
                  ? 0 !== (1073741824 & Nc) &&
                    (za(t), 6 & t.subtreeFlags && (t.flags |= 8192))
                  : za(t),
                null
              );
            case 24:
            case 25:
              return null;
          }
          throw Error(i(156, t.tag));
        }
        function Ja(e, t) {
          switch ((ti(t), t.tag)) {
            case 1:
              return (
                Ns(t.type) && Rs(),
                65536 & (e = t.flags)
                  ? ((t.flags = (-65537 & e) | 128), t)
                  : null
              );
            case 3:
              return (
                Yi(),
                Ts(ks),
                Ts(Cs),
                no(),
                0 !== (65536 & (e = t.flags)) && 0 === (128 & e)
                  ? ((t.flags = (-65537 & e) | 128), t)
                  : null
              );
            case 5:
              return Zi(t), null;
            case 13:
              if (
                (Ts($i),
                null !== (e = t.memoizedState) && null !== e.dehydrated)
              ) {
                if (null === t.alternate) throw Error(i(340));
                pi();
              }
              return 65536 & (e = t.flags)
                ? ((t.flags = (-65537 & e) | 128), t)
                : null;
            case 19:
              return Ts($i), null;
            case 4:
              return Yi(), null;
            case 10:
              return Ii(t.type._context), null;
            case 22:
            case 23:
              return dl(), null;
            default:
              return null;
          }
        }
        (xa = function (e, t) {
          for (var n = t.child; null !== n; ) {
            if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode);
            else if (4 !== n.tag && null !== n.child) {
              (n.child.return = n), (n = n.child);
              continue;
            }
            if (n === t) break;
            for (; null === n.sibling; ) {
              if (null === n.return || n.return === t) return;
              n = n.return;
            }
            (n.sibling.return = n.return), (n = n.sibling);
          }
        }),
          (Na = function () {}),
          (Ra = function (e, t, n, r) {
            var s = e.memoizedProps;
            if (s !== r) {
              (e = t.stateNode), Ji(Ki.current);
              var i,
                o = null;
              switch (n) {
                case "input":
                  (s = Q(e, s)), (r = Q(e, r)), (o = []);
                  break;
                case "select":
                  (s = L({}, s, { value: void 0 })),
                    (r = L({}, r, { value: void 0 })),
                    (o = []);
                  break;
                case "textarea":
                  (s = re(e, s)), (r = re(e, r)), (o = []);
                  break;
                default:
                  "function" !== typeof s.onClick &&
                    "function" === typeof r.onClick &&
                    (e.onclick = $r);
              }
              for (u in (ye(n, r), (n = null), s))
                if (!r.hasOwnProperty(u) && s.hasOwnProperty(u) && null != s[u])
                  if ("style" === u) {
                    var c = s[u];
                    for (i in c)
                      c.hasOwnProperty(i) && (n || (n = {}), (n[i] = ""));
                  } else
                    "dangerouslySetInnerHTML" !== u &&
                      "children" !== u &&
                      "suppressContentEditableWarning" !== u &&
                      "suppressHydrationWarning" !== u &&
                      "autoFocus" !== u &&
                      (a.hasOwnProperty(u)
                        ? o || (o = [])
                        : (o = o || []).push(u, null));
              for (u in r) {
                var l = r[u];
                if (
                  ((c = null != s ? s[u] : void 0),
                  r.hasOwnProperty(u) && l !== c && (null != l || null != c))
                )
                  if ("style" === u)
                    if (c) {
                      for (i in c)
                        !c.hasOwnProperty(i) ||
                          (l && l.hasOwnProperty(i)) ||
                          (n || (n = {}), (n[i] = ""));
                      for (i in l)
                        l.hasOwnProperty(i) &&
                          c[i] !== l[i] &&
                          (n || (n = {}), (n[i] = l[i]));
                    } else n || (o || (o = []), o.push(u, n)), (n = l);
                  else
                    "dangerouslySetInnerHTML" === u
                      ? ((l = l ? l.__html : void 0),
                        (c = c ? c.__html : void 0),
                        null != l && c !== l && (o = o || []).push(u, l))
                      : "children" === u
                      ? ("string" !== typeof l && "number" !== typeof l) ||
                        (o = o || []).push(u, "" + l)
                      : "suppressContentEditableWarning" !== u &&
                        "suppressHydrationWarning" !== u &&
                        (a.hasOwnProperty(u)
                          ? (null != l && "onScroll" === u && Fr("scroll", e),
                            o || c === l || (o = []))
                          : (o = o || []).push(u, l));
              }
              n && (o = o || []).push("style", n);
              var u = o;
              (t.updateQueue = u) && (t.flags |= 4);
            }
          }),
          (Da = function (e, t, n, r) {
            n !== r && (t.flags |= 4);
          });
        var Qa = !1,
          Ya = !1,
          Xa = "function" === typeof WeakSet ? WeakSet : Set,
          Za = null;
        function $a(e, t) {
          var n = e.ref;
          if (null !== n)
            if ("function" === typeof n)
              try {
                n(null);
              } catch (r) {
                Al(e, t, r);
              }
            else n.current = null;
        }
        function ec(e, t, n) {
          try {
            n();
          } catch (r) {
            Al(e, t, r);
          }
        }
        var tc = !1;
        function nc(e, t, n) {
          var r = t.updateQueue;
          if (null !== (r = null !== r ? r.lastEffect : null)) {
            var s = (r = r.next);
            do {
              if ((s.tag & e) === e) {
                var i = s.destroy;
                (s.destroy = void 0), void 0 !== i && ec(t, n, i);
              }
              s = s.next;
            } while (s !== r);
          }
        }
        function rc(e, t) {
          if (
            null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)
          ) {
            var n = (t = t.next);
            do {
              if ((n.tag & e) === e) {
                var r = n.create;
                n.destroy = r();
              }
              n = n.next;
            } while (n !== t);
          }
        }
        function sc(e) {
          var t = e.ref;
          if (null !== t) {
            var n = e.stateNode;
            e.tag, (e = n), "function" === typeof t ? t(e) : (t.current = e);
          }
        }
        function ic(e) {
          var t = e.alternate;
          null !== t && ((e.alternate = null), ic(t)),
            (e.child = null),
            (e.deletions = null),
            (e.sibling = null),
            5 === e.tag &&
              null !== (t = e.stateNode) &&
              (delete t[hs],
              delete t[ps],
              delete t[ms],
              delete t[gs],
              delete t[vs]),
            (e.stateNode = null),
            (e.return = null),
            (e.dependencies = null),
            (e.memoizedProps = null),
            (e.memoizedState = null),
            (e.pendingProps = null),
            (e.stateNode = null),
            (e.updateQueue = null);
        }
        function oc(e) {
          return 5 === e.tag || 3 === e.tag || 4 === e.tag;
        }
        function ac(e) {
          e: for (;;) {
            for (; null === e.sibling; ) {
              if (null === e.return || oc(e.return)) return null;
              e = e.return;
            }
            for (
              e.sibling.return = e.return, e = e.sibling;
              5 !== e.tag && 6 !== e.tag && 18 !== e.tag;

            ) {
              if (2 & e.flags) continue e;
              if (null === e.child || 4 === e.tag) continue e;
              (e.child.return = e), (e = e.child);
            }
            if (!(2 & e.flags)) return e.stateNode;
          }
        }
        function cc(e, t, n) {
          var r = e.tag;
          if (5 === r || 6 === r)
            (e = e.stateNode),
              t
                ? 8 === n.nodeType
                  ? n.parentNode.insertBefore(e, t)
                  : n.insertBefore(e, t)
                : (8 === n.nodeType
                    ? (t = n.parentNode).insertBefore(e, n)
                    : (t = n).appendChild(e),
                  (null !== (n = n._reactRootContainer) && void 0 !== n) ||
                    null !== t.onclick ||
                    (t.onclick = $r));
          else if (4 !== r && null !== (e = e.child))
            for (cc(e, t, n), e = e.sibling; null !== e; )
              cc(e, t, n), (e = e.sibling);
        }
        function lc(e, t, n) {
          var r = e.tag;
          if (5 === r || 6 === r)
            (e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e);
          else if (4 !== r && null !== (e = e.child))
            for (lc(e, t, n), e = e.sibling; null !== e; )
              lc(e, t, n), (e = e.sibling);
        }
        var uc = null,
          dc = !1;
        function hc(e, t, n) {
          for (n = n.child; null !== n; ) pc(e, t, n), (n = n.sibling);
        }
        function pc(e, t, n) {
          if (it && "function" === typeof it.onCommitFiberUnmount)
            try {
              it.onCommitFiberUnmount(st, n);
            } catch (a) {}
          switch (n.tag) {
            case 5:
              Ya || $a(n, t);
            case 6:
              var r = uc,
                s = dc;
              (uc = null),
                hc(e, t, n),
                (dc = s),
                null !== (uc = r) &&
                  (dc
                    ? ((e = uc),
                      (n = n.stateNode),
                      8 === e.nodeType
                        ? e.parentNode.removeChild(n)
                        : e.removeChild(n))
                    : uc.removeChild(n.stateNode));
              break;
            case 18:
              null !== uc &&
                (dc
                  ? ((e = uc),
                    (n = n.stateNode),
                    8 === e.nodeType
                      ? cs(e.parentNode, n)
                      : 1 === e.nodeType && cs(e, n),
                    qt(e))
                  : cs(uc, n.stateNode));
              break;
            case 4:
              (r = uc),
                (s = dc),
                (uc = n.stateNode.containerInfo),
                (dc = !0),
                hc(e, t, n),
                (uc = r),
                (dc = s);
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              if (
                !Ya &&
                null !== (r = n.updateQueue) &&
                null !== (r = r.lastEffect)
              ) {
                s = r = r.next;
                do {
                  var i = s,
                    o = i.destroy;
                  (i = i.tag),
                    void 0 !== o &&
                      (0 !== (2 & i) || 0 !== (4 & i)) &&
                      ec(n, t, o),
                    (s = s.next);
                } while (s !== r);
              }
              hc(e, t, n);
              break;
            case 1:
              if (
                !Ya &&
                ($a(n, t),
                "function" === typeof (r = n.stateNode).componentWillUnmount)
              )
                try {
                  (r.props = n.memoizedProps),
                    (r.state = n.memoizedState),
                    r.componentWillUnmount();
                } catch (a) {
                  Al(n, t, a);
                }
              hc(e, t, n);
              break;
            case 21:
              hc(e, t, n);
              break;
            case 22:
              1 & n.mode
                ? ((Ya = (r = Ya) || null !== n.memoizedState),
                  hc(e, t, n),
                  (Ya = r))
                : hc(e, t, n);
              break;
            default:
              hc(e, t, n);
          }
        }
        function fc(e) {
          var t = e.updateQueue;
          if (null !== t) {
            e.updateQueue = null;
            var n = e.stateNode;
            null === n && (n = e.stateNode = new Xa()),
              t.forEach(function (t) {
                var r = Cl.bind(null, e, t);
                n.has(t) || (n.add(t), t.then(r, r));
              });
          }
        }
        function mc(e, t) {
          var n = t.deletions;
          if (null !== n)
            for (var r = 0; r < n.length; r++) {
              var s = n[r];
              try {
                var o = e,
                  a = t,
                  c = a;
                e: for (; null !== c; ) {
                  switch (c.tag) {
                    case 5:
                      (uc = c.stateNode), (dc = !1);
                      break e;
                    case 3:
                    case 4:
                      (uc = c.stateNode.containerInfo), (dc = !0);
                      break e;
                  }
                  c = c.return;
                }
                if (null === uc) throw Error(i(160));
                pc(o, a, s), (uc = null), (dc = !1);
                var l = s.alternate;
                null !== l && (l.return = null), (s.return = null);
              } catch (u) {
                Al(s, t, u);
              }
            }
          if (12854 & t.subtreeFlags)
            for (t = t.child; null !== t; ) gc(t, e), (t = t.sibling);
        }
        function gc(e, t) {
          var n = e.alternate,
            r = e.flags;
          switch (e.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              if ((mc(t, e), vc(e), 4 & r)) {
                try {
                  nc(3, e, e.return), rc(3, e);
                } catch (g) {
                  Al(e, e.return, g);
                }
                try {
                  nc(5, e, e.return);
                } catch (g) {
                  Al(e, e.return, g);
                }
              }
              break;
            case 1:
              mc(t, e), vc(e), 512 & r && null !== n && $a(n, n.return);
              break;
            case 5:
              if (
                (mc(t, e),
                vc(e),
                512 & r && null !== n && $a(n, n.return),
                32 & e.flags)
              ) {
                var s = e.stateNode;
                try {
                  he(s, "");
                } catch (g) {
                  Al(e, e.return, g);
                }
              }
              if (4 & r && null != (s = e.stateNode)) {
                var o = e.memoizedProps,
                  a = null !== n ? n.memoizedProps : o,
                  c = e.type,
                  l = e.updateQueue;
                if (((e.updateQueue = null), null !== l))
                  try {
                    "input" === c &&
                      "radio" === o.type &&
                      null != o.name &&
                      X(s, o),
                      be(c, a);
                    var u = be(c, o);
                    for (a = 0; a < l.length; a += 2) {
                      var d = l[a],
                        h = l[a + 1];
                      "style" === d
                        ? ge(s, h)
                        : "dangerouslySetInnerHTML" === d
                        ? de(s, h)
                        : "children" === d
                        ? he(s, h)
                        : b(s, d, h, u);
                    }
                    switch (c) {
                      case "input":
                        Z(s, o);
                        break;
                      case "textarea":
                        ie(s, o);
                        break;
                      case "select":
                        var p = s._wrapperState.wasMultiple;
                        s._wrapperState.wasMultiple = !!o.multiple;
                        var f = o.value;
                        null != f
                          ? ne(s, !!o.multiple, f, !1)
                          : p !== !!o.multiple &&
                            (null != o.defaultValue
                              ? ne(s, !!o.multiple, o.defaultValue, !0)
                              : ne(s, !!o.multiple, o.multiple ? [] : "", !1));
                    }
                    s[ps] = o;
                  } catch (g) {
                    Al(e, e.return, g);
                  }
              }
              break;
            case 6:
              if ((mc(t, e), vc(e), 4 & r)) {
                if (null === e.stateNode) throw Error(i(162));
                (s = e.stateNode), (o = e.memoizedProps);
                try {
                  s.nodeValue = o;
                } catch (g) {
                  Al(e, e.return, g);
                }
              }
              break;
            case 3:
              if (
                (mc(t, e),
                vc(e),
                4 & r && null !== n && n.memoizedState.isDehydrated)
              )
                try {
                  qt(t.containerInfo);
                } catch (g) {
                  Al(e, e.return, g);
                }
              break;
            case 4:
            default:
              mc(t, e), vc(e);
              break;
            case 13:
              mc(t, e),
                vc(e),
                8192 & (s = e.child).flags &&
                  ((o = null !== s.memoizedState),
                  (s.stateNode.isHidden = o),
                  !o ||
                    (null !== s.alternate &&
                      null !== s.alternate.memoizedState) ||
                    (Vc = Xe())),
                4 & r && fc(e);
              break;
            case 22:
              if (
                ((d = null !== n && null !== n.memoizedState),
                1 & e.mode
                  ? ((Ya = (u = Ya) || d), mc(t, e), (Ya = u))
                  : mc(t, e),
                vc(e),
                8192 & r)
              ) {
                if (
                  ((u = null !== e.memoizedState),
                  (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode))
                )
                  for (Za = e, d = e.child; null !== d; ) {
                    for (h = Za = d; null !== Za; ) {
                      switch (((f = (p = Za).child), p.tag)) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          nc(4, p, p.return);
                          break;
                        case 1:
                          $a(p, p.return);
                          var m = p.stateNode;
                          if ("function" === typeof m.componentWillUnmount) {
                            (r = p), (n = p.return);
                            try {
                              (t = r),
                                (m.props = t.memoizedProps),
                                (m.state = t.memoizedState),
                                m.componentWillUnmount();
                            } catch (g) {
                              Al(r, n, g);
                            }
                          }
                          break;
                        case 5:
                          $a(p, p.return);
                          break;
                        case 22:
                          if (null !== p.memoizedState) {
                            Sc(h);
                            continue;
                          }
                      }
                      null !== f ? ((f.return = p), (Za = f)) : Sc(h);
                    }
                    d = d.sibling;
                  }
                e: for (d = null, h = e; ; ) {
                  if (5 === h.tag) {
                    if (null === d) {
                      d = h;
                      try {
                        (s = h.stateNode),
                          u
                            ? "function" === typeof (o = s.style).setProperty
                              ? o.setProperty("display", "none", "important")
                              : (o.display = "none")
                            : ((c = h.stateNode),
                              (a =
                                void 0 !== (l = h.memoizedProps.style) &&
                                null !== l &&
                                l.hasOwnProperty("display")
                                  ? l.display
                                  : null),
                              (c.style.display = me("display", a)));
                      } catch (g) {
                        Al(e, e.return, g);
                      }
                    }
                  } else if (6 === h.tag) {
                    if (null === d)
                      try {
                        h.stateNode.nodeValue = u ? "" : h.memoizedProps;
                      } catch (g) {
                        Al(e, e.return, g);
                      }
                  } else if (
                    ((22 !== h.tag && 23 !== h.tag) ||
                      null === h.memoizedState ||
                      h === e) &&
                    null !== h.child
                  ) {
                    (h.child.return = h), (h = h.child);
                    continue;
                  }
                  if (h === e) break e;
                  for (; null === h.sibling; ) {
                    if (null === h.return || h.return === e) break e;
                    d === h && (d = null), (h = h.return);
                  }
                  d === h && (d = null),
                    (h.sibling.return = h.return),
                    (h = h.sibling);
                }
              }
              break;
            case 19:
              mc(t, e), vc(e), 4 & r && fc(e);
            case 21:
          }
        }
        function vc(e) {
          var t = e.flags;
          if (2 & t) {
            try {
              e: {
                for (var n = e.return; null !== n; ) {
                  if (oc(n)) {
                    var r = n;
                    break e;
                  }
                  n = n.return;
                }
                throw Error(i(160));
              }
              switch (r.tag) {
                case 5:
                  var s = r.stateNode;
                  32 & r.flags && (he(s, ""), (r.flags &= -33)),
                    lc(e, ac(e), s);
                  break;
                case 3:
                case 4:
                  var o = r.stateNode.containerInfo;
                  cc(e, ac(e), o);
                  break;
                default:
                  throw Error(i(161));
              }
            } catch (a) {
              Al(e, e.return, a);
            }
            e.flags &= -3;
          }
          4096 & t && (e.flags &= -4097);
        }
        function yc(e, t, n) {
          (Za = e), bc(e, t, n);
        }
        function bc(e, t, n) {
          for (var r = 0 !== (1 & e.mode); null !== Za; ) {
            var s = Za,
              i = s.child;
            if (22 === s.tag && r) {
              var o = null !== s.memoizedState || Qa;
              if (!o) {
                var a = s.alternate,
                  c = (null !== a && null !== a.memoizedState) || Ya;
                a = Qa;
                var l = Ya;
                if (((Qa = o), (Ya = c) && !l))
                  for (Za = s; null !== Za; )
                    (c = (o = Za).child),
                      22 === o.tag && null !== o.memoizedState
                        ? _c(s)
                        : null !== c
                        ? ((c.return = o), (Za = c))
                        : _c(s);
                for (; null !== i; ) (Za = i), bc(i, t, n), (i = i.sibling);
                (Za = s), (Qa = a), (Ya = l);
              }
              wc(e);
            } else
              0 !== (8772 & s.subtreeFlags) && null !== i
                ? ((i.return = s), (Za = i))
                : wc(e);
          }
        }
        function wc(e) {
          for (; null !== Za; ) {
            var t = Za;
            if (0 !== (8772 & t.flags)) {
              var n = t.alternate;
              try {
                if (0 !== (8772 & t.flags))
                  switch (t.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ya || rc(5, t);
                      break;
                    case 1:
                      var r = t.stateNode;
                      if (4 & t.flags && !Ya)
                        if (null === n) r.componentDidMount();
                        else {
                          var s =
                            t.elementType === t.type
                              ? n.memoizedProps
                              : na(t.type, n.memoizedProps);
                          r.componentDidUpdate(
                            s,
                            n.memoizedState,
                            r.__reactInternalSnapshotBeforeUpdate
                          );
                        }
                      var o = t.updateQueue;
                      null !== o && Hi(t, o, r);
                      break;
                    case 3:
                      var a = t.updateQueue;
                      if (null !== a) {
                        if (((n = null), null !== t.child))
                          switch (t.child.tag) {
                            case 5:
                            case 1:
                              n = t.child.stateNode;
                          }
                        Hi(t, a, n);
                      }
                      break;
                    case 5:
                      var c = t.stateNode;
                      if (null === n && 4 & t.flags) {
                        n = c;
                        var l = t.memoizedProps;
                        switch (t.type) {
                          case "button":
                          case "input":
                          case "select":
                          case "textarea":
                            l.autoFocus && n.focus();
                            break;
                          case "img":
                            l.src && (n.src = l.src);
                        }
                      }
                      break;
                    case 6:
                    case 4:
                    case 12:
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                      break;
                    case 13:
                      if (null === t.memoizedState) {
                        var u = t.alternate;
                        if (null !== u) {
                          var d = u.memoizedState;
                          if (null !== d) {
                            var h = d.dehydrated;
                            null !== h && qt(h);
                          }
                        }
                      }
                      break;
                    default:
                      throw Error(i(163));
                  }
                Ya || (512 & t.flags && sc(t));
              } catch (p) {
                Al(t, t.return, p);
              }
            }
            if (t === e) {
              Za = null;
              break;
            }
            if (null !== (n = t.sibling)) {
              (n.return = t.return), (Za = n);
              break;
            }
            Za = t.return;
          }
        }
        function Sc(e) {
          for (; null !== Za; ) {
            var t = Za;
            if (t === e) {
              Za = null;
              break;
            }
            var n = t.sibling;
            if (null !== n) {
              (n.return = t.return), (Za = n);
              break;
            }
            Za = t.return;
          }
        }
        function _c(e) {
          for (; null !== Za; ) {
            var t = Za;
            try {
              switch (t.tag) {
                case 0:
                case 11:
                case 15:
                  var n = t.return;
                  try {
                    rc(4, t);
                  } catch (c) {
                    Al(t, n, c);
                  }
                  break;
                case 1:
                  var r = t.stateNode;
                  if ("function" === typeof r.componentDidMount) {
                    var s = t.return;
                    try {
                      r.componentDidMount();
                    } catch (c) {
                      Al(t, s, c);
                    }
                  }
                  var i = t.return;
                  try {
                    sc(t);
                  } catch (c) {
                    Al(t, i, c);
                  }
                  break;
                case 5:
                  var o = t.return;
                  try {
                    sc(t);
                  } catch (c) {
                    Al(t, o, c);
                  }
              }
            } catch (c) {
              Al(t, t.return, c);
            }
            if (t === e) {
              Za = null;
              break;
            }
            var a = t.sibling;
            if (null !== a) {
              (a.return = t.return), (Za = a);
              break;
            }
            Za = t.return;
          }
        }
        var Ec,
          Ac = Math.ceil,
          Tc = w.ReactCurrentDispatcher,
          Pc = w.ReactCurrentOwner,
          Ic = w.ReactCurrentBatchConfig,
          Cc = 0,
          kc = null,
          Oc = null,
          xc = 0,
          Nc = 0,
          Rc = As(0),
          Dc = 0,
          Mc = null,
          jc = 0,
          Lc = 0,
          Uc = 0,
          Fc = null,
          Bc = null,
          Vc = 0,
          qc = 1 / 0,
          Hc = null,
          Wc = !1,
          Kc = null,
          zc = null,
          Gc = !1,
          Jc = null,
          Qc = 0,
          Yc = 0,
          Xc = null,
          Zc = -1,
          $c = 0;
        function el() {
          return 0 !== (6 & Cc) ? Xe() : -1 !== Zc ? Zc : (Zc = Xe());
        }
        function tl(e) {
          return 0 === (1 & e.mode)
            ? 1
            : 0 !== (2 & Cc) && 0 !== xc
            ? xc & -xc
            : null !== mi.transition
            ? (0 === $c && ($c = mt()), $c)
            : 0 !== (e = bt)
            ? e
            : (e = void 0 === (e = window.event) ? 16 : Yt(e.type));
        }
        function nl(e, t, n, r) {
          if (50 < Yc) throw ((Yc = 0), (Xc = null), Error(i(185)));
          vt(e, n, r),
            (0 !== (2 & Cc) && e === kc) ||
              (e === kc && (0 === (2 & Cc) && (Lc |= n), 4 === Dc && al(e, xc)),
              rl(e, r),
              1 === n &&
                0 === Cc &&
                0 === (1 & t.mode) &&
                ((qc = Xe() + 500), Fs && qs()));
        }
        function rl(e, t) {
          var n = e.callbackNode;
          !(function (e, t) {
            for (
              var n = e.suspendedLanes,
                r = e.pingedLanes,
                s = e.expirationTimes,
                i = e.pendingLanes;
              0 < i;

            ) {
              var o = 31 - ot(i),
                a = 1 << o,
                c = s[o];
              -1 === c
                ? (0 !== (a & n) && 0 === (a & r)) || (s[o] = pt(a, t))
                : c <= t && (e.expiredLanes |= a),
                (i &= ~a);
            }
          })(e, t);
          var r = ht(e, e === kc ? xc : 0);
          if (0 === r)
            null !== n && Je(n),
              (e.callbackNode = null),
              (e.callbackPriority = 0);
          else if (((t = r & -r), e.callbackPriority !== t)) {
            if ((null != n && Je(n), 1 === t))
              0 === e.tag
                ? (function (e) {
                    (Fs = !0), Vs(e);
                  })(cl.bind(null, e))
                : Vs(cl.bind(null, e)),
                os(function () {
                  0 === (6 & Cc) && qs();
                }),
                (n = null);
            else {
              switch (wt(r)) {
                case 1:
                  n = $e;
                  break;
                case 4:
                  n = et;
                  break;
                case 16:
                default:
                  n = tt;
                  break;
                case 536870912:
                  n = rt;
              }
              n = kl(n, sl.bind(null, e));
            }
            (e.callbackPriority = t), (e.callbackNode = n);
          }
        }
        function sl(e, t) {
          if (((Zc = -1), ($c = 0), 0 !== (6 & Cc))) throw Error(i(327));
          var n = e.callbackNode;
          if (_l() && e.callbackNode !== n) return null;
          var r = ht(e, e === kc ? xc : 0);
          if (0 === r) return null;
          if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = gl(e, r);
          else {
            t = r;
            var s = Cc;
            Cc |= 2;
            var o = fl();
            for (
              (kc === e && xc === t) ||
              ((Hc = null), (qc = Xe() + 500), hl(e, t));
              ;

            )
              try {
                yl();
                break;
              } catch (c) {
                pl(e, c);
              }
            Pi(),
              (Tc.current = o),
              (Cc = s),
              null !== Oc ? (t = 0) : ((kc = null), (xc = 0), (t = Dc));
          }
          if (0 !== t) {
            if (
              (2 === t && 0 !== (s = ft(e)) && ((r = s), (t = il(e, s))),
              1 === t)
            )
              throw ((n = Mc), hl(e, 0), al(e, r), rl(e, Xe()), n);
            if (6 === t) al(e, r);
            else {
              if (
                ((s = e.current.alternate),
                0 === (30 & r) &&
                  !(function (e) {
                    for (var t = e; ; ) {
                      if (16384 & t.flags) {
                        var n = t.updateQueue;
                        if (null !== n && null !== (n = n.stores))
                          for (var r = 0; r < n.length; r++) {
                            var s = n[r],
                              i = s.getSnapshot;
                            s = s.value;
                            try {
                              if (!ar(i(), s)) return !1;
                            } catch (a) {
                              return !1;
                            }
                          }
                      }
                      if (((n = t.child), 16384 & t.subtreeFlags && null !== n))
                        (n.return = t), (t = n);
                      else {
                        if (t === e) break;
                        for (; null === t.sibling; ) {
                          if (null === t.return || t.return === e) return !0;
                          t = t.return;
                        }
                        (t.sibling.return = t.return), (t = t.sibling);
                      }
                    }
                    return !0;
                  })(s) &&
                  (2 === (t = gl(e, r)) &&
                    0 !== (o = ft(e)) &&
                    ((r = o), (t = il(e, o))),
                  1 === t))
              )
                throw ((n = Mc), hl(e, 0), al(e, r), rl(e, Xe()), n);
              switch (((e.finishedWork = s), (e.finishedLanes = r), t)) {
                case 0:
                case 1:
                  throw Error(i(345));
                case 2:
                case 5:
                  Sl(e, Bc, Hc);
                  break;
                case 3:
                  if (
                    (al(e, r),
                    (130023424 & r) === r && 10 < (t = Vc + 500 - Xe()))
                  ) {
                    if (0 !== ht(e, 0)) break;
                    if (((s = e.suspendedLanes) & r) !== r) {
                      el(), (e.pingedLanes |= e.suspendedLanes & s);
                      break;
                    }
                    e.timeoutHandle = rs(Sl.bind(null, e, Bc, Hc), t);
                    break;
                  }
                  Sl(e, Bc, Hc);
                  break;
                case 4:
                  if ((al(e, r), (4194240 & r) === r)) break;
                  for (t = e.eventTimes, s = -1; 0 < r; ) {
                    var a = 31 - ot(r);
                    (o = 1 << a), (a = t[a]) > s && (s = a), (r &= ~o);
                  }
                  if (
                    ((r = s),
                    10 <
                      (r =
                        (120 > (r = Xe() - r)
                          ? 120
                          : 480 > r
                          ? 480
                          : 1080 > r
                          ? 1080
                          : 1920 > r
                          ? 1920
                          : 3e3 > r
                          ? 3e3
                          : 4320 > r
                          ? 4320
                          : 1960 * Ac(r / 1960)) - r))
                  ) {
                    e.timeoutHandle = rs(Sl.bind(null, e, Bc, Hc), r);
                    break;
                  }
                  Sl(e, Bc, Hc);
                  break;
                default:
                  throw Error(i(329));
              }
            }
          }
          return rl(e, Xe()), e.callbackNode === n ? sl.bind(null, e) : null;
        }
        function il(e, t) {
          var n = Fc;
          return (
            e.current.memoizedState.isDehydrated && (hl(e, t).flags |= 256),
            2 !== (e = gl(e, t)) && ((t = Bc), (Bc = n), null !== t && ol(t)),
            e
          );
        }
        function ol(e) {
          null === Bc ? (Bc = e) : Bc.push.apply(Bc, e);
        }
        function al(e, t) {
          for (
            t &= ~Uc,
              t &= ~Lc,
              e.suspendedLanes |= t,
              e.pingedLanes &= ~t,
              e = e.expirationTimes;
            0 < t;

          ) {
            var n = 31 - ot(t),
              r = 1 << n;
            (e[n] = -1), (t &= ~r);
          }
        }
        function cl(e) {
          if (0 !== (6 & Cc)) throw Error(i(327));
          _l();
          var t = ht(e, 0);
          if (0 === (1 & t)) return rl(e, Xe()), null;
          var n = gl(e, t);
          if (0 !== e.tag && 2 === n) {
            var r = ft(e);
            0 !== r && ((t = r), (n = il(e, r)));
          }
          if (1 === n) throw ((n = Mc), hl(e, 0), al(e, t), rl(e, Xe()), n);
          if (6 === n) throw Error(i(345));
          return (
            (e.finishedWork = e.current.alternate),
            (e.finishedLanes = t),
            Sl(e, Bc, Hc),
            rl(e, Xe()),
            null
          );
        }
        function ll(e, t) {
          var n = Cc;
          Cc |= 1;
          try {
            return e(t);
          } finally {
            0 === (Cc = n) && ((qc = Xe() + 500), Fs && qs());
          }
        }
        function ul(e) {
          null !== Jc && 0 === Jc.tag && 0 === (6 & Cc) && _l();
          var t = Cc;
          Cc |= 1;
          var n = Ic.transition,
            r = bt;
          try {
            if (((Ic.transition = null), (bt = 1), e)) return e();
          } finally {
            (bt = r), (Ic.transition = n), 0 === (6 & (Cc = t)) && qs();
          }
        }
        function dl() {
          (Nc = Rc.current), Ts(Rc);
        }
        function hl(e, t) {
          (e.finishedWork = null), (e.finishedLanes = 0);
          var n = e.timeoutHandle;
          if ((-1 !== n && ((e.timeoutHandle = -1), ss(n)), null !== Oc))
            for (n = Oc.return; null !== n; ) {
              var r = n;
              switch ((ti(r), r.tag)) {
                case 1:
                  null !== (r = r.type.childContextTypes) &&
                    void 0 !== r &&
                    Rs();
                  break;
                case 3:
                  Yi(), Ts(ks), Ts(Cs), no();
                  break;
                case 5:
                  Zi(r);
                  break;
                case 4:
                  Yi();
                  break;
                case 13:
                case 19:
                  Ts($i);
                  break;
                case 10:
                  Ii(r.type._context);
                  break;
                case 22:
                case 23:
                  dl();
              }
              n = n.return;
            }
          if (
            ((kc = e),
            (Oc = e = Rl(e.current, null)),
            (xc = Nc = t),
            (Dc = 0),
            (Mc = null),
            (Uc = Lc = jc = 0),
            (Bc = Fc = null),
            null !== xi)
          ) {
            for (t = 0; t < xi.length; t++)
              if (null !== (r = (n = xi[t]).interleaved)) {
                n.interleaved = null;
                var s = r.next,
                  i = n.pending;
                if (null !== i) {
                  var o = i.next;
                  (i.next = s), (r.next = o);
                }
                n.pending = r;
              }
            xi = null;
          }
          return e;
        }
        function pl(e, t) {
          for (;;) {
            var n = Oc;
            try {
              if ((Pi(), (ro.current = Zo), lo)) {
                for (var r = oo.memoizedState; null !== r; ) {
                  var s = r.queue;
                  null !== s && (s.pending = null), (r = r.next);
                }
                lo = !1;
              }
              if (
                ((io = 0),
                (co = ao = oo = null),
                (uo = !1),
                (ho = 0),
                (Pc.current = null),
                null === n || null === n.return)
              ) {
                (Dc = 1), (Mc = t), (Oc = null);
                break;
              }
              e: {
                var o = e,
                  a = n.return,
                  c = n,
                  l = t;
                if (
                  ((t = xc),
                  (c.flags |= 32768),
                  null !== l &&
                    "object" === typeof l &&
                    "function" === typeof l.then)
                ) {
                  var u = l,
                    d = c,
                    h = d.tag;
                  if (0 === (1 & d.mode) && (0 === h || 11 === h || 15 === h)) {
                    var p = d.alternate;
                    p
                      ? ((d.updateQueue = p.updateQueue),
                        (d.memoizedState = p.memoizedState),
                        (d.lanes = p.lanes))
                      : ((d.updateQueue = null), (d.memoizedState = null));
                  }
                  var f = ga(a);
                  if (null !== f) {
                    (f.flags &= -257),
                      va(f, a, c, 0, t),
                      1 & f.mode && ma(o, u, t),
                      (l = u);
                    var m = (t = f).updateQueue;
                    if (null === m) {
                      var g = new Set();
                      g.add(l), (t.updateQueue = g);
                    } else m.add(l);
                    break e;
                  }
                  if (0 === (1 & t)) {
                    ma(o, u, t), ml();
                    break e;
                  }
                  l = Error(i(426));
                } else if (si && 1 & c.mode) {
                  var v = ga(a);
                  if (null !== v) {
                    0 === (65536 & v.flags) && (v.flags |= 256),
                      va(v, a, c, 0, t),
                      fi(la(l, c));
                    break e;
                  }
                }
                (o = l = la(l, c)),
                  4 !== Dc && (Dc = 2),
                  null === Fc ? (Fc = [o]) : Fc.push(o),
                  (o = a);
                do {
                  switch (o.tag) {
                    case 3:
                      (o.flags |= 65536),
                        (t &= -t),
                        (o.lanes |= t),
                        Vi(o, pa(0, l, t));
                      break e;
                    case 1:
                      c = l;
                      var y = o.type,
                        b = o.stateNode;
                      if (
                        0 === (128 & o.flags) &&
                        ("function" === typeof y.getDerivedStateFromError ||
                          (null !== b &&
                            "function" === typeof b.componentDidCatch &&
                            (null === zc || !zc.has(b))))
                      ) {
                        (o.flags |= 65536),
                          (t &= -t),
                          (o.lanes |= t),
                          Vi(o, fa(o, c, t));
                        break e;
                      }
                  }
                  o = o.return;
                } while (null !== o);
              }
              wl(n);
            } catch (w) {
              (t = w), Oc === n && null !== n && (Oc = n = n.return);
              continue;
            }
            break;
          }
        }
        function fl() {
          var e = Tc.current;
          return (Tc.current = Zo), null === e ? Zo : e;
        }
        function ml() {
          (0 !== Dc && 3 !== Dc && 2 !== Dc) || (Dc = 4),
            null === kc ||
              (0 === (268435455 & jc) && 0 === (268435455 & Lc)) ||
              al(kc, xc);
        }
        function gl(e, t) {
          var n = Cc;
          Cc |= 2;
          var r = fl();
          for ((kc === e && xc === t) || ((Hc = null), hl(e, t)); ; )
            try {
              vl();
              break;
            } catch (s) {
              pl(e, s);
            }
          if ((Pi(), (Cc = n), (Tc.current = r), null !== Oc))
            throw Error(i(261));
          return (kc = null), (xc = 0), Dc;
        }
        function vl() {
          for (; null !== Oc; ) bl(Oc);
        }
        function yl() {
          for (; null !== Oc && !Qe(); ) bl(Oc);
        }
        function bl(e) {
          var t = Ec(e.alternate, e, Nc);
          (e.memoizedProps = e.pendingProps),
            null === t ? wl(e) : (Oc = t),
            (Pc.current = null);
        }
        function wl(e) {
          var t = e;
          do {
            var n = t.alternate;
            if (((e = t.return), 0 === (32768 & t.flags))) {
              if (null !== (n = Ga(n, t, Nc))) return void (Oc = n);
            } else {
              if (null !== (n = Ja(n, t)))
                return (n.flags &= 32767), void (Oc = n);
              if (null === e) return (Dc = 6), void (Oc = null);
              (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null);
            }
            if (null !== (t = t.sibling)) return void (Oc = t);
            Oc = t = e;
          } while (null !== t);
          0 === Dc && (Dc = 5);
        }
        function Sl(e, t, n) {
          var r = bt,
            s = Ic.transition;
          try {
            (Ic.transition = null),
              (bt = 1),
              (function (e, t, n, r) {
                do {
                  _l();
                } while (null !== Jc);
                if (0 !== (6 & Cc)) throw Error(i(327));
                n = e.finishedWork;
                var s = e.finishedLanes;
                if (null === n) return null;
                if (
                  ((e.finishedWork = null),
                  (e.finishedLanes = 0),
                  n === e.current)
                )
                  throw Error(i(177));
                (e.callbackNode = null), (e.callbackPriority = 0);
                var o = n.lanes | n.childLanes;
                if (
                  ((function (e, t) {
                    var n = e.pendingLanes & ~t;
                    (e.pendingLanes = t),
                      (e.suspendedLanes = 0),
                      (e.pingedLanes = 0),
                      (e.expiredLanes &= t),
                      (e.mutableReadLanes &= t),
                      (e.entangledLanes &= t),
                      (t = e.entanglements);
                    var r = e.eventTimes;
                    for (e = e.expirationTimes; 0 < n; ) {
                      var s = 31 - ot(n),
                        i = 1 << s;
                      (t[s] = 0), (r[s] = -1), (e[s] = -1), (n &= ~i);
                    }
                  })(e, o),
                  e === kc && ((Oc = kc = null), (xc = 0)),
                  (0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags)) ||
                    Gc ||
                    ((Gc = !0),
                    kl(tt, function () {
                      return _l(), null;
                    })),
                  (o = 0 !== (15990 & n.flags)),
                  0 !== (15990 & n.subtreeFlags) || o)
                ) {
                  (o = Ic.transition), (Ic.transition = null);
                  var a = bt;
                  bt = 1;
                  var c = Cc;
                  (Cc |= 4),
                    (Pc.current = null),
                    (function (e, t) {
                      if (((es = Wt), pr((e = hr())))) {
                        if ("selectionStart" in e)
                          var n = {
                            start: e.selectionStart,
                            end: e.selectionEnd,
                          };
                        else
                          e: {
                            var r =
                              (n =
                                ((n = e.ownerDocument) && n.defaultView) ||
                                window).getSelection && n.getSelection();
                            if (r && 0 !== r.rangeCount) {
                              n = r.anchorNode;
                              var s = r.anchorOffset,
                                o = r.focusNode;
                              r = r.focusOffset;
                              try {
                                n.nodeType, o.nodeType;
                              } catch (S) {
                                n = null;
                                break e;
                              }
                              var a = 0,
                                c = -1,
                                l = -1,
                                u = 0,
                                d = 0,
                                h = e,
                                p = null;
                              t: for (;;) {
                                for (
                                  var f;
                                  h !== n ||
                                    (0 !== s && 3 !== h.nodeType) ||
                                    (c = a + s),
                                    h !== o ||
                                      (0 !== r && 3 !== h.nodeType) ||
                                      (l = a + r),
                                    3 === h.nodeType &&
                                      (a += h.nodeValue.length),
                                    null !== (f = h.firstChild);

                                )
                                  (p = h), (h = f);
                                for (;;) {
                                  if (h === e) break t;
                                  if (
                                    (p === n && ++u === s && (c = a),
                                    p === o && ++d === r && (l = a),
                                    null !== (f = h.nextSibling))
                                  )
                                    break;
                                  p = (h = p).parentNode;
                                }
                                h = f;
                              }
                              n =
                                -1 === c || -1 === l
                                  ? null
                                  : { start: c, end: l };
                            } else n = null;
                          }
                        n = n || { start: 0, end: 0 };
                      } else n = null;
                      for (
                        ts = { focusedElem: e, selectionRange: n },
                          Wt = !1,
                          Za = t;
                        null !== Za;

                      )
                        if (
                          ((e = (t = Za).child),
                          0 !== (1028 & t.subtreeFlags) && null !== e)
                        )
                          (e.return = t), (Za = e);
                        else
                          for (; null !== Za; ) {
                            t = Za;
                            try {
                              var m = t.alternate;
                              if (0 !== (1024 & t.flags))
                                switch (t.tag) {
                                  case 0:
                                  case 11:
                                  case 15:
                                  case 5:
                                  case 6:
                                  case 4:
                                  case 17:
                                    break;
                                  case 1:
                                    if (null !== m) {
                                      var g = m.memoizedProps,
                                        v = m.memoizedState,
                                        y = t.stateNode,
                                        b = y.getSnapshotBeforeUpdate(
                                          t.elementType === t.type
                                            ? g
                                            : na(t.type, g),
                                          v
                                        );
                                      y.__reactInternalSnapshotBeforeUpdate = b;
                                    }
                                    break;
                                  case 3:
                                    var w = t.stateNode.containerInfo;
                                    1 === w.nodeType
                                      ? (w.textContent = "")
                                      : 9 === w.nodeType &&
                                        w.documentElement &&
                                        w.removeChild(w.documentElement);
                                    break;
                                  default:
                                    throw Error(i(163));
                                }
                            } catch (S) {
                              Al(t, t.return, S);
                            }
                            if (null !== (e = t.sibling)) {
                              (e.return = t.return), (Za = e);
                              break;
                            }
                            Za = t.return;
                          }
                      (m = tc), (tc = !1);
                    })(e, n),
                    gc(n, e),
                    fr(ts),
                    (Wt = !!es),
                    (ts = es = null),
                    (e.current = n),
                    yc(n, e, s),
                    Ye(),
                    (Cc = c),
                    (bt = a),
                    (Ic.transition = o);
                } else e.current = n;
                if (
                  (Gc && ((Gc = !1), (Jc = e), (Qc = s)),
                  (o = e.pendingLanes),
                  0 === o && (zc = null),
                  (function (e) {
                    if (it && "function" === typeof it.onCommitFiberRoot)
                      try {
                        it.onCommitFiberRoot(
                          st,
                          e,
                          void 0,
                          128 === (128 & e.current.flags)
                        );
                      } catch (t) {}
                  })(n.stateNode),
                  rl(e, Xe()),
                  null !== t)
                )
                  for (r = e.onRecoverableError, n = 0; n < t.length; n++)
                    (s = t[n]),
                      r(s.value, { componentStack: s.stack, digest: s.digest });
                if (Wc) throw ((Wc = !1), (e = Kc), (Kc = null), e);
                0 !== (1 & Qc) && 0 !== e.tag && _l(),
                  (o = e.pendingLanes),
                  0 !== (1 & o)
                    ? e === Xc
                      ? Yc++
                      : ((Yc = 0), (Xc = e))
                    : (Yc = 0),
                  qs();
              })(e, t, n, r);
          } finally {
            (Ic.transition = s), (bt = r);
          }
          return null;
        }
        function _l() {
          if (null !== Jc) {
            var e = wt(Qc),
              t = Ic.transition,
              n = bt;
            try {
              if (((Ic.transition = null), (bt = 16 > e ? 16 : e), null === Jc))
                var r = !1;
              else {
                if (((e = Jc), (Jc = null), (Qc = 0), 0 !== (6 & Cc)))
                  throw Error(i(331));
                var s = Cc;
                for (Cc |= 4, Za = e.current; null !== Za; ) {
                  var o = Za,
                    a = o.child;
                  if (0 !== (16 & Za.flags)) {
                    var c = o.deletions;
                    if (null !== c) {
                      for (var l = 0; l < c.length; l++) {
                        var u = c[l];
                        for (Za = u; null !== Za; ) {
                          var d = Za;
                          switch (d.tag) {
                            case 0:
                            case 11:
                            case 15:
                              nc(8, d, o);
                          }
                          var h = d.child;
                          if (null !== h) (h.return = d), (Za = h);
                          else
                            for (; null !== Za; ) {
                              var p = (d = Za).sibling,
                                f = d.return;
                              if ((ic(d), d === u)) {
                                Za = null;
                                break;
                              }
                              if (null !== p) {
                                (p.return = f), (Za = p);
                                break;
                              }
                              Za = f;
                            }
                        }
                      }
                      var m = o.alternate;
                      if (null !== m) {
                        var g = m.child;
                        if (null !== g) {
                          m.child = null;
                          do {
                            var v = g.sibling;
                            (g.sibling = null), (g = v);
                          } while (null !== g);
                        }
                      }
                      Za = o;
                    }
                  }
                  if (0 !== (2064 & o.subtreeFlags) && null !== a)
                    (a.return = o), (Za = a);
                  else
                    e: for (; null !== Za; ) {
                      if (0 !== (2048 & (o = Za).flags))
                        switch (o.tag) {
                          case 0:
                          case 11:
                          case 15:
                            nc(9, o, o.return);
                        }
                      var y = o.sibling;
                      if (null !== y) {
                        (y.return = o.return), (Za = y);
                        break e;
                      }
                      Za = o.return;
                    }
                }
                var b = e.current;
                for (Za = b; null !== Za; ) {
                  var w = (a = Za).child;
                  if (0 !== (2064 & a.subtreeFlags) && null !== w)
                    (w.return = a), (Za = w);
                  else
                    e: for (a = b; null !== Za; ) {
                      if (0 !== (2048 & (c = Za).flags))
                        try {
                          switch (c.tag) {
                            case 0:
                            case 11:
                            case 15:
                              rc(9, c);
                          }
                        } catch (_) {
                          Al(c, c.return, _);
                        }
                      if (c === a) {
                        Za = null;
                        break e;
                      }
                      var S = c.sibling;
                      if (null !== S) {
                        (S.return = c.return), (Za = S);
                        break e;
                      }
                      Za = c.return;
                    }
                }
                if (
                  ((Cc = s),
                  qs(),
                  it && "function" === typeof it.onPostCommitFiberRoot)
                )
                  try {
                    it.onPostCommitFiberRoot(st, e);
                  } catch (_) {}
                r = !0;
              }
              return r;
            } finally {
              (bt = n), (Ic.transition = t);
            }
          }
          return !1;
        }
        function El(e, t, n) {
          (e = Fi(e, (t = pa(0, (t = la(n, t)), 1)), 1)),
            (t = el()),
            null !== e && (vt(e, 1, t), rl(e, t));
        }
        function Al(e, t, n) {
          if (3 === e.tag) El(e, e, n);
          else
            for (; null !== t; ) {
              if (3 === t.tag) {
                El(t, e, n);
                break;
              }
              if (1 === t.tag) {
                var r = t.stateNode;
                if (
                  "function" === typeof t.type.getDerivedStateFromError ||
                  ("function" === typeof r.componentDidCatch &&
                    (null === zc || !zc.has(r)))
                ) {
                  (t = Fi(t, (e = fa(t, (e = la(n, e)), 1)), 1)),
                    (e = el()),
                    null !== t && (vt(t, 1, e), rl(t, e));
                  break;
                }
              }
              t = t.return;
            }
        }
        function Tl(e, t, n) {
          var r = e.pingCache;
          null !== r && r.delete(t),
            (t = el()),
            (e.pingedLanes |= e.suspendedLanes & n),
            kc === e &&
              (xc & n) === n &&
              (4 === Dc ||
              (3 === Dc && (130023424 & xc) === xc && 500 > Xe() - Vc)
                ? hl(e, 0)
                : (Uc |= n)),
            rl(e, t);
        }
        function Pl(e, t) {
          0 === t &&
            (0 === (1 & e.mode)
              ? (t = 1)
              : ((t = ut), 0 === (130023424 & (ut <<= 1)) && (ut = 4194304)));
          var n = el();
          null !== (e = Di(e, t)) && (vt(e, t, n), rl(e, n));
        }
        function Il(e) {
          var t = e.memoizedState,
            n = 0;
          null !== t && (n = t.retryLane), Pl(e, n);
        }
        function Cl(e, t) {
          var n = 0;
          switch (e.tag) {
            case 13:
              var r = e.stateNode,
                s = e.memoizedState;
              null !== s && (n = s.retryLane);
              break;
            case 19:
              r = e.stateNode;
              break;
            default:
              throw Error(i(314));
          }
          null !== r && r.delete(t), Pl(e, n);
        }
        function kl(e, t) {
          return Ge(e, t);
        }
        function Ol(e, t, n, r) {
          (this.tag = e),
            (this.key = n),
            (this.sibling =
              this.child =
              this.return =
              this.stateNode =
              this.type =
              this.elementType =
                null),
            (this.index = 0),
            (this.ref = null),
            (this.pendingProps = t),
            (this.dependencies =
              this.memoizedState =
              this.updateQueue =
              this.memoizedProps =
                null),
            (this.mode = r),
            (this.subtreeFlags = this.flags = 0),
            (this.deletions = null),
            (this.childLanes = this.lanes = 0),
            (this.alternate = null);
        }
        function xl(e, t, n, r) {
          return new Ol(e, t, n, r);
        }
        function Nl(e) {
          return !(!(e = e.prototype) || !e.isReactComponent);
        }
        function Rl(e, t) {
          var n = e.alternate;
          return (
            null === n
              ? (((n = xl(e.tag, t, e.key, e.mode)).elementType =
                  e.elementType),
                (n.type = e.type),
                (n.stateNode = e.stateNode),
                (n.alternate = e),
                (e.alternate = n))
              : ((n.pendingProps = t),
                (n.type = e.type),
                (n.flags = 0),
                (n.subtreeFlags = 0),
                (n.deletions = null)),
            (n.flags = 14680064 & e.flags),
            (n.childLanes = e.childLanes),
            (n.lanes = e.lanes),
            (n.child = e.child),
            (n.memoizedProps = e.memoizedProps),
            (n.memoizedState = e.memoizedState),
            (n.updateQueue = e.updateQueue),
            (t = e.dependencies),
            (n.dependencies =
              null === t
                ? null
                : { lanes: t.lanes, firstContext: t.firstContext }),
            (n.sibling = e.sibling),
            (n.index = e.index),
            (n.ref = e.ref),
            n
          );
        }
        function Dl(e, t, n, r, s, o) {
          var a = 2;
          if (((r = e), "function" === typeof e)) Nl(e) && (a = 1);
          else if ("string" === typeof e) a = 5;
          else
            e: switch (e) {
              case E:
                return Ml(n.children, s, o, t);
              case A:
                (a = 8), (s |= 8);
                break;
              case T:
                return (
                  ((e = xl(12, n, t, 2 | s)).elementType = T), (e.lanes = o), e
                );
              case k:
                return (
                  ((e = xl(13, n, t, s)).elementType = k), (e.lanes = o), e
                );
              case O:
                return (
                  ((e = xl(19, n, t, s)).elementType = O), (e.lanes = o), e
                );
              case R:
                return jl(n, s, o, t);
              default:
                if ("object" === typeof e && null !== e)
                  switch (e.$$typeof) {
                    case P:
                      a = 10;
                      break e;
                    case I:
                      a = 9;
                      break e;
                    case C:
                      a = 11;
                      break e;
                    case x:
                      a = 14;
                      break e;
                    case N:
                      (a = 16), (r = null);
                      break e;
                  }
                throw Error(i(130, null == e ? e : typeof e, ""));
            }
          return (
            ((t = xl(a, n, t, s)).elementType = e),
            (t.type = r),
            (t.lanes = o),
            t
          );
        }
        function Ml(e, t, n, r) {
          return ((e = xl(7, e, r, t)).lanes = n), e;
        }
        function jl(e, t, n, r) {
          return (
            ((e = xl(22, e, r, t)).elementType = R),
            (e.lanes = n),
            (e.stateNode = { isHidden: !1 }),
            e
          );
        }
        function Ll(e, t, n) {
          return ((e = xl(6, e, null, t)).lanes = n), e;
        }
        function Ul(e, t, n) {
          return (
            ((t = xl(
              4,
              null !== e.children ? e.children : [],
              e.key,
              t
            )).lanes = n),
            (t.stateNode = {
              containerInfo: e.containerInfo,
              pendingChildren: null,
              implementation: e.implementation,
            }),
            t
          );
        }
        function Fl(e, t, n, r, s) {
          (this.tag = t),
            (this.containerInfo = e),
            (this.finishedWork =
              this.pingCache =
              this.current =
              this.pendingChildren =
                null),
            (this.timeoutHandle = -1),
            (this.callbackNode = this.pendingContext = this.context = null),
            (this.callbackPriority = 0),
            (this.eventTimes = gt(0)),
            (this.expirationTimes = gt(-1)),
            (this.entangledLanes =
              this.finishedLanes =
              this.mutableReadLanes =
              this.expiredLanes =
              this.pingedLanes =
              this.suspendedLanes =
              this.pendingLanes =
                0),
            (this.entanglements = gt(0)),
            (this.identifierPrefix = r),
            (this.onRecoverableError = s),
            (this.mutableSourceEagerHydrationData = null);
        }
        function Bl(e, t, n, r, s, i, o, a, c) {
          return (
            (e = new Fl(e, t, n, a, c)),
            1 === t ? ((t = 1), !0 === i && (t |= 8)) : (t = 0),
            (i = xl(3, null, null, t)),
            (e.current = i),
            (i.stateNode = e),
            (i.memoizedState = {
              element: r,
              isDehydrated: n,
              cache: null,
              transitions: null,
              pendingSuspenseBoundaries: null,
            }),
            ji(i),
            e
          );
        }
        function Vl(e) {
          if (!e) return Is;
          e: {
            if (qe((e = e._reactInternals)) !== e || 1 !== e.tag)
              throw Error(i(170));
            var t = e;
            do {
              switch (t.tag) {
                case 3:
                  t = t.stateNode.context;
                  break e;
                case 1:
                  if (Ns(t.type)) {
                    t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e;
                  }
              }
              t = t.return;
            } while (null !== t);
            throw Error(i(171));
          }
          if (1 === e.tag) {
            var n = e.type;
            if (Ns(n)) return Ms(e, n, t);
          }
          return t;
        }
        function ql(e, t, n, r, s, i, o, a, c) {
          return (
            ((e = Bl(n, r, !0, e, 0, i, 0, a, c)).context = Vl(null)),
            (n = e.current),
            ((i = Ui((r = el()), (s = tl(n)))).callback =
              void 0 !== t && null !== t ? t : null),
            Fi(n, i, s),
            (e.current.lanes = s),
            vt(e, s, r),
            rl(e, r),
            e
          );
        }
        function Hl(e, t, n, r) {
          var s = t.current,
            i = el(),
            o = tl(s);
          return (
            (n = Vl(n)),
            null === t.context ? (t.context = n) : (t.pendingContext = n),
            ((t = Ui(i, o)).payload = { element: e }),
            null !== (r = void 0 === r ? null : r) && (t.callback = r),
            null !== (e = Fi(s, t, o)) && (nl(e, s, o, i), Bi(e, s, o)),
            o
          );
        }
        function Wl(e) {
          return (e = e.current).child
            ? (e.child.tag, e.child.stateNode)
            : null;
        }
        function Kl(e, t) {
          if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
            var n = e.retryLane;
            e.retryLane = 0 !== n && n < t ? n : t;
          }
        }
        function zl(e, t) {
          Kl(e, t), (e = e.alternate) && Kl(e, t);
        }
        Ec = function (e, t, n) {
          if (null !== e)
            if (e.memoizedProps !== t.pendingProps || ks.current) ba = !0;
            else {
              if (0 === (e.lanes & n) && 0 === (128 & t.flags))
                return (
                  (ba = !1),
                  (function (e, t, n) {
                    switch (t.tag) {
                      case 3:
                        ka(t), pi();
                        break;
                      case 5:
                        Xi(t);
                        break;
                      case 1:
                        Ns(t.type) && js(t);
                        break;
                      case 4:
                        Qi(t, t.stateNode.containerInfo);
                        break;
                      case 10:
                        var r = t.type._context,
                          s = t.memoizedProps.value;
                        Ps(_i, r._currentValue), (r._currentValue = s);
                        break;
                      case 13:
                        if (null !== (r = t.memoizedState))
                          return null !== r.dehydrated
                            ? (Ps($i, 1 & $i.current), (t.flags |= 128), null)
                            : 0 !== (n & t.child.childLanes)
                            ? La(e, t, n)
                            : (Ps($i, 1 & $i.current),
                              null !== (e = Wa(e, t, n)) ? e.sibling : null);
                        Ps($i, 1 & $i.current);
                        break;
                      case 19:
                        if (
                          ((r = 0 !== (n & t.childLanes)),
                          0 !== (128 & e.flags))
                        ) {
                          if (r) return qa(e, t, n);
                          t.flags |= 128;
                        }
                        if (
                          (null !== (s = t.memoizedState) &&
                            ((s.rendering = null),
                            (s.tail = null),
                            (s.lastEffect = null)),
                          Ps($i, $i.current),
                          r)
                        )
                          break;
                        return null;
                      case 22:
                      case 23:
                        return (t.lanes = 0), Aa(e, t, n);
                    }
                    return Wa(e, t, n);
                  })(e, t, n)
                );
              ba = 0 !== (131072 & e.flags);
            }
          else (ba = !1), si && 0 !== (1048576 & t.flags) && $s(t, zs, t.index);
          switch (((t.lanes = 0), t.tag)) {
            case 2:
              var r = t.type;
              Ha(e, t), (e = t.pendingProps);
              var s = xs(t, Cs.current);
              ki(t, n), (s = go(null, t, r, e, s, n));
              var o = vo();
              return (
                (t.flags |= 1),
                "object" === typeof s &&
                null !== s &&
                "function" === typeof s.render &&
                void 0 === s.$$typeof
                  ? ((t.tag = 1),
                    (t.memoizedState = null),
                    (t.updateQueue = null),
                    Ns(r) ? ((o = !0), js(t)) : (o = !1),
                    (t.memoizedState =
                      null !== s.state && void 0 !== s.state ? s.state : null),
                    ji(t),
                    (s.updater = sa),
                    (t.stateNode = s),
                    (s._reactInternals = t),
                    ca(t, r, e, n),
                    (t = Ca(null, t, r, !0, o, n)))
                  : ((t.tag = 0),
                    si && o && ei(t),
                    wa(null, t, s, n),
                    (t = t.child)),
                t
              );
            case 16:
              r = t.elementType;
              e: {
                switch (
                  (Ha(e, t),
                  (e = t.pendingProps),
                  (r = (s = r._init)(r._payload)),
                  (t.type = r),
                  (s = t.tag =
                    (function (e) {
                      if ("function" === typeof e) return Nl(e) ? 1 : 0;
                      if (void 0 !== e && null !== e) {
                        if ((e = e.$$typeof) === C) return 11;
                        if (e === x) return 14;
                      }
                      return 2;
                    })(r)),
                  (e = na(r, e)),
                  s)
                ) {
                  case 0:
                    t = Pa(null, t, r, e, n);
                    break e;
                  case 1:
                    t = Ia(null, t, r, e, n);
                    break e;
                  case 11:
                    t = Sa(null, t, r, e, n);
                    break e;
                  case 14:
                    t = _a(null, t, r, na(r.type, e), n);
                    break e;
                }
                throw Error(i(306, r, ""));
              }
              return t;
            case 0:
              return (
                (r = t.type),
                (s = t.pendingProps),
                Pa(e, t, r, (s = t.elementType === r ? s : na(r, s)), n)
              );
            case 1:
              return (
                (r = t.type),
                (s = t.pendingProps),
                Ia(e, t, r, (s = t.elementType === r ? s : na(r, s)), n)
              );
            case 3:
              e: {
                if ((ka(t), null === e)) throw Error(i(387));
                (r = t.pendingProps),
                  (s = (o = t.memoizedState).element),
                  Li(e, t),
                  qi(t, r, null, n);
                var a = t.memoizedState;
                if (((r = a.element), o.isDehydrated)) {
                  if (
                    ((o = {
                      element: r,
                      isDehydrated: !1,
                      cache: a.cache,
                      pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                      transitions: a.transitions,
                    }),
                    (t.updateQueue.baseState = o),
                    (t.memoizedState = o),
                    256 & t.flags)
                  ) {
                    t = Oa(e, t, r, n, (s = la(Error(i(423)), t)));
                    break e;
                  }
                  if (r !== s) {
                    t = Oa(e, t, r, n, (s = la(Error(i(424)), t)));
                    break e;
                  }
                  for (
                    ri = ls(t.stateNode.containerInfo.firstChild),
                      ni = t,
                      si = !0,
                      ii = null,
                      n = Si(t, null, r, n),
                      t.child = n;
                    n;

                  )
                    (n.flags = (-3 & n.flags) | 4096), (n = n.sibling);
                } else {
                  if ((pi(), r === s)) {
                    t = Wa(e, t, n);
                    break e;
                  }
                  wa(e, t, r, n);
                }
                t = t.child;
              }
              return t;
            case 5:
              return (
                Xi(t),
                null === e && li(t),
                (r = t.type),
                (s = t.pendingProps),
                (o = null !== e ? e.memoizedProps : null),
                (a = s.children),
                ns(r, s)
                  ? (a = null)
                  : null !== o && ns(r, o) && (t.flags |= 32),
                Ta(e, t),
                wa(e, t, a, n),
                t.child
              );
            case 6:
              return null === e && li(t), null;
            case 13:
              return La(e, t, n);
            case 4:
              return (
                Qi(t, t.stateNode.containerInfo),
                (r = t.pendingProps),
                null === e ? (t.child = wi(t, null, r, n)) : wa(e, t, r, n),
                t.child
              );
            case 11:
              return (
                (r = t.type),
                (s = t.pendingProps),
                Sa(e, t, r, (s = t.elementType === r ? s : na(r, s)), n)
              );
            case 7:
              return wa(e, t, t.pendingProps, n), t.child;
            case 8:
            case 12:
              return wa(e, t, t.pendingProps.children, n), t.child;
            case 10:
              e: {
                if (
                  ((r = t.type._context),
                  (s = t.pendingProps),
                  (o = t.memoizedProps),
                  (a = s.value),
                  Ps(_i, r._currentValue),
                  (r._currentValue = a),
                  null !== o)
                )
                  if (ar(o.value, a)) {
                    if (o.children === s.children && !ks.current) {
                      t = Wa(e, t, n);
                      break e;
                    }
                  } else
                    for (
                      null !== (o = t.child) && (o.return = t);
                      null !== o;

                    ) {
                      var c = o.dependencies;
                      if (null !== c) {
                        a = o.child;
                        for (var l = c.firstContext; null !== l; ) {
                          if (l.context === r) {
                            if (1 === o.tag) {
                              (l = Ui(-1, n & -n)).tag = 2;
                              var u = o.updateQueue;
                              if (null !== u) {
                                var d = (u = u.shared).pending;
                                null === d
                                  ? (l.next = l)
                                  : ((l.next = d.next), (d.next = l)),
                                  (u.pending = l);
                              }
                            }
                            (o.lanes |= n),
                              null !== (l = o.alternate) && (l.lanes |= n),
                              Ci(o.return, n, t),
                              (c.lanes |= n);
                            break;
                          }
                          l = l.next;
                        }
                      } else if (10 === o.tag)
                        a = o.type === t.type ? null : o.child;
                      else if (18 === o.tag) {
                        if (null === (a = o.return)) throw Error(i(341));
                        (a.lanes |= n),
                          null !== (c = a.alternate) && (c.lanes |= n),
                          Ci(a, n, t),
                          (a = o.sibling);
                      } else a = o.child;
                      if (null !== a) a.return = o;
                      else
                        for (a = o; null !== a; ) {
                          if (a === t) {
                            a = null;
                            break;
                          }
                          if (null !== (o = a.sibling)) {
                            (o.return = a.return), (a = o);
                            break;
                          }
                          a = a.return;
                        }
                      o = a;
                    }
                wa(e, t, s.children, n), (t = t.child);
              }
              return t;
            case 9:
              return (
                (s = t.type),
                (r = t.pendingProps.children),
                ki(t, n),
                (r = r((s = Oi(s)))),
                (t.flags |= 1),
                wa(e, t, r, n),
                t.child
              );
            case 14:
              return (
                (s = na((r = t.type), t.pendingProps)),
                _a(e, t, r, (s = na(r.type, s)), n)
              );
            case 15:
              return Ea(e, t, t.type, t.pendingProps, n);
            case 17:
              return (
                (r = t.type),
                (s = t.pendingProps),
                (s = t.elementType === r ? s : na(r, s)),
                Ha(e, t),
                (t.tag = 1),
                Ns(r) ? ((e = !0), js(t)) : (e = !1),
                ki(t, n),
                oa(t, r, s),
                ca(t, r, s, n),
                Ca(null, t, r, !0, e, n)
              );
            case 19:
              return qa(e, t, n);
            case 22:
              return Aa(e, t, n);
          }
          throw Error(i(156, t.tag));
        };
        var Gl =
          "function" === typeof reportError
            ? reportError
            : function (e) {
                console.error(e);
              };
        function Jl(e) {
          this._internalRoot = e;
        }
        function Ql(e) {
          this._internalRoot = e;
        }
        function Yl(e) {
          return !(
            !e ||
            (1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
          );
        }
        function Xl(e) {
          return !(
            !e ||
            (1 !== e.nodeType &&
              9 !== e.nodeType &&
              11 !== e.nodeType &&
              (8 !== e.nodeType ||
                " react-mount-point-unstable " !== e.nodeValue))
          );
        }
        function Zl() {}
        function $l(e, t, n, r, s) {
          var i = n._reactRootContainer;
          if (i) {
            var o = i;
            if ("function" === typeof s) {
              var a = s;
              s = function () {
                var e = Wl(o);
                a.call(e);
              };
            }
            Hl(t, o, e, s);
          } else
            o = (function (e, t, n, r, s) {
              if (s) {
                if ("function" === typeof r) {
                  var i = r;
                  r = function () {
                    var e = Wl(o);
                    i.call(e);
                  };
                }
                var o = ql(t, r, e, 0, null, !1, 0, "", Zl);
                return (
                  (e._reactRootContainer = o),
                  (e[fs] = o.current),
                  qr(8 === e.nodeType ? e.parentNode : e),
                  ul(),
                  o
                );
              }
              for (; (s = e.lastChild); ) e.removeChild(s);
              if ("function" === typeof r) {
                var a = r;
                r = function () {
                  var e = Wl(c);
                  a.call(e);
                };
              }
              var c = Bl(e, 0, !1, null, 0, !1, 0, "", Zl);
              return (
                (e._reactRootContainer = c),
                (e[fs] = c.current),
                qr(8 === e.nodeType ? e.parentNode : e),
                ul(function () {
                  Hl(t, c, n, r);
                }),
                c
              );
            })(n, t, e, s, r);
          return Wl(o);
        }
        (Ql.prototype.render = Jl.prototype.render =
          function (e) {
            var t = this._internalRoot;
            if (null === t) throw Error(i(409));
            Hl(e, t, null, null);
          }),
          (Ql.prototype.unmount = Jl.prototype.unmount =
            function () {
              var e = this._internalRoot;
              if (null !== e) {
                this._internalRoot = null;
                var t = e.containerInfo;
                ul(function () {
                  Hl(null, e, null, null);
                }),
                  (t[fs] = null);
              }
            }),
          (Ql.prototype.unstable_scheduleHydration = function (e) {
            if (e) {
              var t = At();
              e = { blockedOn: null, target: e, priority: t };
              for (
                var n = 0;
                n < Rt.length && 0 !== t && t < Rt[n].priority;
                n++
              );
              Rt.splice(n, 0, e), 0 === n && Lt(e);
            }
          }),
          (St = function (e) {
            switch (e.tag) {
              case 3:
                var t = e.stateNode;
                if (t.current.memoizedState.isDehydrated) {
                  var n = dt(t.pendingLanes);
                  0 !== n &&
                    (yt(t, 1 | n),
                    rl(t, Xe()),
                    0 === (6 & Cc) && ((qc = Xe() + 500), qs()));
                }
                break;
              case 13:
                ul(function () {
                  var t = Di(e, 1);
                  if (null !== t) {
                    var n = el();
                    nl(t, e, 1, n);
                  }
                }),
                  zl(e, 1);
            }
          }),
          (_t = function (e) {
            if (13 === e.tag) {
              var t = Di(e, 134217728);
              if (null !== t) nl(t, e, 134217728, el());
              zl(e, 134217728);
            }
          }),
          (Et = function (e) {
            if (13 === e.tag) {
              var t = tl(e),
                n = Di(e, t);
              if (null !== n) nl(n, e, t, el());
              zl(e, t);
            }
          }),
          (At = function () {
            return bt;
          }),
          (Tt = function (e, t) {
            var n = bt;
            try {
              return (bt = e), t();
            } finally {
              bt = n;
            }
          }),
          (_e = function (e, t, n) {
            switch (t) {
              case "input":
                if ((Z(e, n), (t = n.name), "radio" === n.type && null != t)) {
                  for (n = e; n.parentNode; ) n = n.parentNode;
                  for (
                    n = n.querySelectorAll(
                      "input[name=" + JSON.stringify("" + t) + '][type="radio"]'
                    ),
                      t = 0;
                    t < n.length;
                    t++
                  ) {
                    var r = n[t];
                    if (r !== e && r.form === e.form) {
                      var s = Ss(r);
                      if (!s) throw Error(i(90));
                      G(r), Z(r, s);
                    }
                  }
                }
                break;
              case "textarea":
                ie(e, n);
                break;
              case "select":
                null != (t = n.value) && ne(e, !!n.multiple, t, !1);
            }
          }),
          (Ce = ll),
          (ke = ul);
        var eu = {
            usingClientEntryPoint: !1,
            Events: [bs, ws, Ss, Pe, Ie, ll],
          },
          tu = {
            findFiberByHostInstance: ys,
            bundleType: 0,
            version: "18.3.1",
            rendererPackageName: "react-dom",
          },
          nu = {
            bundleType: tu.bundleType,
            version: tu.version,
            rendererPackageName: tu.rendererPackageName,
            rendererConfig: tu.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: w.ReactCurrentDispatcher,
            findHostInstanceByFiber: function (e) {
              return null === (e = Ke(e)) ? null : e.stateNode;
            },
            findFiberByHostInstance:
              tu.findFiberByHostInstance ||
              function () {
                return null;
              },
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
          };
        if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
          var ru = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (!ru.isDisabled && ru.supportsFiber)
            try {
              (st = ru.inject(nu)), (it = ru);
            } catch (ue) {}
        }
        (t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = eu),
          (t.createPortal = function (e, t) {
            var n =
              2 < arguments.length && void 0 !== arguments[2]
                ? arguments[2]
                : null;
            if (!Yl(t)) throw Error(i(200));
            return (function (e, t, n) {
              var r =
                3 < arguments.length && void 0 !== arguments[3]
                  ? arguments[3]
                  : null;
              return {
                $$typeof: _,
                key: null == r ? null : "" + r,
                children: e,
                containerInfo: t,
                implementation: n,
              };
            })(e, t, null, n);
          }),
          (t.createRoot = function (e, t) {
            if (!Yl(e)) throw Error(i(299));
            var n = !1,
              r = "",
              s = Gl;
            return (
              null !== t &&
                void 0 !== t &&
                (!0 === t.unstable_strictMode && (n = !0),
                void 0 !== t.identifierPrefix && (r = t.identifierPrefix),
                void 0 !== t.onRecoverableError && (s = t.onRecoverableError)),
              (t = Bl(e, 1, !1, null, 0, n, 0, r, s)),
              (e[fs] = t.current),
              qr(8 === e.nodeType ? e.parentNode : e),
              new Jl(t)
            );
          }),
          (t.findDOMNode = function (e) {
            if (null == e) return null;
            if (1 === e.nodeType) return e;
            var t = e._reactInternals;
            if (void 0 === t) {
              if ("function" === typeof e.render) throw Error(i(188));
              throw ((e = Object.keys(e).join(",")), Error(i(268, e)));
            }
            return (e = null === (e = Ke(t)) ? null : e.stateNode);
          }),
          (t.flushSync = function (e) {
            return ul(e);
          }),
          (t.hydrate = function (e, t, n) {
            if (!Xl(t)) throw Error(i(200));
            return $l(null, e, t, !0, n);
          }),
          (t.hydrateRoot = function (e, t, n) {
            if (!Yl(e)) throw Error(i(405));
            var r = (null != n && n.hydratedSources) || null,
              s = !1,
              o = "",
              a = Gl;
            if (
              (null !== n &&
                void 0 !== n &&
                (!0 === n.unstable_strictMode && (s = !0),
                void 0 !== n.identifierPrefix && (o = n.identifierPrefix),
                void 0 !== n.onRecoverableError && (a = n.onRecoverableError)),
              (t = ql(t, null, e, 1, null != n ? n : null, s, 0, o, a)),
              (e[fs] = t.current),
              qr(e),
              r)
            )
              for (e = 0; e < r.length; e++)
                (s = (s = (n = r[e])._getVersion)(n._source)),
                  null == t.mutableSourceEagerHydrationData
                    ? (t.mutableSourceEagerHydrationData = [n, s])
                    : t.mutableSourceEagerHydrationData.push(n, s);
            return new Ql(t);
          }),
          (t.render = function (e, t, n) {
            if (!Xl(t)) throw Error(i(200));
            return $l(null, e, t, !1, n);
          }),
          (t.unmountComponentAtNode = function (e) {
            if (!Xl(e)) throw Error(i(40));
            return (
              !!e._reactRootContainer &&
              (ul(function () {
                $l(null, null, e, !1, function () {
                  (e._reactRootContainer = null), (e[fs] = null);
                });
              }),
              !0)
            );
          }),
          (t.unstable_batchedUpdates = ll),
          (t.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
            if (!Xl(n)) throw Error(i(200));
            if (null == e || void 0 === e._reactInternals) throw Error(i(38));
            return $l(e, t, n, !1, r);
          }),
          (t.version = "18.3.1-next-f1338f8080-20240426");
      },
      391: (e, t, n) => {
        "use strict";
        var r = n(950);
        (t.createRoot = r.createRoot), (t.hydrateRoot = r.hydrateRoot);
      },
      950: (e, t, n) => {
        "use strict";
        !(function e() {
          if (
            "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&
            "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE
          )
            try {
              __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
            } catch (t) {
              console.error(t);
            }
        })(),
          (e.exports = n(730));
      },
      82: function (e, t, n) {
        var r;
        "undefined" != typeof self && self,
          (e.exports =
            ((r = n(43)),
            (() => {
              "use strict";
              var e = {
                  156: (e) => {
                    e.exports = r;
                  },
                },
                t = {};
              function n(r) {
                var s = t[r];
                if (void 0 !== s) return s.exports;
                var i = (t[r] = { exports: {} });
                return e[r](i, i.exports, n), i.exports;
              }
              (n.d = (e, t) => {
                for (var r in t)
                  n.o(t, r) &&
                    !n.o(e, r) &&
                    Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
              }),
                (n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
                (n.r = (e) => {
                  "undefined" != typeof Symbol &&
                    Symbol.toStringTag &&
                    Object.defineProperty(e, Symbol.toStringTag, {
                      value: "Module",
                    }),
                    Object.defineProperty(e, "__esModule", { value: !0 });
                });
              var s = {};
              return (
                (() => {
                  n.r(s),
                    n.d(s, {
                      default: () => d,
                      useStopwatch: () => l,
                      useTime: () => u,
                      useTimer: () => c,
                    });
                  var e = n(156);
                  class t {
                    static expiryTimestamp(e) {
                      const t = new Date(e).getTime() > 0;
                      return (
                        t ||
                          console.warn(
                            "react-timer-hook: { useTimer } Invalid expiryTimestamp settings",
                            e
                          ),
                        t
                      );
                    }
                    static onExpire(e) {
                      const t = e && "function" == typeof e;
                      return (
                        e &&
                          !t &&
                          console.warn(
                            "react-timer-hook: { useTimer } Invalid onExpire settings function",
                            e
                          ),
                        t
                      );
                    }
                  }
                  class r {
                    static getTimeFromSeconds(e) {
                      const t = Math.ceil(e),
                        n = Math.floor(t / 86400),
                        r = Math.floor((t % 86400) / 3600),
                        s = Math.floor((t % 3600) / 60);
                      return {
                        totalSeconds: t,
                        seconds: Math.floor(t % 60),
                        minutes: s,
                        hours: r,
                        days: n,
                      };
                    }
                    static getSecondsFromExpiry(e, t) {
                      const n = e - new Date().getTime();
                      if (n > 0) {
                        const e = n / 1e3;
                        return t ? Math.round(e) : e;
                      }
                      return 0;
                    }
                    static getSecondsFromPrevTime(e, t) {
                      const n = new Date().getTime() - e;
                      if (n > 0) {
                        const e = n / 1e3;
                        return t ? Math.round(e) : e;
                      }
                      return 0;
                    }
                    static getSecondsFromTimeNow() {
                      const e = new Date();
                      return e.getTime() / 1e3 - 60 * e.getTimezoneOffset();
                    }
                    static getFormattedTimeFromSeconds(e, t) {
                      const {
                        seconds: n,
                        minutes: s,
                        hours: i,
                      } = r.getTimeFromSeconds(e);
                      let o = "",
                        a = i;
                      return (
                        "12-hour" === t &&
                          ((o = i >= 12 ? "pm" : "am"), (a = i % 12)),
                        { seconds: n, minutes: s, hours: a, ampm: o }
                      );
                    }
                  }
                  function i(t, n) {
                    const r = (0, e.useRef)();
                    (0, e.useEffect)(() => {
                      r.current = t;
                    }),
                      (0, e.useEffect)(() => {
                        if (!n) return () => {};
                        const e = setInterval(() => {
                          r.current && r.current();
                        }, n);
                        return () => clearInterval(e);
                      }, [n]);
                  }
                  const o = 1e3;
                  function a(e) {
                    if (!t.expiryTimestamp(e)) return null;
                    const n = r.getSecondsFromExpiry(e),
                      s = Math.floor(1e3 * (n - Math.floor(n)));
                    return s > 0 ? s : o;
                  }
                  function c() {
                    let {
                      expiryTimestamp: n,
                      onExpire: s,
                      autoStart: c = !0,
                    } = arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : {};
                    const [l, u] = (0, e.useState)(n),
                      [d, h] = (0, e.useState)(r.getSecondsFromExpiry(l)),
                      [p, f] = (0, e.useState)(c),
                      [m, g] = (0, e.useState)(c),
                      [v, y] = (0, e.useState)(a(l)),
                      b = (0, e.useCallback)(() => {
                        t.onExpire(s) && s(), f(!1), y(null);
                      }, [s]),
                      w = (0, e.useCallback)(() => {
                        f(!1);
                      }, []),
                      S = (0, e.useCallback)(function (e) {
                        let t =
                          !(arguments.length > 1 && void 0 !== arguments[1]) ||
                          arguments[1];
                        y(a(e)), g(t), f(t), u(e), h(r.getSecondsFromExpiry(e));
                      }, []),
                      _ = (0, e.useCallback)(() => {
                        const e = new Date();
                        e.setMilliseconds(e.getMilliseconds() + 1e3 * d), S(e);
                      }, [d, S]),
                      E = (0, e.useCallback)(() => {
                        m ? (h(r.getSecondsFromExpiry(l)), f(!0)) : _();
                      }, [l, m, _]);
                    return (
                      i(
                        () => {
                          v !== o && y(o);
                          const e = r.getSecondsFromExpiry(l);
                          h(e), e <= 0 && b();
                        },
                        p ? v : null
                      ),
                      {
                        ...r.getTimeFromSeconds(d),
                        start: E,
                        pause: w,
                        resume: _,
                        restart: S,
                        isRunning: p,
                      }
                    );
                  }
                  function l() {
                    let { autoStart: t, offsetTimestamp: n } =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : {};
                    const [s, o] = (0, e.useState)(
                        r.getSecondsFromExpiry(n, !0) || 0
                      ),
                      [a, c] = (0, e.useState)(new Date()),
                      [l, u] = (0, e.useState)(
                        s + r.getSecondsFromPrevTime(a || 0, !0)
                      ),
                      [d, h] = (0, e.useState)(t);
                    i(
                      () => {
                        u(s + r.getSecondsFromPrevTime(a, !0));
                      },
                      d ? 1e3 : null
                    );
                    const p = (0, e.useCallback)(() => {
                        const e = new Date();
                        c(e), h(!0), u(s + r.getSecondsFromPrevTime(e, !0));
                      }, [s]),
                      f = (0, e.useCallback)(() => {
                        o(l), h(!1);
                      }, [l]),
                      m = (0, e.useCallback)(function () {
                        let e =
                            arguments.length > 0 && void 0 !== arguments[0]
                              ? arguments[0]
                              : 0,
                          t =
                            !(
                              arguments.length > 1 && void 0 !== arguments[1]
                            ) || arguments[1];
                        const n = r.getSecondsFromExpiry(e, !0) || 0,
                          s = new Date();
                        c(s),
                          o(n),
                          h(t),
                          u(n + r.getSecondsFromPrevTime(s, !0));
                      }, []);
                    return {
                      ...r.getTimeFromSeconds(l),
                      start: p,
                      pause: f,
                      reset: m,
                      isRunning: d,
                    };
                  }
                  function u() {
                    let { format: t } =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : {};
                    const [n, s] = (0, e.useState)(r.getSecondsFromTimeNow());
                    return (
                      i(() => {
                        s(r.getSecondsFromTimeNow());
                      }, 1e3),
                      { ...r.getFormattedTimeFromSeconds(n, t) }
                    );
                  }
                  function d(t) {
                    if (
                      ((0, e.useEffect)(() => {
                        console.warn(
                          "react-timer-hook: default export useTimer is deprecated, use named exports { useTimer, useStopwatch, useTime } instead"
                        );
                      }, []),
                      t.expiryTimestamp)
                    ) {
                      const e = c(t);
                      return {
                        ...e,
                        startTimer: e.start,
                        stopTimer: e.pause,
                        resetTimer: () => {},
                      };
                    }
                    const n = l(t);
                    return {
                      ...n,
                      startTimer: n.start,
                      stopTimer: n.pause,
                      resetTimer: n.reset,
                    };
                  }
                })(),
                s
              );
            })()));
      },
      153: (e, t, n) => {
        "use strict";
        var r = n(43),
          s = Symbol.for("react.element"),
          i = Symbol.for("react.fragment"),
          o = Object.prototype.hasOwnProperty,
          a =
            r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
              .ReactCurrentOwner,
          c = { key: !0, ref: !0, __self: !0, __source: !0 };
        function l(e, t, n) {
          var r,
            i = {},
            l = null,
            u = null;
          for (r in (void 0 !== n && (l = "" + n),
          void 0 !== t.key && (l = "" + t.key),
          void 0 !== t.ref && (u = t.ref),
          t))
            o.call(t, r) && !c.hasOwnProperty(r) && (i[r] = t[r]);
          if (e && e.defaultProps)
            for (r in (t = e.defaultProps)) void 0 === i[r] && (i[r] = t[r]);
          return {
            $$typeof: s,
            type: e,
            key: l,
            ref: u,
            props: i,
            _owner: a.current,
          };
        }
        (t.Fragment = i), (t.jsx = l), (t.jsxs = l);
      },
      202: (e, t) => {
        "use strict";
        var n = Symbol.for("react.element"),
          r = Symbol.for("react.portal"),
          s = Symbol.for("react.fragment"),
          i = Symbol.for("react.strict_mode"),
          o = Symbol.for("react.profiler"),
          a = Symbol.for("react.provider"),
          c = Symbol.for("react.context"),
          l = Symbol.for("react.forward_ref"),
          u = Symbol.for("react.suspense"),
          d = Symbol.for("react.memo"),
          h = Symbol.for("react.lazy"),
          p = Symbol.iterator;
        var f = {
            isMounted: function () {
              return !1;
            },
            enqueueForceUpdate: function () {},
            enqueueReplaceState: function () {},
            enqueueSetState: function () {},
          },
          m = Object.assign,
          g = {};
        function v(e, t, n) {
          (this.props = e),
            (this.context = t),
            (this.refs = g),
            (this.updater = n || f);
        }
        function y() {}
        function b(e, t, n) {
          (this.props = e),
            (this.context = t),
            (this.refs = g),
            (this.updater = n || f);
        }
        (v.prototype.isReactComponent = {}),
          (v.prototype.setState = function (e, t) {
            if ("object" !== typeof e && "function" !== typeof e && null != e)
              throw Error(
                "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
              );
            this.updater.enqueueSetState(this, e, t, "setState");
          }),
          (v.prototype.forceUpdate = function (e) {
            this.updater.enqueueForceUpdate(this, e, "forceUpdate");
          }),
          (y.prototype = v.prototype);
        var w = (b.prototype = new y());
        (w.constructor = b), m(w, v.prototype), (w.isPureReactComponent = !0);
        var S = Array.isArray,
          _ = Object.prototype.hasOwnProperty,
          E = { current: null },
          A = { key: !0, ref: !0, __self: !0, __source: !0 };
        function T(e, t, r) {
          var s,
            i = {},
            o = null,
            a = null;
          if (null != t)
            for (s in (void 0 !== t.ref && (a = t.ref),
            void 0 !== t.key && (o = "" + t.key),
            t))
              _.call(t, s) && !A.hasOwnProperty(s) && (i[s] = t[s]);
          var c = arguments.length - 2;
          if (1 === c) i.children = r;
          else if (1 < c) {
            for (var l = Array(c), u = 0; u < c; u++) l[u] = arguments[u + 2];
            i.children = l;
          }
          if (e && e.defaultProps)
            for (s in (c = e.defaultProps)) void 0 === i[s] && (i[s] = c[s]);
          return {
            $$typeof: n,
            type: e,
            key: o,
            ref: a,
            props: i,
            _owner: E.current,
          };
        }
        function P(e) {
          return "object" === typeof e && null !== e && e.$$typeof === n;
        }
        var I = /\/+/g;
        function C(e, t) {
          return "object" === typeof e && null !== e && null != e.key
            ? (function (e) {
                var t = { "=": "=0", ":": "=2" };
                return (
                  "$" +
                  e.replace(/[=:]/g, function (e) {
                    return t[e];
                  })
                );
              })("" + e.key)
            : t.toString(36);
        }
        function k(e, t, s, i, o) {
          var a = typeof e;
          ("undefined" !== a && "boolean" !== a) || (e = null);
          var c = !1;
          if (null === e) c = !0;
          else
            switch (a) {
              case "string":
              case "number":
                c = !0;
                break;
              case "object":
                switch (e.$$typeof) {
                  case n:
                  case r:
                    c = !0;
                }
            }
          if (c)
            return (
              (o = o((c = e))),
              (e = "" === i ? "." + C(c, 0) : i),
              S(o)
                ? ((s = ""),
                  null != e && (s = e.replace(I, "$&/") + "/"),
                  k(o, t, s, "", function (e) {
                    return e;
                  }))
                : null != o &&
                  (P(o) &&
                    (o = (function (e, t) {
                      return {
                        $$typeof: n,
                        type: e.type,
                        key: t,
                        ref: e.ref,
                        props: e.props,
                        _owner: e._owner,
                      };
                    })(
                      o,
                      s +
                        (!o.key || (c && c.key === o.key)
                          ? ""
                          : ("" + o.key).replace(I, "$&/") + "/") +
                        e
                    )),
                  t.push(o)),
              1
            );
          if (((c = 0), (i = "" === i ? "." : i + ":"), S(e)))
            for (var l = 0; l < e.length; l++) {
              var u = i + C((a = e[l]), l);
              c += k(a, t, s, u, o);
            }
          else if (
            ((u = (function (e) {
              return null === e || "object" !== typeof e
                ? null
                : "function" === typeof (e = (p && e[p]) || e["@@iterator"])
                ? e
                : null;
            })(e)),
            "function" === typeof u)
          )
            for (e = u.call(e), l = 0; !(a = e.next()).done; )
              c += k((a = a.value), t, s, (u = i + C(a, l++)), o);
          else if ("object" === a)
            throw (
              ((t = String(e)),
              Error(
                "Objects are not valid as a React child (found: " +
                  ("[object Object]" === t
                    ? "object with keys {" + Object.keys(e).join(", ") + "}"
                    : t) +
                  "). If you meant to render a collection of children, use an array instead."
              ))
            );
          return c;
        }
        function O(e, t, n) {
          if (null == e) return e;
          var r = [],
            s = 0;
          return (
            k(e, r, "", "", function (e) {
              return t.call(n, e, s++);
            }),
            r
          );
        }
        function x(e) {
          if (-1 === e._status) {
            var t = e._result;
            (t = t()).then(
              function (t) {
                (0 !== e._status && -1 !== e._status) ||
                  ((e._status = 1), (e._result = t));
              },
              function (t) {
                (0 !== e._status && -1 !== e._status) ||
                  ((e._status = 2), (e._result = t));
              }
            ),
              -1 === e._status && ((e._status = 0), (e._result = t));
          }
          if (1 === e._status) return e._result.default;
          throw e._result;
        }
        var N = { current: null },
          R = { transition: null },
          D = {
            ReactCurrentDispatcher: N,
            ReactCurrentBatchConfig: R,
            ReactCurrentOwner: E,
          };
        function M() {
          throw Error(
            "act(...) is not supported in production builds of React."
          );
        }
        (t.Children = {
          map: O,
          forEach: function (e, t, n) {
            O(
              e,
              function () {
                t.apply(this, arguments);
              },
              n
            );
          },
          count: function (e) {
            var t = 0;
            return (
              O(e, function () {
                t++;
              }),
              t
            );
          },
          toArray: function (e) {
            return (
              O(e, function (e) {
                return e;
              }) || []
            );
          },
          only: function (e) {
            if (!P(e))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return e;
          },
        }),
          (t.Component = v),
          (t.Fragment = s),
          (t.Profiler = o),
          (t.PureComponent = b),
          (t.StrictMode = i),
          (t.Suspense = u),
          (t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = D),
          (t.act = M),
          (t.cloneElement = function (e, t, r) {
            if (null === e || void 0 === e)
              throw Error(
                "React.cloneElement(...): The argument must be a React element, but you passed " +
                  e +
                  "."
              );
            var s = m({}, e.props),
              i = e.key,
              o = e.ref,
              a = e._owner;
            if (null != t) {
              if (
                (void 0 !== t.ref && ((o = t.ref), (a = E.current)),
                void 0 !== t.key && (i = "" + t.key),
                e.type && e.type.defaultProps)
              )
                var c = e.type.defaultProps;
              for (l in t)
                _.call(t, l) &&
                  !A.hasOwnProperty(l) &&
                  (s[l] = void 0 === t[l] && void 0 !== c ? c[l] : t[l]);
            }
            var l = arguments.length - 2;
            if (1 === l) s.children = r;
            else if (1 < l) {
              c = Array(l);
              for (var u = 0; u < l; u++) c[u] = arguments[u + 2];
              s.children = c;
            }
            return {
              $$typeof: n,
              type: e.type,
              key: i,
              ref: o,
              props: s,
              _owner: a,
            };
          }),
          (t.createContext = function (e) {
            return (
              ((e = {
                $$typeof: c,
                _currentValue: e,
                _currentValue2: e,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null,
              }).Provider = { $$typeof: a, _context: e }),
              (e.Consumer = e)
            );
          }),
          (t.createElement = T),
          (t.createFactory = function (e) {
            var t = T.bind(null, e);
            return (t.type = e), t;
          }),
          (t.createRef = function () {
            return { current: null };
          }),
          (t.forwardRef = function (e) {
            return { $$typeof: l, render: e };
          }),
          (t.isValidElement = P),
          (t.lazy = function (e) {
            return {
              $$typeof: h,
              _payload: { _status: -1, _result: e },
              _init: x,
            };
          }),
          (t.memo = function (e, t) {
            return { $$typeof: d, type: e, compare: void 0 === t ? null : t };
          }),
          (t.startTransition = function (e) {
            var t = R.transition;
            R.transition = {};
            try {
              e();
            } finally {
              R.transition = t;
            }
          }),
          (t.unstable_act = M),
          (t.useCallback = function (e, t) {
            return N.current.useCallback(e, t);
          }),
          (t.useContext = function (e) {
            return N.current.useContext(e);
          }),
          (t.useDebugValue = function () {}),
          (t.useDeferredValue = function (e) {
            return N.current.useDeferredValue(e);
          }),
          (t.useEffect = function (e, t) {
            return N.current.useEffect(e, t);
          }),
          (t.useId = function () {
            return N.current.useId();
          }),
          (t.useImperativeHandle = function (e, t, n) {
            return N.current.useImperativeHandle(e, t, n);
          }),
          (t.useInsertionEffect = function (e, t) {
            return N.current.useInsertionEffect(e, t);
          }),
          (t.useLayoutEffect = function (e, t) {
            return N.current.useLayoutEffect(e, t);
          }),
          (t.useMemo = function (e, t) {
            return N.current.useMemo(e, t);
          }),
          (t.useReducer = function (e, t, n) {
            return N.current.useReducer(e, t, n);
          }),
          (t.useRef = function (e) {
            return N.current.useRef(e);
          }),
          (t.useState = function (e) {
            return N.current.useState(e);
          }),
          (t.useSyncExternalStore = function (e, t, n) {
            return N.current.useSyncExternalStore(e, t, n);
          }),
          (t.useTransition = function () {
            return N.current.useTransition();
          }),
          (t.version = "18.3.1");
      },
      43: (e, t, n) => {
        "use strict";
        e.exports = n(202);
      },
      579: (e, t, n) => {
        "use strict";
        e.exports = n(153);
      },
      234: (e, t) => {
        "use strict";
        function n(e, t) {
          var n = e.length;
          e.push(t);
          e: for (; 0 < n; ) {
            var r = (n - 1) >>> 1,
              s = e[r];
            if (!(0 < i(s, t))) break e;
            (e[r] = t), (e[n] = s), (n = r);
          }
        }
        function r(e) {
          return 0 === e.length ? null : e[0];
        }
        function s(e) {
          if (0 === e.length) return null;
          var t = e[0],
            n = e.pop();
          if (n !== t) {
            e[0] = n;
            e: for (var r = 0, s = e.length, o = s >>> 1; r < o; ) {
              var a = 2 * (r + 1) - 1,
                c = e[a],
                l = a + 1,
                u = e[l];
              if (0 > i(c, n))
                l < s && 0 > i(u, c)
                  ? ((e[r] = u), (e[l] = n), (r = l))
                  : ((e[r] = c), (e[a] = n), (r = a));
              else {
                if (!(l < s && 0 > i(u, n))) break e;
                (e[r] = u), (e[l] = n), (r = l);
              }
            }
          }
          return t;
        }
        function i(e, t) {
          var n = e.sortIndex - t.sortIndex;
          return 0 !== n ? n : e.id - t.id;
        }
        if (
          "object" === typeof performance &&
          "function" === typeof performance.now
        ) {
          var o = performance;
          t.unstable_now = function () {
            return o.now();
          };
        } else {
          var a = Date,
            c = a.now();
          t.unstable_now = function () {
            return a.now() - c;
          };
        }
        var l = [],
          u = [],
          d = 1,
          h = null,
          p = 3,
          f = !1,
          m = !1,
          g = !1,
          v = "function" === typeof setTimeout ? setTimeout : null,
          y = "function" === typeof clearTimeout ? clearTimeout : null,
          b = "undefined" !== typeof setImmediate ? setImmediate : null;
        function w(e) {
          for (var t = r(u); null !== t; ) {
            if (null === t.callback) s(u);
            else {
              if (!(t.startTime <= e)) break;
              s(u), (t.sortIndex = t.expirationTime), n(l, t);
            }
            t = r(u);
          }
        }
        function S(e) {
          if (((g = !1), w(e), !m))
            if (null !== r(l)) (m = !0), R(_);
            else {
              var t = r(u);
              null !== t && D(S, t.startTime - e);
            }
        }
        function _(e, n) {
          (m = !1), g && ((g = !1), y(P), (P = -1)), (f = !0);
          var i = p;
          try {
            for (
              w(n), h = r(l);
              null !== h && (!(h.expirationTime > n) || (e && !k()));

            ) {
              var o = h.callback;
              if ("function" === typeof o) {
                (h.callback = null), (p = h.priorityLevel);
                var a = o(h.expirationTime <= n);
                (n = t.unstable_now()),
                  "function" === typeof a
                    ? (h.callback = a)
                    : h === r(l) && s(l),
                  w(n);
              } else s(l);
              h = r(l);
            }
            if (null !== h) var c = !0;
            else {
              var d = r(u);
              null !== d && D(S, d.startTime - n), (c = !1);
            }
            return c;
          } finally {
            (h = null), (p = i), (f = !1);
          }
        }
        "undefined" !== typeof navigator &&
          void 0 !== navigator.scheduling &&
          void 0 !== navigator.scheduling.isInputPending &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        var E,
          A = !1,
          T = null,
          P = -1,
          I = 5,
          C = -1;
        function k() {
          return !(t.unstable_now() - C < I);
        }
        function O() {
          if (null !== T) {
            var e = t.unstable_now();
            C = e;
            var n = !0;
            try {
              n = T(!0, e);
            } finally {
              n ? E() : ((A = !1), (T = null));
            }
          } else A = !1;
        }
        if ("function" === typeof b)
          E = function () {
            b(O);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var x = new MessageChannel(),
            N = x.port2;
          (x.port1.onmessage = O),
            (E = function () {
              N.postMessage(null);
            });
        } else
          E = function () {
            v(O, 0);
          };
        function R(e) {
          (T = e), A || ((A = !0), E());
        }
        function D(e, n) {
          P = v(function () {
            e(t.unstable_now());
          }, n);
        }
        (t.unstable_IdlePriority = 5),
          (t.unstable_ImmediatePriority = 1),
          (t.unstable_LowPriority = 4),
          (t.unstable_NormalPriority = 3),
          (t.unstable_Profiling = null),
          (t.unstable_UserBlockingPriority = 2),
          (t.unstable_cancelCallback = function (e) {
            e.callback = null;
          }),
          (t.unstable_continueExecution = function () {
            m || f || ((m = !0), R(_));
          }),
          (t.unstable_forceFrameRate = function (e) {
            0 > e || 125 < e
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (I = 0 < e ? Math.floor(1e3 / e) : 5);
          }),
          (t.unstable_getCurrentPriorityLevel = function () {
            return p;
          }),
          (t.unstable_getFirstCallbackNode = function () {
            return r(l);
          }),
          (t.unstable_next = function (e) {
            switch (p) {
              case 1:
              case 2:
              case 3:
                var t = 3;
                break;
              default:
                t = p;
            }
            var n = p;
            p = t;
            try {
              return e();
            } finally {
              p = n;
            }
          }),
          (t.unstable_pauseExecution = function () {}),
          (t.unstable_requestPaint = function () {}),
          (t.unstable_runWithPriority = function (e, t) {
            switch (e) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                e = 3;
            }
            var n = p;
            p = e;
            try {
              return t();
            } finally {
              p = n;
            }
          }),
          (t.unstable_scheduleCallback = function (e, s, i) {
            var o = t.unstable_now();
            switch (
              ("object" === typeof i && null !== i
                ? (i = "number" === typeof (i = i.delay) && 0 < i ? o + i : o)
                : (i = o),
              e)
            ) {
              case 1:
                var a = -1;
                break;
              case 2:
                a = 250;
                break;
              case 5:
                a = 1073741823;
                break;
              case 4:
                a = 1e4;
                break;
              default:
                a = 5e3;
            }
            return (
              (e = {
                id: d++,
                callback: s,
                priorityLevel: e,
                startTime: i,
                expirationTime: (a = i + a),
                sortIndex: -1,
              }),
              i > o
                ? ((e.sortIndex = i),
                  n(u, e),
                  null === r(l) &&
                    e === r(u) &&
                    (g ? (y(P), (P = -1)) : (g = !0), D(S, i - o)))
                : ((e.sortIndex = a), n(l, e), m || f || ((m = !0), R(_))),
              e
            );
          }),
          (t.unstable_shouldYield = k),
          (t.unstable_wrapCallback = function (e) {
            var t = p;
            return function () {
              var n = p;
              p = t;
              try {
                return e.apply(this, arguments);
              } finally {
                p = n;
              }
            };
          });
      },
      853: (e, t, n) => {
        "use strict";
        e.exports = n(234);
      },
      844: (e) => {
        e.exports = {
          area: !0,
          base: !0,
          br: !0,
          col: !0,
          embed: !0,
          hr: !0,
          img: !0,
          input: !0,
          link: !0,
          meta: !0,
          param: !0,
          source: !0,
          track: !0,
          wbr: !0,
        };
      },
      953: (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            DOMException: () => _,
            Headers: () => u,
            Request: () => v,
            Response: () => w,
            fetch: () => E,
          });
        var r =
            ("undefined" !== typeof globalThis && globalThis) ||
            ("undefined" !== typeof self && self) ||
            ("undefined" !== typeof n.g && n.g) ||
            {},
          s = {
            searchParams: "URLSearchParams" in r,
            iterable: "Symbol" in r && "iterator" in Symbol,
            blob:
              "FileReader" in r &&
              "Blob" in r &&
              (function () {
                try {
                  return new Blob(), !0;
                } catch (e) {
                  return !1;
                }
              })(),
            formData: "FormData" in r,
            arrayBuffer: "ArrayBuffer" in r,
          };
        if (s.arrayBuffer)
          var i = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]",
            ],
            o =
              ArrayBuffer.isView ||
              function (e) {
                return e && i.indexOf(Object.prototype.toString.call(e)) > -1;
              };
        function a(e) {
          if (
            ("string" !== typeof e && (e = String(e)),
            /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || "" === e)
          )
            throw new TypeError(
              'Invalid character in header field name: "' + e + '"'
            );
          return e.toLowerCase();
        }
        function c(e) {
          return "string" !== typeof e && (e = String(e)), e;
        }
        function l(e) {
          var t = {
            next: function () {
              var t = e.shift();
              return { done: void 0 === t, value: t };
            },
          };
          return (
            s.iterable &&
              (t[Symbol.iterator] = function () {
                return t;
              }),
            t
          );
        }
        function u(e) {
          (this.map = {}),
            e instanceof u
              ? e.forEach(function (e, t) {
                  this.append(t, e);
                }, this)
              : Array.isArray(e)
              ? e.forEach(function (e) {
                  if (2 != e.length)
                    throw new TypeError(
                      "Headers constructor: expected name/value pair to be length 2, found" +
                        e.length
                    );
                  this.append(e[0], e[1]);
                }, this)
              : e &&
                Object.getOwnPropertyNames(e).forEach(function (t) {
                  this.append(t, e[t]);
                }, this);
        }
        function d(e) {
          if (!e._noBody)
            return e.bodyUsed
              ? Promise.reject(new TypeError("Already read"))
              : void (e.bodyUsed = !0);
        }
        function h(e) {
          return new Promise(function (t, n) {
            (e.onload = function () {
              t(e.result);
            }),
              (e.onerror = function () {
                n(e.error);
              });
          });
        }
        function p(e) {
          var t = new FileReader(),
            n = h(t);
          return t.readAsArrayBuffer(e), n;
        }
        function f(e) {
          if (e.slice) return e.slice(0);
          var t = new Uint8Array(e.byteLength);
          return t.set(new Uint8Array(e)), t.buffer;
        }
        function m() {
          return (
            (this.bodyUsed = !1),
            (this._initBody = function (e) {
              var t;
              (this.bodyUsed = this.bodyUsed),
                (this._bodyInit = e),
                e
                  ? "string" === typeof e
                    ? (this._bodyText = e)
                    : s.blob && Blob.prototype.isPrototypeOf(e)
                    ? (this._bodyBlob = e)
                    : s.formData && FormData.prototype.isPrototypeOf(e)
                    ? (this._bodyFormData = e)
                    : s.searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(e)
                    ? (this._bodyText = e.toString())
                    : s.arrayBuffer &&
                      s.blob &&
                      (t = e) &&
                      DataView.prototype.isPrototypeOf(t)
                    ? ((this._bodyArrayBuffer = f(e.buffer)),
                      (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                    : s.arrayBuffer &&
                      (ArrayBuffer.prototype.isPrototypeOf(e) || o(e))
                    ? (this._bodyArrayBuffer = f(e))
                    : (this._bodyText = e = Object.prototype.toString.call(e))
                  : ((this._noBody = !0), (this._bodyText = "")),
                this.headers.get("content-type") ||
                  ("string" === typeof e
                    ? this.headers.set(
                        "content-type",
                        "text/plain;charset=UTF-8"
                      )
                    : this._bodyBlob && this._bodyBlob.type
                    ? this.headers.set("content-type", this._bodyBlob.type)
                    : s.searchParams &&
                      URLSearchParams.prototype.isPrototypeOf(e) &&
                      this.headers.set(
                        "content-type",
                        "application/x-www-form-urlencoded;charset=UTF-8"
                      ));
            }),
            s.blob &&
              (this.blob = function () {
                var e = d(this);
                if (e) return e;
                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                if (this._bodyArrayBuffer)
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                if (this._bodyFormData)
                  throw new Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([this._bodyText]));
              }),
            (this.arrayBuffer = function () {
              if (this._bodyArrayBuffer) {
                var e = d(this);
                return (
                  e ||
                  (ArrayBuffer.isView(this._bodyArrayBuffer)
                    ? Promise.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset +
                            this._bodyArrayBuffer.byteLength
                        )
                      )
                    : Promise.resolve(this._bodyArrayBuffer))
                );
              }
              if (s.blob) return this.blob().then(p);
              throw new Error("could not read as ArrayBuffer");
            }),
            (this.text = function () {
              var e = d(this);
              if (e) return e;
              if (this._bodyBlob)
                return (function (e) {
                  var t = new FileReader(),
                    n = h(t),
                    r = /charset=([A-Za-z0-9_-]+)/.exec(e.type),
                    s = r ? r[1] : "utf-8";
                  return t.readAsText(e, s), n;
                })(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return Promise.resolve(
                  (function (e) {
                    for (
                      var t = new Uint8Array(e), n = new Array(t.length), r = 0;
                      r < t.length;
                      r++
                    )
                      n[r] = String.fromCharCode(t[r]);
                    return n.join("");
                  })(this._bodyArrayBuffer)
                );
              if (this._bodyFormData)
                throw new Error("could not read FormData body as text");
              return Promise.resolve(this._bodyText);
            }),
            s.formData &&
              (this.formData = function () {
                return this.text().then(y);
              }),
            (this.json = function () {
              return this.text().then(JSON.parse);
            }),
            this
          );
        }
        (u.prototype.append = function (e, t) {
          (e = a(e)), (t = c(t));
          var n = this.map[e];
          this.map[e] = n ? n + ", " + t : t;
        }),
          (u.prototype.delete = function (e) {
            delete this.map[a(e)];
          }),
          (u.prototype.get = function (e) {
            return (e = a(e)), this.has(e) ? this.map[e] : null;
          }),
          (u.prototype.has = function (e) {
            return this.map.hasOwnProperty(a(e));
          }),
          (u.prototype.set = function (e, t) {
            this.map[a(e)] = c(t);
          }),
          (u.prototype.forEach = function (e, t) {
            for (var n in this.map)
              this.map.hasOwnProperty(n) && e.call(t, this.map[n], n, this);
          }),
          (u.prototype.keys = function () {
            var e = [];
            return (
              this.forEach(function (t, n) {
                e.push(n);
              }),
              l(e)
            );
          }),
          (u.prototype.values = function () {
            var e = [];
            return (
              this.forEach(function (t) {
                e.push(t);
              }),
              l(e)
            );
          }),
          (u.prototype.entries = function () {
            var e = [];
            return (
              this.forEach(function (t, n) {
                e.push([n, t]);
              }),
              l(e)
            );
          }),
          s.iterable && (u.prototype[Symbol.iterator] = u.prototype.entries);
        var g = [
          "CONNECT",
          "DELETE",
          "GET",
          "HEAD",
          "OPTIONS",
          "PATCH",
          "POST",
          "PUT",
          "TRACE",
        ];
        function v(e, t) {
          if (!(this instanceof v))
            throw new TypeError(
              'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
            );
          var n = (t = t || {}).body;
          if (e instanceof v) {
            if (e.bodyUsed) throw new TypeError("Already read");
            (this.url = e.url),
              (this.credentials = e.credentials),
              t.headers || (this.headers = new u(e.headers)),
              (this.method = e.method),
              (this.mode = e.mode),
              (this.signal = e.signal),
              n ||
                null == e._bodyInit ||
                ((n = e._bodyInit), (e.bodyUsed = !0));
          } else this.url = String(e);
          if (
            ((this.credentials =
              t.credentials || this.credentials || "same-origin"),
            (!t.headers && this.headers) || (this.headers = new u(t.headers)),
            (this.method = (function (e) {
              var t = e.toUpperCase();
              return g.indexOf(t) > -1 ? t : e;
            })(t.method || this.method || "GET")),
            (this.mode = t.mode || this.mode || null),
            (this.signal =
              t.signal ||
              this.signal ||
              (function () {
                if ("AbortController" in r) return new AbortController().signal;
              })()),
            (this.referrer = null),
            ("GET" === this.method || "HEAD" === this.method) && n)
          )
            throw new TypeError("Body not allowed for GET or HEAD requests");
          if (
            (this._initBody(n),
            ("GET" === this.method || "HEAD" === this.method) &&
              ("no-store" === t.cache || "no-cache" === t.cache))
          ) {
            var s = /([?&])_=[^&]*/;
            if (s.test(this.url))
              this.url = this.url.replace(s, "$1_=" + new Date().getTime());
            else {
              this.url +=
                (/\?/.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
            }
          }
        }
        function y(e) {
          var t = new FormData();
          return (
            e
              .trim()
              .split("&")
              .forEach(function (e) {
                if (e) {
                  var n = e.split("="),
                    r = n.shift().replace(/\+/g, " "),
                    s = n.join("=").replace(/\+/g, " ");
                  t.append(decodeURIComponent(r), decodeURIComponent(s));
                }
              }),
            t
          );
        }
        function b(e) {
          var t = new u();
          return (
            e
              .replace(/\r?\n[\t ]+/g, " ")
              .split("\r")
              .map(function (e) {
                return 0 === e.indexOf("\n") ? e.substr(1, e.length) : e;
              })
              .forEach(function (e) {
                var n = e.split(":"),
                  r = n.shift().trim();
                if (r) {
                  var s = n.join(":").trim();
                  try {
                    t.append(r, s);
                  } catch (i) {
                    console.warn("Response " + i.message);
                  }
                }
              }),
            t
          );
        }
        function w(e, t) {
          if (!(this instanceof w))
            throw new TypeError(
              'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
            );
          if (
            (t || (t = {}),
            (this.type = "default"),
            (this.status = void 0 === t.status ? 200 : t.status),
            this.status < 200 || this.status > 599)
          )
            throw new RangeError(
              "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
            );
          (this.ok = this.status >= 200 && this.status < 300),
            (this.statusText =
              void 0 === t.statusText ? "" : "" + t.statusText),
            (this.headers = new u(t.headers)),
            (this.url = t.url || ""),
            this._initBody(e);
        }
        (v.prototype.clone = function () {
          return new v(this, { body: this._bodyInit });
        }),
          m.call(v.prototype),
          m.call(w.prototype),
          (w.prototype.clone = function () {
            return new w(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new u(this.headers),
              url: this.url,
            });
          }),
          (w.error = function () {
            var e = new w(null, { status: 200, statusText: "" });
            return (e.ok = !1), (e.status = 0), (e.type = "error"), e;
          });
        var S = [301, 302, 303, 307, 308];
        w.redirect = function (e, t) {
          if (-1 === S.indexOf(t)) throw new RangeError("Invalid status code");
          return new w(null, { status: t, headers: { location: e } });
        };
        var _ = r.DOMException;
        try {
          new _();
        } catch (A) {
          ((_ = function (e, t) {
            (this.message = e), (this.name = t);
            var n = Error(e);
            this.stack = n.stack;
          }).prototype = Object.create(Error.prototype)),
            (_.prototype.constructor = _);
        }
        function E(e, t) {
          return new Promise(function (n, i) {
            var o = new v(e, t);
            if (o.signal && o.signal.aborted)
              return i(new _("Aborted", "AbortError"));
            var l = new XMLHttpRequest();
            function d() {
              l.abort();
            }
            if (
              ((l.onload = function () {
                var e = {
                  statusText: l.statusText,
                  headers: b(l.getAllResponseHeaders() || ""),
                };
                0 === o.url.indexOf("file://") &&
                (l.status < 200 || l.status > 599)
                  ? (e.status = 200)
                  : (e.status = l.status),
                  (e.url =
                    "responseURL" in l
                      ? l.responseURL
                      : e.headers.get("X-Request-URL"));
                var t = "response" in l ? l.response : l.responseText;
                setTimeout(function () {
                  n(new w(t, e));
                }, 0);
              }),
              (l.onerror = function () {
                setTimeout(function () {
                  i(new TypeError("Network request failed"));
                }, 0);
              }),
              (l.ontimeout = function () {
                setTimeout(function () {
                  i(new TypeError("Network request timed out"));
                }, 0);
              }),
              (l.onabort = function () {
                setTimeout(function () {
                  i(new _("Aborted", "AbortError"));
                }, 0);
              }),
              l.open(
                o.method,
                (function (e) {
                  try {
                    return "" === e && r.location.href ? r.location.href : e;
                  } catch (t) {
                    return e;
                  }
                })(o.url),
                !0
              ),
              "include" === o.credentials
                ? (l.withCredentials = !0)
                : "omit" === o.credentials && (l.withCredentials = !1),
              "responseType" in l &&
                (s.blob
                  ? (l.responseType = "blob")
                  : s.arrayBuffer && (l.responseType = "arraybuffer")),
              t &&
                "object" === typeof t.headers &&
                !(
                  t.headers instanceof u ||
                  (r.Headers && t.headers instanceof r.Headers)
                ))
            ) {
              var h = [];
              Object.getOwnPropertyNames(t.headers).forEach(function (e) {
                h.push(a(e)), l.setRequestHeader(e, c(t.headers[e]));
              }),
                o.headers.forEach(function (e, t) {
                  -1 === h.indexOf(t) && l.setRequestHeader(t, e);
                });
            } else
              o.headers.forEach(function (e, t) {
                l.setRequestHeader(t, e);
              });
            o.signal &&
              (o.signal.addEventListener("abort", d),
              (l.onreadystatechange = function () {
                4 === l.readyState && o.signal.removeEventListener("abort", d);
              })),
              l.send("undefined" === typeof o._bodyInit ? null : o._bodyInit);
          });
        }
        (E.polyfill = !0),
          r.fetch ||
            ((r.fetch = E), (r.Headers = u), (r.Request = v), (r.Response = w));
      },
      779: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.InMemoryStorageAdapter = void 0);
        var n = (function () {
          function e(e) {
            (this.storage = e), (this.cache = new Map());
          }
          return (
            Object.defineProperty(e.prototype, "length", {
              get: function () {
                return this.storage.length;
              },
              enumerable: !1,
              configurable: !0,
            }),
            (e.prototype.clear = function () {
              this.cache.clear(), this.storage.clear();
            }),
            (e.prototype.getItem = function (e) {
              var t = this.storage.getItem(e);
              return "undefined" !== typeof t && null !== t
                ? (this.cache.set(e, t), t)
                : this.cache.has(e)
                ? this.cache.get(e)
                : t;
            }),
            (e.prototype.key = function (e) {
              return this.storage.key(e);
            }),
            (e.prototype.removeItem = function (e) {
              this.cache.delete(e), this.storage.removeItem(e);
            }),
            (e.prototype.setItem = function (e, t) {
              this.cache.set(e, t), this.storage.setItem(e, t);
            }),
            e
          );
        })();
        t.InMemoryStorageAdapter = n;
      },
      615: (e, t, n) => {
        "use strict";
        t.Lr = void 0;
        var r = n(779),
          s = {
            length: 0,
            clear: function () {},
            getItem: function () {
              return null;
            },
            key: function () {
              return null;
            },
            removeItem: function () {},
            setItem: function () {},
          };
        function i() {
          try {
            var e = new Date().toString();
            window.localStorage.setItem(e, e);
            var t = window.localStorage.getItem(e) === e;
            return window.localStorage.removeItem(e), t;
          } catch (n) {
            return !1;
          }
        }
        function o() {
          return "undefined" !== typeof window && i() ? window.localStorage : s;
        }
        t.Lr = new r.InMemoryStorageAdapter(o());
      },
    },
    t = {};
  function n(r) {
    var s = t[r];
    if (void 0 !== s) return s.exports;
    var i = (t[r] = { exports: {} });
    return e[r].call(i.exports, i, i.exports, n), i.exports;
  }
  (n.m = e),
    (n.amdO = {}),
    (n.n = (e) => {
      var t = e && e.__esModule ? () => e.default : () => e;
      return n.d(t, { a: t }), t;
    }),
    (() => {
      var e,
        t = Object.getPrototypeOf
          ? (e) => Object.getPrototypeOf(e)
          : (e) => e.__proto__;
      n.t = function (r, s) {
        if ((1 & s && (r = this(r)), 8 & s)) return r;
        if ("object" === typeof r && r) {
          if (4 & s && r.__esModule) return r;
          if (16 & s && "function" === typeof r.then) return r;
        }
        var i = Object.create(null);
        n.r(i);
        var o = {};
        e = e || [null, t({}), t([]), t(t)];
        for (
          var a = 2 & s && r;
          "object" == typeof a && !~e.indexOf(a);
          a = t(a)
        )
          Object.getOwnPropertyNames(a).forEach((e) => (o[e] = () => r[e]));
        return (o.default = () => r), n.d(i, o), i;
      };
    })(),
    (n.d = (e, t) => {
      for (var r in t)
        n.o(t, r) &&
          !n.o(e, r) &&
          Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
    }),
    (n.f = {}),
    (n.e = (e) =>
      Promise.all(Object.keys(n.f).reduce((t, r) => (n.f[r](e, t), t), []))),
    (n.u = (e) =>
      "static/js/" +
      e +
      "." +
      { 227: "74867b84", 453: "44ada99f" }[e] +
      ".chunk.js"),
    (n.miniCssF = (e) => {}),
    (n.g = (function () {
      if ("object" === typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e) {
        if ("object" === typeof window) return window;
      }
    })()),
    (n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
    (() => {
      var e = {},
        t = "not-gemz-app:";
      n.l = (r, s, i, o) => {
        if (e[r]) e[r].push(s);
        else {
          var a, c;
          if (void 0 !== i)
            for (
              var l = document.getElementsByTagName("script"), u = 0;
              u < l.length;
              u++
            ) {
              var d = l[u];
              if (
                d.getAttribute("src") == r ||
                d.getAttribute("data-webpack") == t + i
              ) {
                a = d;
                break;
              }
            }
          a ||
            ((c = !0),
            ((a = document.createElement("script")).charset = "utf-8"),
            (a.timeout = 120),
            n.nc && a.setAttribute("nonce", n.nc),
            a.setAttribute("data-webpack", t + i),
            (a.src = r)),
            (e[r] = [s]);
          var h = (t, n) => {
              (a.onerror = a.onload = null), clearTimeout(p);
              var s = e[r];
              if (
                (delete e[r],
                a.parentNode && a.parentNode.removeChild(a),
                s && s.forEach((e) => e(n)),
                t)
              )
                return t(n);
            },
            p = setTimeout(
              h.bind(null, void 0, { type: "timeout", target: a }),
              12e4
            );
          (a.onerror = h.bind(null, a.onerror)),
            (a.onload = h.bind(null, a.onload)),
            c && document.head.appendChild(a);
        }
      };
    })(),
    (n.r = (e) => {
      "undefined" !== typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (n.p = "/"),
    (() => {
      var e = { 792: 0 };
      n.f.j = (t, r) => {
        var s = n.o(e, t) ? e[t] : void 0;
        if (0 !== s)
          if (s) r.push(s[2]);
          else {
            var i = new Promise((n, r) => (s = e[t] = [n, r]));
            r.push((s[2] = i));
            var o = n.p + n.u(t),
              a = new Error();
            n.l(
              o,
              (r) => {
                if (n.o(e, t) && (0 !== (s = e[t]) && (e[t] = void 0), s)) {
                  var i = r && ("load" === r.type ? "missing" : r.type),
                    o = r && r.target && r.target.src;
                  (a.message =
                    "Loading chunk " + t + " failed.\n(" + i + ": " + o + ")"),
                    (a.name = "ChunkLoadError"),
                    (a.type = i),
                    (a.request = o),
                    s[1](a);
                }
              },
              "chunk-" + t,
              t
            );
          }
      };
      var t = (t, r) => {
          var s,
            i,
            o = r[0],
            a = r[1],
            c = r[2],
            l = 0;
          if (o.some((t) => 0 !== e[t])) {
            for (s in a) n.o(a, s) && (n.m[s] = a[s]);
            if (c) c(n);
          }
          for (t && t(r); l < o.length; l++)
            (i = o[l]), n.o(e, i) && e[i] && e[i][0](), (e[i] = 0);
        },
        r = (self.webpackChunknot_gemz_app =
          self.webpackChunknot_gemz_app || []);
      r.forEach(t.bind(null, 0)), (r.push = t.bind(null, r.push.bind(r)));
    })(),
    (() => {
      "use strict";
      var e = {};
      n.r(e),
        n.d(e, {
          exclude: () => L,
          extract: () => x,
          parse: () => N,
          parseUrl: () => D,
          pick: () => j,
          stringify: () => R,
          stringifyUrl: () => M,
        });
      var t = {};
      n.r(t),
        n.d(t, {
          ArraySchema: () => sa,
          BooleanSchema: () => ta,
          IntegerSchema: () => ea,
          MapSchema: () => oa,
          NullSchema: () => Zo,
          NumberSchema: () => $o,
          ObjectSchema: () => ra,
          Schema: () => Xo,
          StringSchema: () => na,
          TupleSchema: () => ia,
          UnionSchema: () => aa,
          UnknownSchema: () => ca,
          ValidationError: () => Yo,
          array: () => va,
          boolean: () => fa,
          float: () => ha,
          int: () => pa,
          map: () => ya,
          null: () => la,
          number: () => da,
          object: () => ga,
          string: () => ua,
          tuple: () => ba,
          union: () => ma,
          unknown: () => wa,
        });
      var r = {};
      n.r(r),
        n.d(r, {
          APIConnectionError: () => Qu,
          APIConnectionTimeoutError: () => Yu,
          APIError: () => Gu,
          APIUserAbortError: () => Ju,
          AuthenticationError: () => Zu,
          BadRequestError: () => Xu,
          ConflictError: () => td,
          InternalServerError: () => sd,
          NotFoundError: () => ed,
          OpenAIError: () => zu,
          PermissionDeniedError: () => $u,
          RateLimitError: () => rd,
          UnprocessableEntityError: () => nd,
        });
      var s = {};
      n.r(s),
        n.d(s, {
          JsonPatchError: () => pm,
          _areEquals: () => Em,
          applyOperation: () => ym,
          applyPatch: () => bm,
          applyReducer: () => wm,
          deepClone: () => fm,
          getValueByPointer: () => vm,
          validate: () => _m,
          validator: () => Sm,
        });
      var i = {};
      n.r(i),
        n.d(i, {
          compare: () => xm,
          generate: () => km,
          observe: () => Cm,
          unobserve: () => Im,
        });
      var o = n(43),
        a = n(391);
      function c(e) {
        (!{
          NODE_ENV: "production",
          PUBLIC_URL: "",
          WDS_SOCKET_HOST: void 0,
          WDS_SOCKET_PATH: void 0,
          WDS_SOCKET_PORT: void 0,
          FAST_REFRESH: !0,
          REACT_APP_STAGE: "prod",
          REACT_APP_ENV: "prod",
          REACT_APP_APP_VERSION: "2.8.0",
        }.IS_DEVELOPMENT &&
          !{
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_STAGE: "prod",
            REACT_APP_ENV: "prod",
            REACT_APP_APP_VERSION: "2.8.0",
          }.REACT_APP_IS_DEVELOPMENT) ||
          n.e(227).then(n.bind(n, 227)).then(e);
      }
      var l = n(274),
        u = n(615);
      function d() {
        return (
          "object" === typeof window &&
          void 0 !==
            (null === window || void 0 === window ? void 0 : window.document)
        );
      }
      var h = n(79),
        p = n.n(h);
      const f = "%[a-f0-9]{2}",
        m = new RegExp("(" + f + ")|([^%]+?)", "gi"),
        g = new RegExp("(" + f + ")+", "gi");
      function v(e, t) {
        try {
          return [decodeURIComponent(e.join(""))];
        } catch {}
        if (1 === e.length) return e;
        t = t || 1;
        const n = e.slice(0, t),
          r = e.slice(t);
        return Array.prototype.concat.call([], v(n), v(r));
      }
      function y(e) {
        try {
          return decodeURIComponent(e);
        } catch {
          let t = e.match(m) || [];
          for (let n = 1; n < t.length; n++)
            t = (e = v(t, n).join("")).match(m) || [];
          return e;
        }
      }
      function b(e) {
        if ("string" !== typeof e)
          throw new TypeError(
            "Expected `encodedURI` to be of type `string`, got `" +
              typeof e +
              "`"
          );
        try {
          return decodeURIComponent(e);
        } catch {
          return (function (e) {
            const t = { "%FE%FF": "\ufffd\ufffd", "%FF%FE": "\ufffd\ufffd" };
            let n = g.exec(e);
            for (; n; ) {
              try {
                t[n[0]] = decodeURIComponent(n[0]);
              } catch {
                const e = y(n[0]);
                e !== n[0] && (t[n[0]] = e);
              }
              n = g.exec(e);
            }
            t["%C2"] = "\ufffd";
            const r = Object.keys(t);
            for (const s of r) e = e.replace(new RegExp(s, "g"), t[s]);
            return e;
          })(e);
        }
      }
      function w(e, t) {
        if ("string" !== typeof e || "string" !== typeof t)
          throw new TypeError("Expected the arguments to be of type `string`");
        if ("" === e || "" === t) return [];
        const n = e.indexOf(t);
        return -1 === n ? [] : [e.slice(0, n), e.slice(n + t.length)];
      }
      function S(e, t) {
        const n = {};
        if (Array.isArray(t))
          for (const r of t) {
            const t = Object.getOwnPropertyDescriptor(e, r);
            null !== t &&
              void 0 !== t &&
              t.enumerable &&
              Object.defineProperty(n, r, t);
          }
        else
          for (const r of Reflect.ownKeys(e)) {
            const s = Object.getOwnPropertyDescriptor(e, r);
            if (s.enumerable) {
              t(r, e[r], e) && Object.defineProperty(n, r, s);
            }
          }
        return n;
      }
      const _ = (e) => null === e || void 0 === e,
        E = (e) =>
          encodeURIComponent(e).replace(/[!'()*]/g, (e) =>
            "%".concat(e.charCodeAt(0).toString(16).toUpperCase())
          ),
        A = Symbol("encodeFragmentIdentifier");
      function T(e) {
        if ("string" !== typeof e || 1 !== e.length)
          throw new TypeError(
            "arrayFormatSeparator must be single character string"
          );
      }
      function P(e, t) {
        return t.encode ? (t.strict ? E(e) : encodeURIComponent(e)) : e;
      }
      function I(e, t) {
        return t.decode ? b(e) : e;
      }
      function C(e) {
        return Array.isArray(e)
          ? e.sort()
          : "object" === typeof e
          ? C(Object.keys(e))
              .sort((e, t) => Number(e) - Number(t))
              .map((t) => e[t])
          : e;
      }
      function k(e) {
        const t = e.indexOf("#");
        return -1 !== t && (e = e.slice(0, t)), e;
      }
      function O(e, t) {
        return (
          t.parseNumbers &&
          !Number.isNaN(Number(e)) &&
          "string" === typeof e &&
          "" !== e.trim()
            ? (e = Number(e))
            : !t.parseBooleans ||
              null === e ||
              ("true" !== e.toLowerCase() && "false" !== e.toLowerCase()) ||
              (e = "true" === e.toLowerCase()),
          e
        );
      }
      function x(e) {
        const t = (e = k(e)).indexOf("?");
        return -1 === t ? "" : e.slice(t + 1);
      }
      function N(e, t) {
        T(
          (t = {
            decode: !0,
            sort: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            parseNumbers: !1,
            parseBooleans: !1,
            ...t,
          }).arrayFormatSeparator
        );
        const n = (function (e) {
            let t;
            switch (e.arrayFormat) {
              case "index":
                return (e, n, r) => {
                  (t = /\[(\d*)]$/.exec(e)),
                    (e = e.replace(/\[\d*]$/, "")),
                    t
                      ? (void 0 === r[e] && (r[e] = {}), (r[e][t[1]] = n))
                      : (r[e] = n);
                };
              case "bracket":
                return (e, n, r) => {
                  (t = /(\[])$/.exec(e)),
                    (e = e.replace(/\[]$/, "")),
                    t
                      ? void 0 !== r[e]
                        ? (r[e] = [...r[e], n])
                        : (r[e] = [n])
                      : (r[e] = n);
                };
              case "colon-list-separator":
                return (e, n, r) => {
                  (t = /(:list)$/.exec(e)),
                    (e = e.replace(/:list$/, "")),
                    t
                      ? void 0 !== r[e]
                        ? (r[e] = [...r[e], n])
                        : (r[e] = [n])
                      : (r[e] = n);
                };
              case "comma":
              case "separator":
                return (t, n, r) => {
                  const s =
                      "string" === typeof n &&
                      n.includes(e.arrayFormatSeparator),
                    i =
                      "string" === typeof n &&
                      !s &&
                      I(n, e).includes(e.arrayFormatSeparator);
                  n = i ? I(n, e) : n;
                  const o =
                    s || i
                      ? n.split(e.arrayFormatSeparator).map((t) => I(t, e))
                      : null === n
                      ? n
                      : I(n, e);
                  r[t] = o;
                };
              case "bracket-separator":
                return (t, n, r) => {
                  const s = /(\[])$/.test(t);
                  if (((t = t.replace(/\[]$/, "")), !s))
                    return void (r[t] = n ? I(n, e) : n);
                  const i =
                    null === n
                      ? []
                      : n.split(e.arrayFormatSeparator).map((t) => I(t, e));
                  void 0 !== r[t] ? (r[t] = [...r[t], ...i]) : (r[t] = i);
                };
              default:
                return (e, t, n) => {
                  void 0 !== n[e] ? (n[e] = [...[n[e]].flat(), t]) : (n[e] = t);
                };
            }
          })(t),
          r = Object.create(null);
        if ("string" !== typeof e) return r;
        if (!(e = e.trim().replace(/^[?#&]/, ""))) return r;
        for (const s of e.split("&")) {
          if ("" === s) continue;
          const e = t.decode ? s.replace(/\+/g, " ") : s;
          let [i, o] = w(e, "=");
          void 0 === i && (i = e),
            (o =
              void 0 === o
                ? null
                : ["comma", "separator", "bracket-separator"].includes(
                    t.arrayFormat
                  )
                ? o
                : I(o, t)),
            n(I(i, t), o, r);
        }
        for (const [s, i] of Object.entries(r))
          if ("object" === typeof i && null !== i)
            for (const [e, n] of Object.entries(i)) i[e] = O(n, t);
          else r[s] = O(i, t);
        return !1 === t.sort
          ? r
          : (!0 === t.sort
              ? Object.keys(r).sort()
              : Object.keys(r).sort(t.sort)
            ).reduce((e, t) => {
              const n = r[t];
              return (
                Boolean(n) && "object" === typeof n && !Array.isArray(n)
                  ? (e[t] = C(n))
                  : (e[t] = n),
                e
              );
            }, Object.create(null));
      }
      function R(e, t) {
        if (!e) return "";
        T(
          (t = {
            encode: !0,
            strict: !0,
            arrayFormat: "none",
            arrayFormatSeparator: ",",
            ...t,
          }).arrayFormatSeparator
        );
        const n = (n) =>
            (t.skipNull && _(e[n])) || (t.skipEmptyString && "" === e[n]),
          r = (function (e) {
            switch (e.arrayFormat) {
              case "index":
                return (t) => (n, r) => {
                  const s = n.length;
                  return void 0 === r ||
                    (e.skipNull && null === r) ||
                    (e.skipEmptyString && "" === r)
                    ? n
                    : null === r
                    ? [...n, [P(t, e), "[", s, "]"].join("")]
                    : [...n, [P(t, e), "[", P(s, e), "]=", P(r, e)].join("")];
                };
              case "bracket":
                return (t) => (n, r) =>
                  void 0 === r ||
                  (e.skipNull && null === r) ||
                  (e.skipEmptyString && "" === r)
                    ? n
                    : null === r
                    ? [...n, [P(t, e), "[]"].join("")]
                    : [...n, [P(t, e), "[]=", P(r, e)].join("")];
              case "colon-list-separator":
                return (t) => (n, r) =>
                  void 0 === r ||
                  (e.skipNull && null === r) ||
                  (e.skipEmptyString && "" === r)
                    ? n
                    : null === r
                    ? [...n, [P(t, e), ":list="].join("")]
                    : [...n, [P(t, e), ":list=", P(r, e)].join("")];
              case "comma":
              case "separator":
              case "bracket-separator": {
                const t = "bracket-separator" === e.arrayFormat ? "[]=" : "=";
                return (n) => (r, s) =>
                  void 0 === s ||
                  (e.skipNull && null === s) ||
                  (e.skipEmptyString && "" === s)
                    ? r
                    : ((s = null === s ? "" : s),
                      0 === r.length
                        ? [[P(n, e), t, P(s, e)].join("")]
                        : [[r, P(s, e)].join(e.arrayFormatSeparator)]);
              }
              default:
                return (t) => (n, r) =>
                  void 0 === r ||
                  (e.skipNull && null === r) ||
                  (e.skipEmptyString && "" === r)
                    ? n
                    : null === r
                    ? [...n, P(t, e)]
                    : [...n, [P(t, e), "=", P(r, e)].join("")];
            }
          })(t),
          s = {};
        for (const [o, a] of Object.entries(e)) n(o) || (s[o] = a);
        const i = Object.keys(s);
        return (
          !1 !== t.sort && i.sort(t.sort),
          i
            .map((n) => {
              const s = e[n];
              return void 0 === s
                ? ""
                : null === s
                ? P(n, t)
                : Array.isArray(s)
                ? 0 === s.length && "bracket-separator" === t.arrayFormat
                  ? P(n, t) + "[]"
                  : s.reduce(r(n), []).join("&")
                : P(n, t) + "=" + P(s, t);
            })
            .filter((e) => e.length > 0)
            .join("&")
        );
      }
      function D(e, t) {
        var n, r;
        t = { decode: !0, ...t };
        let [s, i] = w(e, "#");
        return (
          void 0 === s && (s = e),
          {
            url:
              null !==
                (n =
                  null === (r = s) ||
                  void 0 === r ||
                  null === (r = r.split("?")) ||
                  void 0 === r
                    ? void 0
                    : r[0]) && void 0 !== n
                ? n
                : "",
            query: N(x(e), t),
            ...(t && t.parseFragmentIdentifier && i
              ? { fragmentIdentifier: I(i, t) }
              : {}),
          }
        );
      }
      function M(e, t) {
        t = { encode: !0, strict: !0, [A]: !0, ...t };
        const n = k(e.url).split("?")[0] || "";
        let r = R({ ...N(x(e.url), { sort: !1 }), ...e.query }, t);
        r && (r = "?".concat(r));
        let s = (function (e) {
          let t = "";
          const n = e.indexOf("#");
          return -1 !== n && (t = e.slice(n)), t;
        })(e.url);
        if (e.fragmentIdentifier) {
          const r = new URL(n);
          (r.hash = e.fragmentIdentifier),
            (s = t[A] ? r.hash : "#".concat(e.fragmentIdentifier));
        }
        return "".concat(n).concat(r).concat(s);
      }
      function j(e, t, n) {
        n = { parseFragmentIdentifier: !0, [A]: !1, ...n };
        const { url: r, query: s, fragmentIdentifier: i } = D(e, n);
        return M({ url: r, query: S(s, t), fragmentIdentifier: i }, n);
      }
      function L(e, t, n) {
        return j(
          e,
          Array.isArray(t) ? (e) => !t.includes(e) : (e, n) => !t(e, n),
          n
        );
      }
      const U = e;
      var F = n(503),
        B = n.n(F),
        V = (function () {
          function e() {}
          return (
            (e.prototype.getApplicationContext = function () {
              return {
                versionName: this.versionName,
                language: q(),
                platform: "Web",
                os: void 0,
                deviceModel: void 0,
              };
            }),
            e
          );
        })(),
        q = function () {
          return (
            ("undefined" !== typeof navigator &&
              ((navigator.languages && navigator.languages[0]) ||
                navigator.language)) ||
            ""
          );
        },
        H = (function () {
          function e() {
            this.queue = [];
          }
          return (
            (e.prototype.logEvent = function (e) {
              this.receiver
                ? this.receiver(e)
                : this.queue.length < 512 && this.queue.push(e);
            }),
            (e.prototype.setEventReceiver = function (e) {
              (this.receiver = e),
                this.queue.length > 0 &&
                  (this.queue.forEach(function (t) {
                    e(t);
                  }),
                  (this.queue = []));
            }),
            e
          );
        })(),
        W = function () {
          return (
            (W =
              Object.assign ||
              function (e) {
                for (var t, n = 1, r = arguments.length; n < r; n++)
                  for (var s in (t = arguments[n]))
                    Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
                return e;
              }),
            W.apply(this, arguments)
          );
        },
        K = function (e, t) {
          var n = typeof e;
          if (n !== typeof t) return !1;
          for (
            var r = 0, s = ["string", "number", "boolean", "undefined"];
            r < s.length;
            r++
          ) {
            if (s[r] === n) return e === t;
          }
          if (null == e && null == t) return !0;
          if (null == e || null == t) return !1;
          if (e.length !== t.length) return !1;
          var i = Array.isArray(e),
            o = Array.isArray(t);
          if (i !== o) return !1;
          if (!i || !o) {
            var a = Object.keys(e).sort(),
              c = Object.keys(t).sort();
            if (!K(a, c)) return !1;
            var l = !0;
            return (
              Object.keys(e).forEach(function (n) {
                K(e[n], t[n]) || (l = !1);
              }),
              l
            );
          }
          for (var u = 0; u < e.length; u++) if (!K(e[u], t[u])) return !1;
          return !0;
        };
      Object.entries ||
        (Object.entries = function (e) {
          for (var t = Object.keys(e), n = t.length, r = new Array(n); n--; )
            r[n] = [t[n], e[t[n]]];
          return r;
        });
      var z = (function () {
          function e() {
            (this.identity = { userProperties: {} }),
              (this.listeners = new Set());
          }
          return (
            (e.prototype.editIdentity = function () {
              var e = this,
                t = W({}, this.identity.userProperties),
                n = W(W({}, this.identity), { userProperties: t });
              return {
                setUserId: function (e) {
                  return (n.userId = e), this;
                },
                setDeviceId: function (e) {
                  return (n.deviceId = e), this;
                },
                setUserProperties: function (e) {
                  return (n.userProperties = e), this;
                },
                setOptOut: function (e) {
                  return (n.optOut = e), this;
                },
                updateUserProperties: function (e) {
                  for (
                    var t = n.userProperties || {},
                      r = 0,
                      s = Object.entries(e);
                    r < s.length;
                    r++
                  ) {
                    var i = s[r],
                      o = i[0],
                      a = i[1];
                    switch (o) {
                      case "$set":
                        for (
                          var c = 0, l = Object.entries(a);
                          c < l.length;
                          c++
                        ) {
                          var u = l[c],
                            d = u[0],
                            h = u[1];
                          t[d] = h;
                        }
                        break;
                      case "$unset":
                        for (var p = 0, f = Object.keys(a); p < f.length; p++) {
                          delete t[(d = f[p])];
                        }
                        break;
                      case "$clearAll":
                        t = {};
                    }
                  }
                  return (n.userProperties = t), this;
                },
                commit: function () {
                  return e.setIdentity(n), this;
                },
              };
            }),
            (e.prototype.getIdentity = function () {
              return W({}, this.identity);
            }),
            (e.prototype.setIdentity = function (e) {
              var t = W({}, this.identity);
              (this.identity = W({}, e)),
                K(t, this.identity) ||
                  this.listeners.forEach(function (t) {
                    t(e);
                  });
            }),
            (e.prototype.addIdentityListener = function (e) {
              this.listeners.add(e);
            }),
            (e.prototype.removeIdentityListener = function (e) {
              this.listeners.delete(e);
            }),
            e
          );
        })(),
        G =
          "undefined" !== typeof globalThis
            ? globalThis
            : "undefined" !== typeof n.g
            ? n.g
            : self,
        J = (function () {
          function e() {
            (this.identityStore = new z()),
              (this.eventBridge = new H()),
              (this.applicationContextProvider = new V());
          }
          return (
            (e.getInstance = function (t) {
              return (
                G.analyticsConnectorInstances ||
                  (G.analyticsConnectorInstances = {}),
                G.analyticsConnectorInstances[t] ||
                  (G.analyticsConnectorInstances[t] = new e()),
                G.analyticsConnectorInstances[t]
              );
            }),
            e
          );
        })();
      function Q(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(e);
          t &&
            (r = r.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function Y(e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = null != arguments[t] ? arguments[t] : {};
          t % 2
            ? Q(Object(n), !0).forEach(function (t) {
                te(e, t, n[t]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : Q(Object(n)).forEach(function (t) {
                Object.defineProperty(
                  e,
                  t,
                  Object.getOwnPropertyDescriptor(n, t)
                );
              });
        }
        return e;
      }
      function X(e) {
        return (
          (X =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e &&
                    "function" == typeof Symbol &&
                    e.constructor === Symbol &&
                    e !== Symbol.prototype
                    ? "symbol"
                    : typeof e;
                }),
          X(e)
        );
      }
      function Z(e, t) {
        if (!(e instanceof t))
          throw new TypeError("Cannot call a class as a function");
      }
      function $(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(e, ie(r.key), r);
        }
      }
      function ee(e, t, n) {
        return (
          t && $(e.prototype, t),
          n && $(e, n),
          Object.defineProperty(e, "prototype", { writable: !1 }),
          e
        );
      }
      function te(e, t, n) {
        return (
          (t = ie(t)) in e
            ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[t] = n),
          e
        );
      }
      function ne(e) {
        return (
          (function (e) {
            if (Array.isArray(e)) return se(e);
          })(e) ||
          (function (e) {
            if (
              ("undefined" !== typeof Symbol && null != e[Symbol.iterator]) ||
              null != e["@@iterator"]
            )
              return Array.from(e);
          })(e) ||
          re(e) ||
          (function () {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
      function re(e, t) {
        if (e) {
          if ("string" === typeof e) return se(e, t);
          var n = Object.prototype.toString.call(e).slice(8, -1);
          return (
            "Object" === n && e.constructor && (n = e.constructor.name),
            "Map" === n || "Set" === n
              ? Array.from(e)
              : "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? se(e, t)
              : void 0
          );
        }
      }
      function se(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
        return r;
      }
      function ie(e) {
        var t = (function (e, t) {
          if ("object" !== typeof e || null === e) return e;
          var n = e[Symbol.toPrimitive];
          if (void 0 !== n) {
            var r = n.call(e, t || "default");
            if ("object" !== typeof r) return r;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t ? String : Number)(e);
        })(e, "string");
        return "symbol" === typeof t ? t : String(t);
      }
      var oe = "$default_instance",
        ae = 2,
        ce = 4096,
        le = 1e3,
        ue = "$identify",
        de = "$groupidentify",
        he = "api.amplitude.com",
        pe = "api.eu.amplitude.com",
        fe = "regionconfig.amplitude.com",
        me = "regionconfig.eu.amplitude.com",
        ge = 0,
        ve = 1,
        ye = 2,
        be = 3,
        we = 4,
        Se = 5,
        _e = 6,
        Ee = 7,
        Ae = "amp_cookie_test",
        Te = "amp",
        Pe = "",
        Ie = "cookies",
        Ce = "none",
        ke = "localStorage",
        Oe = "sessionStorage",
        xe = "revenue_amount",
        Ne = "$productId",
        Re = "$quantity",
        De = "$price",
        Me = "$revenueType",
        je = "amp_device_id",
        Le = "amp_referrer",
        Ue = "referrer",
        Fe = "referring_domain",
        Be = "utm_source",
        Ve = "utm_medium",
        qe = "utm_campaign",
        He = "utm_term",
        We = "utm_content",
        Ke = "[Amplitude] Attribution Captured",
        ze = "http",
        Ge = "beacon",
        Je = function (e) {
          for (var t = "", n = 0; n < e.length; n++) {
            var r = e.charCodeAt(n);
            r < 128
              ? (t += String.fromCharCode(r))
              : r > 127 && r < 2048
              ? ((t += String.fromCharCode((r >> 6) | 192)),
                (t += String.fromCharCode((63 & r) | 128)))
              : ((t += String.fromCharCode((r >> 12) | 224)),
                (t += String.fromCharCode(((r >> 6) & 63) | 128)),
                (t += String.fromCharCode((63 & r) | 128)));
          }
          return t;
        },
        Qe = function (e) {
          for (var t = "", n = 0, r = 0, s = 0, i = 0; n < e.length; )
            (r = e.charCodeAt(n)) < 128
              ? ((t += String.fromCharCode(r)), n++)
              : r > 191 && r < 224
              ? ((s = e.charCodeAt(n + 1)),
                (t += String.fromCharCode(((31 & r) << 6) | (63 & s))),
                (n += 2))
              : ((s = e.charCodeAt(n + 1)),
                (i = e.charCodeAt(n + 2)),
                (t += String.fromCharCode(
                  ((15 & r) << 12) | ((63 & s) << 6) | (63 & i)
                )),
                (n += 3));
          return t;
        },
        Ye =
          "undefined" !== typeof globalThis
            ? globalThis
            : "undefined" !== typeof window
            ? window
            : "undefined" !== typeof self
            ? self
            : "undefined" !== typeof n.g
            ? n.g
            : void 0,
        Xe = {
          _keyStr:
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          encode: function (e) {
            try {
              if (Ye.btoa && Ye.atob)
                return Ye.btoa(unescape(encodeURIComponent(e)));
            } catch (a_) {}
            return Xe._encode(e);
          },
          _encode: function (e) {
            var t,
              n,
              r,
              s,
              i,
              o,
              a,
              c = "",
              l = 0;
            for (e = Je(e); l < e.length; )
              (s = (t = e.charCodeAt(l++)) >> 2),
                (i = ((3 & t) << 4) | ((n = e.charCodeAt(l++)) >> 4)),
                (o = ((15 & n) << 2) | ((r = e.charCodeAt(l++)) >> 6)),
                (a = 63 & r),
                isNaN(n) ? (o = a = 64) : isNaN(r) && (a = 64),
                (c =
                  c +
                  Xe._keyStr.charAt(s) +
                  Xe._keyStr.charAt(i) +
                  Xe._keyStr.charAt(o) +
                  Xe._keyStr.charAt(a));
            return c;
          },
          decode: function (e) {
            try {
              if (Ye.btoa && Ye.atob)
                return decodeURIComponent(escape(Ye.atob(e)));
            } catch (a_) {}
            return Xe._decode(e);
          },
          _decode: function (e) {
            var t,
              n,
              r,
              s,
              i,
              o,
              a = "",
              c = 0;
            for (e = e.replace(/[^A-Za-z0-9+/=]/g, ""); c < e.length; )
              (t =
                (Xe._keyStr.indexOf(e.charAt(c++)) << 2) |
                ((s = Xe._keyStr.indexOf(e.charAt(c++))) >> 4)),
                (n =
                  ((15 & s) << 4) |
                  ((i = Xe._keyStr.indexOf(e.charAt(c++))) >> 2)),
                (r = ((3 & i) << 6) | (o = Xe._keyStr.indexOf(e.charAt(c++)))),
                (a += String.fromCharCode(t)),
                64 !== i && (a += String.fromCharCode(n)),
                64 !== o && (a += String.fromCharCode(r));
            return (a = Qe(a));
          },
        },
        Ze = Object.prototype.toString;
      function $e(e) {
        switch (Ze.call(e)) {
          case "[object Date]":
            return "date";
          case "[object RegExp]":
            return "regexp";
          case "[object Arguments]":
            return "arguments";
          case "[object Array]":
            return "array";
          case "[object Error]":
            return "error";
        }
        return null === e
          ? "null"
          : void 0 === e
          ? "undefined"
          : e !== e
          ? "nan"
          : e && 1 === e.nodeType
          ? "element"
          : "undefined" !== typeof Buffer &&
            "function" === typeof Buffer.isBuffer &&
            Buffer.isBuffer(e)
          ? "buffer"
          : X(
              (e = e.valueOf ? e.valueOf() : Object.prototype.valueOf.apply(e))
            );
      }
      var et,
        tt = { DISABLE: 0, ERROR: 1, WARN: 2, INFO: 3 },
        nt = tt.WARN,
        rt = {
          error: function (e) {
            nt >= tt.ERROR && st(e);
          },
          warn: function (e) {
            nt >= tt.WARN && st(e);
          },
          info: function (e) {
            nt >= tt.INFO && st(e);
          },
        },
        st = function (e) {
          try {
            console.log("[Amplitude] " + e);
          } catch (a_) {}
        },
        it = function (e) {
          return "string" === $e(e) && e.length > ce ? e.substring(0, ce) : e;
        },
        ot = function (e, t, n) {
          return (
            $e(e) === n ||
            (rt.error(
              "Invalid " +
                t +
                " input type. Expected " +
                n +
                " but received " +
                $e(e)
            ),
            !1)
          );
        },
        at = function (e) {
          var t = $e(e);
          if ("object" !== t)
            return (
              rt.error(
                "Error: invalid properties format. Expecting Javascript object, received " +
                  t +
                  ", ignoring"
              ),
              {}
            );
          if (Object.keys(e).length > le)
            return (
              rt.error("Error: too many properties (more than 1000), ignoring"),
              {}
            );
          var n = {};
          for (var r in e)
            if (Object.prototype.hasOwnProperty.call(e, r)) {
              var s = r,
                i = $e(s);
              "string" !== i &&
                ((s = String(s)),
                rt.warn(
                  "WARNING: Non-string property key, received type " +
                    i +
                    ', coercing to string "' +
                    s +
                    '"'
                ));
              var o = lt(s, e[r]);
              null !== o && (n[s] = o);
            }
          return n;
        },
        ct = ["nan", "function", "arguments", "regexp", "element"],
        lt = function e(t, n) {
          var r = $e(n);
          if (-1 !== ct.indexOf(r))
            rt.warn(
              'WARNING: Property key "' +
                t +
                '" with invalid value type ' +
                r +
                ", ignoring"
            ),
              (n = null);
          else if ("undefined" === r) n = null;
          else if ("error" === r)
            (n = String(n)),
              rt.warn(
                'WARNING: Property key "' +
                  t +
                  '" with value type error, coercing to ' +
                  n
              );
          else if ("array" === r) {
            for (var s = [], i = 0; i < n.length; i++) {
              var o = n[i],
                a = $e(o);
              "array" !== a
                ? "object" === a
                  ? s.push(at(o))
                  : s.push(e(t, o))
                : rt.warn(
                    "WARNING: Cannot have " +
                      a +
                      " nested in an array property value, skipping"
                  );
            }
            n = s;
          } else "object" === r && (n = at(n));
          return n;
        },
        ut = function (e, t) {
          var n = $e(t);
          if ("string" === n) return t;
          if ("date" === n || "number" === n || "boolean" === n)
            return (
              (t = String(t)),
              rt.warn(
                "WARNING: Non-string groupName, received type " +
                  n +
                  ', coercing to string "' +
                  t +
                  '"'
              ),
              t
            );
          if ("array" === n) {
            for (var r = [], s = 0; s < t.length; s++) {
              var i = t[s],
                o = $e(i);
              "array" !== o && "object" !== o
                ? "string" === o
                  ? r.push(i)
                  : ("date" !== o && "number" !== o && "boolean" !== o) ||
                    ((i = String(i)),
                    rt.warn(
                      "WARNING: Non-string groupName, received type " +
                        o +
                        ', coercing to string "' +
                        i +
                        '"'
                    ),
                    r.push(i))
                : rt.warn(
                    "WARNING: Skipping nested " + o + " in array groupName"
                  );
            }
            return r;
          }
          rt.warn(
            "WARNING: Non-string groupName, received type " +
              n +
              ". Please use strings or array of strings for groupName"
          );
        },
        dt = function (e) {
          Object.prototype.hasOwnProperty.call(tt, e) && (nt = tt[e]);
        },
        ht = rt,
        pt = function (e) {
          return !e || 0 === e.length;
        },
        ft = function () {
          return "undefined" !== typeof WorkerGlobalScope;
        },
        mt = function (e, t) {
          e = e.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
          var n = new RegExp("[\\?&]" + e + "=([^&#]*)").exec(t);
          return null === n
            ? void 0
            : decodeURIComponent(n[1].replace(/\+/g, " "));
        },
        gt = function e(t) {
          if ("array" === $e(t))
            for (var n = 0; n < t.length; n++) t[n] = e(t[n]);
          else if ("object" === $e(t))
            for (var r in t) r in t && (t[r] = e(t[r]));
          else t = it(t);
          return t;
        },
        vt = function (e) {
          var t = $e(e);
          if ("object" !== t)
            return (
              rt.error(
                "Error: invalid groups format. Expecting Javascript object, received " +
                  t +
                  ", ignoring"
              ),
              {}
            );
          var n = {};
          for (var r in e)
            if (Object.prototype.hasOwnProperty.call(e, r)) {
              var s = r,
                i = $e(s);
              "string" !== i &&
                ((s = String(s)),
                rt.warn(
                  "WARNING: Non-string groupType, received type " +
                    i +
                    ', coercing to string "' +
                    s +
                    '"'
                ));
              var o = ut(s, e[r]);
              null !== o && (n[s] = o);
            }
          return n;
        },
        yt = ot,
        bt = at,
        wt = function (e) {
          return (
            !!ot(e, "deviceId", "string") &&
            (!(e.indexOf(".") >= 0) ||
              (rt.error(
                "Device IDs may not contain '.' characters. Value will be ignored: \"".concat(
                  e,
                  '"'
                )
              ),
              !1))
          );
        },
        St = function (e) {
          return (
            !!ot(e, "transport", "string") &&
            (e !== ze && e !== Ge
              ? (rt.error(
                  "transport value must be one of '"
                    .concat(Ge, "' or '")
                    .concat(ze, "'")
                ),
                !1)
              : !(
                  e !== ze &&
                  "undefined" !== typeof navigator &&
                  !navigator.sendBeacon
                ) ||
                (rt.error(
                  "browser does not support sendBeacon, so transport must be HTTP"
                ),
                !1))
          );
        },
        _t = function (e) {
          return (
            !!(ot(e, "sessionId", "number") && new Date(e).getTime() > 0) ||
            (rt.error(
              "sessionId value must in milliseconds since epoch (Unix Timestamp)"
            ),
            !1)
          );
        },
        Et = function () {
          return Ye.location;
        },
        At = function (e) {
          var t = Ye.location ? Ye.location.hostname : "";
          if (e) {
            if ("undefined" !== typeof document) {
              var n = document.createElement("a");
              return (n.href = e), n.hostname || t;
            }
            if ("function" === typeof URL) return new URL(e).hostname || t;
          }
          return t;
        },
        Tt = function (e) {
          try {
            for (
              var t = document.cookie.split(";"), n = null, r = 0;
              r < t.length;
              r++
            ) {
              for (var s = t[r]; " " === s.charAt(0); )
                s = s.substring(1, s.length);
              if (0 === s.indexOf(e)) {
                n = s.substring(e.length, s.length);
                break;
              }
            }
            return n;
          } catch (a_) {
            return null;
          }
        },
        Pt = function (e, t, n) {
          var r = null !== t ? n.expirationDays : -1;
          if (r) {
            var s = new Date();
            s.setTime(s.getTime() + 24 * r * 60 * 60 * 1e3), (r = s);
          }
          var i = e + "=" + t;
          r && (i += "; expires=" + r.toUTCString()),
            (i += "; path=/"),
            n.domain && (i += "; domain=" + n.domain),
            n.secure && (i += "; Secure"),
            n.sameSite && (i += "; SameSite=" + n.sameSite),
            (document.cookie = i);
        },
        It = function () {
          var e,
            t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : "",
            n = t.split(".")[we];
          return (
            n && (e = parseInt(n, 32)),
            e || (ht.warn("unable to parse malformed cookie: ".concat(t)), 0)
          );
        },
        Ct = Pt,
        kt = Tt,
        Ot = function (e) {
          try {
            var t,
              n = document.cookie.split(";").map(function (e) {
                return e.trimStart();
              }),
              r = [],
              s = (function (e, t) {
                var n =
                  ("undefined" !== typeof Symbol && e[Symbol.iterator]) ||
                  e["@@iterator"];
                if (!n) {
                  if (
                    Array.isArray(e) ||
                    (n = re(e)) ||
                    (t && e && "number" === typeof e.length)
                  ) {
                    n && (e = n);
                    var r = 0,
                      s = function () {};
                    return {
                      s: s,
                      n: function () {
                        return r >= e.length
                          ? { done: !0 }
                          : { done: !1, value: e[r++] };
                      },
                      e: function (e) {
                        throw e;
                      },
                      f: s,
                    };
                  }
                  throw new TypeError(
                    "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                }
                var i,
                  o = !0,
                  a = !1;
                return {
                  s: function () {
                    n = n.call(e);
                  },
                  n: function () {
                    var e = n.next();
                    return (o = e.done), e;
                  },
                  e: function (e) {
                    (a = !0), (i = e);
                  },
                  f: function () {
                    try {
                      o || null == n.return || n.return();
                    } finally {
                      if (a) throw i;
                    }
                  },
                };
              })(n);
            try {
              for (s.s(); !(t = s.n()).done; ) {
                for (var i = t.value; " " === i.charAt(0); ) i = i.substring(1);
                0 === i.indexOf(e) && r.push(i.substring(e.length));
              }
            } catch (o) {
              s.e(o);
            } finally {
              s.f();
            }
            return r;
          } catch (a_) {
            return [];
          }
        },
        xt = function (e) {
          return ne(e).sort(function (e, t) {
            var n = It(e);
            return It(t) - n;
          });
        },
        Nt = function () {
          var e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = Ae;
          if ("undefined" === typeof document) return !1;
          var n = !1;
          try {
            var r = String(Date.now());
            Pt(t, r, e),
              ht.info("Testing if cookies available"),
              (n = Tt(t + "=") === r);
          } catch (a_) {
            ht.warn(
              'Error thrown when checking for cookies. Reason: "'.concat(
                a_,
                '"'
              )
            );
          } finally {
            ht.info("Cleaning up cookies availability test"), Pt(t, null, e);
          }
          return n;
        },
        Rt = function () {
          for (var e = "", t = 0; t < 22; ++t)
            e +=
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".charAt(
                Math.floor(64 * Math.random())
              );
          return e;
        },
        Dt = function (e) {
          var t = At(e).split("."),
            n = [],
            r = "_tldtest_" + Rt();
          if (ft()) return "";
          for (var s = t.length - 2; s >= 0; --s) n.push(t.slice(s).join("."));
          for (var i = 0; i < n.length; ++i) {
            var o = n[i],
              a = { domain: "." + o };
            if ((Ct(r, 1, a), kt(r))) return Ct(r, null, a), o;
          }
          return "";
        },
        Mt = { expirationDays: void 0, domain: void 0 },
        jt = function (e) {
          var t = "";
          return (
            Mt.domain &&
              (t =
                "." === Mt.domain.charAt(0)
                  ? Mt.domain.substring(1)
                  : Mt.domain),
            e + t
          );
        },
        Lt = function (e) {
          var t = jt(e) + "=",
            n = kt(t);
          try {
            if (n) return JSON.parse(Xe.decode(n));
          } catch (a_) {
            return null;
          }
          return null;
        },
        Ut = function (e, t) {
          try {
            return Ct(jt(e), Xe.encode(JSON.stringify(t)), Mt), !0;
          } catch (a_) {
            return !1;
          }
        },
        Ft = function (e) {
          try {
            return Ct(jt(e), null, Mt), !0;
          } catch (a_) {
            return !1;
          }
        },
        Bt = {
          reset: function () {
            Mt = { expirationDays: void 0, domain: void 0 };
          },
          options: function (e) {
            if (0 === arguments.length) return Mt;
            (e = e || {}),
              (Mt.expirationDays = e.expirationDays),
              (Mt.secure = e.secure),
              (Mt.sameSite = e.sameSite);
            var t = pt(e.domain) ? "." + Dt(Et().href) : e.domain,
              n = Math.random();
            (Mt.domain = t), Ut("amplitude_test", n);
            var r = Lt("amplitude_test");
            return (
              (r && r === n) || (t = null),
              Ft("amplitude_test"),
              (Mt.domain = t),
              Mt
            );
          },
          get: Lt,
          set: Ut,
          remove: Ft,
          setRaw: function (e, t) {
            try {
              return Ct(jt(e), t, Mt), !0;
            } catch (a_) {
              return !1;
            }
          },
          getRaw: function (e) {
            var t = jt(e) + "=";
            return kt(t);
          },
        },
        Vt = (function () {
          function e() {
            Z(this, e), (this.map = new Map()), (this.length = 0);
          }
          return (
            ee(e, [
              {
                key: "key",
                value: function (e) {
                  var t = Array.from(this.map.keys())[e];
                  return this.map.get(t);
                },
              },
              {
                key: "getItem",
                value: function (e) {
                  return this.map.get(e);
                },
              },
              {
                key: "setItem",
                value: function (e, t) {
                  this.map.has(e) || (this.length += 1), this.map.set(e, t);
                },
              },
              {
                key: "removeItem",
                value: function (e) {
                  this.map.has(e) && ((this.length -= 1), this.map.delete(e));
                },
              },
              {
                key: "clear",
                value: function () {
                  this.map.clear(), (this.length = 0);
                },
              },
            ]),
            e
          );
        })();
      if (
        (function () {
          var e,
            t = new Date();
          try {
            return (
              Ye.localStorage.setItem(t, t),
              (e = Ye.localStorage.getItem(t) === String(t)),
              Ye.localStorage.removeItem(t),
              e
            );
          } catch (a_) {}
          return !1;
        })()
      )
        et = Ye.localStorage;
      else if ("undefined" !== typeof Ye && Ye.globalStorage)
        try {
          et = Ye.globalStorage[Ye.location.hostname];
        } catch (a_) {}
      else if ("undefined" !== typeof document) {
        var qt = document.createElement("div"),
          Ht = "localStorage";
        (qt.style.display = "none"),
          document.getElementsByTagName("head")[0].appendChild(qt),
          qt.addBehavior &&
            (qt.addBehavior("#default#userdata"),
            (et = {
              length: 0,
              setItem: function (e, t) {
                qt.load(Ht),
                  qt.getAttribute(e) || this.length++,
                  qt.setAttribute(e, t),
                  qt.save(Ht);
              },
              getItem: function (e) {
                return qt.load(Ht), qt.getAttribute(e);
              },
              removeItem: function (e) {
                qt.load(Ht),
                  qt.getAttribute(e) && this.length--,
                  qt.removeAttribute(e),
                  qt.save(Ht);
              },
              clear: function () {
                qt.load(Ht);
                for (
                  var e, t = 0;
                  (e = qt.XMLDocument.documentElement.attributes[t++]);

                )
                  qt.removeAttribute(e.name);
                qt.save(Ht), (this.length = 0);
              },
              key: function (e) {
                return (
                  qt.load(Ht), qt.XMLDocument.documentElement.attributes[e]
                );
              },
            }),
            qt.load(Ht),
            (et.length = qt.XMLDocument.documentElement.attributes.length));
      } else ft() && (et = new Vt());
      et ||
        (et = {
          length: 0,
          setItem: function (e, t) {},
          getItem: function (e) {},
          removeItem: function (e) {},
          clear: function () {},
          key: function (e) {},
        });
      var Wt,
        Kt = et,
        zt = function () {
          this.storage = null;
        };
      zt.prototype.getStorage = function (e) {
        if (null !== this.storage) return this.storage;
        if (!e && Nt()) this.storage = Bt;
        else {
          var t = "amp_cookiestore_";
          this.storage = {
            _options: { expirationDays: void 0, domain: void 0, secure: !1 },
            reset: function () {
              this._options = {
                expirationDays: void 0,
                domain: void 0,
                secure: !1,
              };
            },
            options: function (e) {
              return 0 === arguments.length
                ? this._options
                : ((e = e || {}),
                  (this._options.expirationDays =
                    e.expirationDays || this._options.expirationDays),
                  (this._options.domain =
                    e.domain ||
                    this._options.domain ||
                    (Ye && Ye.location && Ye.location.hostname)),
                  (this._options.secure = e.secure || !1));
            },
            get: function (e) {
              try {
                return JSON.parse(Kt.getItem(t + e));
              } catch (a_) {}
              return null;
            },
            set: function (e, n) {
              try {
                return Kt.setItem(t + e, JSON.stringify(n)), !0;
              } catch (a_) {}
              return !1;
            },
            remove: function (e) {
              try {
                Kt.removeItem(t + e);
              } catch (a_) {
                return !1;
              }
            },
          };
        }
        return this.storage;
      };
      var Gt =
          (te((Wt = {}), Ie, !0),
          te(Wt, Ce, !0),
          te(Wt, ke, !0),
          te(Wt, Oe, !0),
          Wt),
        Jt = (function () {
          function e(t) {
            var n = t.storageKey,
              r = t.disableCookies,
              s = t.domain,
              i = t.secure,
              o = t.sameSite,
              a = t.expirationDays,
              c = t.storage;
            Z(this, e),
              (this.storageKey = n),
              (this.domain = s),
              (this.secure = i),
              (this.sameSite = o),
              (this.expirationDays = a),
              (this.cookieDomain = "");
            var l = Et() ? Et().href : void 0,
              u = r ? "" : Dt(l);
            if (((this.cookieDomain = s || (u ? "." + u : null)), Gt[c]))
              this.storage = c;
            else {
              var d =
                r ||
                !Nt({
                  domain: this.cookieDomain,
                  secure: this.secure,
                  sameSite: this.sameSite,
                  expirationDays: this.expirationDays,
                });
              this.storage = d ? ke : Ie;
            }
          }
          return (
            ee(e, [
              {
                key: "getCookieStorageKey",
                value: function () {
                  if (!this.domain) return this.storageKey;
                  var e =
                    "." === this.domain.charAt(0)
                      ? this.domain.substring(1)
                      : this.domain;
                  return ""
                    .concat(this.storageKey)
                    .concat(e ? "_".concat(e) : "");
                },
              },
              {
                key: "save",
                value: function (e) {
                  var t = e.deviceId,
                    n = e.userId,
                    r = e.optOut,
                    s = e.sessionId,
                    i = e.lastEventTime,
                    o = e.eventId,
                    a = e.identifyId,
                    c = e.sequenceNumber;
                  if (this.storage !== Ce) {
                    var l = [
                      t,
                      Xe.encode(n || ""),
                      r ? "1" : "",
                      s ? s.toString(32) : "0",
                      i ? i.toString(32) : "0",
                      o ? o.toString(32) : "0",
                      a ? a.toString(32) : "0",
                      c ? c.toString(32) : "0",
                    ].join(".");
                    switch (this.storage) {
                      case Oe:
                        Ye.sessionStorage &&
                          Ye.sessionStorage.setItem(this.storageKey, l);
                        break;
                      case ke:
                        Kt.setItem(this.storageKey, l);
                        break;
                      case Ie:
                        this.saveCookie(l);
                    }
                  }
                },
              },
              {
                key: "saveCookie",
                value: function (e) {
                  Ct(this.getCookieStorageKey(), e, {
                    domain: this.cookieDomain,
                    secure: this.secure,
                    sameSite: this.sameSite,
                    expirationDays: this.expirationDays,
                  });
                },
              },
              {
                key: "load",
                value: function () {
                  var e,
                    t = this;
                  if (this.storage === Ie) {
                    var n = this.getCookieStorageKey() + "=",
                      r = Ot(n);
                    if (0 === r.length || 1 === r.length) e = r[0];
                    else {
                      var s = xt(r)[0];
                      r.forEach(function () {
                        return Ct(t.getCookieStorageKey(), null, {});
                      }),
                        this.saveCookie(s),
                        (e = kt(n));
                    }
                  }
                  if ((e || (e = Kt.getItem(this.storageKey)), !e))
                    try {
                      e =
                        Ye.sessionStorage &&
                        Ye.sessionStorage.getItem(this.storageKey);
                    } catch (a_) {
                      ht.info(
                        'window.sessionStorage unavailable. Reason: "'.concat(
                          a_,
                          '"'
                        )
                      );
                    }
                  if (!e) return null;
                  var i = e.split("."),
                    o = null;
                  if (i[ve])
                    try {
                      o = Xe.decode(i[ve]);
                    } catch (a_) {
                      o = null;
                    }
                  return {
                    deviceId: i[ge],
                    userId: o,
                    optOut: "1" === i[ye],
                    sessionId: parseInt(i[be], 32),
                    lastEventTime: parseInt(i[we], 32),
                    eventId: parseInt(i[Se], 32),
                    identifyId: parseInt(i[_e], 32),
                    sequenceNumber: parseInt(i[Ee], 32),
                  };
                },
              },
              {
                key: "clear",
                value: function () {
                  var e;
                  if (
                    (this.storage === Ie &&
                      ((e = kt(this.getCookieStorageKey() + "=")),
                      Ct(this.getCookieStorageKey(), null, {
                        domain: this.cookieDomain,
                        secure: this.secure,
                        sameSite: this.sameSite,
                        expirationDays: 0,
                      })),
                    e || ((e = Kt.getItem(this.storageKey)), Kt.clear()),
                    !e)
                  )
                    try {
                      (e =
                        Ye.sessionStorage &&
                        Ye.sessionStorage.getItem(this.storageKey)),
                        Ye.sessionStorage.clear();
                    } catch (a_) {
                      ht.info(
                        'window.sessionStorage unavailable. Reason: "'.concat(
                          a_,
                          '"'
                        )
                      );
                    }
                  return !!e;
                },
              },
            ]),
            e
          );
        })(),
        Qt = "$clearAll",
        Yt = function () {
          (this.userPropertiesOperations = {}), (this.properties = []);
        };
      (Yt.prototype.add = function (e, t) {
        return (
          "number" === $e(t) || "string" === $e(t)
            ? this._addOperation("$add", e, t)
            : ht.error(
                "Unsupported type for value: " +
                  $e(t) +
                  ", expecting number or string"
              ),
          this
        );
      }),
        (Yt.prototype.append = function (e, t) {
          return this._addOperation("$append", e, t), this;
        }),
        (Yt.prototype.clearAll = function () {
          return Object.keys(this.userPropertiesOperations).length > 0
            ? (Object.prototype.hasOwnProperty.call(
                this.userPropertiesOperations,
                Qt
              ) ||
                ht.error(
                  "Need to send $clearAll on its own Identify object without any other operations, skipping $clearAll"
                ),
              this)
            : ((this.userPropertiesOperations[Qt] = "-"), this);
        }),
        (Yt.prototype.prepend = function (e, t) {
          return this._addOperation("$prepend", e, t), this;
        }),
        (Yt.prototype.set = function (e, t) {
          return this._addOperation("$set", e, t), this;
        }),
        (Yt.prototype.setOnce = function (e, t) {
          return this._addOperation("$setOnce", e, t), this;
        }),
        (Yt.prototype.unset = function (e) {
          return this._addOperation("$unset", e, "-"), this;
        }),
        (Yt.prototype.preInsert = function (e, t) {
          return this._addOperation("$preInsert", e, t), this;
        }),
        (Yt.prototype.postInsert = function (e, t) {
          return this._addOperation("$postInsert", e, t), this;
        }),
        (Yt.prototype.remove = function (e, t) {
          return this._addOperation("$remove", e, t), this;
        }),
        (Yt.prototype._addOperation = function (e, t, n) {
          Object.prototype.hasOwnProperty.call(
            this.userPropertiesOperations,
            Qt
          )
            ? ht.error(
                "This identify already contains a $clearAll operation, skipping operation " +
                  e
              )
            : -1 === this.properties.indexOf(t)
            ? (Object.prototype.hasOwnProperty.call(
                this.userPropertiesOperations,
                e
              ) || (this.userPropertiesOperations[e] = {}),
              (this.userPropertiesOperations[e][t] = n),
              this.properties.push(t))
            : ht.error(
                'User property "' +
                  t +
                  '" already used in this identify, skipping operation ' +
                  e
              );
        });
      var Xt = function (e, t, n) {
        (this.url = e), (this.data = t || {}), (this.headers = n);
      };
      Xt.prototype.send = function (e) {
        if (!!Ye.XDomainRequest) {
          var t = new Ye.XDomainRequest();
          t.open("POST", this.url, !0),
            (t.onload = function () {
              e(200, t.responseText);
            }),
            (t.onerror = function () {
              "Request Entity Too Large" === t.responseText
                ? e(413, t.responseText)
                : e(500, t.responseText);
            }),
            (t.ontimeout = function () {}),
            (t.onprogress = function () {}),
            t.send(U.stringify(this.data));
        } else if ("undefined" !== typeof XMLHttpRequest) {
          var n = new XMLHttpRequest();
          n.open("POST", this.url, !0),
            (n.onreadystatechange = function () {
              4 === n.readyState && e(n.status, n.responseText);
            }),
            (function (e, t) {
              for (var n in t)
                ("Cross-Origin-Resource-Policy" !== n || t[n]) &&
                  e.setRequestHeader(n, t[n]);
            })(n, this.headers),
            n.send(U.stringify(this.data));
        } else {
          var r = void 0;
          fetch(this.url, {
            method: "POST",
            headers: this.headers,
            body: U.stringify(this.data),
          })
            .then(function (e) {
              return (r = e.status), e.text();
            })
            .then(function (t) {
              e(r, t);
            });
        }
      };
      var Zt = function () {
        (this._price = null),
          (this._productId = null),
          (this._quantity = 1),
          (this._revenueType = null),
          (this._properties = null);
      };
      (Zt.prototype.setProductId = function (e) {
        return (
          "string" !== $e(e)
            ? ht.error(
                "Unsupported type for productId: " +
                  $e(e) +
                  ", expecting string"
              )
            : pt(e)
            ? ht.error("Invalid empty productId")
            : (this._productId = e),
          this
        );
      }),
        (Zt.prototype.setQuantity = function (e) {
          return (
            "number" !== $e(e)
              ? ht.error(
                  "Unsupported type for quantity: " +
                    $e(e) +
                    ", expecting number"
                )
              : (this._quantity = parseInt(e)),
            this
          );
        }),
        (Zt.prototype.setPrice = function (e) {
          return (
            "number" !== $e(e)
              ? ht.error(
                  "Unsupported type for price: " + $e(e) + ", expecting number"
                )
              : (this._price = e),
            this
          );
        }),
        (Zt.prototype.setRevenueType = function (e) {
          return (
            "string" !== $e(e)
              ? ht.error(
                  "Unsupported type for revenueType: " +
                    $e(e) +
                    ", expecting string"
                )
              : (this._revenueType = e),
            this
          );
        }),
        (Zt.prototype.setEventProperties = function (e) {
          return (
            "object" !== $e(e)
              ? ht.error(
                  "Unsupported type for eventProperties: " +
                    $e(e) +
                    ", expecting object"
                )
              : (this._properties = bt(e)),
            this
          );
        }),
        (Zt.prototype._isValidRevenue = function () {
          return (
            "number" === $e(this._price) ||
            (ht.error("Invalid revenue, need to set price field"), !1)
          );
        }),
        (Zt.prototype._toJSONObject = function () {
          var e = "object" === $e(this._properties) ? this._properties : {};
          return (
            null !== this._productId && (e[Ne] = this._productId),
            null !== this._quantity && (e[Re] = this._quantity),
            null !== this._price && (e[De] = this._price),
            null !== this._revenueType && (e[Me] = this._revenueType),
            e
          );
        });
      var $t = function e(t) {
          return t
            ? (t ^ ((16 * Math.random()) >> (t / 4))).toString(16)
            : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, e);
        },
        en = "US",
        tn = "EU",
        nn = function (e) {
          var t = he;
          switch (e) {
            case tn:
              t = pe;
              break;
            case en:
              t = he;
          }
          return t;
        },
        rn = "8.21.9",
        sn = {
          apiEndpoint: he,
          batchEvents: !1,
          cookieExpiration: 365,
          cookieName: "amplitude_id",
          sameSiteCookie: "Lax",
          cookieForceUpgrade: !1,
          deferInitialization: !1,
          disableCookies: !1,
          deviceIdFromUrlParam: !1,
          domain: "",
          eventUploadPeriodMillis: 3e4,
          eventUploadThreshold: 30,
          forceHttps: !0,
          includeFbclid: !1,
          includeGclid: !1,
          includeReferrer: !1,
          includeUtm: !1,
          ingestionMetadata: { sourceName: "", sourceVersion: "" },
          language: (function () {
            return (
              ("undefined" !== typeof navigator &&
                ((navigator.languages && navigator.languages[0]) ||
                  navigator.language ||
                  navigator.userLanguage)) ||
              ""
            );
          })(),
          library: { name: "amplitude-js", version: rn },
          logLevel: "WARN",
          logAttributionCapturedEvent: !1,
          optOut: !1,
          onError: function () {},
          onExitPage: function () {},
          onNewSessionStart: function () {},
          plan: { branch: "", source: "", version: "", versionId: "" },
          platform: "Web",
          savedMaxCount: 1e3,
          saveEvents: !0,
          saveParamsReferrerOncePerSession: !0,
          secureCookie: !1,
          sessionTimeout: 18e5,
          storage: Pe,
          trackingOptions: {
            city: !0,
            country: !0,
            carrier: !0,
            device_manufacturer: !0,
            device_model: !0,
            dma: !0,
            ip_address: !0,
            language: !0,
            os_name: !0,
            os_version: !0,
            platform: !0,
            region: !0,
            version_name: !0,
          },
          transport: ze,
          unsetParamsReferrerOnNewSession: !1,
          unsentKey: "amplitude_unsent",
          unsentIdentifyKey: "amplitude_unsent_identify",
          uploadBatchSize: 100,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Cross-Origin-Resource-Policy": "cross-origin",
          },
          serverZone: en,
          useDynamicConfig: !1,
          serverZoneBasedApi: !1,
          sessionId: null,
          partnerId: "",
        },
        on = new ((function () {
          function e() {
            return (
              Z(this, e),
              e.instance ||
                ((this.ingestionEndpoint = he), (e.instance = this)),
              e.instance
            );
          }
          return (
            ee(e, [
              {
                key: "refresh",
                value: function (e, t, n) {
                  var r = "https";
                  t || "https:" === Ye.location.protocol || (r = "http");
                  var s =
                      r +
                      "://" +
                      (function (e) {
                        var t = fe;
                        switch (e) {
                          case tn:
                            t = me;
                            break;
                          case en:
                            t = fe;
                        }
                        return t;
                      })(e),
                    i = this;
                  if (!!Ye.XDomainRequest) {
                    var o = new Ye.XDomainRequest();
                    o.open("GET", s, !0),
                      (o.onload = function () {
                        var e = JSON.parse(o.responseText);
                        (i.ingestionEndpoint = e.ingestionEndpoint), n && n();
                      }),
                      (o.onerror = function () {}),
                      (o.ontimeout = function () {}),
                      (o.onprogress = function () {}),
                      o.send();
                  } else {
                    var a = new XMLHttpRequest();
                    a.open("GET", s, !0),
                      (a.onreadystatechange = function () {
                        if (4 === a.readyState && 200 === a.status) {
                          var e = JSON.parse(a.responseText);
                          (i.ingestionEndpoint = e.ingestionEndpoint), n && n();
                        }
                      }),
                      a.send();
                  }
                },
              },
            ]),
            e
          );
        })())(),
        an = function (e) {
          d() ||
            ft() ||
            ht.warn(
              "amplitude-js will not work in a non-browser environment. If you are planning to add Amplitude to a node environment, please use @amplitude/node"
            ),
            (this._instanceName = pt(e) ? oe : e.toLowerCase()),
            (this._unsentEvents = []),
            (this._unsentIdentifys = []),
            (this.options = Y(
              Y({}, sn),
              {},
              {
                headers: Y({}, sn.headers),
                ingestionMetadata: Y({}, sn.ingestionMetadata),
                library: Y({}, sn.library),
                plan: Y({}, sn.plan),
                trackingOptions: Y({}, sn.trackingOptions),
              }
            )),
            (this._q = []),
            (this._sending = !1),
            (this._updateScheduled = !1),
            (this._onInitCallbacks = []),
            (this._onNewSessionStartCallbacks = []),
            (this._eventId = 0),
            (this._identifyId = 0),
            (this._lastEventTime = null),
            (this._newSession = !1),
            (this._sequenceNumber = 0),
            (this._sessionId = null),
            (this._isInitialized = !1),
            (this._connector = null),
            (this._userAgent =
              ("undefined" !== typeof navigator &&
                navigator &&
                navigator.userAgent) ||
              null),
            (this._ua = new (B())(this._userAgent).getResult());
        };
      (an.prototype.Identify = Yt),
        (an.prototype.Revenue = Zt),
        (an.prototype.init = function (e, t, n, r) {
          var s = this;
          if ("string" !== $e(e) || pt(e))
            ht.error(
              "Invalid apiKey. Please re-initialize with a valid apiKey"
            );
          else
            try {
              (this._connector = J.getInstance(this._instanceName)),
                ln(this.options, n),
                (d() || ft()) &&
                  void 0 !== Ye.Prototype &&
                  Array.prototype.toJSON &&
                  (!(function () {
                    var e;
                    if (d()) {
                      var t = window,
                        n = Array;
                      if (
                        void 0 !== t.Prototype &&
                        void 0 !==
                          (null === (e = n.prototype) || void 0 === e
                            ? void 0
                            : e.toJSON)
                      )
                        return delete n.prototype.toJSON, !0;
                    }
                  })(),
                  ht.warn(
                    "Prototype.js injected Array.prototype.toJSON. Deleting Array.prototype.toJSON to prevent double-stringify"
                  )),
                this.options.cookieName !== sn.cookieName &&
                  ht.warn(
                    "The cookieName option is deprecated. We will be ignoring it for newer cookies"
                  ),
                this.options.serverZoneBasedApi &&
                  (this.options.apiEndpoint = nn(this.options.serverZone)),
                this._refreshDynamicConfig(),
                (this.options.apiKey = e),
                (this._storageSuffix =
                  "_" +
                  e +
                  (this._instanceName === oe ? "" : "_" + this._instanceName)),
                (this._storageSuffixV5 = e.slice(0, 6)),
                (this._oldCookiename =
                  this.options.cookieName + this._storageSuffix),
                (this._unsentKey =
                  this.options.unsentKey + this._storageSuffix),
                (this._unsentIdentifyKey =
                  this.options.unsentIdentifyKey + this._storageSuffix),
                (this._cookieName = Te + "_" + this._storageSuffixV5),
                (this.cookieStorage = new zt().getStorage(
                  this.options.disableCookies
                )),
                this.cookieStorage.options({
                  expirationDays: this.options.cookieExpiration,
                  domain: this.options.domain,
                  secure: this.options.secureCookie,
                  sameSite: this.options.sameSiteCookie,
                }),
                (this._metadataStorage = new Jt({
                  storageKey: this._cookieName,
                  disableCookies: this.options.disableCookies,
                  expirationDays: this.options.cookieExpiration,
                  domain: this.options.domain,
                  secure: this.options.secureCookie,
                  sameSite: this.options.sameSiteCookie,
                  storage: this.options.storage,
                }));
              var i = !!this.cookieStorage.get(this._oldCookiename),
                o = !!this._metadataStorage.load();
              this._useOldCookie = !o && i && !this.options.cookieForceUpgrade;
              var a = o || i;
              if (this.options.deferInitialization && !a)
                return void this._deferInitialization(e, t, n, r);
              (this.options.domain = this.cookieStorage.options().domain),
                "string" === $e(this.options.logLevel) &&
                  dt(this.options.logLevel);
              var c = bn(this);
              (this._apiPropertiesTrackingOptions =
                Object.keys(c).length > 0 ? { tracking_options: c } : {}),
                this.options.cookieForceUpgrade &&
                  i &&
                  (o || dn(this),
                  this.cookieStorage.remove(this._oldCookiename)),
                un(this),
                (this._pendingReadStorage = !0);
              this.options.saveEvents &&
                ((this._unsentEvents = this._loadSavedUnsentEvents(
                  this.options.unsentKey
                )
                  .map(function (e) {
                    return { event: e };
                  })
                  .concat(this._unsentEvents)),
                (this._unsentIdentifys = this._loadSavedUnsentEvents(
                  this.options.unsentIdentifyKey
                )
                  .map(function (e) {
                    return { event: e };
                  })
                  .concat(this._unsentIdentifys))),
                n &&
                  n.onNewSessionStart &&
                  this.onNewSessionStart(this.options.onNewSessionStart),
                (function (e) {
                  n &&
                    n.deviceId &&
                    !wt(n.deviceId) &&
                    (ht.error(
                      'Invalid device ID rejected. Randomly generated UUID will be used instead of "'.concat(
                        n.deviceId,
                        '"'
                      )
                    ),
                    delete n.deviceId),
                    (s.options.deviceId = s._getInitialDeviceId(
                      n && n.deviceId,
                      e
                    )),
                    (s.options.userId =
                      ("string" === $e(t) && !pt(t) && t) ||
                      ("number" === $e(t) && t.toString()) ||
                      s.options.userId ||
                      null);
                  var r = new Date().getTime(),
                    i =
                      !s._sessionId ||
                      !s._lastEventTime ||
                      r - s._lastEventTime > s.options.sessionTimeout ||
                      s.options.sessionId;
                  i &&
                    (s.options.unsetParamsReferrerOnNewSession &&
                      s._unsetUTMParams(),
                    (s._newSession = !0),
                    (s._sessionId = s.options.sessionId || r),
                    (s.options.sessionId = void 0),
                    s.options.saveParamsReferrerOncePerSession &&
                      s._trackParamsAndReferrer()),
                    s.options.saveParamsReferrerOncePerSession ||
                      s._trackParamsAndReferrer(),
                    s.options.saveEvents &&
                      (cn(s._unsentEvents), cn(s._unsentIdentifys)),
                    (s._lastEventTime = r),
                    pn(s),
                    (s._pendingReadStorage = !1),
                    s._sendEventsIfReady();
                  for (var o = 0; o < s._onInitCallbacks.length; o++)
                    s._onInitCallbacks[o](s);
                  (s._onInitCallbacks = []),
                    (s._isInitialized = !0),
                    i && s._runNewSessionStartCallbacks();
                })(),
                this.runQueuedFunctions(),
                "function" === $e(r) && r(this);
              var l = this.options.onExitPage;
              if (
                "function" === $e(l) &&
                Ye.addEventListener &&
                !this.pageHandlersAdded
              ) {
                this.pageHandlersAdded = !0;
                Ye.addEventListener(
                  "pagehide",
                  function () {
                    !(function () {
                      var e = s.options.transport;
                      s.setTransport(Ge), l(), s.setTransport(e);
                    })();
                  },
                  !1
                );
              }
              this._connector.eventBridge.setEventReceiver(function (e) {
                s._logEvent(e.eventType, e.eventProperties, e.userProperties);
              });
              var u = this._connector.identityStore.editIdentity();
              this.options.deviceId && u.setDeviceId(this.options.deviceId),
                this.options.userId && u.setUserId(this.options.userId),
                u.commit();
            } catch (h) {
              ht.error(h), n && "function" === $e(n.onError) && n.onError(h);
            }
        }),
        (an.prototype._runNewSessionStartCallbacks = function () {
          for (var e = 0; e < this._onNewSessionStartCallbacks.length; e++)
            this._onNewSessionStartCallbacks[e](this);
        }),
        (an.prototype.deleteLowerLevelDomainCookies = function () {
          var e = At(),
            t =
              this.options.domain && "." === this.options.domain[0]
                ? this.options.domain.slice(1)
                : this.options.domain;
          if (t && ft() && e !== t && new RegExp(t + "$").test(e)) {
            for (
              var n = e.split("."), r = t.split("."), s = n.length;
              s > r.length;
              --s
            ) {
              var i = n.slice(n.length - s).join(".");
              Ct(this._cookieName, null, { domain: "." + i });
            }
            Ct(this._cookieName, null, {});
          }
        }),
        (an.prototype._getInitialDeviceId = function (e, t) {
          if (e) return e;
          if (this.options.deviceIdFromUrlParam) {
            var n = this._getDeviceIdFromUrlParam(this._getUrlParams());
            if (n) return n;
          }
          return this.options.deviceId ? this.options.deviceId : t || Rt();
        });
      var cn = function (e) {
        for (var t = 0; t < e.length; t++) {
          var n = e[t].event.user_properties,
            r = e[t].event.event_properties,
            s = e[t].event.groups;
          (e[t].event.user_properties = bt(n)),
            (e[t].event.event_properties = bt(r)),
            (e[t].event.groups = vt(s));
        }
      };
      an.prototype._trackParamsAndReferrer = function () {
        var e, t, n, r;
        if (
          (this.options.includeUtm && (e = this._initUtmData()),
          this.options.includeReferrer &&
            (t = this._saveReferrer(this._getReferrer())),
          this.options.includeGclid &&
            (n = this._saveGclid(this._getUrlParams())),
          this.options.includeFbclid &&
            (r = this._saveFbclid(this._getUrlParams())),
          this.options.logAttributionCapturedEvent)
        ) {
          var s = Y(Y(Y(Y({}, e), t), n), r);
          Object.keys(s).length > 0 && this.logEvent(Ke, s);
        }
      };
      var ln = function e(t, n) {
        if ("object" === $e(n)) {
          var r = new Set(["headers"]),
            s = new Set(["eventUploadPeriodMillis"]),
            i = function (r) {
              if (Object.prototype.hasOwnProperty.call(t, r)) {
                var i = n[r],
                  o = $e(t[r]);
                ("transport" !== r || St(i)) &&
                  ("sessionId" !== r || null === i
                    ? yt(i, r + " option", o) &&
                      ("boolean" === o
                        ? (t[r] = !!i)
                        : ("string" === o && !pt(i)) ||
                          ("number" === o &&
                            (i > 0 || (0 === i && s.has(r)))) ||
                          "function" === o
                        ? (t[r] = i)
                        : "object" === o && e(t[r], i))
                    : (t[r] = _t(i) ? i : null));
              }
            };
          for (var o in n)
            r.has(o)
              ? (t[o] = Y(Y({}, t[o]), n[o]))
              : Object.prototype.hasOwnProperty.call(n, o) && i(o);
        }
      };
      (an.prototype.runQueuedFunctions = function () {
        var e = this._q;
        this._q = [];
        for (var t = 0; t < e.length; t++) {
          var n = this[e[t][0]];
          "function" === $e(n) && n.apply(this, e[t].slice(1));
        }
      }),
        (an.prototype._apiKeySet = function (e) {
          return (
            !pt(this.options.apiKey) ||
            (ht.error(
              "Invalid apiKey. Please set a valid apiKey with init() before calling " +
                e
            ),
            !1)
          );
        }),
        (an.prototype._loadSavedUnsentEvents = function (e) {
          var t = this._getFromStorage(Kt, e),
            n = this._parseSavedUnsentEventsString(t, e);
          return this._setInStorage(Kt, e, JSON.stringify(n)), n;
        }),
        (an.prototype._parseSavedUnsentEventsString = function (e, t) {
          if (pt(e)) return [];
          if ("string" === $e(e))
            try {
              var n = JSON.parse(e);
              if ("array" === $e(n)) return n;
            } catch (a_) {}
          return (
            ht.error(
              "Unable to load " + t + " events. Restart with a new empty queue."
            ),
            []
          );
        }),
        (an.prototype.isNewSession = function () {
          return this._newSession;
        }),
        (an.prototype.onInit = function (e) {
          this._isInitialized ? e(this) : this._onInitCallbacks.push(e);
        }),
        (an.prototype.onNewSessionStart = function (e) {
          this._onNewSessionStartCallbacks.push(e);
        }),
        (an.prototype.getSessionId = function () {
          return this._sessionId;
        }),
        (an.prototype.nextEventId = function () {
          return this._eventId++, this._eventId;
        }),
        (an.prototype.nextIdentifyId = function () {
          return this._identifyId++, this._identifyId;
        }),
        (an.prototype.nextSequenceNumber = function () {
          return this._sequenceNumber++, this._sequenceNumber;
        }),
        (an.prototype._unsentCount = function () {
          return this._unsentEvents.length + this._unsentIdentifys.length;
        }),
        (an.prototype._sendEventsIfReady = function () {
          return (
            0 !== this._unsentCount() &&
            (this.options.batchEvents
              ? this._unsentCount() >= this.options.eventUploadThreshold ||
                this.options.transport === Ge
                ? (this.sendEvents(), !0)
                : (this._updateScheduled ||
                    ((this._updateScheduled = !0),
                    setTimeout(
                      function () {
                        (this._updateScheduled = !1), this.sendEvents();
                      }.bind(this),
                      this.options.eventUploadPeriodMillis
                    )),
                  !1)
              : (this.sendEvents(), !0))
          );
        }),
        (an.prototype.clearStorage = function () {
          return this._metadataStorage.clear();
        }),
        (an.prototype._getFromStorage = function (e, t) {
          return e.getItem(t + this._storageSuffix);
        }),
        (an.prototype._setInStorage = function (e, t, n) {
          e.setItem(t + this._storageSuffix, n);
        });
      var un = function (e) {
          if (e._useOldCookie) {
            var t = e.cookieStorage.get(e._oldCookiename);
            "object" !== $e(t) || hn(e, t);
          } else {
            var n = e._metadataStorage.load();
            "object" === $e(n) && hn(e, n);
          }
        },
        dn = function (e) {
          var t = e.cookieStorage.get(e._oldCookiename);
          "object" === $e(t) && (hn(e, t), pn(e));
        },
        hn = function (e, t) {
          t.deviceId && (e.options.deviceId = t.deviceId),
            t.userId && (e.options.userId = t.userId),
            null !== t.optOut &&
              void 0 !== t.optOut &&
              !1 !== t.optOut &&
              (e.options.optOut = t.optOut),
            t.sessionId && (e._sessionId = parseInt(t.sessionId, 10)),
            t.lastEventTime &&
              (e._lastEventTime = parseInt(t.lastEventTime, 10)),
            t.eventId && (e._eventId = parseInt(t.eventId, 10)),
            t.identifyId && (e._identifyId = parseInt(t.identifyId, 10)),
            t.sequenceNumber &&
              (e._sequenceNumber = parseInt(t.sequenceNumber, 10));
        },
        pn = function (e) {
          var t = {
            deviceId: e.options.deviceId,
            userId: e.options.userId,
            optOut: e.options.optOut,
            sessionId: e._sessionId,
            lastEventTime: e._lastEventTime,
            eventId: e._eventId,
            identifyId: e._identifyId,
            sequenceNumber: e._sequenceNumber,
          };
          e._useOldCookie
            ? e.cookieStorage.set(e.options.cookieName + e._storageSuffix, t)
            : e._metadataStorage.save(t);
        };
      (an.prototype._initUtmData = function (e, t) {
        e = e || this._getUrlParams();
        var n = (function (e, t) {
          var n = e ? "?" + e.split(".").slice(-1)[0].replace(/\|/g, "&") : "",
            r = function (e, t, n, r) {
              return mt(e, t) || mt(n, r);
            },
            s = r(Be, t, "utmcsr", n),
            i = r(Ve, t, "utmcmd", n),
            o = r(qe, t, "utmccn", n),
            a = r(He, t, "utmctr", n),
            c = r(We, t, "utmcct", n),
            l = {},
            u = function (e, t) {
              pt(t) || (l[e] = t);
            };
          return u(Be, s), u(Ve, i), u(qe, o), u(He, a), u(We, c), l;
        })((t = t || this.cookieStorage.get("__utmz")), e);
        return fn(this, n), n;
      }),
        (an.prototype._unsetUTMParams = function () {
          var e = new Yt();
          e.unset(Ue),
            e.unset(Fe),
            e.unset(Be),
            e.unset(Ve),
            e.unset(qe),
            e.unset(He),
            e.unset(We),
            this.identify(e);
        });
      var fn = function (e, t) {
        if ("object" === $e(t) && 0 !== Object.keys(t).length) {
          var n = new Yt();
          for (var r in t)
            Object.prototype.hasOwnProperty.call(t, r) &&
              (n.setOnce("initial_" + r, t[r]), n.set(r, t[r]));
          e.identify(n);
        }
      };
      (an.prototype._getReferrer = function () {
        var e = this._getReferrerFromUrlParam(this._getUrlParams());
        return e || ("undefined" !== typeof document ? document.referrer : "");
      }),
        (an.prototype._getUrlParams = function () {
          return Ye.location.search;
        }),
        (an.prototype._saveGclid = function (e) {
          var t = mt("gclid", e);
          if (!pt(t)) {
            var n = { gclid: t };
            return fn(this, n), n;
          }
        }),
        (an.prototype._saveFbclid = function (e) {
          var t = mt("fbclid", e);
          if (!pt(t)) {
            var n = { fbclid: t };
            return fn(this, n), n;
          }
        }),
        (an.prototype._getDeviceIdFromUrlParam = function (e) {
          return mt(je, e);
        }),
        (an.prototype._getReferrerFromUrlParam = function (e) {
          return mt(Le, e);
        }),
        (an.prototype._getReferringDomain = function (e) {
          if (pt(e)) return null;
          var t = e.split("/");
          return t.length >= 3 ? t[2] : null;
        }),
        (an.prototype._saveReferrer = function (e) {
          if (!pt(e)) {
            var t = {
              referrer: e,
              referring_domain: this._getReferringDomain(e),
            };
            return fn(this, t), t;
          }
        }),
        (an.prototype.saveEvents = function () {
          try {
            var e = JSON.stringify(
              this._unsentEvents.map(function (e) {
                return e.event;
              })
            );
            this._setInStorage(Kt, this.options.unsentKey, e);
          } catch (a_) {}
          try {
            var t = JSON.stringify(
              this._unsentIdentifys.map(function (e) {
                return e.event;
              })
            );
            this._setInStorage(Kt, this.options.unsentIdentifyKey, t);
          } catch (a_) {}
        }),
        (an.prototype.setDomain = function (e) {
          if (this._shouldDeferCall())
            return this._q.push(
              ["setDomain"].concat(Array.prototype.slice.call(arguments, 0))
            );
          if (yt(e, "domain", "string"))
            try {
              this.cookieStorage.options({
                expirationDays: this.options.cookieExpiration,
                secure: this.options.secureCookie,
                domain: e,
                sameSite: this.options.sameSiteCookie,
              }),
                (this.options.domain = this.cookieStorage.options().domain),
                un(this),
                pn(this);
            } catch (a_) {
              ht.error(a_);
            }
        }),
        (an.prototype.setUserId = function (e) {
          var t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
          if (yt(t, "startNewSession", "boolean")) {
            if (this._shouldDeferCall())
              return this._q.push(
                ["setUserId"].concat(Array.prototype.slice.call(arguments, 0))
              );
            try {
              (this.options.userId =
                (void 0 !== e && null !== e && "" + e) || null),
                t &&
                  (this.options.unsetParamsReferrerOnNewSession &&
                    this._unsetUTMParams(),
                  (this._newSession = !0),
                  (this._sessionId = new Date().getTime()),
                  this._runNewSessionStartCallbacks(),
                  this.options.saveParamsReferrerOncePerSession &&
                    this._trackParamsAndReferrer()),
                pn(this),
                this._connector &&
                  this._connector.identityStore
                    .editIdentity()
                    .setUserId(this.options.userId)
                    .commit();
            } catch (a_) {
              ht.error(a_);
            }
          }
        }),
        (an.prototype.setGroup = function (e, t) {
          if (this._shouldDeferCall())
            return this._q.push(
              ["setGroup"].concat(Array.prototype.slice.call(arguments, 0))
            );
          if (
            this._apiKeySet("setGroup()") &&
            yt(e, "groupType", "string") &&
            !pt(e)
          ) {
            var n = {};
            n[e] = t;
            var r = new Yt().set(e, t);
            this._logEvent(
              ue,
              null,
              null,
              r.userPropertiesOperations,
              n,
              null,
              null,
              null
            );
          }
        }),
        (an.prototype.setOptOut = function (e) {
          if (this._shouldDeferCall())
            return this._q.push(
              ["setOptOut"].concat(Array.prototype.slice.call(arguments, 0))
            );
          if (yt(e, "enable", "boolean"))
            try {
              (this.options.optOut = e), pn(this);
            } catch (a_) {
              ht.error(a_);
            }
        }),
        (an.prototype.setSessionId = function (e) {
          if (yt(e, "sessionId", "number"))
            try {
              (this._sessionId = e), pn(this);
            } catch (a_) {
              ht.error(a_);
            }
        }),
        (an.prototype.resetSessionId = function () {
          this.setSessionId(new Date().getTime());
        }),
        (an.prototype.regenerateDeviceId = function () {
          if (this._shouldDeferCall())
            return this._q.push(
              ["regenerateDeviceId"].concat(
                Array.prototype.slice.call(arguments, 0)
              )
            );
          this.setDeviceId(Rt());
        }),
        (an.prototype.setDeviceId = function (e) {
          if (this._shouldDeferCall())
            return this._q.push(
              ["setDeviceId"].concat(Array.prototype.slice.call(arguments, 0))
            );
          if (wt(e))
            try {
              pt(e) ||
                ((this.options.deviceId = "" + e),
                pn(this),
                this._connector &&
                  this._connector.identityStore
                    .editIdentity()
                    .setDeviceId(this.options.deviceId)
                    .commit());
            } catch (a_) {
              ht.error(a_);
            }
        }),
        (an.prototype.setTransport = function (e) {
          if (this._shouldDeferCall())
            return this._q.push(
              ["setTransport"].concat(Array.prototype.slice.call(arguments, 0))
            );
          St(e) && (this.options.transport = e);
        }),
        (an.prototype.setUserProperties = function (e) {
          if (this._shouldDeferCall())
            return this._q.push(
              ["setUserProperties"].concat(
                Array.prototype.slice.call(arguments, 0)
              )
            );
          if (
            this._apiKeySet("setUserProperties()") &&
            yt(e, "userProperties", "object")
          ) {
            var t = gt(bt(e));
            if (0 !== Object.keys(t).length) {
              var n = new Yt();
              for (var r in t)
                Object.prototype.hasOwnProperty.call(t, r) && n.set(r, t[r]);
              this.identify(n);
            }
          }
        }),
        (an.prototype.clearUserProperties = function () {
          if (this._shouldDeferCall())
            return this._q.push(
              ["clearUserProperties"].concat(
                Array.prototype.slice.call(arguments, 0)
              )
            );
          if (this._apiKeySet("clearUserProperties()")) {
            var e = new Yt();
            e.clearAll(), this.identify(e);
          }
        });
      var mn = function (e, t) {
        for (var n = 0; n < t._q.length; n++) {
          var r = e[t._q[n][0]];
          "function" === $e(r) && r.apply(e, t._q[n].slice(1));
        }
        return e;
      };
      (an.prototype.identify = function (e, t, n, r) {
        if (this._shouldDeferCall())
          return this._q.push(
            ["identify"].concat(Array.prototype.slice.call(arguments, 0))
          );
        if (this._apiKeySet("identify()"))
          if (
            ("object" === $e(e) &&
              Object.prototype.hasOwnProperty.call(e, "_q") &&
              (e = mn(new Yt(), e)),
            e instanceof Yt)
          ) {
            if (Object.keys(e.userPropertiesOperations).length > 0)
              return this._logEvent(
                ue,
                null,
                null,
                e.userPropertiesOperations,
                null,
                null,
                null,
                t,
                n,
                r
              );
            Sn(t, n, 0, "No request sent", {
              reason: "No user property operations",
            });
          } else
            ht.error(
              "Invalid identify input type. Expected Identify object but saw " +
                $e(e)
            ),
              Sn(t, n, 0, "No request sent", {
                reason: "Invalid identify input type",
              });
        else Sn(t, n, 0, "No request sent", { reason: "API key is not set" });
      }),
        (an.prototype.groupIdentify = function (e, t, n, r, s, i) {
          if (this._shouldDeferCall())
            return this._q.push(
              ["groupIdentify"].concat(Array.prototype.slice.call(arguments, 0))
            );
          if (this._apiKeySet("groupIdentify()"))
            if (yt(e, "group_type", "string") && !pt(e))
              if (null !== t && void 0 !== t)
                if (
                  ("object" === $e(n) &&
                    Object.prototype.hasOwnProperty.call(n, "_q") &&
                    (n = mn(new Yt(), n)),
                  n instanceof Yt)
                ) {
                  if (Object.keys(n.userPropertiesOperations).length > 0)
                    return this._logEvent(
                      de,
                      null,
                      null,
                      null,
                      te({}, e, t),
                      n.userPropertiesOperations,
                      null,
                      r,
                      s,
                      i
                    );
                  Sn(r, s, 0, "No request sent", {
                    reason: "No group property operations",
                  });
                } else
                  ht.error(
                    "Invalid identify input type. Expected Identify object but saw " +
                      $e(n)
                  ),
                    Sn(r, s, 0, "No request sent", {
                      reason: "Invalid identify input type",
                    });
              else
                Sn(r, s, 0, "No request sent", {
                  reason: "Invalid group name",
                });
            else
              Sn(r, s, 0, "No request sent", { reason: "Invalid group type" });
          else Sn(r, s, 0, "No request sent", { reason: "API key is not set" });
        }),
        (an.prototype.setVersionName = function (e) {
          if (this._shouldDeferCall())
            return this._q.push(
              ["setVersionName"].concat(
                Array.prototype.slice.call(arguments, 0)
              )
            );
          yt(e, "versionName", "string") && (this.options.versionName = e);
        }),
        (an.prototype._logEvent = function (e, t, n, r, s, i, o, a, c, l) {
          if ((un(this), e))
            if (this.options.optOut)
              Sn(a, c, 0, "No request sent", {
                reason: "optOut is set to true",
              });
            else
              try {
                var u;
                u =
                  e === ue || e === de
                    ? this.nextIdentifyId()
                    : this.nextEventId();
                var d = this.nextSequenceNumber(),
                  h = "number" === $e(o) ? o : new Date().getTime();
                l
                  ? (this._sessionId = -1)
                  : (!this._sessionId ||
                      !this._lastEventTime ||
                      h - this._lastEventTime > this.options.sessionTimeout) &&
                    ((this._sessionId = h),
                    this._runNewSessionStartCallbacks()),
                  (this._lastEventTime = h),
                  pn(this);
                var p = this._ua.browser.name,
                  f = this._ua.browser.major,
                  m = this._ua.device.model || this._ua.os.name,
                  g = this._ua.device.vendor;
                r = r || {};
                var v = Y({}, this._apiPropertiesTrackingOptions);
                (n = Y(Y({}, n || {}), v)),
                  (t = t || {}),
                  (s = s || {}),
                  (i = i || {});
                var y = {
                  device_id: this.options.deviceId,
                  user_id: this.options.userId,
                  timestamp: h,
                  event_id: u,
                  session_id: this._sessionId || -1,
                  event_type: e,
                  version_name: this.options.versionName || null,
                  platform: yn(this, "platform") ? this.options.platform : null,
                  os_name: (yn(this, "os_name") && p) || null,
                  os_version: (yn(this, "os_version") && f) || null,
                  device_model: (yn(this, "device_model") && m) || null,
                  device_manufacturer:
                    (yn(this, "device_manufacturer") && g) || null,
                  language: yn(this, "language") ? this.options.language : null,
                  api_properties: n,
                  event_properties: gt(bt(t)),
                  user_properties: gt(bt(r)),
                  uuid: $t(),
                  library: this.options.library,
                  sequence_number: d,
                  groups: gt(vt(s)),
                  group_properties: gt(bt(i)),
                  user_agent: this._userAgent,
                  partner_id: this.options.partnerId || null,
                };
                return (
                  gn(this) &&
                    (y.plan = {
                      branch: this.options.plan.branch || void 0,
                      source: this.options.plan.source || void 0,
                      version: this.options.plan.version || void 0,
                      versionId: this.options.plan.versionId || void 0,
                    }),
                  vn(this) &&
                    (y.ingestion_metadata = {
                      source_name:
                        this.options.ingestionMetadata.sourceName || void 0,
                      source_version:
                        this.options.ingestionMetadata.sourceVersion || void 0,
                    }),
                  e === ue || e === de
                    ? (this._unsentIdentifys.push({
                        event: y,
                        callback: a,
                        errorCallback: c,
                      }),
                      this._limitEventsQueued(this._unsentIdentifys))
                    : (this._unsentEvents.push({
                        event: y,
                        callback: a,
                        errorCallback: c,
                      }),
                      this._limitEventsQueued(this._unsentEvents)),
                  this.options.saveEvents && this.saveEvents(),
                  this._sendEventsIfReady(),
                  e === ue &&
                    this._connector &&
                    this._connector.identityStore
                      .editIdentity()
                      .updateUserProperties(gt(bt(r)))
                      .commit(),
                  u
                );
              } catch (a_) {
                ht.error(a_);
              }
          else Sn(a, c, 0, "No request sent", { reason: "Missing eventType" });
        });
      var gn = function (e) {
          return (
            e.options.plan &&
            (e.options.plan.source ||
              e.options.plan.branch ||
              e.options.plan.version ||
              e.options.plan.versionId)
          );
        },
        vn = function (e) {
          return (
            e.options.ingestionMetadata &&
            (e.options.ingestionMetadata.sourceName ||
              e.options.ingestionMetadata.sourceVersion)
          );
        },
        yn = function (e, t) {
          return !!e.options.trackingOptions[t];
        },
        bn = function (e) {
          for (
            var t = ["city", "country", "dma", "ip_address", "region"],
              n = {},
              r = 0;
            r < t.length;
            r++
          ) {
            var s = t[r];
            yn(e, s) || (n[s] = !1);
          }
          return n;
        };
      (an.prototype._limitEventsQueued = function (e) {
        e.length > this.options.savedMaxCount &&
          e
            .splice(0, e.length - this.options.savedMaxCount)
            .forEach(function (e) {
              Sn(e.callback, e.errorCallback, 0, "No request sent", {
                reason:
                  "Event dropped because options.savedMaxCount exceeded. User may be offline or have a content blocker",
              });
            });
      }),
        (an.prototype.logEvent = function (e, t, n, r) {
          var s =
            arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
          return this._shouldDeferCall()
            ? this._q.push(
                ["logEvent"].concat(Array.prototype.slice.call(arguments, 0))
              )
            : this.logEventWithTimestamp(e, t, null, n, r, s);
        }),
        (an.prototype.logEventWithTimestamp = function (e, t, n, r, s) {
          var i =
            arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
          return this._shouldDeferCall()
            ? this._q.push(
                ["logEventWithTimestamp"].concat(
                  Array.prototype.slice.call(arguments, 0)
                )
              )
            : this._apiKeySet("logEvent()")
            ? yt(e, "eventType", "string")
              ? pt(e)
                ? (Sn(r, s, 0, "No request sent", {
                    reason: "Missing eventType",
                  }),
                  -1)
                : (yt(i, "outOfSession", "boolean") ||
                    Sn(r, s, 0, "No request sent", {
                      reason: "Invalid outOfSession value",
                    }),
                  this._logEvent(e, t, null, null, null, null, n, r, s, i))
              : (Sn(r, s, 0, "No request sent", {
                  reason: "Invalid type for eventType",
                }),
                -1)
            : (Sn(r, s, 0, "No request sent", { reason: "API key not set" }),
              -1);
        }),
        (an.prototype.logEventWithGroups = function (e, t, n, r, s) {
          var i =
            arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
          return this._shouldDeferCall()
            ? this._q.push(
                ["logEventWithGroups"].concat(
                  Array.prototype.slice.call(arguments, 0)
                )
              )
            : this._apiKeySet("logEventWithGroups()")
            ? yt(e, "eventType", "string")
              ? (yt(i, "outOfSession", "boolean") ||
                  Sn(
                    event.callback,
                    event.errorCallback,
                    0,
                    "No request sent",
                    { reason: "Invalid outOfSession value" }
                  ),
                this._logEvent(e, t, null, null, n, null, null, r, s, i))
              : (Sn(event.callback, event.errorCallback, 0, "No request sent", {
                  reason: "Invalid type for eventType",
                }),
                -1)
            : (Sn(event.callback, event.errorCallback, 0, "No request sent", {
                reason: "API key not set",
              }),
              -1);
        });
      var wn = function (e) {
          return !isNaN(parseFloat(e)) && isFinite(e);
        },
        Sn = function (e, t, n, r, s) {
          "function" === $e(e) && e(n, r, s),
            "function" === $e(t) && t(n, r, s);
        };
      (an.prototype.logRevenueV2 = function (e) {
        if (this._shouldDeferCall())
          return this._q.push(
            ["logRevenueV2"].concat(Array.prototype.slice.call(arguments, 0))
          );
        if (this._apiKeySet("logRevenueV2()"))
          if (
            ("object" === $e(e) &&
              Object.prototype.hasOwnProperty.call(e, "_q") &&
              (e = mn(new Zt(), e)),
            e instanceof Zt)
          ) {
            if (e && e._isValidRevenue())
              return this.logEvent(xe, e._toJSONObject());
          } else
            ht.error(
              "Invalid revenue input type. Expected Revenue object but saw " +
                $e(e)
            );
      }),
        (an.prototype.logRevenue = function (e, t, n) {
          return this._shouldDeferCall()
            ? this._q.push(
                ["logRevenue"].concat(Array.prototype.slice.call(arguments, 0))
              )
            : this._apiKeySet("logRevenue()") &&
              wn(e) &&
              (void 0 === t || wn(t))
            ? this._logEvent(
                xe,
                {},
                {
                  productId: n,
                  special: "revenue_amount",
                  quantity: t || 1,
                  price: e,
                },
                null,
                null,
                null,
                null,
                null
              )
            : -1;
        }),
        (an.prototype._logErrorsOnEvents = function (e, t, n, r) {
          for (
            var s = ["_unsentEvents", "_unsentIdentifys"], i = 0;
            i < s.length;
            i++
          )
            for (
              var o = s[i], a = "_unsentEvents" === o ? e : t, c = 0;
              c < this[o].length;
              c++
            ) {
              var l = this[o][c];
              l.event.event_id <= a && l.errorCallback && l.errorCallback(n, r);
            }
        }),
        (an.prototype.removeEvents = function (e, t, n, r) {
          _n(this, "_unsentEvents", e, n, r),
            _n(this, "_unsentIdentifys", t, n, r);
        });
      var _n = function (e, t, n, r, s) {
        if (!(n < 0)) {
          for (var i = [], o = 0; o < e[t].length; o++) {
            var a = e[t][o];
            a.event.event_id > n ? i.push(a) : a.callback && a.callback(r, s);
          }
          e[t] = i;
        }
      };
      (an.prototype.sendEvents = function () {
        if (this._apiKeySet("sendEvents()")) {
          if (this.options.optOut)
            this.removeEvents(1 / 0, 1 / 0, 0, "No request sent", {
              reason: "Opt out is set to true",
            });
          else if (0 !== this._unsentCount()) {
            if (this.options.transport !== Ge) {
              if (this._sending) return;
              this._sending = !0;
            }
            var e =
                (this.options.forceHttps || "https:" === Ye.location.protocol
                  ? "https"
                  : "http") +
                "://" +
                this.options.apiEndpoint,
              t = Math.min(this._unsentCount(), this.options.uploadBatchSize),
              n = this._mergeEventsAndIdentifys(t),
              r = n.maxEventId,
              s = n.maxIdentifyId,
              i = JSON.stringify(
                n.eventsToSend.map(function (e) {
                  return e.event;
                })
              ),
              o = new Date().getTime(),
              a = {
                client: this.options.apiKey,
                e: i,
                v: ae,
                upload_time: o,
                checksum: p()(ae + this.options.apiKey + i + o),
              };
            if (
              this.options.transport !== Ge ||
              "undefined" === typeof navigator
            ) {
              var c = this;
              try {
                new Xt(e, a, this.options.headers).send(function (e, n) {
                  c._sending = !1;
                  try {
                    200 === e
                      ? (c.removeEvents(r, s, e, n),
                        c.options.saveEvents && c.saveEvents(),
                        c._sendEventsIfReady())
                      : (c._logErrorsOnEvents(r, s, e, n),
                        413 === e &&
                          (1 === c.options.uploadBatchSize &&
                            c.removeEvents(r, s, e, n),
                          (c.options.uploadBatchSize = Math.ceil(t / 2)),
                          c.sendEvents()));
                  } catch (a_) {}
                });
              } catch (a_) {
                var l = "Request failed to send";
                ht.error(l),
                  c._logErrorsOnEvents(r, s, 0, l),
                  c.removeEvents(r, s, 0, l, { reason: a_.message });
              }
            } else {
              navigator.sendBeacon(e, new URLSearchParams(a))
                ? (this.removeEvents(r, s, 200, "success"),
                  this.options.saveEvents && this.saveEvents())
                : this._logErrorsOnEvents(r, s, 0, "");
            }
          }
        } else
          this.removeEvents(1 / 0, 1 / 0, 0, "No request sent", {
            reason: "API key not set",
          });
      }),
        (an.prototype._mergeEventsAndIdentifys = function (e) {
          for (var t = [], n = 0, r = -1, s = 0, i = -1; t.length < e; ) {
            var o = void 0,
              a = s >= this._unsentIdentifys.length,
              c = n >= this._unsentEvents.length;
            if (c && a) {
              ht.error(
                "Merging Events and Identifys, less events and identifys than expected"
              );
              break;
            }
            a
              ? (r = (o = this._unsentEvents[n++]).event.event_id)
              : c
              ? (i = (o = this._unsentIdentifys[s++]).event.event_id)
              : !("sequence_number" in this._unsentEvents[n].event) ||
                this._unsentEvents[n].event.sequence_number <
                  this._unsentIdentifys[s].event.sequence_number
              ? (r = (o = this._unsentEvents[n++]).event.event_id)
              : (i = (o = this._unsentIdentifys[s++]).event.event_id),
              t.push(o);
          }
          return { eventsToSend: t, maxEventId: r, maxIdentifyId: i };
        }),
        (an.prototype.setGlobalUserProperties = function (e) {
          this.setUserProperties(e);
        }),
        (an.prototype.__VERSION__ = function () {
          return this.options.library.version;
        }),
        (an.prototype.setLibrary = function (e, t) {
          null !== e &&
            "undefined" !== typeof e &&
            (this.options.library.name = e),
            null !== t &&
              "undefined" !== typeof t &&
              (this.options.library.version = t);
        }),
        (an.prototype._shouldDeferCall = function () {
          return this._pendingReadStorage || this._initializationDeferred;
        }),
        (an.prototype._deferInitialization = function () {
          (this._initializationDeferred = !0),
            this._q.push(
              ["init"].concat(Array.prototype.slice.call(arguments, 0))
            );
        }),
        (an.prototype.enableTracking = function () {
          (this._initializationDeferred = !1),
            pn(this),
            this.runQueuedFunctions();
        }),
        (an.prototype._refreshDynamicConfig = function () {
          this.options.useDynamicConfig &&
            on.refresh(
              this.options.serverZone,
              this.options.forceHttps,
              function () {
                this.options.apiEndpoint = on.ingestionEndpoint;
              }.bind(this)
            );
        }),
        (an.prototype.getDeviceId = function () {
          return this.options.deviceId;
        }),
        (an.prototype.getUserId = function () {
          return this.options.userId;
        }),
        (an.prototype.setMinTimeBetweenSessionsMillis = function (e) {
          if (yt(e, "timeInMillis", "number")) {
            if (this._shouldDeferCall())
              return this._q.push(
                ["setMinTimeBetweenSessionsMillis"].concat(
                  Array.prototype.slice.call(arguments, 0)
                )
              );
            try {
              this.options.sessionTimeout = e;
            } catch (a_) {
              ht.error(a_);
            }
          }
        }),
        (an.prototype.setEventUploadThreshold = function (e) {
          if (yt(e, "eventUploadThreshold", "number")) {
            if (this._shouldDeferCall())
              return this._q.push(
                ["setEventUploadThreshold"].concat(
                  Array.prototype.slice.call(arguments, 0)
                )
              );
            try {
              this.options.eventUploadThreshold = e;
            } catch (a_) {
              ht.error(a_);
            }
          }
        }),
        (an.prototype.setUseDynamicConfig = function (e) {
          if (yt(e, "useDynamicConfig", "boolean")) {
            if (this._shouldDeferCall())
              return this._q.push(
                ["setUseDynamicConfig"].concat(
                  Array.prototype.slice.call(arguments, 0)
                )
              );
            try {
              (this.options.useDynamicConfig = e), this._refreshDynamicConfig();
            } catch (a_) {
              ht.error(a_);
            }
          }
        }),
        (an.prototype.setServerZone = function (e) {
          var t =
            !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (
            (e === tn || e === en) &&
            yt(t, "serverZoneBasedApi", "boolean")
          ) {
            if (this._shouldDeferCall())
              return this._q.push(
                ["setServerZone"].concat(
                  Array.prototype.slice.call(arguments, 0)
                )
              );
            try {
              (this.options.serverZone = e),
                (this.options.serverZoneBasedApi = t),
                t && (this.options.apiEndpoint = nn(this.options.serverZone));
            } catch (a_) {
              ht.error(a_);
            }
          }
        }),
        (an.prototype.setServerUrl = function (e) {
          if (yt(e, "serverUrl", "string")) {
            if (this._shouldDeferCall())
              return this._q.push(
                ["setServerUrl"].concat(
                  Array.prototype.slice.call(arguments, 0)
                )
              );
            try {
              this.options.apiEndpoint = e;
            } catch (a_) {
              ht.error(a_);
            }
          }
        });
      var En = function () {
        (this.options = Y({}, sn)), (this._q = []), (this._instances = {});
      };
      (En.prototype.Identify = Yt),
        (En.prototype.Revenue = Zt),
        (En.prototype.getInstance = function (e) {
          e = pt(e) ? oe : e.toLowerCase();
          var t = this._instances[e];
          return void 0 === t && ((t = new an(e)), (this._instances[e] = t)), t;
        }),
        (En.prototype.init = function (e, t, n, r) {
          this.getInstance().init(
            e,
            t,
            n,
            function (e) {
              (this.options = e.options), "function" === $e(r) && r(e);
            }.bind(this)
          );
        }),
        (En.prototype.isNewSession = function () {
          return this.getInstance().isNewSession();
        }),
        (En.prototype.getSessionId = function () {
          return this.getInstance().getSessionId();
        }),
        (En.prototype.nextEventId = function () {
          return this.getInstance().nextEventId();
        }),
        (En.prototype.nextIdentifyId = function () {
          return this.getInstance().nextIdentifyId();
        }),
        (En.prototype.nextSequenceNumber = function () {
          return this.getInstance().nextSequenceNumber();
        }),
        (En.prototype.saveEvents = function () {
          this.getInstance().saveEvents();
        }),
        (En.prototype.setDomain = function (e) {
          this.getInstance().setDomain(e);
        }),
        (En.prototype.setUserId = function (e) {
          this.getInstance().setUserId(e);
        }),
        (En.prototype.setGroup = function (e, t) {
          this.getInstance().setGroup(e, t);
        }),
        (En.prototype.setOptOut = function (e) {
          this.getInstance().setOptOut(e);
        }),
        (En.prototype.regenerateDeviceId = function () {
          this.getInstance().regenerateDeviceId();
        }),
        (En.prototype.setDeviceId = function (e) {
          this.getInstance().setDeviceId(e);
        }),
        (En.prototype.setUserProperties = function (e) {
          this.getInstance().setUserProperties(e);
        }),
        (En.prototype.clearUserProperties = function () {
          this.getInstance().clearUserProperties();
        }),
        (En.prototype.identify = function (e, t) {
          this.getInstance().identify(e, t);
        }),
        (En.prototype.setVersionName = function (e) {
          this.getInstance().setVersionName(e);
        }),
        (En.prototype.logEvent = function (e, t, n) {
          return this.getInstance().logEvent(e, t, n);
        }),
        (En.prototype.logEventWithGroups = function (e, t, n, r) {
          return this.getInstance().logEventWithGroups(e, t, n, r);
        }),
        (En.prototype.logRevenueV2 = function (e) {
          return this.getInstance().logRevenueV2(e);
        }),
        (En.prototype.logRevenue = function (e, t, n) {
          return this.getInstance().logRevenue(e, t, n);
        }),
        (En.prototype.removeEvents = function (e, t) {
          this.getInstance().removeEvents(e, t);
        }),
        (En.prototype.sendEvents = function (e) {
          this.getInstance().sendEvents(e);
        }),
        (En.prototype.setGlobalUserProperties = function (e) {
          this.getInstance().setUserProperties(e);
        }),
        (En.prototype.__VERSION__ = rn);
      var An = ("undefined" !== typeof Ye && Ye.amplitude) || {},
        Tn = new En();
      for (var Pn in ((Tn._q = An._q || []), An._iq))
        Object.prototype.hasOwnProperty.call(An._iq, Pn) &&
          (Tn.getInstance(Pn)._q = An._iq[Pn]._q || []);
      function In() {
        try {
          if (window.performance.getEntriesByType) {
            const e = "reload";
            return window.performance
              .getEntriesByType("navigation")
              .map((e) => e.type)
              .includes(e);
          }
          return (
            window.performance.navigation.type ===
            window.performance.navigation.TYPE_RELOAD
          );
        } catch (e) {
          return !1;
        }
      }
      function Cn(e) {
        const t = e
            ? new URL(e).searchParams
            : new URLSearchParams(window.location.search),
          n = {};
        return t.forEach((e, t) => (n[t] = e)), n;
      }
      const kn = window.performance || Date;
      let On = kn.now(),
        xn = Date.now();
      const Nn = {
          setNow(e) {
            (On = kn.now()), (xn = e);
          },
          getNow: () => Math.round(xn + (kn.now() - On)),
        },
        Rn = 1e3,
        Dn = 60 * Rn,
        Mn = 60 * Dn,
        jn = 24 * Mn;
      function Ln(e) {
        let {
          days: t = 0,
          hours: n = 0,
          minutes: r = 0,
          seconds: s = 0,
          ms: i = 0,
        } = e;
        return i + s * Rn + r * Dn + n * Mn + t * jn;
      }
      function Un(e) {
        const { fromTimestamp: t, ianaTimeZone: n, toTimestamp: r } = e;
        return (Bn(r, n) - Bn(t, n)) / Ln({ days: 1 });
      }
      function Fn(e) {
        const t = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ][e.getUTCDay()];
        if (!t) throw Error("Invalid date: ".concat(e.toString()));
        return t;
      }
      function Bn(e, t) {
        const n = Vn(e, t),
          r = Math.max(n.lastIndexOf("+"), n.lastIndexOf("-")),
          s = n.substring(0, 11) + "00:00:00" + n.substring(r);
        return new Date(s).getTime();
      }
      function Vn(e, t) {
        const n = new Date(e),
          r = n.toLocaleString("en-US", { timeZone: t, hourCycle: "h23" }),
          [s, i] = r.split(", "),
          [o, a, c] = s.split("/"),
          l = ""
            .concat(c, "-")
            .concat(o.padStart(2, "0"), "-")
            .concat(a.padStart(2, "0"), "T")
            .concat(i, ".")
            .concat(n.getMilliseconds(), "Z"),
          u = Math.floor((new Date(l).getTime() - n.getTime()) / 6e4),
          d = u < 0 ? "-" : "+",
          h = Math.floor(Math.abs(u) / 60),
          p = Math.abs(u) % 60;
        return ""
          .concat(l.split("Z")[0])
          .concat(d)
          .concat(h.toString().padStart(2, "0"), ":")
          .concat(p.toString().padStart(2, "0"));
      }
      function qn(e, t) {
        const n = Vn(e, t),
          r = new Date(n.split("T")[0]),
          s = r.getUTCDay(),
          i = Vn(e - Ln({ days: 1 === s ? 0 : 0 === s ? 6 : s - 1 }), t);
        return {
          date: n.slice(0, 10),
          dateHour: n.slice(0, 13).replace("T", "-"),
          dateMonth: n.slice(0, 8) + "01",
          dateTime: n,
          dateWeek: i.slice(0, 10),
          dayOfWeek: Fn(r),
          hour: n.slice(11, 13),
        };
      }
      var Hn;
      Object.defineProperty;
      async function Wn(e) {
        if (0 !== e) return new Promise((t) => setTimeout(t, e));
      }
      Error;
      async function Kn(e, t) {
        var n, r;
        const s =
            null !== (n = null == t ? void 0 : t.retryCount) && void 0 !== n
              ? n
              : 2,
          i =
            null !== (r = null == t ? void 0 : t.linearBackoff) && void 0 !== r
              ? r
              : 500;
        let o = 0;
        for (;;)
          try {
            return { result: await e(), requestTries: o + 1 };
          } catch (a) {
            if ((null == t ? void 0 : t.retryOnlyIf) && !t.retryOnlyIf(a))
              return Promise.reject({ error: a, requestTries: o + 1 });
            if (o >= s)
              return Promise.reject({ error: a, requestTries: o + 1 });
            o++, await Wn((o - 1) * i);
          }
      }
      async function zn(e) {
        const t = performance.now();
        try {
          return { result: await e(), requestMs: performance.now() - t };
        } catch (n) {
          return Promise.reject({ error: n, requestMs: performance.now() - t });
        }
      }
      function Gn(e) {
        return 100 * Math.pow(2, e - 1);
      }
      async function Jn() {
        return !0;
      }
      async function Qn(e) {
        return [408, 429, 500, 502, 503, 504].includes(e.status);
      }
      async function Yn(e, t, n) {
        var r;
        const { headers: s, body: i, tracking: o } = n,
          a = (null == (r = n.method) ? void 0 : r.toUpperCase()) || "GET",
          c = new URL(t),
          l = n.retryError || Jn,
          u = n.retryResponse || Qn,
          d = n.retryDelay || Gn,
          h = Math.max(
            Number.isSafeInteger(n.maxAttempts) ? n.maxAttempts : 0,
            1
          ),
          p = performance.now();
        let f,
          m,
          g,
          v = 0;
        do {
          (v += 1), (f = m = void 0);
          try {
            (m = await e(c.href, { method: a, headers: s, body: i })),
              (g = await u(m));
          } catch (S) {
            (f = S), (g = await l(f));
          }
          if (!g) break;
          v < h && (await Wn(d(v)));
        } while (v < h);
        const y = performance.now(),
          b = !g && m && m.ok;
        let w;
        if (
          (!b && m && ((w = await m.text()), (m.text = async () => w)),
          fr.pushEvent("PlatformRequest", {
            platform: o.platform,
            requestTries: v,
            requestMs: y - p,
            source: o.source,
            method: a,
            href: c.href,
            origin: c.origin,
            pathname: c.pathname,
            search: c.search,
            statusCode: null == m ? void 0 : m.status,
            statusText: null == m ? void 0 : m.statusText,
            errorName: null == f ? void 0 : f.name,
            errorMessage: null == f ? void 0 : f.message,
            failedResponseText: w,
            result: b ? "Success" : "Failure",
          }),
          f)
        )
          throw f;
        return m;
      }
      const Xn =
        (null == (Hn = window.TLNative) ? void 0 : Hn.utils.fetch) ||
        window.fetch;
      class Zn {
        constructor(e) {
          this.config = e;
        }
        async sendConversionEvent(e) {
          const {
            tagID: t,
            tagAccessToken: n,
            channelID: r,
            conversionAPIEndpoint: s,
          } = this.config.lineConversionAPIConfig;
          if (!t || !n || !r)
            throw new Error("Missing configuration for LINE Conversion API.");
          const i = ""
              .concat(e.userID, "-")
              .concat(Date.now(), "-")
              .concat(Math.random().toString(36).slice(2)),
            o = {
              web: { referrer: l.referrer, user_agent: l.string },
              event: {
                deduplication_key: i,
                event_timestamp: Math.floor(Date.now() / 1e3),
                event_name: e.eventType,
                event_type: "conversion",
                source_type: "web",
              },
              user: { line_uid: e.userID },
            },
            a = new URLSearchParams(window.location.search).get("ldtag_cl");
          a && (o.user.click_id = a),
            e.revenue &&
              (o.custom = {
                quantity: e.revenue.quantity,
                currency: e.revenue.currency,
                category: e.revenue.category,
                value: e.revenue.value,
              }),
            await Yn(
              Xn,
              ""
                .concat(this.config.lineCORSProxyURL, "/")
                .concat(
                  null !== s && void 0 !== s
                    ? s
                    : "https://conversion-api.tr.line.me",
                  "/v1/"
                )
                .concat(t, "/events"),
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "X-Line-TagAccessToken": n,
                  "X-Line-ChannelID": r,
                },
                body: JSON.stringify([o]),
                tracking: {
                  platform: "LINE",
                  source: "GCInstant/LineConnectedGame.sendConversionEvent",
                },
              }
            ).catch(() => {});
        }
      }
      const $n = {
          trackCrossplayStart(e) {
            hr.pushEvent("CrossplayStart", e);
          },
          trackCrossplayFinish(e) {
            hr.pushEvent("CrossplayFinish", {
              ...e,
              wasInBackground: !!e.wasInBackground,
            });
          },
        },
        er = {
          TutorialStart(e) {
            hr.pushEvent("TutorialStart", e);
          },
          TutorialFinish(e) {
            hr.pushEvent("TutorialFinish", e);
          },
          TutorialStepStart(e) {
            const { stepIndex: t, stepName: n, ...r } = e;
            hr.pushEvent("TutorialStepStart", {
              ...r,
              $stepIndex: t,
              $stepName: n,
            });
          },
          TutorialStepFinish(e) {
            const {
              stepElapsedSeconds: t,
              stepIndex: n,
              stepName: r,
              ...s
            } = e;
            hr.pushEvent("TutorialStepFinish", {
              ...s,
              $stepElapsedSeconds: t,
              $stepIndex: n,
              $stepName: r,
            });
          },
        },
        tr = { crossplay: $n, tutorial: er };
      var nr = Object.defineProperty,
        rr = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? nr(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class sr {
        setUserID(e) {}
        setUserProperties(e) {}
        track(e, t) {}
        trackRevenue(e) {}
        getTrackingQueryParams() {
          return {};
        }
      }
      class ir {
        constructor(e) {
          rr(this, "amplitudeClient"), rr(this, "_userProperties", {});
          const { deviceID: t, key: n, name: r, version: s } = e;
          this.amplitudeClient = Tn.getInstance(r);
          this.amplitudeClient.init(n, void 0, {
            forceHttps: !0,
            logLevel: "ERROR",
            includeReferrer: !0,
            saveParamsReferrerOncePerSession: !1,
            deviceIdFromUrlParam: !0,
          }),
            t && this.amplitudeClient.setDeviceId(t),
            this.amplitudeClient.setVersionName(s),
            this.setUserProperties(this._userProperties);
        }
        setUserID(e) {
          this.amplitudeClient.setUserId(e);
        }
        setDeviceID(e) {
          this.amplitudeClient.setDeviceId(e);
        }
        setUserProperties(e) {
          for (const t in e) this._userProperties[t] = e[t];
          this.amplitudeClient.setUserProperties(this._userProperties);
        }
        track(e, t) {
          this.amplitudeClient.logEvent(e, t);
        }
        trackRevenue(e) {
          const {
            revenueType: t,
            revenueGross: n,
            revenueNet: r,
            productID: s,
            ...i
          } = e;
          this.track("Revenue", e);
          const o = new Tn.Revenue()
            .setProductId(s)
            .setQuantity(1)
            .setPrice(r)
            .setRevenueType(t)
            .setEventProperties(i);
          this.amplitudeClient.logRevenueV2(o);
        }
        getTrackingQueryParams() {
          return { amp_device_id: this.amplitudeClient.options.deviceId };
        }
      }
      class or {
        constructor(e) {
          rr(this, "_osType"), (this._osType = e);
        }
        getTrackingQueryParams() {
          return {};
        }
        setUserID(e) {}
        setUserProperties(e) {}
        track(e, t) {
          window.fbq("trackCustom", e, { ...t, osType: this._osType });
        }
        trackRevenue(e) {
          window.fbq("track", "Purchase", { currency: "USD", value: e.price });
        }
      }
      class ar {
        getTrackingQueryParams() {
          return {};
        }
        setUserID(e) {}
        setUserProperties(e) {}
        track(e, t) {
          window.dataLayer.push(e);
        }
        trackRevenue(e) {}
      }
      class cr {
        constructor(e, t) {
          rr(this, "lineConversionAPI"),
            (this.userID = e),
            (this.lineConversionAPI = new Zn(t));
        }
        getTrackingQueryParams() {
          return {};
        }
        setUserID(e) {}
        setUserProperties(e) {}
        track(e, t) {
          this.lineConversionAPI
            .sendConversionEvent({ eventType: e, userID: this.userID })
            .catch(() => {});
        }
        trackRevenue(e) {
          this.lineConversionAPI
            .sendConversionEvent({
              eventType: "Purchase",
              userID: this.userID,
              revenue: {
                quantity: 1,
                currency: e.currencyCodeLocal,
                category: [e.revenueType],
                value: e.revenueNet,
              },
            })
            .catch(() => {});
        }
      }
      class lr {
        constructor(e) {
          rr(this, "_platform"), (this._platform = e);
        }
        getTrackingQueryParams() {
          return {};
        }
        setUserID(e) {}
        setUserProperties() {}
        track(e, t) {
          const n = Object.keys(t);
          let r = n.length;
          r > 25 && (n.sort(), (r = 25));
          const s = {};
          for (let i = 0; i < r; i++) {
            const e = n[i];
            s[e.replace(/[^a-z0-9_]/gi, "-")] = t[e];
          }
          this._platform.logEvent(e, 1, s);
        }
        trackRevenue() {}
      }
      const ur = {
          komoju_linepay: 3.5,
          komoju_paidy: 9,
          komoju_aupay: 15,
          komoju_rakutenpay: 8.4,
          komoju_docomo: 15,
          komoju_softbank: 15,
          komoju_au: 15,
        },
        dr = {
          amex: 3.85,
          diners: 3.85,
          discover: 3.85,
          jcb: 3.85,
          master: 3.6,
          visa: 3.6,
        };
      const hr = new (class {
          constructor() {
            rr(this, "game", tr),
              rr(this, "_eventQueue"),
              rr(this, "_gameVersion"),
              rr(this, "processEventQueueTimeoutHandle", null),
              rr(this, "_userPropertiesBacklog"),
              rr(this, "services"),
              rr(this, "setUserProperties"),
              rr(this, "toAdServer"),
              rr(this, "toDefault"),
              rr(this, "toDefaultAndAdServer"),
              rr(this, "toDefaultAndPixel"),
              rr(this, "toDefaultAndPixelAndAdServer"),
              rr(this, "_userProperties", {}),
              rr(this, "config"),
              rr(this, "initialized", !1),
              rr(this, "trackedSessionStartEvents", !1),
              rr(this, "zoomClientContext"),
              (this.services = {}),
              (this._eventQueue = []),
              (this._userPropertiesBacklog = []),
              (this.setUserProperties = (e) => {
                this._userPropertiesBacklog.push(e);
                for (const t in e) this._userProperties[t] = e[t];
              });
          }
          setInternalUserProperties(e, t) {
            this.setUserProperties(e, t);
          }
          getUserProperties() {
            return this._userProperties;
          }
          addPlatformService(e) {
            this.services.platform = new lr(e);
          }
          setZoomClientContext(e) {
            this.zoomClientContext = e;
          }
          initialize(e) {
            var t = this;
            if (this.initialized) return;
            (this.initialized = !0),
              (this._gameVersion = e.version),
              (this.config = e);
            const n = {
              lastEntryGCInstantVersion: "40.5.0",
              lastEntryIsPageReload: In(),
              version: this._gameVersion,
              usePolyfills: e.usePolyfills,
              lastEntryAppID: e.appID,
              sessionID: "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
                /[xy]/g,
                function (e) {
                  const t = (16 * Math.random()) | 0;
                  return ("x" === e ? t : (3 & t) | 8).toString(16);
                }
              ),
              documentReferrer: l.referrer,
              userAgent: l.string,
              DEVICE_TYPE: l.isMobile ? "mobile" : "desktop",
              OS_TYPE: l.os.name,
              OS_VERSION: l.os.version,
              BROWSER_TYPE: l.browser.name,
              BROWSER_VERSION: l.browser.version,
              APP_TYPE: l.app.name,
              APP_VERSION: l.app.version,
            };
            if (
              (e.amplitudeKey
                ? (this.services.default = new ir({
                    key: e.amplitudeKey,
                    name: "default",
                    version: this._gameVersion,
                  }))
                : (this.services.default = new sr()),
              (this.toDefault = [this.services.default]),
              (this.toDefaultAndAdServer = this.toDefault.slice()),
              (this.toDefaultAndPixel = this.toDefault.slice()),
              (this.toDefaultAndPixelAndAdServer = this.toDefault.slice()),
              this.services.platform &&
                this.toDefault.push(this.services.platform),
              e.amplitudeAdServerKey
                ? (this.services.adServer = new ir({
                    key: e.amplitudeAdServerKey,
                    name: "adServer",
                    version: this._gameVersion,
                  }))
                : (this.services.adServer = new sr()),
              (this.toAdServer = [this.services.adServer]),
              (this.toDefaultAndAdServer = this.toDefault.slice()),
              this.toDefaultAndAdServer.push(this.services.adServer),
              (this.toDefaultAndPixelAndAdServer =
                this.toDefaultAndAdServer.slice()),
              e.fbPixelId &&
                ((this.services.pixel = new or(l.os.name)),
                this.toDefaultAndPixel.push(this.services.pixel),
                this.toDefaultAndPixelAndAdServer.push(this.services.pixel)),
              e.googleTagManagerId &&
                ((this.services.gtmTracker = new ar()),
                this.toDefaultAndPixel.push(this.services.gtmTracker),
                this.toDefaultAndPixelAndAdServer.push(
                  this.services.gtmTracker
                )),
              this._userPropertiesBacklog.length > 0)
            )
              for (const r of this._userPropertiesBacklog)
                this.services.default.setUserProperties(r);
            (this.setUserProperties = function (n) {
              let r =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : t.toDefault || [];
              e.isDevelopment && console.log("analytics.setUserProperties:", n);
              for (const e of r) e.setUserProperties(n);
              for (const e in n) t._userProperties[e] = n[e];
            }),
              this.setInternalUserProperties(n),
              this.setInternalUserProperties(
                { lastEntryVersion: this._gameVersion, gameID: e.shortName },
                this.toAdServer
              );
          }
          setUserID(e) {
            if (!this.initialized)
              throw Error("Cannot set user ID before analytics initialization");
            this.config.lineConversionAPIConfig &&
              !this.services.lineConversionApi &&
              ((this.services.lineConversionApi = new cr(e, this.config)),
              this.toDefaultAndPixel.push(this.services.lineConversionApi),
              this.toDefaultAndPixelAndAdServer.push(
                this.services.lineConversionApi
              ));
            for (const t of Object.values(this.services)) t.setUserID(e);
            this.setInternalUserProperties({ playerID: e }),
              this.services.adServer &&
                this.services.adServer.setUserProperties({
                  lastEntrySourceGamePlayerID: e,
                });
          }
          setAmplitudeDeviceID(e) {
            if (!this.initialized)
              throw Error(
                "Cannot set device ID before analytics initialization"
              );
            this.services.default instanceof ir &&
              this.services.default.setDeviceID(e),
              this.services.adServer instanceof ir &&
                this.services.adServer.setDeviceID(e);
          }
          trackSessionStartEvents() {
            if (!this.initialized)
              throw Error(
                "Cannot start session before analytics initialization"
              );
            if (this.trackedSessionStartEvents) return;
            this.trackedSessionStartEvents = !0;
            const e = {},
              t = Number(Cn().cdn_ts);
            t && (e.elapsedSinceCDNEntry = Nn.getNow() - t),
              this.pushEvent("session", e);
            try {
              u.Lr.getItem("device-install") ||
                (u.Lr.setItem("device-install", "true"),
                this.services.pixel
                  ? this.pushEvent(
                      "device-install",
                      null,
                      this.toDefaultAndPixel
                    )
                  : this.pushEvent("device-install"));
            } catch (n) {
              console.error("Failed to handle device-install event push", n);
            }
          }
          pushEvent(e, t, n) {
            var r;
            const s = {
              sessionElapsedTime: Math.round(window.performance.now()) / 1e3,
              timestamp: new Date(Nn.getNow()).toISOString(),
              version: this._gameVersion,
            };
            for (const i in t)
              null !== t[i] && void 0 !== t[i] && (s[i] = t[i]);
            (null == (r = this.config) ? void 0 : r.isDevelopment) &&
              (void 0 === s.errorMessage
                ? console.log("analytics.pushEvent: ".concat(e, " ="), s)
                : console.log("analytics.pushError: ".concat(e, " ="), s)),
              this.handleZoomUserProperties(),
              this._eventQueue.push(e),
              this._eventQueue.push(s),
              this._eventQueue.push(n),
              this.processEventQueue();
          }
          handleZoomUserProperties() {
            var e, t, n, r;
            if (!this.zoomClientContext) return;
            let s, i;
            "inMeeting" === this.zoomClientContext
              ? ((s =
                  null == (e = this.config)
                    ? void 0
                    : e.zoomMainClientUserProperties),
                (i =
                  null == (t = this.config)
                    ? void 0
                    : t.zoomMeetingClientUserProperties))
              : "inMainClient" === this.zoomClientContext &&
                ((s =
                  null == (n = this.config)
                    ? void 0
                    : n.zoomMeetingClientUserProperties),
                (i =
                  null == (r = this.config)
                    ? void 0
                    : r.zoomMainClientUserProperties));
            const o = { clientContext: this.zoomClientContext };
            if (s) for (const c of s) o[c] = "(none)";
            const a = this.getUserProperties();
            if (i)
              for (const c of i) {
                a[c] && (o[c] = a[c]);
              }
            this.setInternalUserProperties(o);
          }
          pushError(e, t, n, r) {
            var s;
            (n = n || {}),
              (t = t || {}),
              (null == (s = this.config) ? void 0 : s.isDevelopment) &&
                console.error("Sending ERROR:", e, t, n),
              this.pushEvent(
                e,
                {
                  ...n,
                  errorCode: t.code || "No Code",
                  errorMessage: t.message || "No Message",
                  errorStack: t.stack || "No Stack",
                  viberSupportId: t.supportId,
                },
                r
              ),
              this.pushEvent(
                "Error",
                {
                  ...n,
                  errorOrigin: e,
                  errorCode: t.code || "No Code",
                  errorMessage: t.message || "No Message",
                  errorStack: t.stack || "No Stack",
                  viberSupportId: t.supportId,
                },
                r
              );
          }
          pushRevenue(e) {
            var t;
            if (!this.config)
              throw Error("Initialize analytics before tracking revenue");
            const n = { ...e };
            "in_app_purchase" === n.revenueType &&
              n.revenueProvider &&
              (n.purchaseProvider = n.revenueProvider);
            if (
              !(void 0 !== n.dollarToLocalRate && void 0 !== n.revenueGross)
            ) {
              const e = this.config.convertCurrency({
                amount: n.revenueGrossLocal,
                fromCurrency: n.currencyCodeLocal,
                toCurrency: "USD",
              });
              (n.revenueGross = null == e ? void 0 : e.result),
                (n.dollarToLocalRate = null == e ? void 0 : e.exchangeRate);
            }
            const { revenueCurrency: r } = this.config;
            if (r) {
              const e = this.config.convertCurrency({
                amount: n.revenueGrossLocal,
                fromCurrency: n.currencyCodeLocal,
                toCurrency: r,
              });
              e &&
                ((n.currencyCodeSource = n.currencyCodeLocal),
                (n.currencyCodeLocal = r),
                (n.revenueGrossLocal = e.result),
                (n.sourceToLocalRate = e.exchangeRate));
            }
            let s = n.processorFee;
            void 0 === s &&
              ("stripe" === n.purchaseProvider
                ? (s = 0.044 * n.revenueGross + 0.3)
                : "komoju" === n.purchaseProvider
                ? n.purchaseProviderMethod in ur
                  ? (s = (ur[n.purchaseProviderMethod] * n.revenueGross) / 100)
                  : "komoju_credit_card" === n.purchaseProviderMethod &&
                    n.purchaseProviderCreditCardBrand in dr &&
                    (s =
                      (dr[n.purchaseProviderCreditCardBrand] * n.revenueGross) /
                      100)
                : (s =
                    "atone" === n.purchaseProvider
                      ? 0.039 * n.revenueGross
                      : "xsolla" === n.purchaseProvider
                      ? 0.08 * n.revenueGross
                      : "in_app_purchase" === n.revenueType
                      ? 0.3 * n.revenueGross
                      : 0)),
              delete n.purchaseProviderCreditCardBrand;
            const i =
              n.revenueGross - (null !== (t = s) && void 0 !== t ? t : 0);
            if (r) {
              const e = this.config.convertCurrency({
                amount: i,
                fromCurrency: "USD",
                toCurrency: r,
              });
              e && (n.revenueNetLocal = e.result);
            }
            this.services.default.trackRevenue({
              ...n,
              revenueNet: i,
              processorFee: s,
            }),
              this.config.fbPixelId &&
                this.services.pixel.track("Revenue", {
                  ...n,
                  currency: "USD",
                  value: i,
                }),
              this.services.lineConversionApi &&
                this.services.lineConversionApi.trackRevenue({
                  ...n,
                  revenueNet: i,
                }),
              this.processEventQueue();
          }
          processEventQueue() {
            if (this.initialized) {
              for (let e = 0; e < this._eventQueue.length; e += 3) {
                const t = this._eventQueue[e],
                  n = this._eventQueue[e + 1],
                  r = this._eventQueue[e + 2] || this.toDefault;
                for (const e of r) e.track(t, n);
              }
              this._eventQueue.length = 0;
            } else
              null === this.processEventQueueTimeoutHandle &&
                (this.processEventQueueTimeoutHandle = window.setTimeout(() => {
                  this.processEventQueue();
                }, 1e3));
          }
          getTrackingQueryParams() {
            var e, t;
            return null !==
              (e =
                null == (t = this.services.default)
                  ? void 0
                  : t.getTrackingQueryParams()) && void 0 !== e
              ? e
              : {};
          }
        })(),
        pr = hr,
        fr = hr,
        mr = window.onerror,
        gr = {};
      function vr(e, t, n) {
        n = n || document.body;
        const r = document.createElement(e);
        return n.appendChild(r), t && (r.className = t), r;
      }
      function yr(e, t) {
        return vr("div", e, t);
      }
      function br(e, t) {
        (t = t || document.body).removeChild(e);
      }
      function wr(e, t, n) {
        return (e.onclick = () => t(n)), e;
      }
      function Sr(e, t, n) {
        const r = new Error(t || e);
        return (
          (r.code = e), (r.isRetryable = null == n ? void 0 : n.isRetryable), r
        );
      }
      function _r(e) {
        return (function (e) {
          return e && "object" === typeof e && "error" in e;
        })(e)
          ? e.error
          : e;
      }
      (window.onerror = (e, t, n, r, s) => {
        const i = n + "." + r;
        gr[i] ||
          ((gr[i] = !0),
          hr.pushError("window.onerror", s, {
            msg: e,
            url: t,
            line: n,
            col: r,
          }),
          null == mr || mr(e, t, n, r, s));
      }),
        window.addEventListener("unhandledrejection", function (e) {
          var t;
          const n = e.reason || (null == (t = e.detail) ? void 0 : t.reason);
          "NETWORK_FAILURE" !== (null == n ? void 0 : n.code) ||
          "A network error has occurred" !== (null == n ? void 0 : n.message)
            ? hr.pushError("PromiseError", n)
            : console.warn("Unhandled rejection due to network failure:", n);
        });
      var Er = Object.defineProperty,
        Ar = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Er(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      const Tr = l.os.isIOS
        ? "https://profile.line-scdn.net/0hzGqO9qOwJWhMNgh6B6BaP31kLRl_RnxuMRF2Wz1hKxw8QzpAElBiW2ozfllnQ2M3I1BtWzo2.jpg"
        : "https://profile.line-scdn.net/0hRfNh_nMwDUlzESBbOKdyHkJDBThAYVRPDjZeegJGAz0DZDphLXdKelUUVHBXZEsWHHdFegMR.jpg";
      class Pr {
        constructor(e) {
          Ar(this, "hasPhoto"),
            Ar(this, "id"),
            Ar(this, "isPlayer", !0),
            Ar(this, "name"),
            Ar(this, "photo"),
            Ar(this, "photoLarge"),
            Ar(this, "photoSmall"),
            Ar(this, "_customProperties"),
            (this.hasPhoto = !0),
            this._applyData(e);
        }
        static fromExternalFriend(e) {
          return new Pr({
            providerKey: e.id,
            displayName: e.name,
            pictureUrl: e.profilePicture,
            isPlayer: e.isPlayer,
          });
        }
        _applyData(e) {
          if (Array.isArray(e))
            (this.id = e[0]), (this.name = e[1]), (this.photo = e[2]);
          else if (
            "object" === typeof e &&
            "getID" in e &&
            "function" === typeof e.getID &&
            "function" === typeof e.getName &&
            "function" === typeof e.getPhoto
          )
            (this.id = e.getID()),
              (this.name = e.getName() || ""),
              (this.photo = e.getPhoto() || "");
          else {
            if ("object" !== typeof e || !("providerKey" in e))
              throw Error("Unrecognized friend object: " + e);
            (this.id = e.providerKey),
              (this.isPlayer = e.isPlayer),
              (this.name = e.displayName),
              (this.photo = e.pictureUrl),
              this.photo
                ? ((this.photoLarge = this.photo + "/large"),
                  (this.photoSmall = this.photo + "/small"))
                : ((this.photo = Tr), (this.hasPhoto = !1));
          }
        }
      }
      const Ir = {
          player: {
            6022359826810851: {
              id: "6022359826810851",
              name: "Foxy Fox",
              photo:
                "https://storage.googleapis.com/devkit-instant/avatar/animal_0002.png",
              haveContext: !0,
            },
            2514324314253407: {
              id: "2514324314253407",
              name: "Squidy Squid",
              photo:
                "https://storage.googleapis.com/devkit-instant/avatar/animal_0003.png",
              haveContext: !0,
            },
            1986709586798753: {
              id: "1986709586798753",
              name: "\u3046\u3055\u304e-\u3061\u3083\u3093",
              photo:
                "https://storage.googleapis.com/devkit-instant/avatar/animal_0004.png",
              haveContext: !0,
            },
            6879178275649305: {
              id: "6879178275649305",
              name: "Pedro Parrot",
              photo:
                "https://storage.googleapis.com/devkit-instant/avatar/animal_0005.png",
              haveContext: !0,
            },
            5358425046345768: {
              id: "5358425046345768",
              name: "Froggy Frog",
              photo:
                "https://storage.googleapis.com/devkit-instant/avatar/animal_0006.png",
              haveContext: !1,
            },
            1156382005235567: {
              id: "1156382005235567",
              name: "Teddy Bear",
              photo:
                "https://storage.googleapis.com/devkit-instant/avatar/animal_0007.png",
              haveContext: !1,
            },
            6883023789966730: {
              id: "6883023789966730",
              name: "\u7af9\u718a\u732b",
              photo:
                "https://storage.googleapis.com/devkit-instant/avatar/animal_0008.png",
              haveContext: !1,
            },
            4455676893732006: {
              id: "4455676893732006",
              name: "Doge",
              photo:
                "https://storage.googleapis.com/devkit-instant/avatar/animal_0009.png",
              haveContext: !1,
            },
          },
          group: {
            "0000006279834560": {
              name: "group 1",
              players: [
                "6022359826810851",
                "2514324314253407",
                "1156382005235567",
              ],
            },
            "0000006928932494": {
              name: "group 2",
              players: ["1156382005235567", "5358425046345768"],
            },
            "0000006062502756": {
              name: "group 3",
              players: [
                "2514324314253407",
                "5358425046345768",
                "6883023789966730",
                "4455676893732006",
              ],
            },
          },
          tournament: {
            11111111111: { name: "tournament 1", players: [] },
            22222222222: { name: "tournament 2", players: [] },
            33333333333: { name: "tournament 3", players: [] },
          },
          squad: {
            59111111111: {
              name: "squad 1",
              players: [
                "6022359826810851",
                "2514324314253407",
                "1156382005235567",
              ],
            },
            59222222222: {
              name: "squad 2",
              players: ["1156382005235567", "5358425046345768"],
            },
            59333333333: {
              name: "squad 3",
              players: [
                "2514324314253407",
                "5358425046345768",
                "6883023789966730",
                "4455676893732006",
              ],
            },
          },
        },
        Cr = function (e, t) {
          return new Promise(function (n, r) {
            const s = t.friendsMap[e],
              i = yr("devkit-instant-mock-overlay"),
              o = yr("devkit-instant-mock-context-switch", i),
              a = yr("devkit-instant-mock-context-switch-box", o),
              c = yr("devkit-instant-mock-closeBtn", a),
              l = yr(null, a);
            (yr(
              "devkit-instant-mock-context-switch-icon",
              l
            ).style.backgroundImage = "url(" + t.playerPhoto + ")"),
              (yr(
                "devkit-instant-mock-context-switch-icon",
                l
              ).style.backgroundImage = "url(" + s.photo + ")"),
              (vr("h1", null, a).innerText = "Invite " + s.name + " to play");
            const u = yr(
              "devkit-instant-mock-context-choose-item-btn devkit-instant-mock-context-switch-btn",
              a
            );
            (u.innerText = "Invite"),
              wr(c, () => {
                br(i), r(Sr("USER_INPUT"));
              }),
              wr(u, () => {
                br(i), n(s);
              });
          });
        };
      let kr = !1;
      const Or = function (e) {
        return kr
          ? Promise.reject(Sr("PENDING_REQUEST"))
          : ((kr = !0),
            new Promise(function (t, n) {
              const r = yr("devkit-instant-mock-overlay"),
                s = yr("devkit-instant-mock-context-choose", r),
                i = vr("h1", void 0, s);
              i.innerText = "Invite to Play";
              wr(yr("devkit-instant-mock-closeBtn", i), () => {
                (kr = !1), br(r), n(Sr("USER_INPUT"));
              });
              const o = yr(null, s);
              function a(e) {
                const n = yr("devkit-instant-mock-context-choose-item", o),
                  s = yr("devkit-instant-mock-context-choose-item-icon", n);
                (yr(
                  "devkit-instant-mock-context-choose-item-title",
                  n
                ).innerText = "single" === e.type ? e.friend.name : e.name),
                  (yr(
                    "devkit-instant-mock-context-choose-item-btn",
                    n
                  ).innerText = "PLAY"),
                  "single" === e.type &&
                    (s.style.backgroundImage = "url(" + e.friend.photo + ")"),
                  wr(n, () => {
                    (kr = !1), br(r), t(e);
                  });
              }
              vr("h2", null, o).innerText = "Friends";
              for (const c of e.friends) a({ type: "single", friend: c });
              vr("h2", null, o).innerText = "Groups";
              for (const e in Ir.group) {
                const t = Ir.group[e],
                  n = t.players.map((e) => {
                    const t = Ir.player[e];
                    return new Pr([t.id, t.name, t.photo]);
                  });
                a({ type: "group", id: e, name: t.name, players: n });
              }
              vr("h2", null, o).innerText = "Tournaments";
              for (const e in Ir.tournament)
                a({ type: "tournament", id: e, name: Ir.tournament[e].name });
              setTimeout(() => {
                (s.style.top = "1px"), (s.style.opacity = "1");
              }, 100);
            }));
      };
      function xr(e) {
        const t = new Error(e);
        return (t.code = e), t;
      }
      const Nr = function () {
        return new Promise(function (e, t) {
          const n = yr("devkit-instant-mock-overlay"),
            r = yr("devkit-instant-mock-matchmakingInfo", n),
            s = yr("devkit-instant-mock-matchmakingInfo-box", r),
            i = yr("devkit-instant-mock-closeBtn", s);
          (vr("h1", void 0, s).innerText = "Challenge Others to Play"),
            (vr("p", void 0, s).innerText =
              "Messenger will add you to a group chat with other players so you can connect and play games together. It may take a few moments to find other players so you can close Messenger while you wait."),
            (vr("p", void 0, s).innerText =
              "Your name and profile picture will be displayed. You can leave the group chat at any time. Ready, set, game on!");
          const o = yr("devkit-instant-mock-matchmakingInfo-btn", s);
          (o.innerText = "Challenge Others"),
            wr(i, () => {
              br(n), t(xr("USER_INPUT"));
            }),
            wr(o, () => {
              br(n), e();
            });
        });
      };
      class Rr {
        constructor(e, t, n) {
          (this.id = e), (this.players = t), (this.type = n);
        }
        static single(e, t) {
          const n = "player:" + (t ? [e.id, t].sort().join(",") : e.id);
          return new Rr(n, [e], "SINGLE");
        }
        static group(e, t) {
          return new Rr("group:" + t, e, "GROUP");
        }
        static squad(e) {
          return new Rr("squad:" + e, [], "SQUAD");
        }
        static tournament(e) {
          const t = e || "" + Math.floor(Nn.getNow() / 1e3 / 3600);
          return new Rr("tournament:" + t, [], "TOURNAMENT");
        }
      }
      const Dr = function () {
          return new Promise(function (e, t) {
            const n = Ir.group,
              r = yr("devkit-instant-mock-overlay"),
              s = yr("devkit-instant-mock-matchmakingSearch", r),
              i = yr("devkit-instant-mock-matchmakingSearch-box", s),
              o = yr("devkit-instant-mock-closeBtn", i);
            (vr("h1", null, i).innerText = "Searching ..."),
              wr(o, () => {
                br(r), t(xr("USER_INPUT"));
              });
            const a = Object.keys(n),
              c = a[Math.floor(Math.random() * a.length)],
              l = n[c].players.map((e) => Ir.player[e]),
              u = Rr.group(l, c);
            setTimeout(() => {
              br(r), e(u);
            }, 2e3);
          });
        },
        Mr = (e) =>
          new Promise((t, n) => {
            const { price: r, id: s } = e,
              i = yr("devkit-instant-mock-overlay"),
              o = yr("devkit-instant-mock-purchase-confirmation", i),
              a = yr("devkit-instant-mock-purchase-confirmation-box", o),
              c = yr("devkit-instant-mock-closeBtn", a);
            (vr("h1", null, a).innerText = "Confirm your purchase of " + s),
              (vr("h2", null, a).innerText = r);
            const l = yr("devkit-instant-mock-purchase-confirmation-btn", a);
            (l.innerText = "Confirm"),
              wr(c, () => {
                br(i), n(xr("USER_INPUT"));
              }),
              wr(l, () => {
                br(i), t();
              });
          }),
        jr = function (e) {
          return new Promise(function (t, n) {
            const r = yr("devkit-instant-mock-overlay"),
              s = yr("devkit-instant-mock-shareAsync", r),
              i = yr("devkit-instant-mock-shareAsync-box", s);
            vr(
              "div",
              "devkit-instant-mock-shareAsync-image",
              i
            ).style.backgroundImage = "url(" + e + ")";
            const o = yr("devkit-instant-mock-shareAsync-buttons", i),
              a = yr("devkit-instant-mock-shareAsync-button", o);
            a.innerText = "Cancel";
            const c = yr(
              "devkit-instant-mock-shareAsync-button button-blue",
              o
            );
            (c.innerText = "Share"),
              wr(c, () => {
                br(r), t();
              }),
              wr(a, () => {
                br(r), n(xr("USER_INPUT"));
              });
          });
        },
        Lr = function () {
          return new Promise(function (e, t) {
            const n = yr("devkit-instant-mock-overlay"),
              r = yr("devkit-instant-mock-shareAsyncTournament", n),
              s = yr("devkit-instant-mock-shareAsyncTournament-box", r),
              i = yr("devkit-instant-mock-shareAsyncTournament-text", s);
            (vr("h1", null, i).innerText = "Tournament"),
              (vr("p", null, i).innerText = "Do you want to share your score?");
            const o = yr("devkit-instant-mock-shareAsyncTournament-buttons", s),
              a = yr("devkit-instant-mock-shareAsyncTournament-button", o);
            a.innerText = "Cancel";
            const c = yr(
              "devkit-instant-mock-shareAsyncTournament-button button-blue",
              o
            );
            (c.innerText = "Share"),
              wr(c, () => {
                br(n), e();
              }),
              wr(a, () => {
                br(n), t(xr("USER_INPUT"));
              });
          });
        },
        Ur = function () {
          return new Promise(function (e, t) {
            const n = yr("devkit-instant-mock-overlay"),
              r = yr("devkit-instant-mock-squad-create", n),
              s = yr("devkit-instant-mock-squad-create-box", r);
            vr("h1", null, s).innerText = "Create a squad?";
            const i = yr("devkit-instant-mock-squad-create-buttons", s),
              o = yr("devkit-instant-mock-squad-create-button-cancel", i);
            o.innerText = "Cancel";
            const a = yr("devkit-instant-mock-squad-create-button-confirm", i);
            (a.innerText = "Create"),
              wr(a, () => {
                br(n), e();
              }),
              wr(o, () => {
                br(n), t(xr("USER_INPUT"));
              });
          });
        },
        Fr = function (e, t) {
          return new Promise(function (n, r) {
            const s = Ir.squad[e],
              i = yr("devkit-instant-mock-overlay"),
              o = yr("devkit-instant-mock-squad-join", i),
              a = yr("devkit-instant-mock-squad-join-box", o),
              c = yr(null, a);
            yr("devkit-instant-mock-squad-join-icon", c).style.backgroundImage =
              "url(" + t + ")";
            for (const e of (null == s ? void 0 : s.players) || [])
              yr(
                "devkit-instant-mock-squad-join-icon",
                c
              ).style.backgroundImage = "url(" + Ir.player[e].photo + ")";
            vr("h1", null, a).innerText = "Join ".concat(
              (null == s ? void 0 : s.name) || "this squad",
              "?"
            );
            const l = yr("devkit-instant-mock-squad-create-buttons", a),
              u = yr("devkit-instant-mock-squad-join-button-cancel", l);
            u.innerText = "Cancel";
            const d = yr("devkit-instant-mock-squad-join-button-confirm", l);
            (d.innerText = "Join"),
              wr(d, () => {
                br(i), n();
              }),
              wr(u, () => {
                br(i), r(xr("USER_INPUT"));
              });
          });
        },
        Br = function (e, t) {
          return new Promise(function (n, r) {
            let s = null,
              i = null,
              o = null;
            const [a, c] = e.split(":");
            let l = Ir[a][c];
            if ("tournament" === a) {
              o = [];
              const e = l ? c : void 0;
              (s = Rr.tournament(e)),
                l || (l = { name: "Tournament: " + s.id, players: [] });
            }
            if (!l) return r(xr("INVALID_PARAM"));
            if ("group" === a) {
              o = [];
              for (const e of l.players) o.push(Ir.player[e]);
              s = Rr.group(o, c);
            }
            if (
              ("player" === a &&
                ((i = new Pr([c, l.name, l.photo])), (s = Rr.single(i))),
              !s)
            )
              return r(xr("INVALID_PARAM"));
            if (t.contextID === s.id) return r(xr("SAME_CONTEXT"));
            const u = yr("devkit-instant-mock-overlay"),
              d = yr("devkit-instant-mock-context-switch", u),
              h = yr("devkit-instant-mock-context-switch-box", d),
              p = yr("devkit-instant-mock-closeBtn", h),
              f = yr(null, h);
            if (o) {
              yr(
                "devkit-instant-mock-context-switch-icon",
                f
              ).style.backgroundImage = "url(" + t.playerPhoto + ")";
              for (const e of o)
                yr(
                  "devkit-instant-mock-context-switch-icon",
                  f
                ).style.backgroundImage = "url(" + e.photo + ")";
              vr("h1", null, h).innerText = "Play with ".concat(l.name);
            }
            i &&
              ((yr(
                "devkit-instant-mock-context-switch-icon",
                f
              ).style.backgroundImage = "url(" + t.playerPhoto + ")"),
              (yr(
                "devkit-instant-mock-context-switch-icon",
                f
              ).style.backgroundImage = "url(" + i.photo + ")"),
              (vr("h1", void 0, h).innerText = "Play with ".concat(i.name)));
            const m = yr(
              "devkit-instant-mock-context-choose-item-btn devkit-instant-mock-context-switch-btn",
              h
            );
            (m.innerText = "Play"),
              wr(p, () => {
                br(u), r(xr("USER_INPUT"));
              }),
              wr(m, () => {
                br(u), n(s);
              });
          });
        };
      function Vr(e) {
        let t,
          n = !1;
        return function () {
          return n || ((t = e(...arguments)), (n = !0)), t;
        };
      }
      function qr(e) {
        return {
          title: e.title,
          id: e.productID,
          description: e.description,
          imageURI: e.imageURI,
          price: e.price,
          currencyCode: e.priceCurrencyCode,
        };
      }
      function Hr(e) {
        fr.pushEvent("NativeSubscribePushPrompt", e);
      }
      function Wr(e) {
        fr.pushEvent("NativeSubscribePushPromptSuccess", e);
      }
      function Kr(e, t) {
        fr.pushError("NativeSubscribePushPromptFailure", e, t);
      }
      var zr,
        Gr,
        Jr,
        Qr,
        Yr,
        Xr,
        Zr,
        $r,
        es,
        ts,
        ns = Object.defineProperty,
        rs = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? ns(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      function ss(e) {
        if (!e.isAvailable) throw new Error("API not available");
      }
      class is {
        constructor() {
          rs(this, "interface", "native-builder"),
            rs(this, "platform", {
              get os() {
                var e;
                return null == (e = window.TLNative) ? void 0 : e.Settings.os;
              },
              get version() {
                var e;
                return null == (e = window.TLNative)
                  ? void 0
                  : e.Settings.nativeVersion;
              },
              get locale() {
                var e;
                return null == (e = window.TLNative)
                  ? void 0
                  : e.Settings.locale;
              },
            }),
            rs(this, "app", {
              get version() {
                var e, t;
                return null ==
                  (t = null == (e = window.Native) ? void 0 : e.app)
                  ? void 0
                  : t.version;
              },
            }),
            rs(this, "amplitude", {
              async getDeviceId() {
                var e, t;
                return null ==
                  (t = null == (e = window.Native) ? void 0 : e.amplitude)
                  ? void 0
                  : t.deviceId;
              },
            }),
            rs(
              this,
              "attribution",
              (
                null ==
                (Qr =
                  null ==
                  (Jr =
                    null ==
                    (Gr =
                      null == (zr = window.Native) ? void 0 : zr.attribution)
                      ? void 0
                      : Gr.results)
                    ? void 0
                    : Jr.data)
                  ? void 0
                  : Qr.payload
              )
                ? Promise.resolve(
                    window.Native.attribution.results.data.payload
                  )
                : void 0
            ),
            rs(this, "game", {
              show() {
                var e, t;
                null == (t = null == (e = window.TLNative) ? void 0 : e.core) ||
                  t.notifyLoaded();
              },
              reload(e) {
                var t, n, r;
                null ==
                  (r =
                    null ==
                    (n = null == (t = window.TLNative) ? void 0 : t.core)
                      ? void 0
                      : n.restart) || r.call(n, e);
              },
            }),
            rs(
              this,
              "links",
              new (class {
                constructor() {
                  rs(
                    this,
                    "_firstOpenedPromise",
                    null ==
                      (Zr =
                        null ==
                        (Xr = null == (Yr = window.Native) ? void 0 : Yr.links)
                          ? void 0
                          : Xr.getEvents)
                      ? void 0
                      : Zr.call(Xr).then((e) => {
                          var t;
                          return null ==
                            (t = e.find((e) => "closed" === e.appState))
                            ? void 0
                            : t.url;
                        })
                  );
                }
                get isAvailable() {
                  var e, t;
                  return (
                    "function" ===
                    typeof (null ==
                    (t = null == (e = window.Native) ? void 0 : e.links)
                      ? void 0
                      : t.getEvents)
                  );
                }
                async firstOpened() {
                  return ss(this), this._firstOpenedPromise;
                }
                async list() {
                  ss(this);
                  return (await window.Native.links.getEvents()).map((e) => {
                    let { url: t } = e;
                    return t;
                  });
                }
                async remove(e) {}
                subscribe(e) {
                  ss(this),
                    window.Native.links.addEventListener((t) => {
                      e(t.url);
                    });
                }
              })()
            ),
            rs(
              this,
              "auth",
              new (class {
                get isAvailable() {
                  var e, t;
                  return (
                    "function" ===
                    typeof (null ==
                    (t = null == (e = window.Native) ? void 0 : e.login)
                      ? void 0
                      : t.getSession)
                  );
                }
                async fetch() {
                  return ss(this), window.Native.login.getSession();
                }
                async logout() {
                  ss(this), window.Native.login.logout();
                }
              })()
            ),
            rs(
              this,
              "notifications",
              new (class {
                constructor() {
                  rs(
                    this,
                    "_firstOpenedPromise",
                    null ==
                      (ts =
                        null ==
                        (es =
                          null == ($r = window.Native)
                            ? void 0
                            : $r.pushNotifications)
                          ? void 0
                          : es.getAccepted)
                      ? void 0
                      : ts
                          .call(es)
                          .then((e) => e.find((e) => "closed" === e.appState))
                  );
                }
                get isAvailable() {
                  var e, t;
                  return (
                    "function" ===
                    typeof (null ==
                    (t =
                      null == (e = window.Native)
                        ? void 0
                        : e.pushNotifications)
                      ? void 0
                      : t.register)
                  );
                }
                async firstOpened() {
                  return ss(this), this._firstOpenedPromise;
                }
                async register(e) {
                  ss(this), Hr(e);
                  const { userAuthorization: t, deviceToken: n } =
                      await window.Native.pushNotifications.register(),
                    r = !!n && "denied" !== t;
                  return (
                    hr.setUserProperties({
                      isRegisteredForPushNotifications: r,
                    }),
                    r
                      ? Wr(e)
                      : Kr(
                          Sr(
                            "USER_INPUT",
                            "Did not register for notifications"
                          ),
                          e
                        ),
                    { success: r, deviceToken: r ? n : void 0 }
                  );
                }
                async list() {
                  return (
                    ss(this), window.Native.pushNotifications.getAccepted()
                  );
                }
                async remove(e) {}
                subscribe(e) {
                  ss(this),
                    window.Native.pushNotifications.addAcceptedListener(e);
                }
              })()
            ),
            rs(
              this,
              "purchases",
              new (class {
                constructor() {
                  rs(this, "initPromise"),
                    rs(this, "catalog", []),
                    rs(
                      this,
                      "init",
                      Vr(async (e) => {
                        ss(this),
                          (this.initPromise = (async () => {
                            await Kn(() =>
                              window.TLNative.Payments.initAsync(e)
                            );
                            const { result: t } = await Kn(() =>
                              window.TLNative.Payments.getCatalogAsync()
                            );
                            this.catalog = t.map(qr);
                          })()),
                          await this.initPromise;
                      })
                    );
                }
                get isAvailable() {
                  var e;
                  return (
                    "yes" ===
                    (null == (e = window.TLNative)
                      ? void 0
                      : e.Settings.paymentsAvailable)
                  );
                }
                async products() {
                  return ss(this), await this.initPromise, this.catalog;
                }
                async purchase(e, t) {
                  return (
                    ss(this),
                    await this.initPromise,
                    window.TLNative.Payments.purchaseAsync({
                      productID: e,
                      developerPayload: t,
                    })
                  );
                }
                async finish(e) {
                  return (
                    ss(this),
                    await this.initPromise,
                    window.TLNative.Payments.consumePurchaseAsync(
                      e.purchaseToken
                    )
                  );
                }
                async unfinished() {
                  return (
                    ss(this),
                    await this.initPromise,
                    window.TLNative.Payments.getPurchasesAsync()
                  );
                }
              })()
            ),
            rs(
              this,
              "store",
              new (class {
                get isAvailable() {
                  var e;
                  return (
                    "function" ===
                    typeof (null == (e = window.TLNative)
                      ? void 0
                      : e.RequestStoreReview)
                  );
                }
                async requestReview(e) {
                  return ss(this), window.TLNative.RequestStoreReview(!0);
                }
              })()
            );
        }
        static create() {
          if (window.Native || window.TLNative) return new is();
        }
      }
      var os = Object.defineProperty,
        as = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? os(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class cs {
        constructor() {
          as(
            this,
            "id",
            (function () {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : 21;
              return crypto
                .getRandomValues(new Uint8Array(e))
                .reduce(
                  (e, t) =>
                    e +
                    ((t &= 63) < 36
                      ? t.toString(36)
                      : t < 62
                      ? (t - 26).toString(36).toUpperCase()
                      : t > 62
                      ? "-"
                      : "_"),
                  ""
                );
            })()
          ),
            as(this, "subscribers", []);
        }
        subscribe(e) {
          let t = !0;
          const n = (n) => {
            t && e(n);
          };
          this.subscribers = this.subscribers.concat([n]);
          return () => {
            (t = !1),
              (this.subscribers = this.subscribers.filter((e) => e !== n));
          };
        }
        push(e) {
          for (const t of this.subscribers) t(e);
        }
        unsubscribeAll() {
          this.subscribers = [];
        }
      }
      var ls = Object.defineProperty,
        us = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? ls(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class ds {
        constructor() {
          us(this, "channels", {});
        }
        get(e) {
          return this.channels[e];
        }
        create() {
          const e = new cs();
          return (this.channels[e.id] = e), e;
        }
        remove(e) {
          null == e || e.unsubscribeAll(), delete this.channels[e.id];
        }
      }
      class hs extends Error {
        constructor(e) {
          super("string" === typeof e ? e : JSON.stringify(e)),
            (this.value = e);
        }
      }
      var ps = Object.defineProperty;
      const fs = class e {
        constructor(e, t, n, r, s) {
          (this.major = e),
            (this.minor = t),
            (this.patch = n),
            (this.preRelease = r),
            (this.build = s);
        }
        static parse(t) {
          if (t instanceof e) return t;
          const n = t.match(e.PATTERN);
          if (n) {
            const t = n[1] ? parseInt(n[1], 10) : Number.NaN,
              r = n[2] ? parseInt(n[2], 10) : Number.NaN,
              s = n[3] ? parseInt(n[3], 10) : Number.NaN,
              i = n[4],
              o = n[5];
            if (!Number.isNaN(t) && !Number.isNaN(r) && !Number.isNaN(s))
              return new e(t, r, s, i, o);
          }
          throw new Error("Invalid version: ".concat(t));
        }
        matchMajor(e, t) {
          if (this.major === e) return t(this);
        }
        matchMinor(e, t) {
          if (this.minor >= e) return t(this);
        }
        matchMajorMinor(e, t, n) {
          return this.matchMajor(e, (e) => e.matchMinor(t, n));
        }
        toString() {
          let e = ""
            .concat(this.major, ".")
            .concat(this.minor, ".")
            .concat(this.patch);
          return (
            void 0 !== this.preRelease && (e += "-".concat(this.preRelease)),
            void 0 !== this.build && (e += "+".concat(this.build)),
            e
          );
        }
        equals(t) {
          return (
            (t = e.parse(t)),
            this.major === t.major &&
              this.minor === t.minor &&
              this.patch === t.patch &&
              this.preRelease === t.preRelease
          );
        }
        isGreaterThan(t) {
          if (((t = e.parse(t)), this.major > t.major)) return !0;
          if (this.major === t.major) {
            if (this.minor > t.minor) return !0;
            if (this.minor === t.minor) {
              if (this.patch > t.patch) return !0;
              if (this.patch === t.patch) {
                if (void 0 === this.preRelease && void 0 === t.preRelease)
                  return !1;
                if (void 0 === this.preRelease) return !0;
                if (void 0 === t.preRelease) return !1;
                const e = this.preRelease.split("."),
                  n = t.preRelease.split(".");
                for (let t = 0; t < Math.max(e.length, n.length); t++) {
                  const r = e[t],
                    s = n[t];
                  if (void 0 === r) return !1;
                  if (void 0 === s) return !0;
                  if (r === s) continue;
                  const i = /^\d+$/.test(r),
                    o = /^\d+$/.test(s);
                  return i && o
                    ? parseInt(r, 10) > parseInt(s, 10)
                    : !i && (!!o || r > s);
                }
              }
            }
          }
          return !1;
        }
        isGreaterThanOrEqual(t) {
          return (t = e.parse(t)), this.equals(t) || this.isGreaterThan(t);
        }
        isLessThan(e) {
          return !this.isGreaterThanOrEqual(e);
        }
        isLessThanOrEqual(t) {
          return (t = e.parse(t)), this.equals(t) || !this.isGreaterThan(t);
        }
      };
      var ms;
      ((e, t, n) => {
        t in e
          ? ps(e, t, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: n,
            })
          : (e[t] = n);
      })(
        fs,
        "symbol" !== typeof (ms = "PATTERN") ? ms + "" : ms,
        /^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-.]+))?(?:\+([0-9A-Za-z-.]+))?$/
      );
      let gs = fs;
      var vs = Object.defineProperty,
        ys = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? vs(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      const bs = class e {
        constructor(e, t) {
          var n, r, s, i, o, a;
          ys(this, "version"),
            ys(this, "modules"),
            ys(this, "platform"),
            ys(this, "app"),
            ys(this, "channels", new ds()),
            (this.send = t),
            (this.version = gs.parse(e.version)),
            (this.modules = e.modules.map((e) => ({
              ...e,
              version: gs.parse(e.version),
            }))),
            (this.platform = {
              os:
                null !== (n = null == (i = e.platform) ? void 0 : i.os) &&
                void 0 !== n
                  ? n
                  : e.os,
              version: null == (o = e.platform) ? void 0 : o.version,
              locale:
                null !== (r = null == (a = e.platform) ? void 0 : a.locale) &&
                void 0 !== r
                  ? r
                  : e.app.locale,
            }),
            (this.app = {
              id: null !== (s = e.app.id) && void 0 !== s ? s : e.app.bundle,
              version: e.app.version,
              build: e.app.build,
            });
        }
        static create(t) {
          var n, r;
          if (!t || "object" !== typeof t) return;
          (t.$Native = null !== (n = t.$Native) && void 0 !== n ? n : {}),
            (t.$Native.out =
              null !== (r = t.$Native.out) && void 0 !== r ? r : []);
          const s = t.$Native.in;
          if (Array.isArray(s)) {
            const n = s.find((e) => "ready" === e.type);
            if (!n) return;
            const r = new e(n, (e) => t.$Native.out.push(e));
            t.$Native.in = r;
            for (const e of s) r.push(e);
            return r;
          }
        }
        push(e) {
          if ("event" === e.type) {
            const t = e,
              n = this.channels.get(t.channel);
            null == n || n.push(t.data);
          }
        }
        request(e, t) {
          const n = this.channels.create(),
            r = new Promise((e, t) => {
              n.subscribe((r) => {
                this.channels.remove(n);
                const [s, i] = r;
                switch (s) {
                  case "ok":
                    e(i);
                    break;
                  case "err":
                    t(new hs(i));
                }
              });
            });
          return (
            this.send({ type: "request", module: e, channel: n.id, data: t }), r
          );
        }
        findModule(e, t) {
          return this.modules.find(
            (n) => n.name === e && n.version.major === t
          );
        }
      };
      ys(
        bs,
        "getInstance",
        Vr(() => bs.create(window))
      );
      let ws = bs;
      class Ss {
        constructor(e, t) {
          (this.bridge = e), (this.module = t);
        }
        request(e) {
          return this.bridge.request(this.module.id, e);
        }
        async fetch() {
          return this.request({ type: "fetch" });
        }
      }
      const _s = class {
        constructor(e, t) {
          (this.module = e), (this.version = t), (this.fetch = e.fetch.bind(e));
        }
      };
      (_s.create = (e) => {
        const t = e.findModule("apple-search-ads", 0);
        if (t) return new _s(new Ss(e, t), t.version);
      }),
        (_s.getInstance = Vr(() => {
          const e = ws.getInstance();
          if (e) return _s.create(e);
        }));
      let Es = _s;
      class As {
        constructor(e, t) {
          (this.bridge = e), (this.module = t);
        }
        request(e) {
          return this.bridge.request(this.module.id, e);
        }
        async isShowing() {
          return await this.request({ type: "is showing" });
        }
        async show() {
          await this.request({ type: "show" });
        }
        async hide() {
          await this.request({ type: "hide" });
        }
      }
      const Ts = class {
        constructor(e, t) {
          (this.module = e),
            (this.version = t),
            (this.isShowing = e.isShowing.bind(e)),
            (this.show = e.show.bind(e)),
            (this.hide = e.hide.bind(e));
        }
      };
      (Ts.create = (e) => {
        const t = e.findModule("launch-screen", 0);
        if (t) return new Ts(new As(e, t), t.version);
      }),
        (Ts.getInstance = Vr(() => {
          const e = ws.getInstance();
          if (e) return Ts.create(e);
        }));
      let Ps = Ts;
      class Is {
        constructor(e, t) {
          (this.bridge = e), (this.module = t);
        }
        request(e) {
          return this.bridge.request(this.module.id, e);
        }
        async list() {
          return await this.request({ type: "list" });
        }
        async remove(e) {
          await this.request({ type: "remove", url: e });
        }
        async receive() {
          return await this.request({ type: "receive" });
        }
      }
      const Cs = class {
        constructor(e, t) {
          (this.module = e),
            (this.version = t),
            (this.list = e.list.bind(e)),
            (this.remove = e.remove.bind(e)),
            (this.receive = e.receive.bind(e));
        }
      };
      (Cs.create = (e) => {
        const t = e.findModule("links", 0);
        if (t) return new Cs(new Is(e, t), t.version);
      }),
        (Cs.getInstance = Vr(() => {
          const e = ws.getInstance();
          if (e) return Cs.create(e);
        }));
      let ks = Cs;
      class Os {
        constructor(e, t) {
          (this.bridge = e), (this.module = t);
        }
        request(e) {
          return this.bridge.request(this.module.id, e);
        }
        async isRegistered() {
          return await this.request({ type: "is registered" });
        }
        async register() {
          return await this.request({ type: "register" });
        }
        async list() {
          return await this.request({ type: "list" });
        }
        async remove(e) {
          await this.request({ type: "remove", id: e });
        }
        async receive() {
          return await this.request({ type: "receive" });
        }
      }
      const xs = class {
        constructor(e, t) {
          (this.module = e),
            (this.version = t),
            (this.isRegistered = e.isRegistered.bind(e)),
            (this.register = e.register.bind(e)),
            (this.list = e.list.bind(e)),
            (this.remove = e.remove.bind(e)),
            (this.receive = e.receive.bind(e));
        }
      };
      (xs.create = (e) => {
        const t = e.findModule("notifications", 0);
        if (t) return new xs(new Os(e, t), t.version);
      }),
        (xs.getInstance = Vr(() => {
          const e = ws.getInstance();
          if (e) return xs.create(e);
        }));
      let Ns = xs;
      class Rs {
        constructor(e, t) {
          (this.bridge = e), (this.module = t);
        }
        request(e) {
          return this.bridge.request(this.module.id, e);
        }
        async products(e) {
          return await this.request({ type: "products", ...e });
        }
        async unfinished() {
          return await this.request({ type: "unfinished" });
        }
        async purchase(e) {
          return await this.request({ type: "purchase", ...e });
        }
        async finish(e) {
          return await this.request({ type: "finish", ...e });
        }
      }
      const Ds = class {
        constructor(e, t) {
          (this.module = e),
            (this.version = t),
            (this.products = e.products.bind(e)),
            (this.unfinished = e.unfinished.bind(e)),
            (this.purchase = e.purchase.bind(e)),
            (this.finish = e.finish.bind(e));
        }
      };
      (Ds.create = (e) => {
        const t = e.findModule("purchases", 0);
        if (t) return new Ds(new Rs(e, t), t.version);
      }),
        (Ds.getInstance = Vr(() => {
          const e = ws.getInstance();
          if (e) return Ds.create(e);
        }));
      let Ms = Ds;
      class js {
        constructor(e, t) {
          (this.bridge = e), (this.module = t);
        }
        request(e) {
          return this.bridge.request(this.module.id, e);
        }
        async requestReview() {
          await this.request({ type: "request review" });
        }
      }
      const Ls = class {
        constructor(e, t) {
          (this.module = e),
            (this.version = t),
            (this.requestReview = e.requestReview.bind(e));
        }
      };
      (Ls.create = (e) => {
        const t = e.findModule("store-review", 0);
        if (t) return new Ls(new js(e, t), t.version);
      }),
        (Ls.getInstance = Vr(() => {
          const e = ws.getInstance();
          if (e) return Ls.create(e);
        }));
      let Us = Ls;
      async function Fs(e) {
        try {
          const t = await e.fetch();
          if (!t.attribution) return;
          const {
              orgId: n,
              campaignId: r,
              adGroupId: s,
              adId: i,
              keywordId: o,
            } = t,
            a = await (async function (e, t, n) {
              return Yn(e, t, {
                ...n,
                headers: {
                  ...(n.headers || {}),
                  Accept: "application/json",
                  "Content-Type": "application/json",
                },
                body: n.body ? JSON.stringify(n.body) : void 0,
              });
            })(fetch, "https://asa-attr.dev.gc-internal.net/", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: {
                orgId: n,
                campaignId: r,
                adGroupId: s,
                adId: i,
                keywordId: o,
              },
              tracking: {
                platform: "Core",
                source: "getAppleSearchAdsAttribution",
              },
            }),
            c = await a.json();
          return {
            $channel: "AD",
            $adNetworkName: "Apple Search Ads",
            $adCampaignName: c.campaignName,
            $adSetName: c.adGroupName,
            $adCreativeName: c.adName,
          };
        } catch {
          return;
        }
      }
      var Bs = Object.defineProperty,
        Vs = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Bs(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class qs {
        constructor(e, t) {
          (this.bridge = e), (this.module = t);
        }
        request(e) {
          return this.bridge.request(this.module.id, e);
        }
        async getDeviceId() {
          return this.request({ type: "get device id" });
        }
      }
      const Hs = class {
        constructor(e, t) {
          Vs(this, "getDeviceId"),
            (this.module = e),
            (this.version = t),
            (this.getDeviceId = e.getDeviceId.bind(e));
        }
      };
      Vs(Hs, "create", (e) => {
        const t = e.findModule("amplitude", 0);
        if (t) return new Hs(new qs(e, t), t.version);
      }),
        Vs(
          Hs,
          "getInstance",
          Vr(() => {
            const e = ws.getInstance();
            if (e) return Hs.create(e);
          })
        );
      let Ws = Hs;
      var Ks = Object.defineProperty,
        zs = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Ks(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class Gs {
        constructor(e, t) {
          (this.bridge = e), (this.module = t);
        }
        request(e) {
          return this.bridge.request(this.module.id, e);
        }
        async fetch() {
          return this.request({ type: "fetch" });
        }
        async logout() {
          await this.request({ type: "logout" });
        }
      }
      const Js = class {
        constructor(e, t) {
          zs(this, "fetch"),
            zs(this, "logout"),
            (this.module = e),
            (this.version = t),
            (this.fetch = e.fetch.bind(e)),
            (this.logout = e.logout.bind(e));
        }
      };
      zs(Js, "create", (e) => {
        const t = e.findModule("legacy-auth", 0);
        if (t) return new Js(new Gs(e, t), t.version);
      }),
        zs(
          Js,
          "getInstance",
          Vr(() => {
            const e = ws.getInstance();
            if (e) return Js.create(e);
          })
        );
      let Qs = Js;
      var Ys = Object.defineProperty,
        Xs = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Ys(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      function Zs(e) {
        if (!e) throw new Error("API not available");
      }
      class $s {
        constructor(e, t) {
          var n, r, s, i, o, a, c, l;
          Xs(this, "interface", "reach"),
            Xs(this, "bridge"),
            Xs(this, "platform"),
            Xs(this, "app"),
            Xs(this, "amplitude"),
            Xs(this, "attribution"),
            Xs(this, "game"),
            Xs(this, "links"),
            Xs(this, "auth"),
            Xs(this, "notifications"),
            Xs(this, "purchases"),
            Xs(this, "store"),
            (null !== (n = e) && void 0 !== n) || (e = ws.getInstance()),
            (this.bridge = e);
          const u =
              null !== (r = null == t ? void 0 : t.appleSearchAds) &&
              void 0 !== r
                ? r
                : Es.getInstance(),
            d =
              null !== (s = null == t ? void 0 : t.launchScreen) && void 0 !== s
                ? s
                : Ps.getInstance(),
            h =
              null !== (i = null == t ? void 0 : t.legacyAuth) && void 0 !== i
                ? i
                : Qs.getInstance(),
            p =
              null !== (o = null == t ? void 0 : t.links) && void 0 !== o
                ? o
                : ks.getInstance(),
            f =
              null !== (a = null == t ? void 0 : t.notifications) &&
              void 0 !== a
                ? a
                : Ns.getInstance(),
            m =
              null !== (c = null == t ? void 0 : t.purchases) && void 0 !== c
                ? c
                : Ms.getInstance(),
            g =
              null !== (l = null == t ? void 0 : t.storeReview) && void 0 !== l
                ? l
                : Us.getInstance(),
            v = this;
          (this.platform = {
            get os() {
              return v.bridge.platform.os;
            },
            get version() {
              return v.bridge.platform.version;
            },
            get locale() {
              return v.bridge.platform.locale;
            },
          }),
            (this.app = {
              get version() {
                return v.bridge.app.version;
              },
            }),
            (this.amplitude = {
              getDeviceId: async () => {
                var e;
                return (
                  (await (null == (e = Ws.getInstance())
                    ? void 0
                    : e.getDeviceId())) || void 0
                );
              },
            }),
            (this.attribution = u ? Fs(u) : void 0),
            (this.game = {
              show: () => {
                null == d || d.hide();
              },
              reload: (e) => {
                const t = new URL(window.location.href);
                t.searchParams.set("cache-buster", Date.now().toString()),
                  this.auth
                    .logout()
                    .catch(() => {})
                    .finally(() => window.location.assign(t));
              },
            }),
            (this.links = (() => {
              const e = null == p ? void 0 : p.list().then((e) => e[0]),
                t = [];
              let n = !1;
              return {
                isAvailable: !!p,
                firstOpened: async () => (Zs(p), e),
                list: async () => (Zs(p), p.list()),
                async remove(e) {
                  Zs(p), await p.remove(e);
                },
                subscribe: (e) => {
                  Zs(p),
                    t.push(e),
                    n ||
                      ((n = !0),
                      (async () => {
                        for (;;) {
                          const e = await p.receive();
                          for (const n of t) n(e);
                        }
                      })());
                },
              };
            })()),
            (this.auth = {
              isAvailable: !!h,
              fetch: async () => {
                Zs(h);
                const e = await h.fetch();
                if ("line" === e.type)
                  return {
                    userId: e.userID,
                    accessToken: e.accessToken,
                    profile: e.profile,
                  };
                throw new Error("The user is not authenticated with LINE");
              },
              logout: async () => {
                Zs(h), await h.logout();
              },
            }),
            (this.notifications = (() => {
              const e =
                  null == f
                    ? void 0
                    : f.list().then((e) => {
                        const t = e.find(
                          (e) => "inactive" === e.applicationState
                        );
                        return t ? ei(t) : void 0;
                      }),
                t = [];
              let n = !1;
              return {
                isAvailable: !!f,
                firstOpened: async () => (Zs(f), e),
                register: async (e) => {
                  Zs(f);
                  const t = await f.isRegistered();
                  t || Hr(e);
                  const n = await f.register();
                  return (
                    hr.setUserProperties({
                      isRegisteredForPushNotifications: "success" === n.type,
                    }),
                    t ||
                      ("success" === n.type
                        ? Wr(e)
                        : Kr(
                            Sr(
                              "USER_INPUT",
                              "Did not register for notifications"
                            ),
                            e
                          )),
                    {
                      success: "success" === n.type,
                      deviceToken:
                        "success" === n.type ? n.deviceToken : void 0,
                    }
                  );
                },
                list: async () => (Zs(f), (await f.list()).map(ei)),
                remove: async (e) => {
                  Zs(f), await f.remove(e);
                },
                subscribe: (e) => {
                  Zs(f),
                    t.push(e),
                    n ||
                      ((n = !0),
                      (async () => {
                        for (;;) {
                          const e = ei(await f.receive());
                          for (const n of t) n(e);
                        }
                      })());
                },
              };
            })()),
            (this.purchases = (() => {
              let e = [];
              return {
                isAvailable: !!m,
                init: async (t) => {
                  Zs(m), (e = t);
                },
                products: async () => {
                  Zs(m);
                  return (await m.products({ ids: e })).map((e) => ({
                    title: e.displayName,
                    id: e.id,
                    description: e.description,
                    imageURI: "",
                    price: e.price,
                    currencyCode: e.currencyCode,
                  }));
                },
                purchase: async (e, t) => {
                  Zs(m);
                  const n = await m.purchase({ id: e, payload: t });
                  switch (n.type) {
                    case "user cancelled":
                      throw Sr("USER_INPUT", "The user cancelled the purchase");
                    case "not found":
                      throw new Error(
                        "The product ".concat(e, " was not found")
                      );
                    case "unknown":
                      throw new Error("An unknown (unexpected) error occurred");
                    case "unverified":
                      throw new Error("The purchase was not verified");
                    case "verified": {
                      const { transaction: e, receipt: t } = n;
                      return {
                        paymentID: e.id,
                        productID: e.productID,
                        purchaseTime: e.purchaseDate,
                        purchaseToken: e.id,
                        signedRequest: t,
                      };
                    }
                  }
                },
                finish: async (e) => {
                  Zs(m);
                  if (
                    "failure" === (await m.finish({ id: e.purchaseToken })).type
                  )
                    throw new Error(
                      "Could not finish purchase ".concat(e.purchaseToken)
                    );
                },
                unfinished: async () => {
                  Zs(m);
                  return (await m.unfinished())
                    .flatMap((e) => ("verified" === e.type ? [e] : []))
                    .map((e) => {
                      let { transaction: t, receipt: n } = e;
                      return {
                        paymentID: t.id,
                        productID: t.productID,
                        purchaseTime: t.purchaseDate,
                        purchaseToken: t.id,
                        signedRequest: n,
                      };
                    });
                },
              };
            })()),
            (this.store = {
              isAvailable: !!g,
              requestReview: async (e) => {
                Zs(g),
                  (function (e) {
                    fr.pushEvent("NativeRateAppView", e);
                  })(e),
                  await g.requestReview();
              },
            });
        }
        static create() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : ws.getInstance();
          if (e) {
            if ("ios" === e.platform.os)
              hr.setUserProperties({ lastEntryAppleVersion: e.app.version });
            return new $s(e);
          }
        }
      }
      function ei(e) {
        let t,
          n = {};
        if (
          "object" === typeof e.userInfo &&
          e.userInfo &&
          "payload" in e.userInfo
        )
          try {
            n = JSON.parse(e.userInfo.payload);
          } catch {}
        switch (e.applicationState) {
          case "active":
            t = "foreground";
            break;
          case "background":
            t = "background";
            break;
          case "inactive":
          case "unknown":
            t = "closed";
        }
        return {
          payload: n,
          appState: t,
          userActivated: "default" === e.action,
          id: e.id,
          title: e.title,
          body: e.body,
          time: new Date(e.date).valueOf(),
        };
      }
      var ti = function (e, t, n, r) {
        return new (n || (n = Promise))(function (s, i) {
          function o(e) {
            try {
              c(r.next(e));
            } catch (a_) {
              i(a_);
            }
          }
          function a(e) {
            try {
              c(r.throw(e));
            } catch (a_) {
              i(a_);
            }
          }
          function c(e) {
            e.done
              ? s(e.value)
              : (function (e) {
                  return e instanceof n
                    ? e
                    : new n(function (t) {
                        t(e);
                      });
                })(e.value).then(o, a);
          }
          c((r = r.apply(e, t || [])).next());
        });
      };
      var ni;
      !(function (e) {
        (e[(e.AppLaunch = 0)] = "AppLaunch"),
          (e[(e.Retention = 1)] = "Retention");
      })(ni || (ni = {}));
      class ri {
        constructor(e) {
          this.key = e;
        }
        sendEvent(e, t, n) {
          return ti(this, void 0, void 0, function* () {
            if (!t._UA_adNetwork && !t.$adNetworkName)
              return Promise.reject(
                new Error("No $adNetworkName found in the payload")
              );
            const r =
              e === ni.AppLaunch
                ? "applaunch"
                : e === ni.Retention
                ? "retention"
                : "unknown";
            return fetch(
              ""
                .concat(
                  "https://postback-manager.dev.gc-internal.net",
                  "/postback?key="
                )
                .concat(this.key),
              {
                method: "post",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({
                  entryPayload: t,
                  eventName: r,
                  meta: n,
                }),
              }
            ).then((e) => {
              if (e.status > 400) {
                const t = new Error(e.statusText);
                return (t.code = e.status), Promise.reject(t);
              }
              return e;
            });
          });
        }
      }
      function si(e) {
        fr.pushEvent("ABTestAssigned", e);
      }
      function ii(e) {
        fr.pushEvent("PinchConversion", e);
      }
      function oi(e, t) {
        fr.pushError("GetEntryTimestampsFailure", e, t);
      }
      function ai(e, t) {
        fr.pushError("PayloadReadFailure", e, t);
      }
      var ci = Object.defineProperty,
        li = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? ci(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      function ui(e, t) {
        if (!(null == e ? void 0 : e[t])) return !1;
        if (pi(t)) return !1;
        const { active: n, excludeFromABTag: r } = e[t];
        return n && !r;
      }
      const di = {
        "0000_placebo_2": {
          active: !0,
          default: "a",
          buckets: [{ id: "a" }, { id: "b" }],
        },
        "0000_placebo_3": {
          active: !0,
          default: "a",
          buckets: [{ id: "a" }, { id: "b" }, { id: "c" }],
        },
        "0000_placebo_4": {
          active: !0,
          default: "a",
          buckets: [{ id: "a" }, { id: "b" }, { id: "c" }, { id: "d" }],
        },
        "0000_placebo_5": {
          active: !0,
          default: "a",
          buckets: [
            { id: "a" },
            { id: "b" },
            { id: "c" },
            { id: "d" },
            { id: "e" },
          ],
        },
      };
      class hi {
        constructor(e, t, n, r) {
          li(this, "config"),
            li(this, "hash"),
            li(this, "isNewPlayer"),
            li(this, "storageKey"),
            li(this, "storage"),
            li(this, "tests"),
            (this.userID = e),
            (this.platformStorage = n),
            (this.getExternalABTag = r),
            (this.storageKey = t + "AB"),
            (this.isNewPlayer = 1 === n.entry.count),
            (this.storage = { tests: {}, userID: this.userID });
        }
        initialize(e, t, n) {
          console.warn(
            "GCInstant A/B tests are deprecated. Please use Replicant A/B tests instead: https://docs.dev.gc-internal.net/replicant/ab-tests/."
          ),
            (function (e) {
              const t = Object.keys(e)
                .filter((t) => ui(e, t))
                .map(
                  (t) =>
                    Math.min(4, t.length) +
                    2 +
                    Math.max(e[t].buckets.length - 1, 0).toString().length
                )
                .reduce((e, t) => e + t, -1);
              t > 1024 &&
                console.warn(
                  "AB tag can become too long. Try to limit the number of tests to 140 to prevent this from happening"
                );
            })(e),
            (this.config = { ...di, ...e }),
            (this.hash = t),
            n && (this.storageKey = n),
            this.load(),
            this.initializeTests(),
            this.save(),
            this.applyUserProperties();
        }
        load() {
          if (Object.keys(this.platformStorage.abTests || {}).length > 0)
            this.storage.tests = { ...this.platformStorage.abTests };
          else
            try {
              const e = localStorage.getItem(this.storageKey);
              if (e) {
                this.storage = JSON.parse(e);
                const t = this.storage.userID;
                void 0 === t
                  ? (this.storage.userID = this.userID)
                  : t !== this.userID &&
                    ((this.storage.tests = {}),
                    (this.storage.userID = this.userID));
              }
            } catch (a_) {
              console.error("FAILED TO LOAD AB TESTS!", a_);
            }
        }
        save() {
          this.platformStorage.assign(
            (e) => (e.abTests = { ...this.storage.tests })
          );
        }
        initializeTests() {
          this.tests = this.storage.tests;
          for (const e in this.config) {
            const t = this.config[e];
            if (!t.active) continue;
            if (t.assignManually) continue;
            if (this.tests[e]) continue;
            if (!this.isNewPlayer && t.newPlayersOnly) continue;
            const n = this.getUserBucketID(e, this.userID),
              r = t.newPlayersOnly || !1;
            this.assignTest(e, n, r);
          }
        }
        assignTest(e, t, n) {
          (this.tests[e] = t), si({ test: e, bucket: t, newPlayersOnly: n });
        }
        assignTestManually(e, t, n) {
          this.throwIfNotInitialized();
          const r = this.config[e],
            s = r.buckets.map((e) => {
              let { id: t } = e;
              return t;
            });
          if (void 0 !== t && !s.includes(t))
            throw new Error(
              "Invalid bucket id '"
                .concat(t, "' for test '")
                .concat(e, "'. Valid bucket ids are: [")
                .concat(s.join(", "), "]")
            );
          (!this.tests[e] || n) &&
            r &&
            r.active &&
            (this.assignTest(e, t || this.getUserBucketID(e, this.userID), !1),
            this.save(),
            this.applyUserProperties());
        }
        applyUserProperties() {
          const e = this.getAbTag(),
            t = this.getExternalABTag(),
            n = { ABtag: e && t ? "".concat(e, ",").concat(t) : e || t };
          for (const r in this.tests) n["abTest_" + r] = this.tests[r];
          pr.setUserProperties(n, pr.toDefault);
        }
        applyPayloadProperties(e) {
          this.throwIfNotInitialized();
          for (const t in this.tests) {
            const n = this.config[t];
            n && n.active && (e["sourceAB_" + t] = this.tests[t]);
          }
          return e;
        }
        getAssignedNonPlaceboTestIds() {
          return this.config
            ? this.getListOfActiveTests()
                .map((e) => e.id)
                .filter((e) => !pi(e))
            : [];
        }
        getListOfActiveTests() {
          this.throwIfNotInitialized();
          const e = [];
          for (const t in this.config) {
            const n = this.config[t];
            n.active && e.push({ ...n, id: t });
          }
          return e;
        }
        getBucketID(e) {
          return this.throwIfNotInitialized(), this.tests[e];
        }
        getUserBucketID(e, t) {
          this.throwIfNotInitialized();
          const n = this.config[e].buckets,
            r = this.hash(e + t);
          return n[Math.min(n.length - 1, Math.floor(r() * n.length))].id;
        }
        getBucketConfig(e) {
          this.throwIfNotInitialized();
          const t = this.config[e];
          if (!t) return console.error("Invalid AB test name: " + e), null;
          let n = this.tests[e];
          n || (n = t.default || "control");
          const r = t.buckets;
          for (const s of r) if (s.id === n) return s;
          return console.error("Invalid AB config for " + e + "/" + n), null;
        }
        getAbTag() {
          return Object.keys(this.tests)
            .filter((e) => ui(this.config, e))
            .sort()
            .map((e) => this.getTestTag(e))
            .join(",");
        }
        throwIfNotInitialized() {
          if (!this.config) throw Error("Initialize ABTests before usage!");
        }
        getTestTag(e) {
          const t = this.getBucketID(e),
            n = this.config[e].buckets.findIndex((e) => e.id === t);
          return "".concat(e.substring(0, 4), "-").concat(n);
        }
      }
      function pi(e) {
        return e.startsWith("0000_placebo");
      }
      function fi() {
        const e = (function (e) {
          try {
            const t = performance
              .getEntriesByType("resource")
              .filter((t) => new URL(t.name).hostname === e);
            if (0 === t.length) return;
            const n = {
              cacheHitCount: 0,
              cacheHitRatio: 0,
              requestCount: t.length,
            };
            let r = 0,
              s = 0;
            for (const e of t) {
              let t = !1;
              (t =
                void 0 === e.transferSize || void 0 === e.encodedBodySize
                  ? e.responseEnd - e.requestStart < 20
                  : e.encodedBodySize > 0 && 0 === e.transferSize),
                t
                  ? (n.cacheHitCount += 1)
                  : ((r += e.responseEnd - e.connectStart),
                    (s += e.transferSize));
            }
            n.cacheHitRatio = n.cacheHitCount / n.requestCount;
            const i = n.requestCount - n.cacheHitCount;
            return (
              i > 0 &&
                ((n.requestTimeAverageMs = Math.round(r / i)),
                Number.isNaN(s) ||
                  (n.transferSizeAverageBytes = Math.round(s / i))),
              n
            );
          } catch (t) {
            console.warn("Skipping CDN performance metrics:", t);
          }
        })(location.hostname);
        e &&
          (function (e) {
            fr.pushEvent("CDNPerformance", e);
          })(e);
      }
      function mi(e) {
        const { min: t, max: n } = e;
        return void 0 === n
          ? "".concat(t, "+")
          : 0 === t
          ? n.toString()
          : "".concat(t, "-").concat(n);
      }
      function gi(e) {
        if (/^\d{1,3}$/.test(e)) return { min: 0, max: Number(e) };
        if (/^\d{1,3}\+$/.test(e)) return { min: Number(e.replace("+", "")) };
        if (/^\d{1,3}-\d{1,3}$/.test(e)) {
          const [t, n] = e.split("-").map((e) => Number(e));
          return { min: t, max: n };
        }
      }
      function vi(e) {
        const { outer: t, inner: n } = e;
        return t.min <= n.min && (void 0 === t.max || t.max >= n.max);
      }
      function yi(e) {
        return e.min >= 20;
      }
      function bi(e) {
        const { entryData: t, lastEntryIsRepeat: n, storage: r, userId: s } = e,
          i = 1 === r.entry.count;
        const o = (function () {
          if ("AD" === t.$channel) {
            if (!i || !t.$adSetName) return {};
            const { ageRange: e, gender: n } = (function (e) {
              var t, n;
              const r =
                  null == (t = e.match(/(Male|Female)/g)) ? void 0 : t.pop(),
                s = "Male" === r ? "male" : "Female" === r ? "female" : void 0;
              let i;
              const o =
                null == (n = e.match(/\d{1,3}-\d{1,3}/g)) ? void 0 : n.pop();
              if (o) {
                const [e, t] = o.split("-").map((e) => Number(e));
                i = { min: e, max: t };
              }
              return { ageRange: i, gender: s };
            })(t.$adSetName);
            return !e || (e.min < 20 && (void 0 === e.max || e.max > 20))
              ? { gender: n }
              : { ageRange: e, ageConfidence: 70, gender: n };
          }
          if ("CHATBOT" === t.$channel) {
            if (n) return {};
            const { ageRange: e, gender: s } = (function (e) {
              const t =
                  "male" === e.gender
                    ? "male"
                    : "female" === e.gender
                    ? "female"
                    : void 0,
                n = "string" === typeof e.ageRange ? gi(e.ageRange) : void 0;
              return { ageRange: n, gender: t };
            })(t);
            if (!e) return { gender: s };
            const i = r.demographics.ageRange;
            if (!i) return { ageConfidence: 80, ageRange: e, gender: s };
            const o = vi({ outer: e, inner: i }),
              a = vi({ outer: i, inner: e });
            if (o && !a) return { gender: s };
            if (a) {
              const t = r.demographics.ageConfidence || 0;
              return {
                ageConfidence: t < 80 ? 80 : Math.min(t + 10, 99),
                ageRange: e,
                gender: s,
              };
            }
            return { ageConfidence: 50, ageRange: e, gender: s };
          }
          if (t.playerID) {
            if (!i || t.playerID === s) return {};
            const { ageConfidence: e, ageRange: n } = (function (e) {
              return {
                ageConfidence: e.lastEntryAgeConfidence,
                ageRange: e.lastEntryAgeRange
                  ? gi(e.lastEntryAgeRange)
                  : void 0,
              };
            })(t);
            if (!e || !n) return {};
            if (e < 20) return {};
            return n.min < 20 && (void 0 === n.max || n.max > 20)
              ? {}
              : {
                  ageConfidence: Math.ceil(0.6 * e),
                  ageRange:
                    n.max < 15
                      ? { min: 0, max: 14 }
                      : n.max < 20
                      ? { min: 15, max: 19 }
                      : { min: 20, max: 59 },
                };
          }
          return {};
        })();
        if (!o.ageRange && i) {
          const { adult: t, teen: n } = e.friendAgeGroupDistribution || {
            adult: 0,
            teen: 0,
          };
          if (t > 0 && 0 === n)
            return { ageConfidence: 40, ageRange: { min: 20, max: 59 } };
        }
        return o;
      }
      function wi() {
        const e = () => {
          !(function (e) {
            fr.pushEvent("FirstScreenTap", e);
          })({ occasion: "sessionStart" }),
            window.removeEventListener("pointerdown", e);
        };
        window.addEventListener("pointerdown", e);
      }
      function Si(e) {
        return ["TOURNAMENT", "INVITE", "SHARE", "UPDATE"].includes(e);
      }
      const _i = {
          AF: "Afghanistan",
          AX: "Aland Islands",
          AL: "Albania",
          DZ: "Algeria",
          AS: "American Samoa",
          AD: "Andorra",
          AO: "Angola",
          AI: "Anguilla",
          AQ: "Antarctica",
          AG: "Antigua And Barbuda",
          AR: "Argentina",
          AM: "Armenia",
          AW: "Aruba",
          AU: "Australia",
          AT: "Austria",
          AZ: "Azerbaijan",
          BS: "Bahamas",
          BH: "Bahrain",
          BD: "Bangladesh",
          BB: "Barbados",
          BY: "Belarus",
          BE: "Belgium",
          BZ: "Belize",
          BJ: "Benin",
          BM: "Bermuda",
          BT: "Bhutan",
          BO: "Bolivia",
          BA: "Bosnia And Herzegovina",
          BW: "Botswana",
          BV: "Bouvet Island",
          BR: "Brazil",
          IO: "British Indian Ocean Territory",
          BN: "Brunei Darussalam",
          BG: "Bulgaria",
          BF: "Burkina Faso",
          BI: "Burundi",
          KH: "Cambodia",
          CM: "Cameroon",
          CA: "Canada",
          CV: "Cape Verde",
          KY: "Cayman Islands",
          CF: "Central African Republic",
          TD: "Chad",
          CL: "Chile",
          CN: "China",
          CX: "Christmas Island",
          CC: "Cocos (Keeling) Islands",
          CO: "Colombia",
          KM: "Comoros",
          CG: "Congo",
          CD: "Congo, Democratic Republic",
          CK: "Cook Islands",
          CR: "Costa Rica",
          CI: "Cote D'Ivoire",
          HR: "Croatia",
          CU: "Cuba",
          CY: "Cyprus",
          CZ: "Czech Republic",
          DK: "Denmark",
          DJ: "Djibouti",
          DM: "Dominica",
          DO: "Dominican Republic",
          EC: "Ecuador",
          EG: "Egypt",
          SV: "El Salvador",
          GQ: "Equatorial Guinea",
          ER: "Eritrea",
          EE: "Estonia",
          ET: "Ethiopia",
          FK: "Falkland Islands (Malvinas)",
          FO: "Faroe Islands",
          FJ: "Fiji",
          FI: "Finland",
          FR: "France",
          GF: "French Guiana",
          PF: "French Polynesia",
          TF: "French Southern Territories",
          GA: "Gabon",
          GM: "Gambia",
          GE: "Georgia",
          DE: "Germany",
          GH: "Ghana",
          GI: "Gibraltar",
          GR: "Greece",
          GL: "Greenland",
          GD: "Grenada",
          GP: "Guadeloupe",
          GU: "Guam",
          GT: "Guatemala",
          GG: "Guernsey",
          GN: "Guinea",
          GW: "Guinea-Bissau",
          GY: "Guyana",
          HT: "Haiti",
          HM: "Heard Island & Mcdonald Islands",
          VA: "Holy See (Vatican City State)",
          HN: "Honduras",
          HK: "Hong Kong",
          HU: "Hungary",
          IS: "Iceland",
          IN: "India",
          ID: "Indonesia",
          IR: "Iran, Islamic Republic Of",
          IQ: "Iraq",
          IE: "Ireland",
          IM: "Isle Of Man",
          IL: "Israel",
          IT: "Italy",
          JM: "Jamaica",
          JP: "Japan",
          JE: "Jersey",
          JO: "Jordan",
          KZ: "Kazakhstan",
          KE: "Kenya",
          KI: "Kiribati",
          KR: "Korea",
          KW: "Kuwait",
          KG: "Kyrgyzstan",
          LA: "Lao People's Democratic Republic",
          LV: "Latvia",
          LB: "Lebanon",
          LS: "Lesotho",
          LR: "Liberia",
          LY: "Libyan Arab Jamahiriya",
          LI: "Liechtenstein",
          LT: "Lithuania",
          LU: "Luxembourg",
          MO: "Macao",
          MK: "Macedonia",
          MG: "Madagascar",
          MW: "Malawi",
          MY: "Malaysia",
          MV: "Maldives",
          ML: "Mali",
          MT: "Malta",
          MH: "Marshall Islands",
          MQ: "Martinique",
          MR: "Mauritania",
          MU: "Mauritius",
          YT: "Mayotte",
          MX: "Mexico",
          FM: "Micronesia, Federated States Of",
          MD: "Moldova",
          MC: "Monaco",
          MN: "Mongolia",
          ME: "Montenegro",
          MS: "Montserrat",
          MA: "Morocco",
          MZ: "Mozambique",
          MM: "Myanmar",
          NA: "Namibia",
          NR: "Nauru",
          NP: "Nepal",
          NL: "Netherlands",
          AN: "Netherlands Antilles",
          NC: "New Caledonia",
          NZ: "New Zealand",
          NI: "Nicaragua",
          NE: "Niger",
          NG: "Nigeria",
          NU: "Niue",
          NF: "Norfolk Island",
          MP: "Northern Mariana Islands",
          NO: "Norway",
          OM: "Oman",
          PK: "Pakistan",
          PW: "Palau",
          PS: "Palestinian Territory, Occupied",
          PA: "Panama",
          PG: "Papua New Guinea",
          PY: "Paraguay",
          PE: "Peru",
          PH: "Philippines",
          PN: "Pitcairn",
          PL: "Poland",
          PT: "Portugal",
          PR: "Puerto Rico",
          QA: "Qatar",
          RE: "Reunion",
          RO: "Romania",
          RU: "Russian Federation",
          RW: "Rwanda",
          BL: "Saint Barthelemy",
          SH: "Saint Helena",
          KN: "Saint Kitts And Nevis",
          LC: "Saint Lucia",
          MF: "Saint Martin",
          PM: "Saint Pierre And Miquelon",
          VC: "Saint Vincent And Grenadines",
          WS: "Samoa",
          SM: "San Marino",
          ST: "Sao Tome And Principe",
          SA: "Saudi Arabia",
          SN: "Senegal",
          RS: "Serbia",
          SC: "Seychelles",
          SL: "Sierra Leone",
          SG: "Singapore",
          SK: "Slovakia",
          SI: "Slovenia",
          SB: "Solomon Islands",
          SO: "Somalia",
          ZA: "South Africa",
          GS: "South Georgia And Sandwich Isl.",
          ES: "Spain",
          LK: "Sri Lanka",
          SD: "Sudan",
          SR: "Suriname",
          SJ: "Svalbard And Jan Mayen",
          SZ: "Swaziland",
          SE: "Sweden",
          CH: "Switzerland",
          SY: "Syrian Arab Republic",
          TW: "Taiwan",
          TJ: "Tajikistan",
          TZ: "Tanzania",
          TH: "Thailand",
          TL: "Timor-Leste",
          TG: "Togo",
          TK: "Tokelau",
          TO: "Tonga",
          TT: "Trinidad And Tobago",
          TN: "Tunisia",
          TR: "Turkey",
          TM: "Turkmenistan",
          TC: "Turks And Caicos Islands",
          TV: "Tuvalu",
          UG: "Uganda",
          UA: "Ukraine",
          AE: "United Arab Emirates",
          GB: "United Kingdom",
          US: "United States",
          UM: "United States Outlying Islands",
          UY: "Uruguay",
          UZ: "Uzbekistan",
          VU: "Vanuatu",
          VE: "Venezuela",
          VN: "Viet Nam",
          VG: "Virgin Islands, British",
          VI: "Virgin Islands, U.S.",
          WF: "Wallis And Futuna",
          EH: "Western Sahara",
          YE: "Yemen",
          ZM: "Zambia",
          ZW: "Zimbabwe",
        },
        Ei = Object.entries(_i).reduce((e, t) => {
          let [n, r] = t;
          return (e[r] = n), e;
        }, {});
      class Ai {
        constructor(e) {
          this.platform = e;
        }
        getCrossplayPayload(e) {
          return { isAppSwitch: !0, crossplayTracking: e };
        }
        isCrossplayEntry() {
          return !!this.platform.entryData.isAppSwitch;
        }
      }
      var Ti = Object.defineProperty,
        Pi = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Ti(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class Ii {
        constructor(e) {
          Pi(this, "source"), (this.opts = e);
        }
        setSource(e) {
          var t = this;
          if (this.source)
            throw new Error("ExternalABTestsSource already set!");
          (this.source = e),
            this.updateUserProperties(),
            this.source.setOnChangedHandler(function () {
              return t.onChanged(...arguments);
            });
        }
        getPayloadProperties() {
          return this.source ? this.getTests("sourceAB_") : {};
        }
        getABTag() {
          var e;
          return (null == (e = this.source) ? void 0 : e.getABTag()) || "";
        }
        getAssignedNonPlaceboTestIds() {
          var e;
          return Object.keys(
            (null == (e = this.source) ? void 0 : e.getABTests()) || {}
          ).filter((e) => !pi(e));
        }
        onChanged(e) {
          const t = this.opts.getInternalABTestIDs();
          for (const n of e || []) {
            const e = t.includes(n.testId) && pi(n.testId);
            n.bucketId &&
              !e &&
              si({
                bucket: n.bucketId,
                newPlayersOnly: n.newUsersOnly,
                test: n.testId,
              });
          }
          this.updateUserProperties();
        }
        updateUserProperties() {
          const e = this.opts.getInternalABTag(),
            t = this.source.getABTag(),
            n = {
              ABtag: e && t ? "".concat(e, ",").concat(t) : e || t,
              ...this.getTests("abTest_"),
            };
          fr.setUserProperties(n, fr.toDefault);
        }
        getTests(e) {
          const t = this.source.getABTests(),
            n = this.opts.getInternalABTestIDs(),
            r = {};
          for (const s in t) {
            if (n.includes(s)) {
              if (pi(s)) continue;
              throw new Error(
                "Test id '".concat(
                  s,
                  "' is present in both internal and external tests!"
                )
              );
            }
            const i = t[s];
            i && (r[e + s] = i);
          }
          return r;
        }
      }
      var Ci = Object.defineProperty,
        ki = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Ci(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class Oi {
        constructor(e) {
          ki(this, "breadcrumbs", []),
            ki(this, "conversionCountsByResource", {}),
            ki(this, "latestPinchesByResource", {}),
            ki(this, "sessionPinchCount", 0),
            ki(this, "sessionPerResourcePinchCounts", {}),
            (this.storage = e);
        }
        trackPinch(e) {
          const { resource: t, trigger: n, ...r } = e;
          (this.sessionPinchCount = (this.sessionPinchCount || 0) + 1),
            (this.sessionPerResourcePinchCounts[t] =
              (this.sessionPerResourcePinchCounts[t] || 0) + 1),
            this.storage.assign((e) => {
              (e.trackPinchAllTimeCount =
                (this.storage.trackPinchAllTimeCount || 0) + 1),
                (e.trackPinchAllTimeCounts[t] =
                  (this.storage.trackPinchAllTimeCounts[t] || 0) + 1);
            });
          const s = {
            allTimeCount: this.storage.trackPinchAllTimeCount,
            allTimeCountForResource: this.storage.trackPinchAllTimeCounts[t],
            resource: t,
            sessionCount: this.sessionPinchCount,
            sessionCountForResource: this.sessionPerResourcePinchCounts[t],
            trigger: n,
          };
          !(function (e) {
            fr.pushEvent("Pinch", e);
          })({ ...s, ...r }),
            (this.breadcrumbs = [...this.breadcrumbs.slice(-4), n]),
            (this.latestPinchesByResource[t] = s);
        }
        trackPinchConversion(e) {
          const {
            action: t,
            feature: n,
            resource: r,
            subFeature: s,
            wasSurfacedByPinch: i,
            ...o
          } = e;
          this.conversionCountsByResource[r] ||
            (this.conversionCountsByResource[r] = 0),
            this.conversionCountsByResource[r]++;
          const a = this.latestPinchesByResource[r],
            c = {
              ...o,
              action: t,
              breadcrumbs: this.breadcrumbs.join(";") || void 0,
              conversionCount: this.conversionCountsByResource[r],
              feature: n,
              resource: r,
              subFeature: s,
              wasSurfacedByPinch: i,
            };
          ii(
            a
              ? {
                  ...c,
                  pinchAllTimeCount: a.allTimeCount,
                  pinchAllTimeCountForResource: a.allTimeCountForResource,
                  pinchAssociated: !0,
                  pinchSessionCount: a.sessionCount,
                  pinchSessionCountForResource: a.sessionCountForResource,
                  pinchTrigger: a.trigger,
                }
              : { ...c, pinchAssociated: !1 }
          );
        }
      }
      var xi = Object.defineProperty,
        Ni = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? xi(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class Ri {
        constructor() {
          Ni(this, "absoluteSequence", 0),
            Ni(this, "abTests", {}),
            Ni(this, "analytics", {}),
            Ni(this, "botSubscriptionViewCount", 0),
            Ni(this, "dailyInvites", {
              count: 0,
              invitees: {},
              lastInviteDay: 0,
            }),
            Ni(this, "demographics", {}),
            Ni(this, "entry", {
              first: 1545231968498,
              last: 0,
              lastAdEntry: 0,
              lastNativeAndroidEntry: 0,
              lastNativeIOSEntry: 0,
              lastResurrected: 0,
              count: 0,
            }),
            Ni(this, "featureAbsoluteSequences", {}),
            Ni(this, "gcn", { adsWatched: 0 }),
            Ni(this, "previousPayload"),
            Ni(this, "settings", { bgmVolume: 0.5, sfxVolume: 0.5 }),
            Ni(this, "tos", {}),
            Ni(this, "trackPinchAllTimeCount", 0),
            Ni(this, "trackPinchAllTimeCounts", {});
        }
      }
      function Di(e, t) {
        for (const n in t) {
          const r = n,
            s = t[r];
          s && "object" === typeof s && e[r] ? Di(e[r], s) : (e[r] = s);
        }
      }
      const Mi = class extends Ri {
          constructor(e) {
            super(),
              Ni(this, "_loadPromise", null),
              Ni(this, "_saveHandle", null),
              Ni(this, "_savePromise", null),
              Ni(this, "_storageKey", null),
              Ni(this, "adapter"),
              Ni(this, "savedProperties"),
              (this._platform = e),
              (this.savedProperties = JSON.stringify(
                this.getStorageProperties()
              ));
          }
          hasAdapter() {
            return !!this.adapter;
          }
          getStorageProperties() {
            const e = new Ri();
            for (const t in e) e[t] = this[t];
            return e;
          }
          assign(e) {
            e(this), this.save();
          }
          load() {
            if (null != this._loadPromise) return this._loadPromise;
            this._storageKey = this._platform._gameConfig.appID + ".models";
            const e = () =>
              this._platform
                .getDataAsync([this._storageKey])
                .then((e) => (null == e ? void 0 : e[this._storageKey]));
            return (
              (this._loadPromise = (
                this.adapter
                  ? this.adapter
                      .load()
                      .then((t) =>
                        t || !0 !== this.adapter.fallbackToPlatformStorage
                          ? t
                          : e()
                      )
                  : e()
              )
                .then((e) => {
                  e && Di(this, e);
                })
                .catch((e) => {
                  console.error("Failed to load platform data:", e);
                })),
              this._loadPromise
            );
          }
          save() {
            if ((null === this._loadPromise && this.load(), this._saveHandle))
              return this._savePromise;
            let e = null;
            return (
              (this._savePromise = new Promise((t) => {
                e = t;
              })),
              (this._saveHandle = window.setTimeout(() => {
                (this._saveHandle = null),
                  this._loadPromise
                    .then(async () => {
                      const e = this.getStorageProperties(),
                        t = JSON.stringify(e);
                      t !== this.savedProperties &&
                        (await (this.adapter
                          ? this.adapter.save(e)
                          : this._platform.setDataAsync({
                              [this._storageKey]: e,
                            })),
                        (this.savedProperties = t));
                    })
                    .then(() => {
                      e();
                    });
              }, 0)),
              this._savePromise
            );
          }
          setStorageAdapter(e, t) {
            this.adapter = {
              ...e,
              fallbackToPlatformStorage: !!(null == t
                ? void 0
                : t.fallbackToPlatformStorage),
            };
          }
        },
        ji = class e {
          constructor(e) {
            this._value = e;
          }
          match(e, t) {
            switch (this._value[0]) {
              case "ok":
                return e(this._value[1]);
              case "err":
                return t(this._value[1]);
            }
          }
          isOk() {
            return "ok" === this._value[0];
          }
          isError() {
            return "err" === this._value[0];
          }
          get unsafeValue() {
            return this.match(
              (e) => e,
              (e) => {
                throw e;
              }
            );
          }
          get value() {
            return this._value[1];
          }
          withDefault(e) {
            return this.match(
              (e) => e,
              () => e
            );
          }
          orUndefined() {
            return this.withDefault(void 0);
          }
          orNull() {
            return this.withDefault(null);
          }
          map(t) {
            return this.match(
              (n) => e.ok(t(n)),
              (t) => e.error(t)
            );
          }
          mapError(t) {
            return this.match(
              (t) => e.ok(t),
              (n) => e.error(t(n))
            );
          }
          flatMap(t) {
            return this.match(t, (t) => e.error(t));
          }
        };
      (ji.ok = (e) => new ji(["ok", e])),
        (ji.error = (e) => new ji(["err", e]));
      let Li = ji;
      const Ui = (e, t) =>
          Ki.create((n) =>
            e.decode(n).match(
              (e) => Li.ok(e),
              (e) =>
                t.decode(n).match(
                  (e) => Li.ok(e),
                  (t) => Li.error(e.append(t))
                )
            )
          ),
        Fi = (e) => ["ErrorMessage", e],
        Bi = (e, t) => ["TypeMismatch", e, t],
        Vi = (e) => {
          switch (e[0]) {
            case "ErrorMessage":
              return e[1];
            case "ErrorAtIndex":
              return "Error at array index " + e[1] + ": " + Vi(e[2]);
            case "ErrorAtProperty":
              return "Error at property " + e[1] + ": " + Vi(e[2]);
            case "TypeMismatch":
              return "Type mismatch: expected " + e[1] + ", found " + e[2];
          }
        },
        qi = class e extends Error {
          constructor(e) {
            if ((super(), (this.errors = e), 0 === this.errors.length))
              throw new Error("DecodingError must have at least one error");
          }
          get name() {
            return "DecodingError";
          }
          get message() {
            return "The following errors were encountered:\n".concat(
              this.errors.map((e) => "  - ".concat(Vi(e))).join("\n")
            );
          }
          map(t) {
            return new e(this.errors.map(t));
          }
          append(t) {
            return new e([...this.errors, ...t.errors]);
          }
        };
      (qi.errorMessage = (e) => new qi([Fi(e)])),
        (qi.typeMismatch = (e, t) => new qi([Bi(e, t)])),
        (qi.errorAtIndex = (e, t) =>
          new qi(
            t.errors.map((t) => ((e, t) => ["ErrorAtIndex", e, t])(e, t))
          )),
        (qi.errorAtProperty = (e, t) =>
          new qi(
            t.errors.map((t) => ((e, t) => ["ErrorAtProperty", e, t])(e, t))
          )),
        (qi.fold = (e) => new qi(e.flatMap((e) => e.errors)));
      let Hi = qi;
      const Wi = class {
        constructor(e) {
          this.decode = e;
        }
        map(e) {
          return ((e, t) => Ki.create((n) => e.decode(n).map(t)))(this, e);
        }
        flatMap(e) {
          return ((e, t) =>
            Ki.create((n) => e.decode(n).flatMap((e) => t(e).decode(e))))(
            this,
            e
          );
        }
        or(e) {
          return Ui(this, e);
        }
        optional() {
          return Ui(this, Yi);
        }
        nullable() {
          return Ui(this, Xi);
        }
        default(e) {
          return ((e, t) =>
            Ui(
              e,
              Yi.map(() => t)
            ))(this, e);
        }
        parseJSON(e) {
          try {
            return this.decode(JSON.parse(e));
          } catch (t) {
            return Li.error(Hi.errorMessage(t.message));
          }
        }
      };
      (Wi.create = (e) => new Wi(e)),
        (Wi.pure = (e) => Wi.create(() => Li.ok(e))),
        (Wi.fail = (e) => Wi.create(() => Li.error(Hi.errorMessage(e))));
      let Ki = Wi;
      const zi = Ki.create,
        Gi = Ki.pure,
        Ji = Ki.fail,
        Qi = (e, t) => Li.error(Hi.typeMismatch(e, t)),
        Yi = Ki.create((e) =>
          void 0 === e ? Li.ok(e) : Qi("undefined", typeof e)
        ),
        Xi = Ki.create((e) => (null === e ? Li.ok(e) : Qi("null", typeof e))),
        Zi = Ki.create(Li.ok),
        $i = Ki.create((e) =>
          "boolean" === typeof e ? Li.ok(e) : Qi("boolean", typeof e)
        ),
        eo = Ki.create((e) =>
          "number" !== typeof e
            ? Qi("number", typeof e)
            : Number.isFinite(e)
            ? Li.ok(e)
            : Qi("number", e.toString())
        ),
        to = Ki.create((e) =>
          "number" !== typeof e
            ? Qi("number", typeof e)
            : Number.isInteger(e)
            ? Li.ok(e)
            : Qi("integer", e.toString())
        ),
        no = Ki.create((e) =>
          "string" === typeof e ? Li.ok(e) : Qi("string", typeof e)
        ),
        ro = (e) =>
          Ki.create((t) => {
            if ("object" !== typeof t) return Qi("object", typeof t);
            if (null === t) return Qi("object", "null");
            {
              const n = t,
                r = {},
                s = [];
              for (const t in n)
                e.decode(n[t]).match(
                  (e) => (r[t] = e),
                  (e) => s.push(Hi.errorAtProperty(t, e))
                );
              return s.length ? Li.error(Hi.fold(s)) : Li.ok(r);
            }
          }),
        so = (e, t) =>
          t.flatMap((t) =>
            t < e
              ? Ji(
                  "Unexpected value: expected >= "
                    .concat(e, ", found ")
                    .concat(t)
                )
              : Gi(t)
          ),
        io = (e, t) =>
          t.flatMap((t) =>
            t > e
              ? Ji(
                  "Unexpected value: expected <= "
                    .concat(e, ", found ")
                    .concat(t)
                )
              : Gi(t)
          ),
        oo = (e) =>
          ((e) =>
            Ki.create((t) => {
              if ("object" !== typeof t) return Qi("object", typeof t);
              if (null === t) return Qi("object", "null");
              {
                const n = t,
                  r = {},
                  s = [];
                for (const t in e)
                  e[t].decode(n[t]).match(
                    (e) => (r[t] = e),
                    (e) => s.push(Hi.errorAtProperty(t, e))
                  );
                return s.length ? Li.error(Hi.fold(s)) : Li.ok(r);
              }
            }))(e).map((e) => {
            for (const t in e) void 0 === e[t] && delete e[t];
            return e;
          });
      var ao = Function.prototype.toString,
        co = Object.create,
        lo = Object.prototype.toString,
        uo = (function () {
          function e() {
            (this._keys = []), (this._values = []);
          }
          return (
            (e.prototype.has = function (e) {
              return !!~this._keys.indexOf(e);
            }),
            (e.prototype.get = function (e) {
              return this._values[this._keys.indexOf(e)];
            }),
            (e.prototype.set = function (e, t) {
              this._keys.push(e), this._values.push(t);
            }),
            e
          );
        })();
      var ho =
        "undefined" !== typeof WeakMap
          ? function () {
              return new WeakMap();
            }
          : function () {
              return new uo();
            };
      function po(e) {
        if (!e) return co(null);
        var t = e.constructor;
        if (t === Object) return e === Object.prototype ? {} : co(e);
        if (t && ~ao.call(t).indexOf("[native code]"))
          try {
            return new t();
          } catch (Hn) {}
        return co(e);
      }
      var fo =
        "g" === /test/g.flags
          ? function (e) {
              return e.flags;
            }
          : function (e) {
              var t = "";
              return (
                e.global && (t += "g"),
                e.ignoreCase && (t += "i"),
                e.multiline && (t += "m"),
                e.unicode && (t += "u"),
                e.sticky && (t += "y"),
                t
              );
            };
      function mo(e) {
        var t = lo.call(e);
        return t.substring(8, t.length - 1);
      }
      var go =
          "undefined" !== typeof Symbol
            ? function (e) {
                return e[Symbol.toStringTag] || mo(e);
              }
            : mo,
        vo = Object.defineProperty,
        yo = Object.getOwnPropertyDescriptor,
        bo = Object.getOwnPropertyNames,
        wo = Object.getOwnPropertySymbols,
        So = Object.prototype,
        _o = So.hasOwnProperty,
        Eo = So.propertyIsEnumerable,
        Ao = "function" === typeof wo;
      var To = Ao
        ? function (e) {
            return bo(e).concat(wo(e));
          }
        : bo;
      function Po(e, t, n) {
        for (
          var r = To(e), s = 0, i = r.length, o = void 0, a = void 0;
          s < i;
          ++s
        )
          if ("callee" !== (o = r[s]) && "caller" !== o)
            if ((a = yo(e, o))) {
              a.get || a.set || (a.value = n.copier(a.value, n));
              try {
                vo(t, o, a);
              } catch (c) {
                t[o] = a.value;
              }
            } else t[o] = n.copier(e[o], n);
        return t;
      }
      function Io(e, t) {
        return e.slice(0);
      }
      function Co(e, t) {
        var n = new t.Constructor();
        return (
          t.cache.set(e, n),
          e.forEach(function (e, r) {
            n.set(r, t.copier(e, t));
          }),
          n
        );
      }
      var ko = Ao
        ? function (e, t) {
            var n = po(t.prototype);
            for (var r in (t.cache.set(e, n), e))
              _o.call(e, r) && (n[r] = t.copier(e[r], t));
            for (var s = wo(e), i = 0, o = s.length, a = void 0; i < o; ++i)
              (a = s[i]), Eo.call(e, a) && (n[a] = t.copier(e[a], t));
            return n;
          }
        : function (e, t) {
            var n = po(t.prototype);
            for (var r in (t.cache.set(e, n), e))
              _o.call(e, r) && (n[r] = t.copier(e[r], t));
            return n;
          };
      function Oo(e, t) {
        return new t.Constructor(e.valueOf());
      }
      function xo(e, t) {
        return e;
      }
      function No(e, t) {
        var n = new t.Constructor();
        return (
          t.cache.set(e, n),
          e.forEach(function (e) {
            n.add(t.copier(e, t));
          }),
          n
        );
      }
      var Ro = Array.isArray,
        Do = Object.assign,
        Mo =
          Object.getPrototypeOf ||
          function (e) {
            return e.__proto__;
          },
        jo = {
          array: function (e, t) {
            var n = new t.Constructor();
            t.cache.set(e, n);
            for (var r = 0, s = e.length; r < s; ++r) n[r] = t.copier(e[r], t);
            return n;
          },
          arrayBuffer: Io,
          blob: function (e, t) {
            return e.slice(0, e.size, e.type);
          },
          dataView: function (e, t) {
            return new t.Constructor(Io(e.buffer));
          },
          date: function (e, t) {
            return new t.Constructor(e.getTime());
          },
          error: xo,
          map: Co,
          object: ko,
          regExp: function (e, t) {
            var n = new t.Constructor(e.source, fo(e));
            return (n.lastIndex = e.lastIndex), n;
          },
          set: No,
        },
        Lo = Do({}, jo, {
          array: function (e, t) {
            var n = new t.Constructor();
            return t.cache.set(e, n), Po(e, n, t);
          },
          map: function (e, t) {
            return Po(e, Co(e, t), t);
          },
          object: function (e, t) {
            var n = po(t.prototype);
            return t.cache.set(e, n), Po(e, n, t);
          },
          set: function (e, t) {
            return Po(e, No(e, t), t);
          },
        });
      function Uo(e) {
        var t = (function (e) {
            return {
              Arguments: e.object,
              Array: e.array,
              ArrayBuffer: e.arrayBuffer,
              Blob: e.blob,
              Boolean: Oo,
              DataView: e.dataView,
              Date: e.date,
              Error: e.error,
              Float32Array: e.arrayBuffer,
              Float64Array: e.arrayBuffer,
              Int8Array: e.arrayBuffer,
              Int16Array: e.arrayBuffer,
              Int32Array: e.arrayBuffer,
              Map: e.map,
              Number: Oo,
              Object: e.object,
              Promise: xo,
              RegExp: e.regExp,
              Set: e.set,
              String: Oo,
              WeakMap: xo,
              WeakSet: xo,
              Uint8Array: e.arrayBuffer,
              Uint8ClampedArray: e.arrayBuffer,
              Uint16Array: e.arrayBuffer,
              Uint32Array: e.arrayBuffer,
              Uint64Array: e.arrayBuffer,
            };
          })(Do({}, jo, e)),
          n = t.Array,
          r = t.Object;
        function s(e, s) {
          if (
            ((s.prototype = s.Constructor = void 0),
            !e || "object" !== typeof e)
          )
            return e;
          if (s.cache.has(e)) return s.cache.get(e);
          if (
            ((s.prototype = Mo(e)),
            (s.Constructor = s.prototype && s.prototype.constructor),
            !s.Constructor || s.Constructor === Object)
          )
            return r(e, s);
          if (Ro(e)) return n(e, s);
          var i = t[go(e)];
          return i ? i(e, s) : "function" === typeof e.then ? e : r(e, s);
        }
        return function (e) {
          return s(e, {
            Constructor: void 0,
            cache: ho(),
            copier: s,
            prototype: void 0,
          });
        };
      }
      !(function (e) {
        Uo(Do({}, Lo, e));
      })({});
      var Fo = Uo({}),
        Bo = n(122),
        Vo = n.n(Bo);
      function qo(e, t) {
        if ("object" === typeof t && Array.isArray(t)) {
          if ("object" !== typeof e || !Array.isArray(e)) return Ho(t);
          let n = !1;
          const r = [...t];
          for (let s = 0; s < t.length; s++) {
            const i = qo(e[s], t[s]);
            i !== e[s] && (n = !0), (r[s] = i);
          }
          return t.length !== e.length && (n = !0), n ? r : e;
        }
        if ("object" === typeof t && null !== t) {
          if ("object" !== typeof e || null === e) return Ho(t);
          let n = !1;
          const r = { ...t };
          for (const s in t) {
            const i = qo(e[s], t[s]);
            i !== e[s] && (n = !0), (r[s] = i);
          }
          for (const s in e)
            if (!(s in t)) {
              n = !0;
              break;
            }
          return n ? r : e;
        }
        return t !== e ? t : e;
      }
      function Ho(e) {
        return Fo(e);
      }
      function Wo(e, t) {
        return Vo()(e, t);
      }
      function Ko(e, t) {
        const n = t.split(".");
        if (n.length > 2)
          throw Error("Only 1 level of namespacing is supported");
        const [r, s] = 2 === n.length ? n : [void 0, t],
          i = r ? e[r] : e;
        return null === i || void 0 === i ? void 0 : i[s];
      }
      function zo(e, t) {
        if ("object" !== typeof e) return e;
        const n = { ...e };
        for (const r in n)
          t.includes(r)
            ? (n[r] = "<stripped>")
            : "object" === typeof n[r] && (n[r] = zo(n[r], t));
        return n;
      }
      function Go(e, t) {
        const n = {};
        for (const r in e) n[r] = t(r, e[r]);
        return n;
      }
      const Jo = (e) => {
        if ("object" === typeof e && null !== e) {
          if ("function" === typeof Object.getPrototypeOf) {
            const t = Object.getPrototypeOf(e);
            return t === Object.prototype || null === t;
          }
          return "[object Object]" === Object.prototype.toString.call(e);
        }
        return !1;
      };
      function Qo() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        return t.reduce(
          (e, t) => (
            Object.keys(t).forEach((n) => {
              Jo(e[n]) && Jo(t[n]) ? (e[n] = Qo(e[n], t[n])) : (e[n] = t[n]);
            }),
            e
          ),
          {}
        );
      }
      class Yo extends Error {
        constructor(e) {
          super(e), (this.name = "ValidationError");
        }
      }
      class Xo {
        constructor() {
          (this.__schema = !0),
            (this.required = !0),
            (this.defaultValueSet = !1),
            (this.customValidatorFn = () => null);
        }
        isArraySchema() {
          return "array" === this._type;
        }
        isObjectSchema() {
          return "object" === this._type;
        }
        optional() {
          const e = this.clone();
          return (e.required = !1), e;
        }
        default(e) {
          this.tryValidate(e);
          const t = this.clone();
          return (t.defaultValue = e), (t.defaultValueSet = !0), t;
        }
        customValidator(e) {
          return (this.customValidatorFn = e), this;
        }
        getDefault() {
          if (
            (this.tryValidate(this.defaultValue),
            this.required || this.defaultValueSet)
          )
            return Ho(this.defaultValue);
        }
        tryValidate(e, t) {
          const n = this.validate(e, t);
          if (n) throw new Yo(n);
        }
        validate(e, t) {
          const n = this.validateType(e, t);
          return (
            n ||
            (this.required || void 0 !== e
              ? this.customValidatorFn(e, t)
              : null)
          );
        }
        isValid(e, t) {
          return !this.validate(e, t);
        }
        tryValidateAndFillDefaults(e, t) {
          return void 0 === e && this.required
            ? this.getDefault()
            : (this.tryValidate(e, t), null);
        }
        tryDecode(e) {
          return this.toDecoder().decode(e).unsafeValue;
        }
        clone() {
          return Ho(this);
        }
      }
      class Zo extends Xo {
        constructor() {
          super(), (this._type = "null"), (this.defaultValue = null);
        }
        validateType(e) {
          return (void 0 !== e || this.required) && null !== e
            ? "Not null"
            : null;
        }
        serialize() {
          return { type: "null", optional: !this.required };
        }
        toDecoder() {
          return Sa(this, Xi);
        }
      }
      class $o extends Xo {
        constructor() {
          super(),
            (this._type = "number"),
            (this.minVal = -1 / 0),
            (this.maxVal = 1 / 0),
            (this.defaultValue = 0);
        }
        range(e, t) {
          const n = this.clone();
          return (n.minVal = e), (n.maxVal = t), n;
        }
        min(e) {
          const t = this.clone();
          return (t.minVal = e), t;
        }
        max(e) {
          const t = this.clone();
          return (t.maxVal = e), t;
        }
        validateType(e) {
          return void 0 !== e || this.required
            ? "number" !== typeof e
              ? "Not a number: " + e
              : this.minVal > e || this.maxVal < e
              ? "Out of range: " +
                e +
                " in range [" +
                this.minVal +
                ", " +
                this.maxVal +
                "]"
              : isNaN(e)
              ? "Value is NaN"
              : null
            : null;
        }
        serialize() {
          return {
            type: "number",
            optional: !this.required,
            ...(Number.isSafeInteger(this.minVal)
              ? { minVal: this.minVal }
              : {}),
            ...(Number.isSafeInteger(this.maxVal)
              ? { maxVal: this.maxVal }
              : {}),
          };
        }
        toDecoder() {
          let e = eo;
          return (
            (e = so(this.minVal, e)), (e = io(this.maxVal, e)), Sa(this, e)
          );
        }
      }
      class ea extends $o {
        constructor() {
          super(), (this._type = "integer");
        }
        validateType(e) {
          if (void 0 === e && !this.required) return null;
          const t = super.validateType(e);
          return (
            t || (parseInt(e.toString(), 10) !== e ? "Not an integer" : null)
          );
        }
        toDecoder() {
          let e = to;
          return (
            (e = so(this.minVal, e)), (e = io(this.maxVal, e)), Sa(this, e)
          );
        }
      }
      class ta extends Xo {
        constructor() {
          super(), (this._type = "boolean"), (this.defaultValue = !1);
        }
        validateType(e) {
          return (void 0 !== e || this.required) && "boolean" !== typeof e
            ? "Not a boolean"
            : null;
        }
        serialize() {
          return { type: "boolean", optional: !this.required };
        }
        toDecoder() {
          return Sa(this, $i);
        }
      }
      class na extends Xo {
        constructor() {
          super(), (this._type = "string"), (this.defaultValue = "");
        }
        validateType(e) {
          return void 0 !== e || this.required
            ? "string" === typeof e
              ? null
              : "Not a string: " + e
            : null;
        }
        serialize() {
          return { type: "string", optional: !this.required };
        }
        toDecoder() {
          return Sa(this, no);
        }
      }
      class ra extends Xo {
        constructor(e) {
          super(), (this._type = "object"), (this.objValidators = e);
          for (const n in e) {
            var t;
            if (
              "object" !== typeof e[n] ||
              null === (t = e[n]) ||
              void 0 === t ||
              !t.__schema
            )
              throw new Error(
                "Schema for field " + n + " not constructed by SchemaBuilder."
              );
          }
        }
        validateType(e, t) {
          if (void 0 === e && !this.required) return null;
          if ("object" !== typeof e || null === e) return "Not an object: " + e;
          for (const r in e) {
            let n = this.objValidators[r];
            const s = t && !!t.ignoreUnexpectedFields;
            if (!n) {
              if (s) continue;
              if (!this.additionalPropertyValuesSchema)
                return "Unexpected field: " + r;
              n = this.additionalPropertyValuesSchema;
            }
            const i = n.validate(e[r], t);
            if (i) return "Error validating field `" + r + "`: " + i;
          }
          const n = [];
          for (const r in this.objValidators) {
            this.objValidators[r].required &&
              "undefined" === typeof e[r] &&
              n.push(r);
          }
          return n.length > 0 ? "Missing fields: " + n.join(", ") : null;
        }
        tryValidateAndFillDefaults(e, t) {
          if (void 0 === e && !this.required) return null;
          if ("object" !== typeof e || null === e)
            throw new Error("Not an object.");
          let n = !1;
          for (const s in e) {
            let r = this.objValidators[s];
            const i = t && !!t.ignoreUnexpectedFields;
            if (!r) {
              if (i) continue;
              if (!this.additionalPropertyValuesSchema)
                throw new Error("Unexpected field: " + s);
              r = this.additionalPropertyValuesSchema;
            }
            let o;
            try {
              o = r.tryValidateAndFillDefaults(e[s], t);
            } catch (a_) {
              throw new Error(
                "Error validating field `" + s + "`: " + a_.message
              );
            }
            o && (n || ((e = Ho(e)), (n = !0)), (e[s] = o));
          }
          const r = Object.keys(this.objValidators)
            .filter((e) => this.objValidators[e].required)
            .filter((t) => "undefined" === typeof e[t]);
          for (const s of r)
            n || ((e = Ho(e)), (n = !0)),
              (e[s] = this.objValidators[s].getDefault());
          return n ? e : null;
        }
        getDefault() {
          if (!this.required && !this.defaultValueSet) return;
          let e;
          return (
            (e = this.defaultValue
              ? this.defaultValue
              : Object.keys(this.objValidators)
                  .map((e) => ({ [e]: this.objValidators[e].getDefault() }))
                  .reduce((e, t) => ({ ...e, ...t }), {})),
            this.tryValidate(e),
            Ho(e)
          );
        }
        serialize() {
          const e = {};
          for (const t in this.objValidators)
            e[t] = this.objValidators[t].serialize();
          return { type: "object", optional: !this.required, fields: e };
        }
        getSchema(e) {
          return this.objValidators[e];
        }
        getFullSchema() {
          return this.objValidators;
        }
        getAdditionalPropertyValuesSchema() {
          return this.additionalPropertyValuesSchema;
        }
        additionalProperties(e) {
          const t = this.clone();
          return (
            (t.additionalPropertyValuesSchema =
              null !== e && void 0 !== e ? e : wa()),
            t
          );
        }
        toDecoder() {
          const e = {};
          Object.entries(this.objValidators).forEach((t) => {
            let [n, r] = t;
            e[n] = r.toDecoder();
          });
          let t = oo(e);
          if (this.additionalPropertyValuesSchema) {
            const e = this.additionalPropertyValuesSchema.toDecoder();
            t = t.flatMap((t) =>
              ro(Zi).flatMap((n) => {
                const r = {};
                let s;
                return (
                  Object.entries(n).forEach((t) => {
                    let [n, i] = t;
                    (s = e.decode(i)), s.isOk() && (r[n] = s.value);
                  }),
                  Gi({ ...r, ...t })
                );
              })
            );
          }
          return Sa(this, t);
        }
      }
      class sa extends Xo {
        constructor(e) {
          if (
            (super(),
            (this._type = "array"),
            (this.minLengthVal = -1 / 0),
            (this.maxLengthVal = 1 / 0),
            (this.defaultValue = []),
            (this.itemSchema = e),
            "object" !== typeof e || !e.__schema)
          )
            throw new Error(
              "Item schema for array not constructed by SchemaBuilder"
            );
        }
        lengthRange(e, t) {
          const n = this.clone();
          return (n.minLengthVal = e), (n.maxLengthVal = t), n;
        }
        minLength(e) {
          const t = this.clone();
          return (t.minLengthVal = e), t;
        }
        maxLength(e) {
          const t = this.clone();
          return (t.maxLengthVal = e), t;
        }
        length(e) {
          const t = this.clone();
          return (t.minLengthVal = e), (t.maxLengthVal = e), t;
        }
        validateType(e, t) {
          if (void 0 === e && !this.required) return null;
          if ("object" !== typeof e || !Array.isArray(e))
            return "Not an array " + e;
          if (this.minLengthVal > e.length || this.maxLengthVal < e.length)
            return "Length out of range: "
              .concat(e.length, " in range [")
              .concat(this.minLengthVal, ", ")
              .concat(this.maxLengthVal, "]");
          for (let r = 0; r < e.length; r++) {
            var n;
            const s = null !== (n = e[r]) && void 0 !== n ? n : void 0,
              i = this.itemSchema.validate(s, t);
            if (i) return "Error validating item " + r + ": " + i;
          }
          return null;
        }
        tryValidateAndFillDefaults(e, t) {
          if (void 0 === e && !this.required) return null;
          let n = !1;
          for (let s = 0; s < e.length; s++) {
            var r;
            const i = null !== (r = e[s]) && void 0 !== r ? r : void 0;
            let o;
            try {
              o = this.itemSchema.tryValidateAndFillDefaults(i, t);
            } catch (a_) {
              throw new Error("Error validating item " + s + ": " + a_.message);
            }
            null !== o && (n || (e = Ho(e)), (e[s] = o), (n = !0));
          }
          return this.tryValidate(e, t), n ? e : null;
        }
        getDefault() {
          if (this.required || this.defaultValueSet)
            return this.tryValidate(this.defaultValue), Ho(this.defaultValue);
        }
        serialize() {
          return {
            type: "array",
            optional: !this.required,
            items: this.itemSchema.serialize(),
            ...(Number.isSafeInteger(this.minLengthVal)
              ? { minLengthVal: this.minLengthVal }
              : {}),
            ...(Number.isSafeInteger(this.maxLengthVal)
              ? { maxLengthVal: this.maxLengthVal }
              : {}),
          };
        }
        getItemSchema() {
          return this.itemSchema;
        }
        toDecoder() {
          const e = this.itemSchema.toDecoder();
          let t = ((e) =>
            Ki.create((t) => {
              if (Array.isArray(t)) {
                const n = [];
                let r = [];
                for (let s = 0; s < t.length; s++)
                  e.decode(t[s]).match(
                    (e) => n.push(e),
                    (e) => r.push(Hi.errorAtIndex(s, e))
                  );
                return r.length ? Li.error(Hi.fold(r)) : Li.ok(n);
              }
              return Qi("array", typeof t);
            }))(zi((t) => e.decode(null !== t && void 0 !== t ? t : void 0)));
          return (
            (t = ((e, t) =>
              t.flatMap((t) =>
                t.length < e
                  ? Ji(
                      "Unexpected value: expected .length >= "
                        .concat(e, ", found ")
                        .concat(t.length)
                    )
                  : Gi(t)
              ))(this.minLengthVal, t)),
            (t = ((e, t) =>
              t.flatMap((t) =>
                t.length > e
                  ? Ji(
                      "Unexpected value: expected .length <= "
                        .concat(e, ", found ")
                        .concat(t.length)
                    )
                  : Gi(t)
              ))(this.maxLengthVal, t)),
            Sa(this, t)
          );
        }
      }
      class ia extends Xo {
        constructor(e) {
          if (
            (super(), (this.values = e), (this._type = "tuple"), 0 === e.length)
          )
            throw new Error(
              "Tuple schema requires at least one string literal type."
            );
        }
        validateType(e) {
          return void 0 !== e || this.required
            ? this.values.includes(e)
              ? null
              : e + " is not valid, possible values: " + this.values.join(", ")
            : null;
        }
        getDefault() {
          if (this.required || this.defaultValueSet)
            return this.defaultValueSet ? this.defaultValue : this.values[0];
        }
        serialize() {
          return {
            type: "tuple",
            optional: !this.required,
            values: this.values,
          };
        }
        toDecoder() {
          const e = no.flatMap((e) =>
            this.values.includes(e)
              ? Gi(e)
              : Ji(
                  "Expected one of { " +
                    this.values.map((e) => JSON.stringify(e)).join(", ") +
                    " }"
                )
          );
          return Sa(this, e);
        }
      }
      class oa extends Xo {
        constructor(e) {
          if (
            (super(),
            (this._type = "map"),
            (this.itemSchema = e),
            "object" !== typeof e || !e.__schema)
          )
            throw new Error(
              "Item schema for array not constructed by SchemaBuilder"
            );
          this.defaultValue = {};
        }
        validateType(e, t) {
          if (void 0 === e && !this.required) return null;
          if ("object" !== typeof e || null === e) return "Not a map: " + e;
          for (const n in e) {
            const r = this.itemSchema.validate(e[n], t);
            if (r)
              return 'Error validating item in map with key "' + n + '": ' + r;
          }
          return null;
        }
        tryValidateAndFillDefaults(e, t) {
          if (this.required && void 0 === e) return this.getDefault();
          if (void 0 === e && !this.required) return null;
          if ("object" !== typeof e || null === e) return "Not a map: " + e;
          let n = !1;
          for (const r in e) {
            let s;
            try {
              s = this.itemSchema.tryValidateAndFillDefaults(e[r], t);
            } catch (a_) {
              throw new Error(
                'Error validating item in map with key "' +
                  r +
                  '": ' +
                  a_.message
              );
            }
            s && (n || (e = Ho(e)), (e[r] = s), (n = !0));
          }
          return n ? e : null;
        }
        getDefault() {
          if (this.required || this.defaultValueSet)
            return this.tryValidate(this.defaultValue), Ho(this.defaultValue);
        }
        getItemSchema() {
          return this.itemSchema;
        }
        serialize() {
          return {
            type: "map",
            optional: !this.required,
            items: this.itemSchema.serialize(),
          };
        }
        toDecoder() {
          const e = ro(this.itemSchema.toDecoder());
          return Sa(this, e);
        }
      }
      class aa extends Xo {
        constructor(e) {
          if ((super(), (this._type = "union"), 0 === e.length))
            throw new Error("Cannot define empty union type");
          this.itemSchemas = e;
        }
        validateType(e, t) {
          if (void 0 === e && !this.required) return null;
          const n = [];
          for (const r of this.itemSchemas) {
            const s = r.validate(e, t);
            if (!s) return null;
            n.push(
              "Could not validate value as " + r.constructor.name + ": " + s
            );
          }
          return n.join("\n");
        }
        getDefault() {
          if (this.required || this.defaultValueSet)
            return this.defaultValueSet
              ? this.defaultValue
              : this.itemSchemas[0].getDefault();
        }
        getItemSchemas() {
          return this.itemSchemas;
        }
        tryValidateAndFillDefaults(e, t) {
          if (this.required && void 0 === e) return this.getDefault();
          if (void 0 === e && !this.required) return null;
          if (!this.validate(e, t)) return null;
          const n = [];
          for (const r of this.itemSchemas)
            try {
              return r.tryValidateAndFillDefaults(e, t);
            } catch (a_) {
              n.push(a_);
            }
          throw new Error("Could not validate union: " + n.join(","));
        }
        serialize() {
          return {
            type: "union",
            optional: !this.required,
            variants: this.itemSchemas.map((e) => e.serialize()),
          };
        }
        toDecoder() {
          const e = [...this.itemSchemas]
            .reverse()
            .reduce((e, t) => t.toDecoder().or(e), Ji("EOL"));
          return Sa(this, e);
        }
      }
      class ca extends Xo {
        constructor() {
          return super(), (this._type = "unknown"), this.optional();
        }
        validateType(e) {
          return null;
        }
        serialize() {
          return { type: "unknown", optional: !this.required };
        }
        toDecoder() {
          return Zi.map(Ho);
        }
      }
      function la() {
        return new Zo();
      }
      function ua() {
        return new na();
      }
      function da() {
        return new $o();
      }
      function ha() {
        return new $o();
      }
      function pa() {
        return new ea();
      }
      function fa() {
        return new ta();
      }
      function ma(e) {
        return new aa(e);
      }
      function ga(e) {
        return new ra(e);
      }
      function va(e) {
        return new sa(e);
      }
      function ya(e) {
        return new oa(e);
      }
      function ba(e) {
        return new ia(e);
      }
      function wa() {
        return new ca();
      }
      const Sa = (e, t) => {
          const n = e.customValidatorFn;
          return (
            n &&
              (t = t.flatMap((e) => {
                const t = n(e);
                return t ? Ji(t) : Gi(e);
              })),
            zi((n) =>
              "undefined" === typeof n
                ? ((e) => Li.ok(e))(e.getDefault())
                : t.decode(n)
            )
          );
        },
        _a = t,
        Ea = _a.object({
          entry: _a.object({
            first: _a.int().min(0).optional(),
            last: _a.int().min(0),
            lastAdEntry: _a.int().min(0).optional(),
            lastResurrected: _a.int().min(0).optional(),
          }),
          analytics: _a
            .object({ $zeroEntryDatetime: _a.string().optional() })
            .optional(),
        });
      function Aa(e, t) {
        const n = {};
        for (const r of e) {
          const e = Ta(t(r));
          e && (n[r] = e);
        }
        return n;
      }
      function Ta(e) {
        if (
          !(function (e) {
            return !Ea.validate(e, { ignoreUnexpectedFields: !0 });
          })(e)
        )
          return null;
        const { entry: t, analytics: n } = e;
        return 0 === t.last
          ? null
          : {
              firstEntryAt:
                t.first && 1545231968498 !== t.first ? t.first : void 0,
              lastEntryAt: t.last,
              lastAdEntryAt: t.lastAdEntry ? t.lastAdEntry : void 0,
              lastResurrectedAt: t.lastResurrected ? t.lastResurrected : void 0,
              zeroEntryAt: (null == n ? void 0 : n.$zeroEntryDatetime)
                ? new Date(n.$zeroEntryDatetime).getTime()
                : void 0,
            };
      }
      function Pa(e, t, n) {
        const {
          firstEntryAt: r,
          lastEntryAt: s,
          zeroEntryAt: i,
          lastAdEntryAt: o,
          lastResurrectedAt: a,
        } = e;
        if (
          !(
            (!r || "number" === typeof r) &&
            "number" === typeof s &&
            (!i || "number" === typeof i) &&
            (!o || "number" === typeof o) &&
            (!a || "number" === typeof a)
          )
        )
          return null;
        const c = Ln({ days: 1 }),
          l = {
            daysElapsedLastEntry: (t - s) / c,
            hoursElapsedLastEntry: (t - s) / Ln({ hours: 1 }),
          };
        if (
          r &&
          ((l.daysElapsedFirstEntry = (t - r) / c),
          (l.daysSinceInstall = Math.floor((t - r) / c)),
          n)
        ) {
          const e = Un({ fromTimestamp: r, ianaTimeZone: n, toTimestamp: t });
          (l.projectDaysSinceInstall = e),
            (l.lastEntryCalendarDaysSinceInstall = e);
        }
        if (
          (o && (l.daysSinceLastAdEntry = Math.floor((t - o) / c)),
          a && (l.daysSinceLastResurrected = Math.floor((t - a) / c)),
          i && ((l.$lastEntryElapsedDaysZeroEntry = (t - i) / c), n))
        ) {
          const e = Un({ fromTimestamp: i, ianaTimeZone: n, toTimestamp: t });
          (l.projectDaysSinceZeroEntry = e),
            (l.lastEntryCalendarDaysSinceZeroEntry = e);
        }
        return l;
      }
      var Ia = Object.defineProperty,
        Ca = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Ia(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class ka {
        constructor() {
          Ca(this, "platform"),
            Ca(this, "payload"),
            Ca(this, "playerId"),
            Ca(this, "signature"),
            (this.platform = ""),
            (this.payload = ""),
            (this.playerId = ""),
            (this.signature = "");
        }
        fromFacebookData(e, t) {
          return (
            (this.platform = "fb"),
            (this.payload = t || ""),
            (this.playerId = e.getPlayerID()),
            (this.signature = e.getSignature()),
            this
          );
        }
        fromLineData(e) {
          return (
            (this.platform = "line"),
            (this.payload = e.payload),
            (this.playerId = e.playerId),
            (this.signature = e.idToken),
            this
          );
        }
        fromLinkData(e, t) {
          return (
            (this.platform = "link"),
            (this.payload = t || ""),
            (this.playerId = e.getPlayerID()),
            (this.signature = e.getSignature()),
            this
          );
        }
        fromViberData(e, t) {
          return (
            (this.platform = "viber"),
            (this.payload = t || ""),
            (this.playerId = e.getPlayerID()),
            (this.signature = e.getSignature()),
            this
          );
        }
        fromZoomData(e) {
          return (
            (this.platform = "zoom"),
            (this.payload = e.payload),
            (this.playerId = e.playerId),
            (this.signature = e.idToken),
            this
          );
        }
      }
      class Oa {
        constructor(e) {
          this.platform = e;
        }
        async hasAcceptedToS(e) {
          var t;
          return (
            this.tryValidateTosVersion(e),
            await this.platform.loadStorage(),
            !!(null == (t = this.platform.storage.tos[e])
              ? void 0
              : t.acceptedAt)
          );
        }
        acceptToS(e, t) {
          this.tryValidateTosVersion(e),
            (function (e) {
              fr.pushEvent("ShowToSUpdatePopupAsyncSuccess", e);
            })({ requestMs: t.requestMs, ToSVersion: e }),
            this.platform.storage.assign(
              (t) => (t.tos[e] = { acceptedAt: Nn.getNow() })
            );
        }
        trackPopupOpenEvent(e) {
          this.tryValidateTosVersion(e),
            (function (e) {
              fr.pushEvent("ShowToSUpdatePopupAsync", e);
            })({ ToSVersion: e });
        }
        tryValidateTosVersion(e) {
          if (!["2022-12"].includes(e))
            throw Sr("INVALID_PARAM", "Invalid ToS version: " + e);
        }
      }
      var xa = Object.defineProperty,
        Na = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? xa(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class Ra extends HTMLElement {
        constructor() {
          super(),
            Na(this, "container"),
            Na(this, "onCloseCallback"),
            this.attachShadow({ mode: "open" });
          vr("style", void 0, this.shadowRoot).textContent =
            '.overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  margin: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.4);\n  display: flex;\n  justify-content: center;\n  z-index: 989;\n  cursor: default;\n  overflow-x: hidden;\n  overflow-y: hidden;\n  font-size: 1.4rem;\n  font-family: "\\30E1\\30A4\\30EA\\30AA", Meiryo, "\\30D2\\30E9\\30AE\\30CE\\89D2\\30B4 Pro W3", "Hiragino Kaku Gothic Pro", Osaka, "\\FF2D\\FF33\\FF30\\30B4\\30B7\\30C3\\30AF", "MS PGothic", arial, helvetica, sans-serif;\n}\n\n@media (min-width: 600px) {\n  .overlay {\n    font-size: 1.4rem; /* minimum font size for screens 600px and wider */\n  }\n}\n\n@media (max-width: 600px) {\n  .overlay {\n    font-size: 5vmin; /* font size scales with viewport width for screens narrower than 600px */\n  }\n}\n\n.overlay * {\n  box-sizing: border-box;\n}\n\n.container {\n  opacity: 0;\n  top: 0px;\n  width: 85%;\n  max-width: 320px;\n  max-height: 80%;\n  margin: auto 10px;\n  background-color: #fff;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: auto;\n  position: fixed;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n  border-radius: 12px;\n  transition: top 0.2s ease-out 0.0s, opacity 0.1s;\n}\n\n.button {\n  text-shadow: 0px 1px 0.5px rgba(0, 0, 0, 0.3);\n  background: linear-gradient(180deg, #36D100 0%, #008F64 100%);\n  text-align: center;\n  color: #fff;\n  font-size: 18px;\n  width: 150px;\n  height: 40px;\n  border-radius: 8px;\n  padding: 7px 10px;\n  margin-top: 10px;\n}';
          const e = vr("div", "overlay", this.shadowRoot);
          this.container = vr("div", "container", e);
        }
        connectedCallback() {
          setTimeout(() => {
            (this.container.style.top = "44px"),
              (this.container.style.opacity = "1");
          }, 100);
        }
        onClose(e) {
          this.onCloseCallback = e;
        }
        closePopup() {
          var e;
          null == (e = this.onCloseCallback) || e.call(this), this.remove();
        }
      }
      var Da = Object.defineProperty,
        Ma = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Da(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      const ja = {
        en: {
          agree: "AGREE",
          body: '<p>We\'ve updated our <a href="https://www.play.co/tos">Terms</a> and <a href="https://play.co/privacy">Privacy Notice</a>. Learn about <a href="http://www.play.co/press/updates-to-terms-and-privacy-notice-dec-2022">what\'s changed</a>.</p><p>By continuing to play, you agree to the new terms and acknowledge you\'ve read the privacy notice.</p>',
        },
        ja: {
          agree: "\u540c\u610f\u3059\u308b",
          body: '<p>\u5f53\u793e\u306f<a href="https://www.play.co/tos">\u5229\u7528\u898f\u7d04</a> \u53ca\u3073<a href="https://play.co/privacy">\u30d7\u30e9\u30a4\u30d0\u30b7\u30fc\u901a\u77e5</a> \u3092\u66f4\u65b0\u3057\u307e\u3057\u305f\u3002<a href="http://www.play.co/press/updates-to-terms-and-privacy-notice-dec-2022">\u5909\u66f4\u70b9\u306b\u3064\u3044\u3066</a> \u3092\u3054\u78ba\u8a8d\u304f\u3060\u3055\u3044\u3002</p><p>\u30d7\u30ec\u30fc\u3092\u7d99\u7d9a\u3059\u308b\u3053\u3068\u3067\u3001\u304a\u5ba2\u69d8\u306f\u65b0\u305f\u306a\u898f\u7d04\u306b\u540c\u610f\u3059\u308b\u3053\u3068\u306b\u306a\u308a\u3001\u307e\u305f\u3001\u30d7\u30e9\u30a4\u30d0\u30b7\u30fc\u901a\u77e5\u3092\u65e2\u306b\u8aad\u3093\u3060\u3053\u3068\u3092\u8a8d\u3081\u308b\u3053\u3068\u306b\u306a\u308a\u307e\u3059\u3002</p>',
        },
      };
      class La extends Ra {
        constructor() {
          super(),
            Ma(this, "_locale", "en"),
            Ma(this, "_useLegacyLinks", !1),
            this.render();
        }
        get locale() {
          return this._locale;
        }
        set locale(e) {
          ("en" === e || "ja" === e) &&
            e !== this._locale &&
            ((this._locale = e), this.render());
        }
        set useLegacyLinks(e) {
          e !== this._useLegacyLinks &&
            ((this._useLegacyLinks = e), this.render());
        }
        render() {
          const e = ja[this._locale],
            t = this._useLegacyLinks
              ? e.body
                  .replace(
                    "https://www.play.co/tos",
                    "https://www.chobolabs.com/terms-of-service/"
                  )
                  .replace(
                    "https://play.co/privacy",
                    "https://www.chobolabs.com/privacy-policy/"
                  )
              : e.body;
          this.container.innerHTML = t;
          const n = vr("button", "button", this.container);
          (n.innerText = e.agree), (n.onclick = () => this.closePopup());
        }
      }
      Ma(La, "ELEMENT_NAME", "tos-popup");
      var Ua = Object.defineProperty,
        Fa = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? Ua(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      const Ba = "devkit-fbinstant:MockFBInstant",
        Va = "playerData";
      let qa = 0;
      const Ha = {};
      class Wa {
        constructor(e) {
          Fa(this, "_placementID"),
            Fa(this, "_loaded"),
            Fa(this, "_viewed"),
            (this._placementID = e),
            (this._loaded = !1),
            (this._viewed = !1);
        }
        getPlacementID() {
          return this._placementID;
        }
        loadAsync() {
          return this._viewed
            ? Promise.reject(new Error())
            : ((this._loaded = !0), Promise.resolve());
        }
        showAsync() {
          return !this._loaded || this._viewed
            ? Promise.reject(new Error())
            : ((this._viewed = !0), Promise.resolve());
        }
      }
      function Ka(e, t) {
        try {
          t
            ? u.Lr.setItem(Ba + ":" + e, JSON.stringify(t))
            : u.Lr.removeItem(Ba + ":" + e);
        } catch (a_) {
          console.error("FBINSTANT: mock setDataAsync FAILED!", a_);
        }
      }
      function za(e, t) {
        try {
          const n = u.Lr.getItem(Ba + ":" + e);
          if (n) return JSON.parse(n);
          Ka(e, t);
        } catch (a_) {
          console.error("FBINSTANT: mock getDataAsync FAILED!", a_);
        }
        return t;
      }
      const Ga = 864e5,
        Ja = {
          linePhase: "release",
          lineCORSProxyURL:
            "https://line-relay-1.ap-northeast-1.dev.gc-internal.net",
          linePurchaseAPIEndpoint: "https://lg-elogn.line-apps.com",
          isDevelopment: !1,
        };
      class Qa {
        constructor(e) {
          Fa(this, "abTests"),
            Fa(this, "ads", {
              preloadInterstitialAdAsync: () =>
                Promise.reject("Not implemented"),
              preloadRewardedInterstitialAdAsync: () =>
                Promise.reject("Not implemented"),
              preloadRewardedVideoAdAsync: () =>
                Promise.reject("Not implemented"),
              showPreloadedInterstitialAdAsync: () =>
                Promise.reject("Not implemented"),
              showPreloadedRewardedInterstitialAdAsync: () =>
                Promise.reject("Not implemented"),
              showPreloadedRewardedVideoAdAsync: () =>
                Promise.reject("Not implemented"),
              interstitialAdIsLoaded: () => {
                throw Error("Not implemented");
              },
              rewardedInterstitialAdIsLoaded: () => {
                throw Error("Not implemented");
              },
              rewardedVideoAdIsLoaded: () => {
                throw Error("Not implemented");
              },
            }),
            Fa(this, "appID"),
            Fa(this, "canUseSquads", !1),
            Fa(this, "canChangeContext"),
            Fa(this, "canCreateShortcut"),
            Fa(this, "canPlayerMatch"),
            Fa(this, "_canShowInterstitialAds", !1),
            Fa(this, "_canShowRewardedInterstitialAds", !1),
            Fa(this, "_canShowRewardedVideoAds", !1),
            Fa(this, "_canRegisterForPushNotifications", !1),
            Fa(this, "canSubscribeToBot"),
            Fa(this, "catalog"),
            Fa(this, "community", {
              canFollowOfficialPageAsync: () =>
                Promise.reject("Not implemented"),
              canJoinOfficialGroupAsync: () =>
                Promise.reject("Not implemented"),
              followOfficialPageAsync: () => Promise.reject("Not implemented"),
              joinOfficialGroupAsync: () => Promise.reject("Not implemented"),
            }),
            Fa(this, "contextID"),
            Fa(this, "contextSquad", null),
            Fa(this, "contextTournament", null),
            Fa(this, "crossplay", new Ai(this)),
            Fa(this, "contextType"),
            Fa(this, "entryAnalyticsBundle"),
            Fa(this, "entryContextTournament", null),
            Fa(this, "entryData", null),
            Fa(this, "entryPointName"),
            Fa(this, "friendIds", []),
            Fa(this, "friends"),
            Fa(this, "friendsMap"),
            Fa(this, "insideNativeIOS"),
            Fa(this, "isMobile"),
            Fa(this, "isSubscribedToBot", !1),
            Fa(this, "legacyNative"),
            Fa(this, "locale"),
            Fa(this, "nativeBridge"),
            Fa(this, "osType"),
            Fa(this, "paymentsAvailable"),
            Fa(this, "socialFriends", []),
            Fa(this, "tos"),
            Fa(this, "platformLocale"),
            Fa(this, "playerID"),
            Fa(this, "playerName"),
            Fa(this, "playerEmail"),
            Fa(this, "playerPhoto"),
            Fa(this, "playerPhotoLarge"),
            Fa(this, "playerPhotoSmall"),
            Fa(this, "players"),
            Fa(this, "playerSignature"),
            Fa(this, "regionCode"),
            Fa(this, "storage"),
            Fa(this, "stsid"),
            Fa(this, "supportedAPIs"),
            Fa(this, "beforeContextSwitchCallback"),
            Fa(this, "afterContextSwitchCallback"),
            Fa(this, "beforeEntryFinalCallback"),
            Fa(this, "beforeStartGameAsyncCallback"),
            Fa(this, "didCallStartGameAsync", !1),
            Fa(this, "didCallSendEntryFinalAnalytics", !1),
            Fa(this, "didTrackFirstButtonTap", !1),
            Fa(this, "countryName"),
            Fa(this, "eCPM"),
            Fa(this, "externalFriendsPromise"),
            Fa(this, "friendAgeGroupDistribution"),
            Fa(this, "lastReceivedChatbotMessagePayload"),
            Fa(
              this,
              "externalABTests",
              new Ii({
                getInternalABTag: () => {
                  var e;
                  return (null == (e = this.abTests) ? void 0 : e.config)
                    ? this.abTests.getAbTag()
                    : "";
                },
                getInternalABTestIDs: () => {
                  var e, t;
                  return (null == (e = this.abTests) ? void 0 : e.config)
                    ? Object.keys(
                        null == (t = this.abTests) ? void 0 : t.config
                      )
                    : [];
                },
              })
            ),
            Fa(this, "fallbackPayloadGetter"),
            Fa(this, "pinch"),
            Fa(this, "entryPromise"),
            Fa(this, "onGameStartRetries", []),
            Fa(
              this,
              "friendsAvailablePromise",
              (function () {
                let e, t;
                const n = new Promise((n, r) => {
                  (e = n), (t = r);
                });
                return { reject: t, resolve: e, promise: n };
              })()
            ),
            Fa(
              this,
              "resolveFriendsAvailable",
              this.friendsAvailablePromise.resolve
            ),
            Fa(
              this,
              "rejectFriendsAvailable",
              this.friendsAvailablePromise.reject
            ),
            Fa(this, "timeTo", {}),
            Fa(this, "wasEntryDataReadyEarly", !1),
            Fa(this, "tournamentPayloadMode"),
            Fa(this, "entryTimestampsGetter"),
            Fa(this, "previousEntryTimestamp", null),
            Fa(this, "_entryAnalyticsPromise"),
            Fa(this, "_resolveEntryAnalytics"),
            Fa(this, "_entryDataPromise"),
            Fa(this, "_gameConfig"),
            Fa(this, "_gameStarted"),
            Fa(this, "_initialization"),
            Fa(this, "_initialized"),
            Fa(this, "_instance"),
            Fa(this, "_isPaymentsReady"),
            Fa(this, "_loadStoragePromise"),
            Fa(this, "_matchingEnabled"),
            Fa(this, "_onPause"),
            Fa(this, "_onPaymentsReady"),
            Fa(this, "_onProvisionProductAsync"),
            Fa(this, "_resolveEntryData"),
            Fa(this, "_sessionStartTime"),
            Fa(this, "_supportedAPIs"),
            Fa(this, "dataCodec", {
              encode: (e) => e,
              decode: (e) => Promise.resolve(e),
            }),
            Fa(this, "convertCurrency", () => {}),
            (this.platformID = e),
            (this.playerID = ""),
            (this.playerName = ""),
            (this.playerPhoto = ""),
            (this.playerSignature = ""),
            (this.friends = []),
            (this.friendsMap = {}),
            (this.players = []),
            (this.catalog = []),
            (this.contextID = null),
            (this.contextType = "SOLO"),
            (this.platformLocale = "en"),
            (this.locale = "en"),
            (this.regionCode = null),
            (this.isMobile = !1),
            (this.paymentsAvailable = !1),
            (this.insideNativeIOS = !1),
            (this.canSubscribeToBot = !1),
            (this._initialization = null),
            (this._initialized = !1),
            (this._gameStarted = !1),
            (this._onPause = null),
            (this._onPaymentsReady = null),
            (this._isPaymentsReady = !1),
            (this._onProvisionProductAsync = null),
            (this._matchingEnabled = !1),
            (this._supportedAPIs = []),
            (this._sessionStartTime = Date.now()),
            (this.canChangeContext = !1),
            (this.canCreateShortcut = !1),
            (this.canPlayerMatch = !1),
            (this.supportedAPIs = {}),
            (this._gameConfig = null),
            this._resolveEntryData,
            (this._entryDataPromise = new Promise((e, t) => {
              this._resolveEntryData = { resolve: e, reject: t };
            })),
            (this.storage = new Mi(this)),
            (this.pinch = new Oi(this.storage)),
            (this.tos = new Oa(this)),
            (this.stsid = Date.now()),
            (this._entryAnalyticsPromise = new Promise((e, t) => {
              this._resolveEntryAnalytics = { resolve: e, reject: t };
            }));
        }
        get canShowInterstitialAds() {
          return this.throwIfNotInitialized(), this._canShowInterstitialAds;
        }
        get canShowRewardedInterstitialAds() {
          return (
            this.throwIfNotInitialized(), this._canShowRewardedInterstitialAds
          );
        }
        get canShowRewardedVideoAds() {
          return this.throwIfNotInitialized(), this._canShowRewardedVideoAds;
        }
        get canRegisterForPushNotifications() {
          return (
            this.throwIfNotInitialized(), this._canRegisterForPushNotifications
          );
        }
        waitForEarlyEntryData() {
          var e;
          return (
            this.throwIfNotInitialized(),
            null !== (e = this.entryPromise) && void 0 !== e
              ? e
              : Promise.resolve()
          );
        }
        waitForFriends() {
          return this._gameConfig.disablePlatformFriends &&
            !this.externalFriendsPromise
            ? Promise.resolve()
            : this.friendsAvailablePromise.promise;
        }
        getDemographics() {
          this.throwIfStorageIsNotLoaded();
          const e = JSON.parse(JSON.stringify(this.storage.demographics));
          return e.ageRange && (e.isAdult = yi(e.ageRange)), e;
        }
        readConfiguration(e) {
          var t, n, r, s;
          e.appID && "string" === typeof e.appID && (this.appID = e.appID),
            (this._gameConfig = { ...Ja, ...e });
          try {
            if (
              (({
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.APP_ID ||
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.FB_APP_ID) &&
                (this.appID =
                  {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.APP_ID ||
                  {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.FB_APP_ID),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.AMPLITUDE &&
                (this._gameConfig.amplitudeKey = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.AMPLITUDE),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.AMPLITUDE_AD_SERVER &&
                (this._gameConfig.amplitudeAdServerKey = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.AMPLITUDE_AD_SERVER),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.AMPLITUDE_TIME_ZONE &&
                (this._gameConfig.amplitudeTimeZone = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.AMPLITUDE_TIME_ZONE),
              ("true" ===
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.DISABLE_AUTOMATIC_TOS_POPUP ||
                ("boolean" ===
                  typeof {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.DISABLE_AUTOMATIC_TOS_POPUP &&
                  !0 ===
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.DISABLE_AUTOMATIC_TOS_POPUP)) &&
                (this._gameConfig.disableAutomaticTosPopup = !0),
              ("true" ===
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.DISABLE_PLATFORM_FRIENDS ||
                ("boolean" ===
                  typeof {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.DISABLE_PLATFORM_FRIENDS &&
                  !0 ===
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.DISABLE_PLATFORM_FRIENDS)) &&
                (this._gameConfig.disablePlatformFriends = !0),
              ("true" ===
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.DISABLE_WEB_PUSH ||
                ("boolean" ===
                  typeof {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.DISABLE_WEB_PUSH &&
                  !0 ===
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.DISABLE_WEB_PUSH)) &&
                (this._gameConfig.disableWebPush = !0),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.FB_PIXEL_ID &&
                (this._gameConfig.fbPixelId = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.FB_PIXEL_ID),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.FB_INSTANT_MOCK_SIGNATURE &&
                (this._gameConfig.mockSignature = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.FB_INSTANT_MOCK_SIGNATURE),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.GOOGLE_TAG_MANAGER_ID &&
                (this._gameConfig.googleTagManagerId = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.GOOGLE_TAG_MANAGER_ID),
              ("true" ===
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.IS_DEVELOPMENT ||
                ("boolean" ===
                  typeof {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.IS_DEVELOPMENT &&
                  !0 ===
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.IS_DEVELOPMENT)) &&
                (this._gameConfig.isDevelopment = !0),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LINE_PHASE &&
                ((this._gameConfig.linePhase = {
                  sandbox: "sandbox",
                  staging: "staging",
                  release: "release",
                }[
                  {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.LINE_PHASE.toLowerCase()
                ]),
                !this._gameConfig.linePhase))
            )
              throw new Error(
                "Unexpected value for LINE_PHASE: " +
                  JSON.stringify(
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.LINE_PHASE
                  )
              );
            var i, o, a, c;
            if (
              ({
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LINE_CORS_PROXY_URL &&
                (this._gameConfig.lineCORSProxyURL = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.LINE_CORS_PROXY_URL),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LINE_LIFF_ID &&
                (this._gameConfig.lineLiffID = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.LINE_LIFF_ID),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LINE_PURCHASE_API_ENDPOINT &&
                (this._gameConfig.linePurchaseAPIEndpoint = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.LINE_PURCHASE_API_ENDPOINT),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LINE_OA_ID &&
                (this._gameConfig.lineOfficialAccountID = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.LINE_OA_ID),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LINE_TAG_ID ||
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.LINE_TAG_ACCESS_TOKEN ||
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.LINE_CHANNEL_ID ||
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.LINE_CONVERSION_API_ENDPOINT)
            )
              this._gameConfig.lineConversionAPIConfig = {
                channelID:
                  null !==
                    (i = {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.LINE_CHANNEL_ID) && void 0 !== i
                    ? i
                    : null == (t = this._gameConfig.lineConversionAPIConfig)
                    ? void 0
                    : t.channelID,
                conversionAPIEndpoint:
                  null !==
                    (o = {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.LINE_CONVERSION_API_ENDPOINT) && void 0 !== o
                    ? o
                    : null == (n = this._gameConfig.lineConversionAPIConfig)
                    ? void 0
                    : n.conversionAPIEndpoint,
                tagAccessToken:
                  null !==
                    (a = {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.LINE_TAG_ACCESS_TOKEN) && void 0 !== a
                    ? a
                    : null == (r = this._gameConfig.lineConversionAPIConfig)
                    ? void 0
                    : r.tagAccessToken,
                tagID:
                  null !==
                    (c = {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.LINE_TAG_ID) && void 0 !== c
                    ? c
                    : null == (s = this._gameConfig.lineConversionAPIConfig)
                    ? void 0
                    : s.tagID,
              };
            ({
              NODE_ENV: "production",
              PUBLIC_URL: "",
              WDS_SOCKET_HOST: void 0,
              WDS_SOCKET_PATH: void 0,
              WDS_SOCKET_PORT: void 0,
              FAST_REFRESH: !0,
              REACT_APP_STAGE: "prod",
              REACT_APP_ENV: "prod",
              REACT_APP_APP_VERSION: "2.8.0",
            }).OAUTH_AUTHORIZATION_CODE_URL &&
              (this._gameConfig.oauthAuthorizationCodeUrl = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.OAUTH_AUTHORIZATION_CODE_URL),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.POSTBACK_MANAGER_KEY &&
                (this._gameConfig.postbackManagerKey = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.POSTBACK_MANAGER_KEY),
              ("true" ===
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.REDIRECT_TO_ROOT_ON_AUTH_FAILURE ||
                ("boolean" ===
                  typeof {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.REDIRECT_TO_ROOT_ON_AUTH_FAILURE &&
                  !0 ===
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.REDIRECT_TO_ROOT_ON_AUTH_FAILURE)) &&
                (this._gameConfig.redirectToRootOnAuthFailure = !0),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.REVENUE_CURRENCY &&
                (this._gameConfig.revenueCurrency = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.REVENUE_CURRENCY),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.STRIPE_PUBLISHABLE_KEY &&
                (this._gameConfig.stripePublishableKey = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.STRIPE_PUBLISHABLE_KEY),
              ("true" ===
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.USE_LEGACY_TOS_LINKS ||
                ("boolean" ===
                  typeof {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.USE_LEGACY_TOS_LINKS &&
                  !0 ===
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.USE_LEGACY_TOS_LINKS)) &&
                (this._gameConfig.useLegacyToSLinks = !0),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.WEB_PUSH_PUBLIC_KEY &&
                (this._gameConfig.webPushPublicKey = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.WEB_PUSH_PUBLIC_KEY),
              ("true" ===
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.WEB_SKIP_LINE_PROFILE_FETCH ||
                ("boolean" ===
                  typeof {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.WEB_SKIP_LINE_PROFILE_FETCH &&
                  !0 ===
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.WEB_SKIP_LINE_PROFILE_FETCH)) &&
                (this._gameConfig.webSkipLineUserInfoFetch = !0),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.ZOOM_API_ENDPOINT &&
                (this._gameConfig.zoomAPIEndpoint = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.ZOOM_API_ENDPOINT),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.ZOOM_SDK_CAPABILITIES &&
                (this._gameConfig.zoomSDKConfig ||
                  (this._gameConfig.zoomSDKConfig = { capabilities: [] }),
                (this._gameConfig.zoomSDKConfig.capabilities = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.ZOOM_SDK_CAPABILITIES.split(","))),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.ZOOM_MEETING_CLIENT_USER_PROPS &&
                (this._gameConfig.zoomMeetingClientUserProperties = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.ZOOM_MEETING_CLIENT_USER_PROPS.split(",")),
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.ZOOM_MAIN_CLIENT_USER_PROPS &&
                (this._gameConfig.zoomMainClientUserProperties = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.ZOOM_MAIN_CLIENT_USER_PROPS.split(","));
          } catch {}
          if (!this.appID) throw Error("appID is not defined");
          if (
            this._gameConfig.amplitudeKey &&
            !this._gameConfig.amplitudeTimeZone
          )
            throw Sr(
              "INVALID_PARAM",
              "amplitudeTimeZone is undefined: define the value either in the initializeAsync call or with the AMPLITUDE_TIME_ZONE environment variable"
            );
          if (!this._gameConfig.revenueCurrency)
            throw Sr(
              "INVALID_PARAM",
              "revenueCurrency is undefined: define the value either in the initializeAsync call or with the REVENUE_CURRENCY environment variable"
            );
          try {
            new Date().toLocaleString("en-US", {
              timeZone: this._gameConfig.amplitudeTimeZone,
            });
          } catch (l) {
            this._gameConfig.isDevelopment &&
              console.warn(
                "Invalid Amplitude time zone in GCInstant.initializeAsync: ".concat(
                  this._gameConfig.amplitudeTimeZone,
                  ". Defaulting to UTC"
                )
              ),
              (this._gameConfig.amplitudeTimeZone = "UTC");
          }
          this._gameConfig.isDevelopment &&
            console.warn(
              "Running GCInstant in development mode - make sure to disable development mode in production."
            );
        }
        _initialize(e) {
          if (!e) throw new Error("playerID is falsey!");
          if (!this._gameConfig)
            throw Error(
              "Game configuration is not defined: call readConfiguration before initializing"
            );
          return (
            (this.playerID = e),
            (this._initialized = !0),
            this.getEntryPointData(),
            this.setLoadingProgress(0),
            pr.setUserID(e),
            pr.trackSessionStartEvents(),
            fr.pushEvent("PlatformInitSuccess", null, fr.toDefaultAndAdServer),
            this.refreshPlayerSignature().then(() => {
              this.trackTimeTo("getSignedPlayerInfoAsync");
            })
          );
        }
        setDataCodec(e) {
          if (this.didCallStartGameAsync)
            throw new Error(
              "Set an encoder and decoder before calling 'startGameAsync'. Otherwise, some encoded payloads may not be decoded correctly."
            );
          this.dataCodec = e;
        }
        setExternalFriendsGetter(e) {
          if (this._initialization && !this._gameConfig.disablePlatformFriends)
            throw Sr(
              "INVALID_OPERATION",
              "External friends must be set before initializeAsync"
            );
          this.externalFriendsPromise = e()
            .then((e) => {
              this.updateExternalFriends(e),
                (function (e) {
                  fr.pushEvent("GetAllFriendsSuccess", e);
                })({ friendCount: this.socialFriends.length }),
                this.resolveFriendsAvailable();
            })
            .catch((e) => {
              !(function (e, t) {
                fr.pushError("GetAllFriendsFailed", e, t);
              })(e),
                this.rejectFriendsAvailable(e);
            });
        }
        updateExternalFriends(e) {
          const t = e.map((e) => Pr.fromExternalFriend(e));
          (this.friends = t.filter((e) => e.isPlayer)),
            (this.socialFriends = t),
            (this.friendIds = this.friends.map((e) => e.id)),
            (this.friendsMap = this.friends.reduce(
              (e, t) => ((e[t.id] = t), e),
              {}
            ));
        }
        setFallbackPayloadGetter(e) {
          this.fallbackPayloadGetter = async () => {
            try {
              return (await e()) || {};
            } catch {
              return {};
            }
          };
        }
        setFriendAnalytics(e) {
          this.throwIfNotInitialized(),
            (this.friendAgeGroupDistribution = e.ageGroupDistribution);
          const t = e.clusterCounts,
            n = e.activeFriendCounts;
          function r(e, t) {
            const n = e / t;
            return Number.isFinite(n) ? n : void 0;
          }
          pr.setUserProperties({
            lastEntryActiveClusterSize1D: t.clusterSize1D,
            lastEntryActiveClusterSize3D: t.clusterSize3D,
            lastEntryActiveClusterSize7D: t.clusterSize7D,
            lastEntryActiveClusterSize14D: t.clusterSize14D,
            lastEntryActiveClusterSize30D: t.clusterSize30D,
            lastEntryActiveClusterSize90D: t.clusterSize90D,
            lastEntryActiveClusterConnections1D: t.clusterConnections1D,
            lastEntryActiveClusterConnections3D: t.clusterConnections3D,
            lastEntryActiveClusterConnections7D: t.clusterConnections7D,
            lastEntryActiveClusterConnections14D: t.clusterConnections14D,
            lastEntryActiveClusterConnections30D: t.clusterConnections30D,
            lastEntryActiveClusterConnections90D: t.clusterConnections90D,
            lastEntryActiveClusterConnectedness1D: t.clusterConnectedness1D,
            lastEntryActiveClusterConnectedness3D: t.clusterConnectedness3D,
            lastEntryActiveClusterConnectedness7D: t.clusterConnectedness7D,
            lastEntryActiveClusterConnectedness14D: t.clusterConnectedness14D,
            lastEntryActiveClusterConnectedness30D: t.clusterConnectedness30D,
            lastEntryActiveClusterConnectedness90D: t.clusterConnectedness90D,
            lastEntryActiveFriendCount1D: n.activeFriendCount1D,
            lastEntryActiveFriendCount3D: n.activeFriendCount3D,
            lastEntryActiveFriendCount7D: n.activeFriendCount7D,
            lastEntryActiveFriendCount14D: n.activeFriendCount14D,
            lastEntryActiveFriendCount30D: n.activeFriendCount30D,
            lastEntryActiveFriendCount90D: n.activeFriendCount90D,
            "lastEntryActiveFriendRatio1/3": r(
              n.activeFriendCount1D,
              n.activeFriendCount3D
            ),
            "lastEntryActiveFriendRatio1/7": r(
              n.activeFriendCount1D,
              n.activeFriendCount7D
            ),
            "lastEntryActiveFriendRatio3/7": r(
              n.activeFriendCount3D,
              n.activeFriendCount7D
            ),
            "lastEntryActiveFriendRatio7/30": r(
              n.activeFriendCount7D,
              n.activeFriendCount30D
            ),
          });
        }
        setLastReceivedChatbotMessagePayload(e) {
          if (this._gameStarted)
            throw Sr(
              "INVALID_OPERATION",
              "Method must be called before `startGameAsync`"
            );
          this.lastReceivedChatbotMessagePayload = e;
        }
        async showToSPopupToExistingUsers() {
          this.throwIfNotInitialized();
          const e = "2022-12";
          if (await this.tos.hasAcceptedToS(e)) return;
          this.tos.trackPopupOpenEvent(e);
          const t = vr(La.ELEMENT_NAME);
          (t.locale = this.locale),
            (t.useLegacyLinks = !!this._gameConfig.useLegacyToSLinks);
          const { requestMs: n } = await zn(
            () =>
              new Promise((e) => {
                t.onClose(() => e());
              })
          );
          this.tos.acceptToS(e, { requestMs: n });
        }
        async _prepareEntryData() {
          return (async () => {
            this.entryData = this._getEntryPointDataForce() || this.entryData;
            0 === Object.keys(this.entryData || {}).length &&
              this.fallbackPayloadGetter &&
              (this.entryData = await this.fallbackPayloadGetter());
            const e = await this.dataCodec.decode(this.entryData);
            e && (this.entryData = e);
            const t = this.entryData;
            "fb" === this.platformID
              ? ((t.gameID =
                  t.gameID || t.sourceGameID || this._gameConfig.shortName),
                (t.gameVersion =
                  t.gameVersion || t.sourceGameVersion || t.sourceVersion),
                (t.gamePlayerID =
                  t.gamePlayerID || t.sourceGamePlayerID || this.playerID),
                (t.gameFeature =
                  t.gameFeature || t.sourceGameFeature || t.feature),
                (t.gameLevel =
                  t.gameLevel || t.sourceGamePlayerLevel || t.sourceLevel))
              : ((t.gameID = t.gameID || this._gameConfig.shortName),
                (t.gameVersion = t.gameVersion || t.sourceVersion),
                (t.gamePlayerID = t.gamePlayerID || this.playerID),
                (t.gameFeature = t.gameFeature || t.feature),
                (t.gameLevel = t.gameLevel || t.sourceLevel));
          })()
            .then(this._resolveEntryData.resolve)
            .catch((e) => {
              throw (this._resolveEntryData.reject(e), e);
            });
        }
        async startGameAsync() {
          var e;
          this.throwIfNotInitialized(),
            this.throwIfStartGameAsyncIsCalledMultipleTimes(),
            this.throwIfStorageAdapterIsNotConfigured();
          try {
            await (null == (e = this.beforeStartGameAsyncCallback)
              ? void 0
              : e.call(this)),
              await this.startGameAsyncInner(),
              (this._gameStarted = !0),
              wi(),
              this._sendEntryAnalytics(),
              this._gameConfig.disableAutomaticTosPopup ||
                this.showToSPopupToExistingUsers();
          } catch (t) {
            throw (
              ((function (e) {
                fr.pushError("EntryFailed", e);
              })(_r(t)),
              _r(t))
            );
          }
        }
        beforeContextSwitch(e) {
          this.beforeContextSwitchCallback = e;
        }
        afterContextSwitch(e) {
          this.afterContextSwitchCallback = e;
        }
        beforeEntryFinal(e) {
          this.beforeEntryFinalCallback = e;
        }
        beforeStartGameAsync(e) {
          this.beforeStartGameAsyncCallback = e;
        }
        onPause(e) {
          this._onPause = e;
        }
        onPaymentsReady(e) {
          this._isPaymentsReady ? e() : (this._onPaymentsReady = e);
        }
        onProvisionProductAsync(e) {
          this._onProvisionProductAsync = e;
        }
        _getProduct(e) {
          if (0 !== this.catalog.length)
            for (const t of this.catalog) if (t.id === e) return t;
        }
        checkCanPlayerMatchAsync() {
          return Promise.resolve(!1);
        }
        matchPlayerAsync(e, t, n) {
          return Promise.reject(new Error("not implemented"));
        }
        quit() {}
        getSDKVersion() {}
        setLoadingProgress(e, t) {}
        dismissLoadingScreenAsync() {
          return Promise.resolve();
        }
        getCatalogAsync() {
          return Promise.reject(new Error("not implemented"));
        }
        setSessionData(e) {
          throw new Error("not implemented");
        }
        async iapInit(e) {}
        purchaseAsync(e, t) {
          return Promise.reject(new Error("not implemented"));
        }
        getDataAsync(e) {
          const t = {};
          for (const n of e) t[n] = za("".concat(Va, ":").concat(n));
          return Promise.resolve(t);
        }
        setDataAsync(e) {
          return Promise.resolve().then(() => {
            Object.keys(e).forEach((t) => {
              Ka("".concat(Va, ":").concat(t), e[t]);
            });
          });
        }
        getFriendsAsync() {
          return Promise.resolve(this.friends);
        }
        filterFriendsAsync(e) {
          return Promise.resolve(this.friends);
        }
        getPlayersAsync() {
          return Promise.resolve(this.friends);
        }
        getContextPlayersAsync() {
          return Promise.resolve([]);
        }
        flushDataAsync() {
          return Promise.resolve();
        }
        getSignedPlayerInfoAsync(e) {
          return Promise.resolve(new ka());
        }
        async refreshPlayerSignature() {
          return (
            this.throwIfNotInitialized(),
            this.getSignedPlayerInfoAsync("LOGIN_REQUEST").then(
              (e) => (
                (this.playerSignature = e.signature), this.playerSignature
              )
            )
          );
        }
        switchGameAsync(e, t) {
          return Promise.reject(new Error(""));
        }
        async canSwitchNativeGameAsync() {
          return !1;
        }
        async switchNativeGameAsync(e) {
          throw new Error("GCInstant.switchNativeGameAsync: Not implemented");
        }
        canCreateShortcutAsync() {
          return Promise.resolve().then(() => (this.canCreateShortcut = !1));
        }
        createShortcutAsync(e) {
          return Promise.reject(new Error(""));
        }
        canSubscribeBotAsync() {
          return Promise.resolve(this.canSubscribeToBot);
        }
        subscribeBotAsync(e, t) {
          return null !== e && void 0 !== e ? e : Promise.resolve();
        }
        redirectToLineOfficialAccount(e) {
          !(function (e) {
            fr.pushEvent("RedirectToLineOfficialAccount", e);
          })(e);
          const { lineOfficialAccountID: t } = this._gameConfig;
          if (!t) {
            const t = Sr(
              "INVALID_PARAM",
              "LINE Official Account ID is not configured"
            );
            throw (
              ((function (e, t) {
                fr.pushError("RedirectToLineOfficialAccountFailure", e, t);
              })(t, e),
              t)
            );
          }
          window.location.href = "https://line.me/R/ti/p/" + t;
        }
        getInterstitialAdAsync(e) {
          return Promise.resolve(new Wa(e));
        }
        getRewardedInterstitialAdAsync(e) {
          return Promise.reject(
            Sr(
              "INVALID_OPERATION",
              "Operation not supported by the current platform"
            )
          );
        }
        getRewardedVideoAsync(e) {
          return Promise.resolve(new Wa(e));
        }
        chooseContextAsync(e) {
          return Promise.resolve();
        }
        switchContextAsync(e, t) {
          return (this.contextID = e), Promise.resolve();
        }
        createContextAsync(e, t, n) {
          return Promise.resolve();
        }
        isContextPublicAsync(e) {
          return Promise.resolve(!0);
        }
        canUseSquadsAsync() {
          return Promise.reject(new Error("not implemented"));
        }
        createSquadAsync(e) {
          return Promise.reject(new Error("not implemented"));
        }
        getSquadAsync(e) {
          return Promise.reject(new Error("not implemented"));
        }
        getPlayerSquadsAsync() {
          return Promise.reject(new Error("not implemented"));
        }
        async getTournamentAsync() {
          return Promise.reject(new Error("not implemented"));
        }
        createTournamentAsync(e) {
          return Promise.reject(
            "GCInstant.createTournamentAsync: Not implemented"
          );
        }
        shareTournamentAsync(e) {
          return Promise.reject(
            "GCInstant.shareTournamentAsync: Not implemented"
          );
        }
        postTournamentScoreAsync(e, t) {
          return Promise.reject(
            "GCInstant.postTournamentScoreAsync: Not implemented"
          );
        }
        setEntryTimestampsGetter(e) {
          this.entryTimestampsGetter = e;
        }
        async getTemporalUserProperties(e) {
          var t;
          if (!e.length) return {};
          if (!this.entryTimestampsGetter) return {};
          try {
            const n = await this.entryTimestampsGetter(e),
              r = Nn.getNow(),
              s = {};
            for (const i of e) {
              if (!n[i] || 0 === Object.keys(n[i]).length) continue;
              const e = Pa(
                n[i],
                r,
                null == (t = this._gameConfig) ? void 0 : t.amplitudeTimeZone
              );
              e
                ? (s[i] = e)
                : oi(Error("Invalid entry timestamps"), {
                    entryTimestamps: n[i],
                    receiverID: i,
                  });
            }
            return s;
          } catch (n) {
            return oi(n), {};
          }
        }
        updateAsync(e) {
          console.log("FBInstant.updateAsync", e);
          const t = this._populateNotificationPayload(e.data, "UPDATE");
          return Promise.resolve({ payloadData: t, returnValue: void 0 });
        }
        isContextSizeBetween(e, t) {
          return null;
        }
        shareAsync(e) {
          return console.log("FBInstant.shareAsync", e), Promise.resolve();
        }
        shareLinkAsync(e) {
          return console.log("FBInstant.shareLinkAsync", e), Promise.resolve();
        }
        inviteAsync(e) {
          return console.log("FBInstant.inviteAsync", e), Promise.resolve();
        }
        getEntryPointData() {
          var e;
          return (
            null !== this.entryData ||
              (this.entryData =
                null !== (e = this._getEntryPointDataForce()) && void 0 !== e
                  ? e
                  : {}),
            this.entryData
          );
        }
        _getEntryPointDataForce() {}
        _getQueryEntryData() {
          const e = decodeURIComponent(
              decodeURIComponent(window.location.search.slice(1))
            ).split("&"),
            t = {};
          for (let r = 0; r < e.length; r++) {
            const n = e[r].split("="),
              s = n[0],
              i = n[1];
            (t[s] = i), ("null" !== i && void 0 !== i) || (t.tID = s);
          }
          for (const r in t) {
            const e = t[r];
            (null == e ? void 0 : e.endsWith("=")) &&
              (t[r] = e.slice(0, e.length - 1));
          }
          const n = t.payload;
          return n ? JSON.parse(n) : {};
        }
        async getEntryPointAsync() {
          return (this.entryPointName = "MOCK"), this.entryPointName;
        }
        getEntryDataAsync() {
          return this._entryDataPromise.then(() => this.entryData);
        }
        getPreviousEntryTimestamp() {
          return this.throwIfStorageIsNotLoaded(), this.previousEntryTimestamp;
        }
        getLeaderboardAsync(e) {
          return Promise.resolve({});
        }
        postSessionScoreAsync(e, t) {
          return Promise.reject(
            Error("GCInstant.postSessionScoreAsync: Not implemented")
          );
        }
        getPlatformPayloadData() {
          var e;
          const t = this.storage.analytics,
            n = pr.getUserProperties(),
            r = { ...this.externalABTests.getPayloadProperties() };
          (null == (e = this.abTests) ? void 0 : e.config) &&
            this.abTests.applyPayloadProperties(r);
          const s = Nn.getNow(),
            i = Ln({ days: 1 }),
            o = (this.entryData.sourceChainTimestamps || [])
              .filter((e) => s - e <= i)
              .concat(s),
            a = new Date(s).toISOString().slice(0, 10).replace(/-/g, ""),
            {
              date: c,
              dateHour: u,
              dateMonth: d,
              dateTime: h,
              dateWeek: p,
              dayOfWeek: f,
              hour: m,
            } = qn(s, this._gameConfig.amplitudeTimeZone);
          return {
            ...r,
            ABTag: n.ABtag,
            country: this.countryName,
            date: a,
            dateHour: u,
            dateMonth: d,
            dateTime: h,
            dateWeek: p,
            dayOfWeek: f,
            daysSinceInstall: n.daysSinceInstall,
            firstEntryABTests: t.firstEntryABTests,
            hour: m,
            playerID: this.playerID,
            projectDate: c,
            sourceChainTimestamps: o,
            sourceVersion: this._gameConfig.version,
            sourceOS: l.os.name,
            timestamp: s,
            $firstConnectedPlayerCount: t.firstEntryConnectedPlayerCount,
            $firstEntryChannel: t.$firstEntryChannel,
            $firstEntryDate: t.firstEntryDate,
            $firstEntryPointName: t.firstEntryPointName,
            $firstEntryVersion: t.firstEntryVersion,
            $lastConnectedPlayerCount: n.lastConnectedPlayerCount,
            $lastEntrySessionMaturityRange: n.$lastEntrySessionMaturityRange,
            $lastEntryChannel: n.$lastEntryChannel,
            $lastEntryPlatform: n.$lastEntryPlatform,
            $lastEntryPointName: n.lastEntryPointName,
            $lastEntryVersion: n.lastEntryVersion,
            lastEntryBrowser: n.lastEntryBrowser,
            $firstEntryGeneration: t.$firstEntryGeneration,
            $zeroEntryChannel: t.$zeroEntryChannel,
            $zeroEntryDatetime: t.$zeroEntryDatetime,
            $zeroEntryDate: t.$zeroEntryDate,
            $zeroEntryAdCampaignName: t.$zeroEntryAdCampaignName,
            $zeroEntryAdSetName: t.$zeroEntryAdSetName,
            $zeroEntryAdCreativeName: t.$zeroEntryAdCreativeName,
            $zeroEntryAdNetworkName: t.$zeroEntryAdNetworkName,
            zeroEntrySourcePlayerID: t.zeroEntrySourcePlayerID,
            $entryCount: n.entryCount,
            lastEntryActiveClusterSize1D: n.lastEntryActiveClusterSize1D,
            lastEntryActiveClusterSize3D: n.lastEntryActiveClusterSize3D,
            lastEntryActiveClusterSize7D: n.lastEntryActiveClusterSize7D,
            lastEntryActiveClusterSize14D: n.lastEntryActiveClusterSize14D,
            lastEntryActiveClusterSize30D: n.lastEntryActiveClusterSize30D,
            lastEntryActiveClusterSize90D: n.lastEntryActiveClusterSize90D,
            lastEntryActiveClusterConnections1D:
              n.lastEntryActiveClusterConnections1D,
            lastEntryActiveClusterConnections3D:
              n.lastEntryActiveClusterConnections3D,
            lastEntryActiveClusterConnections7D:
              n.lastEntryActiveClusterConnections7D,
            lastEntryActiveClusterConnections14D:
              n.lastEntryActiveClusterConnections14D,
            lastEntryActiveClusterConnections30D:
              n.lastEntryActiveClusterConnections30D,
            lastEntryActiveClusterConnections90D:
              n.lastEntryActiveClusterConnections90D,
            lastEntryActiveClusterConnectedness1D:
              n.lastEntryActiveClusterConnectedness1D,
            lastEntryActiveClusterConnectedness3D:
              n.lastEntryActiveClusterConnectedness3D,
            lastEntryActiveClusterConnectedness7D:
              n.lastEntryActiveClusterConnectedness7D,
            lastEntryActiveClusterConnectedness14D:
              n.lastEntryActiveClusterConnectedness14D,
            lastEntryActiveClusterConnectedness30D:
              n.lastEntryActiveClusterConnectedness30D,
            lastEntryActiveClusterConnectedness90D:
              n.lastEntryActiveClusterConnectedness90D,
            lastEntryAgeConfidence: this.storage.demographics.ageConfidence,
            lastEntryAgeRange: this.storage.demographics.ageRange
              ? mi(this.storage.demographics.ageRange)
              : void 0,
            lastEntryGender: this.storage.demographics.gender,
            lastEntryAgeIsAdult: this.storage.demographics.ageRange
              ? yi(this.storage.demographics.ageRange)
              : void 0,
            realtimeActiveFriendCount1D: n.lastEntryActiveFriendCount1D,
            realtimeActiveFriendCount3D: n.lastEntryActiveFriendCount3D,
            realtimeActiveFriendCount7D: n.lastEntryActiveFriendCount7D,
            realtimeActiveFriendCount14D: n.lastEntryActiveFriendCount14D,
            realtimeActiveFriendCount30D: n.lastEntryActiveFriendCount30D,
            realtimeActiveFriendCount90D: n.lastEntryActiveFriendCount90D,
          };
        }
        _populateNotificationPayload(e, t) {
          qa += 1;
          const n = this.storage.absoluteSequence + 1;
          this.storage.assign((e) => (e.absoluteSequence = n));
          const r = e.feature,
            s = (Ha[r] || 0) + 1;
          Ha[r] = s;
          const i = (this.storage.featureAbsoluteSequences[r] || 0) + 1;
          this.storage.assign((e) => (e.featureAbsoluteSequences[r] = i));
          const o = [
            this.playerID,
            Nn.getNow(),
            Math.random().toString(36).substr(2, 5),
          ].join("-");
          return {
            ...e,
            ...this.getPlatformPayloadData(),
            UID: e.asset + "/" + e.text + "/" + e.button,
            sessionSequence: qa,
            absoluteSequence: n,
            featureSessionSequence: s,
            featureAbsoluteSequence: i,
            tracerKey: o,
            $channel: t,
          };
        }
        async loadStorage() {
          return (
            this.throwIfNotInitialized(),
            this.throwIfStorageAdapterIsNotConfigured(),
            this._loadStoragePromise ||
              (this._loadStoragePromise = this.storage.load().then(() => {
                this.shouldIncreaseEntryCount() &&
                  this.storage.assign((e) => (e.entry.count += 1));
                1 === this.storage.entry.count &&
                  this.storage.assign(
                    (e) => (e.tos["2022-12"] = { acceptedAt: Nn.getNow() })
                  ),
                  this.storage.entry.last &&
                    (this.previousEntryTimestamp = this.storage.entry.last);
                const e = this._gameConfig.shortName;
                this.abTests = new hi(this.playerID, e, this.storage, () =>
                  this.externalABTests.getABTag()
                );
              })),
            this._loadStoragePromise
          );
        }
        _createEntryPromise() {
          return Promise.resolve();
        }
        _setEntryDataUserProperties(e) {
          const t = { ...e },
            n = this.entryData;
          (t.lastEntryAsset = n.asset),
            (t.lastEntryText = n.text),
            (t.lastEntryButton = n.button),
            (t.lastEntryUID = n.UID),
            (t.lastEntrySourceFeature = n.feature),
            (t.lastEntrySubFeature = n.$subFeature),
            (t.lastEntrySourceVersion = n.sourceVersion),
            (t.lastEntrySourceGameFeature = n.gameFeature),
            (t.lastEntrySourceGameID = n.gameID),
            (t.lastEntrySourceGamePlayerID = n.gamePlayerID),
            (t.lastEntrySourcePlayerID = n.playerID),
            (t.lastEntryAdNetwork = n.adNetwork),
            (t.lastEntryAdType = n.adType),
            (t.lastEntryAdIncentive = n.adIncentive),
            (t.lastEntryAdMedia = n.adMedia),
            (t.lastEntryAdDuration = n.adDuration),
            (t.lastEntryAdUnit = n.adUnit),
            (t.lastEntryAdLanguage = n.adLanguage),
            (t.lastEntryAdCountry = n.adCountry),
            (t.lastEntryAdCampaign = n.adCampaign),
            (t.lastEntryAdSet = n.adSet),
            (t.lastEntryAbTest = n.abTest),
            (t.lastEntryAbTestBucket = n.abTestBucket),
            (t.lastEntryChannelIsInferred = !this.entryData.$channel),
            (t.lastEntryChannelIsSocial = Si(this.getChannel())),
            pr.setUserProperties(t, pr.toDefaultAndAdServer);
        }
        _setCanSubscribeToBot(e) {
          pr.setUserProperties({ canSubscribeBot: e }),
            (this.canSubscribeToBot = e);
        }
        _setContextSquad(e) {
          pr.setUserProperties({ contextIsSquad: !!e }),
            (this.contextSquad = e);
        }
        _setContextTournament(e) {
          pr.setUserProperties({ contextIsTournament: !!e }),
            (this.contextTournament = e);
        }
        _setIsSubscribedToBot(e) {
          pr.setUserProperties({ isSubscribed: e }),
            (this.isSubscribedToBot = e);
        }
        _updateContext(e, t) {
          var n;
          this._setContextTournament(null),
            this._setContextSquad(null),
            (this.contextID = t.getID()),
            (this.contextType = t.getType());
          const r = "Launch" !== e || this.contextID;
          pr.setUserProperties(
            {
              contextID: this.contextID,
              contextType: this.contextType,
              ...(r ? { contextAPI: e } : {}),
            },
            pr.toDefaultAndAdServer
          ),
            "Launch" !== e &&
              "GetTournamentAsync" !== e &&
              (null == (n = this.afterContextSwitchCallback) || n.call(this));
        }
        _populateEntryDataEventProperties(e) {
          var t, n, r;
          const s = this.entryData;
          for (const o in s) o.startsWith("sourceAB_") && (e[o] = s[o]);
          (e.$sourceFirstEntryVersion = s.$firstEntryVersion),
            (e.$wasEntryDataReadyEarly = this.wasEntryDataReadyEarly),
            (e.adSetAdName =
              s.$adSetName && s.$adCreativeName
                ? "".concat(s.$adSetName, ";").concat(s.$adCreativeName)
                : void 0),
            (e.absoluteSequence = s.absoluteSequence),
            (e.isAppSwitch = s.isAppSwitch),
            (e.sessionSequence = s.sessionSequence),
            (e.featureSessionSequence = s.featureSessionSequence),
            (e.featureAbsoluteSequence = s.featureAbsoluteSequence),
            (e.sourceABTag = s.ABTag),
            (e.sourceDate = s.date),
            (e.sourceDateHour = s.dateHour),
            (e.sourceDateMonth = s.dateMonth),
            (e.sourceDateTime = s.dateTime),
            (e.sourceDateWeek = s.dateWeek),
            (e.sourceDayOfWeek = s.dayOfWeek),
            (e.sourceCountry = s.country),
            (e.sourceFirstEntryABTests = s.firstEntryABTests),
            (e.sourceHour = s.hour),
            (e.sourceLastEntryBrowser = s.lastEntryBrowser),
            (e.sourceProjectDate = s.projectDate),
            (e.sourceSelectionUI = s.selectionUI),
            (e.sourceShareDestination = s.destination),
            (e.sourceTournamentAPI = s.tournamentAPI),
            (e.sourceTracerKey = s.tracerKey),
            (e.sourceUpdatePushRequested = s.pushRequested),
            (e.sourceUpdateStrategy = s.strategy),
            (e.sourceUpdateTemplateID = s.templateID),
            (e.tournamentPayloadMode = this.tournamentPayloadMode),
            "line-guest" === this.platformID && (e.isGuest = !0),
            (e.adNetwork = s.adNetwork),
            (e.adCampaign = s.adCampaign),
            (e.adSet = s.adSet),
            (e.abTest = s.abTest),
            (e.abTestBucket = s.abTestBucket),
            (e.adType = s.adType),
            (e.adID = s.adID),
            (e.adIncentive = s.adIncentive),
            (e.adMedia = s.adMedia),
            (e.adDuration = s.adDuration),
            (e.adUnit = s.adUnit),
            (e.adLanguage = s.adLanguage),
            (e.adCountry = s.adCountry),
            (e.channelIsSocial = Si(this.getChannel())),
            (e.sourceDaysSinceInstall = s.daysSinceInstall),
            (e.sourceGameFeature = s.gameFeature),
            (e.sourceGameID = s.gameID),
            (e.sourceGamePlayerID = s.gamePlayerID),
            (e.sourceGameVersion = s.gameVersion),
            (e.sourcePlayerID = s.playerID),
            (e.sourceVersion = s.sourceVersion),
            (e.sourceLevel = s.sourceLevel),
            (e.sourceLevelRange = s.sourceLevelRange),
            (e.sourceFeature = s.feature),
            (e.sourceSubFeature = s.$subFeature),
            (e.sourceSelectionCount = s.selectionCount),
            (e.$subFeature = s.$subFeature),
            (e.UID = s.UID),
            (e.asset = s.asset),
            (e.text = s.text),
            (e.button = s.button),
            (e.webShareLinkId = s.webShareLinkId),
            (e.webShareOrigin = s.webShareOrigin),
            (e.webReferrer =
              null !== (t = s.webReferrer) && void 0 !== t
                ? t
                : document.referrer),
            s.receivers &&
              (e.sourceUpdateIsToPlayer =
                null == (n = s.receivers.find((e) => e.id === this.playerID))
                  ? void 0
                  : n.isPlayer);
          const i =
            (null == (r = this.lastReceivedChatbotMessagePayload)
              ? void 0
              : r.timestamp) >
            Nn.getNow() - Ln({ hours: 2 })
              ? this.lastReceivedChatbotMessagePayload
              : void 0;
          if (i) {
            const { feature: t, $subFeature: n, $creativeAssetID: r } = i;
            (e.latestChatbotSourceFeature = t),
              (e.latestChatbotSourceSubFeature = n),
              (e.latestChatbotCreativeAssetID = r);
          }
        }
        waitForEntryAnalytics() {
          return this._entryAnalyticsPromise;
        }
        _sendEntryAnalytics() {
          const e = this._resolveEntryAnalytics;
          if (!e) throw Error("Entry analytics have already been sent");
          return (
            (this._resolveEntryAnalytics = null),
            Promise.all([
              this._createEntryPromise(),
              this.loadStorage().then(() => {
                this.trackTimeTo("loadStorage");
              }),
            ])
              .catch((e) => (pr.pushError("EntryError", e), Promise.resolve()))
              .then(() => {
                const e = this.storage.entry.count,
                  t = Nn.getNow(),
                  n = new Date(t).toISOString().slice(0, 10).replace(/-/g, ""),
                  r = this.storage.entry.last,
                  s = new Date(r),
                  i = new Date(t),
                  o =
                    i.getDate() !== s.getDate() ||
                    i.getMonth() !== s.getMonth() ||
                    i.getFullYear() !== s.getFullYear(),
                  {
                    date: a,
                    dateHour: c,
                    dateMonth: l,
                    dateTime: u,
                    dateWeek: d,
                    dayOfWeek: h,
                    hour: p,
                  } = qn(t, this._gameConfig.amplitudeTimeZone),
                  f = {
                    contextID: this.contextID,
                    contextType: this.contextType,
                    contextIsSquad: !!this.contextSquad,
                    contextIsTournament: !!this.contextTournament,
                    entryCount: e,
                    adFeatureAvailable:
                      this.canShowInterstitialAds ||
                      this.canShowRewardedVideoAds,
                    lastEntryIsFirstOfDay: o,
                    lastEntryPaymentsEnabled: this.paymentsAvailable,
                    lastEntryVersion: this._gameConfig.version,
                    lastEntryDate: n,
                    lastEntryDateHour: c,
                    lastEntryDateMonth: l,
                    lastEntryDateTime: u,
                    lastEntryDateWeek: d,
                    lastEntryDayOfWeek: h,
                    lastEntryHour: p,
                    lastEntryProjectDate: a,
                  };
                this._setEntryDataUserProperties(f);
                const m = {
                  first: 1 === e,
                  date: n,
                  dateHour: c,
                  dateMonth: l,
                  dateTime: u,
                  dateWeek: d,
                  dayOfWeek: h,
                  connectedPlayerCount: this.friends.length,
                  hour: p,
                  entryPointName: this.entryPointName,
                  isFirstEntryOfDay: o,
                  adFeatureAvailable:
                    this.canShowInterstitialAds || this.canShowRewardedVideoAds,
                };
                this._populateEntryDataEventProperties(m),
                  pr.pushEvent("Entry", m, pr.toDefaultAndAdServer),
                  (this.entryAnalyticsBundle = m);
              })
              .then(e.resolve)
              .catch((t) => {
                throw (e.reject(t), t);
              }),
            this._entryAnalyticsPromise
          );
        }
        trackFirstButtonTap(e) {
          this.didTrackFirstButtonTap ||
            ((this.didTrackFirstButtonTap = !0),
            (function (e) {
              fr.pushEvent("FirstButtonTap", e);
            })({ occasion: "sessionStart", ...e }));
        }
        trackPinch(e) {
          this.pinch.trackPinch(e);
        }
        trackPinchConversion(e) {
          this.throwIfStorageIsNotLoaded(), this.pinch.trackPinchConversion(e);
        }
        sendEntryFinalAnalytics(e, t, n) {
          return (
            this.throwIfSendEntryFinalAnalyticsIsCalledMultipleTimes(),
            this.waitForEntryAnalytics().then(async () => {
              var r, s, i, o, a, c, u;
              const d = this.entryData,
                h = this.entryAnalyticsBundle;
              if (!h) throw Error("Base Entry event properties are not set");
              this._setEntryDataUserProperties(),
                this._populateEntryDataEventProperties(h);
              const p = this.getChannel(),
                f = !this.entryData.$channel,
                m = this.osType;
              let g = d.$adNetworkName;
              d.$adNetworkName ||
                ((
                  null == (r = d.$adCampaignName) ? void 0 : r.startsWith("FB ")
                )
                  ? (g = "Facebook")
                  : (null == (s = d.$adCampaignName)
                      ? void 0
                      : s.startsWith("IG ")) && (g = "Instagram"));
              const v = Nn.getNow(),
                y = this.storage.entry,
                b = y.last;
              let w = y.lastNativeEntry;
              this.storage.assign((e) => (e.entry.last = v)),
                1 === y.count &&
                  this.storage.assign((e) => (e.entry.first = v)),
                "AD" === p &&
                  this.storage.assign((e) => (e.entry.lastAdEntry = v)),
                void 0 !== d.applePushEnabled &&
                  (this.storage.assign((e) => (e.entry.lastNativeEntry = v)),
                  (w = w || v));
              const S =
                  "IOS_APP" === this.osType || "ANDROID_APP" === this.osType,
                _ =
                  S &&
                  0 === this.storage.entry.lastNativeAndroidEntry &&
                  0 === this.storage.entry.lastNativeIOSEntry;
              "ANDROID_APP" === this.osType
                ? this.storage.assign(
                    (e) => (e.entry.lastNativeAndroidEntry = v)
                  )
                : "IOS_APP" === this.osType &&
                  this.storage.assign((e) => (e.entry.lastNativeIOSEntry = v));
              const E = (v - y.first) / Ga,
                A = 0 === b ? 0 : (v - b) / 1e3 / 60 / 60,
                T = A / 24,
                P = T >= 90,
                I = y.lastResurrected
                  ? Math.floor((v - y.lastResurrected) / Ga)
                  : void 0;
              P && this.storage.assign((e) => (e.entry.lastResurrected = v));
              const { currentPayloadIdentifier: C, lastEntryIsRepeat: k } =
                (function (e) {
                  const {
                      entryData: t,
                      entryPointName: n,
                      hoursInactive: r,
                      previousPayloadIdentifier: s,
                    } = e,
                    i = (function (e, t) {
                      const n = [
                          "$adCampaignName",
                          "$adCreativeName",
                          "$adSetName",
                          "$channel",
                          "$creativeAssetID",
                          "$pageLinkId",
                          "$subFeature",
                          "creativeAssetID",
                          "feature",
                          "playerID",
                          "subFeature",
                          "tracerKey",
                        ],
                        r = {};
                      for (const s of n) {
                        const t = e[s];
                        void 0 !== t && null !== t && "" !== t && (r[s] = t);
                      }
                      return t && (r.entryPointName = t), r;
                    })(t, n);
                  return {
                    currentPayloadIdentifier: i,
                    lastEntryIsRepeat:
                      r <= 0.5 &&
                      !!s &&
                      JSON.stringify(i, Object.keys(i).sort()) ===
                        JSON.stringify(s, Object.keys(s).sort()),
                  };
                })({
                  entryData: this.entryData,
                  entryPointName: this.entryPointName,
                  hoursInactive: A,
                  previousPayloadIdentifier: this.storage.previousPayload,
                });
              this.storage.assign((e) => (e.previousPayload = C));
              const O = bi({
                entryData: d,
                friendAgeGroupDistribution: this.friendAgeGroupDistribution,
                lastEntryIsRepeat: k,
                storage: this.storage,
                userId: this.playerID,
              });
              Object.keys(O).length > 0 &&
                this.storage.assign((e) => {
                  O.ageConfidence &&
                    (e.demographics.ageConfidence = O.ageConfidence),
                    O.ageRange && (e.demographics.ageRange = O.ageRange),
                    O.gender && (e.demographics.gender = O.gender);
                }),
                await (null == (i = this.beforeEntryFinalCallback)
                  ? void 0
                  : i.call(this));
              const x =
                  "line" !== this.platformID
                    ? void 0
                    : this.insideNativeIOS
                    ? "NATIVE"
                    : "ANDROID" === this.osType || "IOS" === this.osType
                    ? "LIFF"
                    : "LINE" === l.app.name
                    ? "IAB"
                    : "EXTERNAL",
                N = h.first;
              if (N) {
                const e = (function (e, t, n) {
                    if (null != e.$zeroEntryDatetime)
                      return {
                        $firstEntryGeneration:
                          (+e.$firstEntryGeneration || 0) + 1,
                        $zeroEntryChannel: e.$zeroEntryChannel,
                        $zeroEntryDatetime: e.$zeroEntryDatetime,
                        $zeroEntryDate: e.$zeroEntryDate,
                        $zeroEntryAdCampaignName: e.$zeroEntryAdCampaignName,
                        $zeroEntryAdSetName: e.$zeroEntryAdSetName,
                        $zeroEntryAdCreativeName: e.$zeroEntryAdCreativeName,
                        $zeroEntryAdNetworkName: e.$zeroEntryAdNetworkName,
                        zeroEntrySourcePlayerID: e.zeroEntrySourcePlayerID,
                      };
                    {
                      const r = new Date(t).toISOString();
                      return {
                        $firstEntryGeneration: 0,
                        $zeroEntryChannel: n.channel,
                        $zeroEntryDatetime: r,
                        $zeroEntryDate: r.slice(0, 10),
                        $zeroEntryAdCampaignName: e.$adCampaignName,
                        $zeroEntryAdSetName: e.$adSetName,
                        $zeroEntryAdCreativeName: e.$adCreativeName,
                        $zeroEntryAdNetworkName: e.$adNetworkName,
                        zeroEntrySourcePlayerID: n.playerID,
                      };
                    }
                  })({ ...this.entryData, $adNetworkName: g }, v, {
                    channel: p,
                    playerID: this.playerID,
                  }),
                  n = pr.getUserProperties(),
                  r = (function (e) {
                    return e.filter((t, n) => e.indexOf(t) === n);
                  })([
                    ...((null == (o = this.abTests)
                      ? void 0
                      : o.getAssignedNonPlaceboTestIds()) || []),
                    ...this.externalABTests.getAssignedNonPlaceboTestIds(),
                  ]).sort(),
                  s = {
                    ...t,
                    ...e,
                    $firstEntryChannel: p,
                    $firstEntryPlatform: m,
                    $firstEntrySourceLastEntryPlatform: d.$lastEntryPlatform,
                    $firstEntrySourceLastEntrySessionMaturityRange:
                      d.$lastEntrySessionMaturityRange,
                    firstEntryActiveClusterSize1D:
                      n.lastEntryActiveClusterSize1D,
                    firstEntryActiveClusterSize3D:
                      n.lastEntryActiveClusterSize3D,
                    firstEntryActiveClusterSize7D:
                      n.lastEntryActiveClusterSize7D,
                    firstEntryActiveClusterSize14D:
                      n.lastEntryActiveClusterSize14D,
                    firstEntryActiveClusterSize30D:
                      n.lastEntryActiveClusterSize30D,
                    firstEntryActiveClusterSize90D:
                      n.lastEntryActiveClusterSize90D,
                    firstEntryActiveClusterConnections1D:
                      n.lastEntryActiveClusterConnections1D,
                    firstEntryActiveClusterConnections3D:
                      n.lastEntryActiveClusterConnections3D,
                    firstEntryActiveClusterConnections7D:
                      n.lastEntryActiveClusterConnections7D,
                    firstEntryActiveClusterConnections14D:
                      n.lastEntryActiveClusterConnections14D,
                    firstEntryActiveClusterConnections30D:
                      n.lastEntryActiveClusterConnections30D,
                    firstEntryActiveClusterConnections90D:
                      n.lastEntryActiveClusterConnections90D,
                    firstEntryActiveClusterConnectedness1D:
                      n.lastEntryActiveClusterConnectedness1D,
                    firstEntryActiveClusterConnectedness3D:
                      n.lastEntryActiveClusterConnectedness3D,
                    firstEntryActiveClusterConnectedness7D:
                      n.lastEntryActiveClusterConnectedness7D,
                    firstEntryActiveClusterConnectedness14D:
                      n.lastEntryActiveClusterConnectedness14D,
                    firstEntryActiveClusterConnectedness30D:
                      n.lastEntryActiveClusterConnectedness30D,
                    firstEntryActiveClusterConnectedness90D:
                      n.lastEntryActiveClusterConnectedness90D,
                    firstEntryActiveFriendCount1D:
                      n.lastEntryActiveFriendCount1D,
                    firstEntryActiveFriendCount3D:
                      n.lastEntryActiveFriendCount3D,
                    firstEntryActiveFriendCount7D:
                      n.lastEntryActiveFriendCount7D,
                    firstEntryActiveFriendCount14D:
                      n.lastEntryActiveFriendCount14D,
                    firstEntryActiveFriendCount30D:
                      n.lastEntryActiveFriendCount30D,
                    firstEntryActiveFriendCount90D:
                      n.lastEntryActiveFriendCount90D,
                    "firstEntryActiveFriendRatio1/3":
                      n["lastEntryActiveFriendRatio1/3"],
                    "firstEntryActiveFriendRatio1/7":
                      n["lastEntryActiveFriendRatio1/7"],
                    "firstEntryActiveFriendRatio3/7":
                      n["lastEntryActiveFriendRatio3/7"],
                    "firstEntryActiveFriendRatio7/30":
                      n["lastEntryActiveFriendRatio7/30"],
                    firstEntrySourceRealtimeActiveFriendCount1D:
                      d.realtimeActiveFriendCount1D,
                    firstEntrySourceRealtimeActiveFriendCount3D:
                      d.realtimeActiveFriendCount3D,
                    firstEntrySourceRealtimeActiveFriendCount7D:
                      d.realtimeActiveFriendCount7D,
                    firstEntrySourceRealtimeActiveFriendCount14D:
                      d.realtimeActiveFriendCount14D,
                    firstEntrySourceRealtimeActiveFriendCount30D:
                      d.realtimeActiveFriendCount30D,
                    firstEntrySourceRealtimeActiveFriendCount90D:
                      d.realtimeActiveFriendCount90D,
                    firstEntryAgeConfidence:
                      this.storage.demographics.ageConfidence,
                    firstEntryAgeIsAdult: this.storage.demographics.ageRange
                      ? yi(this.storage.demographics.ageRange)
                      : void 0,
                    firstEntryAgeRange: this.storage.demographics.ageRange
                      ? mi(this.storage.demographics.ageRange)
                      : void 0,
                    firstEntryGender: this.storage.demographics.gender,
                    firstEntryBrowser: x,
                    firstEntryConnectedPlayerCount: h.connectedPlayerCount,
                    firstEntryContextID: d.contextID,
                    firstEntryAdNetwork: d.adNetwork,
                    firstEntryAdCampaign: d.adCampaign,
                    firstEntryAdSet: d.adSet,
                    firstEntryAbTest: d.abTest,
                    firstEntryAbTestBucket: d.abTestBucket,
                    firstEntryABTests: r,
                    firstEntryAdType: d.adType,
                    firstEntryAdIncentive: d.adIncentive,
                    firstEntryAdMedia: d.adMedia,
                    firstEntryAdDuration: d.adDuration,
                    firstEntryAdUnit: d.adUnit,
                    firstEntryAdLanguage: d.adLanguage,
                    firstEntryAdCountry: d.adCountry,
                    firstEntryChannelIsInferred: f,
                    firstEntryChannelIsSocial: Si(this.getChannel()),
                    firstEntryDate: h.date,
                    firstEntryDateHour: n.lastEntryDateHour,
                    firstEntryDateMonth: n.lastEntryDateMonth,
                    firstEntryDateTime: n.lastEntryDateTime,
                    firstEntryDateWeek: n.lastEntryDateWeek,
                    firstEntryDayOfWeek: n.lastEntryDayOfWeek,
                    firstEntryHour: n.lastEntryHour,
                    firstEntryIsNative: S,
                    firstEntryProjectDate: n.lastEntryProjectDate,
                    firstEntrySourceFeature: d.feature,
                    firstEntrySourceGameFeature: d.sourceGameFeature,
                    firstEntrySourceGameID: d.gameID,
                    firstEntrySourceGameLevel: d.gameLevel,
                    firstEntrySourceGamePlayerID: d.gamePlayerID,
                    firstEntrySourceGameVersion: d.gameVersion,
                    firstEntrySourceLevel: d.sourceLevel,
                    firstEntrySourceLevelRange: d.sourceLevelRange,
                    firstEntrySourceOS: d.sourceOS,
                    firstEntrySourcePlayerID: d.playerID,
                    firstEntrySourceVersion: d.sourceVersion,
                    firstEntrySubFeature: d.$subFeature,
                    firstEntryUID: d.UID,
                    firstEntryAsset: d.asset,
                    firstEntryText: d.text,
                    firstEntryButton: d.button,
                    firstEntryVersion: this._gameConfig.version,
                    firstEntryPaymentsEnabled: this.paymentsAvailable,
                    firstEntryPointName: h.entryPointName,
                  };
                if (S) {
                  const e =
                    null == (c = null == (a = window.Native) ? void 0 : a.app)
                      ? void 0
                      : c.version;
                  if (e) {
                    const t =
                      "IOS_APP" === this.osType
                        ? "firstEntryAppleVersion"
                        : "firstEntryAndroidVersion";
                    s[t] = e;
                  }
                }
                const i = [
                  (null == (u = this.abTests) ? void 0 : u.config)
                    ? this.abTests.getAbTag()
                    : void 0,
                  this.externalABTests.getABTag(),
                ]
                  .filter((e) => !!e)
                  .join(",");
                i && (s.firstEntryABTag = i),
                  "line" === this.platformID &&
                    (s.firstEntrySocialFriendCount = this.socialFriends.length),
                  pr.setUserProperties(s, pr.toDefaultAndAdServer),
                  this.storage.assign((e) => {
                    for (const t in s) e.analytics[t] = s[t];
                  });
              }
              const { $zeroEntryDatetime: R } = this.storage.analytics,
                D = null != R ? (v - new Date(R).getTime()) / Ga : null,
                M = (function (e, t) {
                  const n = {
                    "1M": Ln({ minutes: 1 }),
                    "5M": Ln({ minutes: 5 }),
                    "15M": Ln({ minutes: 15 }),
                    "30M": Ln({ minutes: 30 }),
                    "1H": Ln({ hours: 1 }),
                    "2H": Ln({ hours: 2 }),
                    "4H": Ln({ hours: 4 }),
                    "8H": Ln({ hours: 8 }),
                    "12H": Ln({ hours: 12 }),
                    "1D": Ln({ hours: 24 }),
                  };
                  return Object.entries(n).reduce((n, r) => {
                    let [s, i] = r;
                    return (
                      (n[s] = e.filter((e) => t - e <= i).length || "(none)"), n
                    );
                  }, {});
                })(d.sourceChainTimestamps || [], v),
                j = Object.entries(M).reduce((e, t) => {
                  let [n, r] = t;
                  return { ...e, ["lastEntryChainLength".concat(n)]: r };
                }, {}),
                { amplitudeTimeZone: L } = this._gameConfig,
                U = Un({
                  fromTimestamp: y.first,
                  ianaTimeZone: L,
                  toTimestamp: v,
                }),
                F = R
                  ? Un({
                      fromTimestamp: new Date(R).getTime(),
                      ianaTimeZone: L,
                      toTimestamp: v,
                    })
                  : void 0,
                B = {
                  ...n,
                  ...j,
                  $lastEntryChannel: p,
                  $lastEntryPlatform: m,
                  $lastEntrySessionMaturityRange:
                    ((V = y.count),
                    V <= 1
                      ? "1"
                      : V <= 2
                      ? "2"
                      : V <= 5
                      ? "3-5"
                      : V <= 9
                      ? "6-9"
                      : V <= 19
                      ? "10-19"
                      : V <= 49
                      ? "20-49"
                      : V <= 99
                      ? "50-99"
                      : V <= 199
                      ? "100-199"
                      : V <= 399
                      ? "200-399"
                      : V <= 799
                      ? "400-799"
                      : "800+"),
                  $lastEntrySourceLastEntryPlatform: d.$lastEntryPlatform,
                  $lastEntrySourceLastEntrySessionMaturityRange:
                    d.$lastEntrySessionMaturityRange,
                  $lastEntryAdCampaignName: d.$adCampaignName,
                  $lastEntryAdSetName: d.$adSetName,
                  $lastEntryAdCreativeName: d.$adCreativeName,
                  $lastEntryAdNetworkName: g,
                  $lastEntryElapsedDaysZeroEntry: D,
                  hoursElapsedLastEntry: A,
                  lastEntryBrowser: x,
                  requestedLocale: this.locale,
                  platformLocale: this.platformLocale,
                  displayedLocale: this.locale,
                  lastConnectedPlayerCount: h.connectedPlayerCount,
                  projectDaysSinceInstall: U,
                  lastEntryCalendarDaysSinceInstall: U,
                  projectDaysSinceZeroEntry: F,
                  lastEntryCalendarDaysSinceZeroEntry: F,
                  lastEntryIsFirstOnNative: _,
                  lastEntryIsNative: S,
                  lastEntryIsRepeat: k,
                  lastEntryPointName: h.entryPointName,
                  daysSinceInstall: Math.floor(E),
                  daysSinceLastAdEntry: y.lastAdEntry
                    ? Math.floor((v - y.lastAdEntry) / Ga)
                    : void 0,
                  daysSinceLastResurrected: I,
                  daysElapsedFirstEntry: E,
                  daysElapsedLastEntry: A / 24,
                  lastEntrySourceRealtimeActiveFriendCount1D:
                    d.realtimeActiveFriendCount1D,
                  lastEntrySourceRealtimeActiveFriendCount3D:
                    d.realtimeActiveFriendCount3D,
                  lastEntrySourceRealtimeActiveFriendCount7D:
                    d.realtimeActiveFriendCount7D,
                  lastEntrySourceRealtimeActiveFriendCount14D:
                    d.realtimeActiveFriendCount14D,
                  lastEntrySourceRealtimeActiveFriendCount30D:
                    d.realtimeActiveFriendCount30D,
                  lastEntrySourceRealtimeActiveFriendCount90D:
                    d.realtimeActiveFriendCount90D,
                  lastEntryAgeConfidence:
                    this.storage.demographics.ageConfidence,
                  lastEntryAgeIsAdult: this.storage.demographics.ageRange
                    ? yi(this.storage.demographics.ageRange)
                    : void 0,
                  lastEntryAgeRange: this.storage.demographics.ageRange
                    ? mi(this.storage.demographics.ageRange)
                    : void 0,
                  lastEntryGender: this.storage.demographics.gender,
                };
              var V;
              P && (B.isResurrectedUser = !0),
                "line" === this.platformID &&
                  (B.lastEntrySocialFriendCount = this.socialFriends.length);
              const q = Math.max(
                  this.storage.entry.lastNativeAndroidEntry,
                  this.storage.entry.lastNativeIOSEntry
                ),
                H = 0 === q ? 1 / 0 : v - q;
              (B.lastEntryNativeActive1D = H <= Ln({ days: 1 })),
                (B.lastEntryNativeActive3D = H <= Ln({ days: 3 })),
                (B.lastEntryNativeActive7D = H <= Ln({ days: 7 })),
                (B.lastEntryNativeActive14D = H <= Ln({ days: 14 })),
                (B.lastEntryNativeActive30D = H <= Ln({ days: 30 })),
                (B.lastEntryNativeActive90D = H <= Ln({ days: 90 })),
                pr.setUserProperties(B, pr.toDefaultAndAdServer);
              const W = {
                ...h,
                ...e,
                inactiveDay5: T > 5,
                inactiveDay10: T > 10,
                inactiveDay30: T > 30,
                inactiveDay90: T > 90,
                isFirstOrResurrect: N || P,
                isResurrect: P,
                sourceShareSwitchContext: d.switchContext,
                $channel: p,
                $channelIsInferred: f,
                $self: this.entryData.playerID === this.playerID,
                $adCampaignName: d.$adCampaignName,
                $adSetName: d.$adSetName,
                $adCreativeName: d.$adCreativeName,
                $adNetworkName: g,
                $wasEntryDataFullyReadyEarly:
                  this.wasEntryDataReadyEarly &&
                  0 === this.onGameStartRetries.length,
                $sourceFirstEntryChannel: d.$firstEntryChannel,
                $sourceFirstConnectedPlayerCount: d.$firstConnectedPlayerCount,
                $sourceFirstEntryDate: d.$firstEntryDate,
                $sourceFirstEntryPointName: d.$firstEntryPointName,
                $sourceLastEntryChannel: d.$lastEntryChannel,
                $sourceEntryCount: d.$entryCount,
                $sourceLastConnectedPlayerCount: d.$lastConnectedPlayerCount,
                $sourceLastEntryPointName: d.$lastEntryPointName,
                $sourceLastEntryVersion: d.$lastEntryVersion,
                sourceLastEntryActiveClusterSize1D:
                  d.lastEntryActiveClusterSize1D,
                sourceLastEntryActiveClusterSize3D:
                  d.lastEntryActiveClusterSize3D,
                sourceLastEntryActiveClusterSize7D:
                  d.lastEntryActiveClusterSize7D,
                sourceLastEntryActiveClusterSize14D:
                  d.lastEntryActiveClusterSize14D,
                sourceLastEntryActiveClusterSize30D:
                  d.lastEntryActiveClusterSize30D,
                sourceLastEntryActiveClusterSize90D:
                  d.lastEntryActiveClusterSize90D,
                sourceLastEntryActiveClusterConnections1D:
                  d.lastEntryActiveClusterConnections1D,
                sourceLastEntryActiveClusterConnections3D:
                  d.lastEntryActiveClusterConnections3D,
                sourceLastEntryActiveClusterConnections7D:
                  d.lastEntryActiveClusterConnections7D,
                sourceLastEntryActiveClusterConnections14D:
                  d.lastEntryActiveClusterConnections14D,
                sourceLastEntryActiveClusterConnections30D:
                  d.lastEntryActiveClusterConnections30D,
                sourceLastEntryActiveClusterConnections90D:
                  d.lastEntryActiveClusterConnections90D,
                sourceLastEntryActiveClusterConnectedness1D:
                  d.lastEntryActiveClusterConnectedness1D,
                sourceLastEntryActiveClusterConnectedness3D:
                  d.lastEntryActiveClusterConnectedness3D,
                sourceLastEntryActiveClusterConnectedness7D:
                  d.lastEntryActiveClusterConnectedness7D,
                sourceLastEntryActiveClusterConnectedness14D:
                  d.lastEntryActiveClusterConnectedness14D,
                sourceLastEntryActiveClusterConnectedness30D:
                  d.lastEntryActiveClusterConnectedness30D,
                sourceLastEntryActiveClusterConnectedness90D:
                  d.lastEntryActiveClusterConnectedness90D,
                sourceLastEntryAgeConfidence: d.lastEntryAgeConfidence,
                sourceLastEntryAgeIsAdult: d.lastEntryAgeIsAdult,
                sourceLastEntryAgeRange: d.lastEntryAgeRange,
                sourceLastEntryGender: d.lastEntryGender,
                hoursInactive: Math.floor(A),
                daysInactive: Math.floor(T),
                applePushEnabled: d.applePushEnabled,
                appleDaysElapsedLastEntry: w && (v - w) / Ga,
              };
              let K = d.timestamp;
              if (K) {
                "string" === typeof K &&
                  ((K = Date.parse(K)), (d.timestamp = K));
                const e = (v - K) / 1e3;
                (W.elapsedMinutes = e / 60),
                  (W.elapsedHours = e / 60 / 60),
                  (W.elapsedDays = e / 60 / 60 / 24);
              }
              for (const e in this.timeTo) {
                W["timeTo" + e.charAt(0).toUpperCase() + e.slice(1)] =
                  this.timeTo[e];
              }
              for (const [e, t] of Object.entries(M))
                "(none)" !== t && (W["chainLength".concat(e)] = t);
              const z = Number(Cn().cdn_ts);
              z &&
                ((W.elapsedSinceCDNEntry = Nn.getNow() - z),
                (function (e) {
                  const t = new URL(window.location.href);
                  for (const r of e) t.searchParams.delete(r);
                  const n = ""
                    .concat(t.pathname)
                    .concat(t.search)
                    .concat(t.hash);
                  window.history.replaceState({}, document.title, n);
                })(["cdn_ts"])),
                pr.pushEvent("EntryFinal", W, pr.toDefaultAndPixelAndAdServer),
                this.sendConversionEvents({
                  immediateReferrerId: d.playerID,
                  zeroGenerationReferrerId: d.zeroEntrySourcePlayerID,
                  eventProperties: W,
                }),
                this._gameConfig.postbackManagerKey &&
                  this.fireMarketingPostback();
              ("line" === this.platformID ||
                "line-guest" === this.platformID ||
                "telegram" === this.platformID ||
                "web" === this.platformID) &&
                fi();
            })
          );
        }
        async fireMarketingPostback() {
          if (!this.entryData.$adNetworkName) return;
          const e = new ri(this._gameConfig.postbackManagerKey);
          let t;
          switch (this.osType) {
            case "ANDROID":
            default:
              t = "android";
              break;
            case "IOS":
              t = "ios";
              break;
            case "MOBILE_WEB":
              t =
                navigator.userAgent.match(/(iPod|iPhone|iPad)/) &&
                navigator.userAgent.match(/AppleWebKit/)
                  ? "ios"
                  : "android";
          }
          const n = { os: t };
          var r;
          this.countryName && (n.country = ((r = this.countryName), Ei[r]));
          try {
            await e.sendEvent(ni.AppLaunch, this.entryData, n);
          } catch (a_) {
            !(function (e, t) {
              fr.pushError("MarketingPostbackFailure", e, t);
            })(a_, { $adNetworkName: this.entryData.$adNetworkName });
          }
        }
        sendConversionEvents(e) {
          if (!e.immediateReferrerId && !e.zeroGenerationReferrerId) return;
          const t = [
            {
              userID: e.immediateReferrerId,
              eventName: "EntryConversion",
              eventProperties: e.eventProperties,
            },
            {
              userID: e.zeroGenerationReferrerId,
              eventName: "ZeroEntryConversion",
              eventProperties: e.eventProperties,
            },
          ].filter((e) => {
            let { userID: t } = e;
            return !!t;
          });
          this.sendRawAnalyticsEvent(t).catch(() => {});
        }
        async sendRawAnalyticsEvent(e, t) {
          const n = Array.isArray(e) ? e : [e];
          if (0 === n.length) return;
          if (!this._gameConfig.amplitudeKey)
            return void (
              this._gameConfig.isDevelopment &&
              console.log("rawAnalyticsEvent", n)
            );
          const r =
              (null == t ? void 0 : t.temporalUserPropertyUserIds) ||
              Array.from(new Set(n.map((e) => e.userID))),
            s = await this.getTemporalUserProperties(r),
            i = n.map((e) => ({
              event_type: e.eventName,
              event_properties: e.eventProperties,
              user_id: e.userID,
              user_properties: { ...s[e.userID], ...e.userProperties },
            }));
          await (async function (e, t) {
            try {
              const {
                result: { result: n, requestTries: r },
                requestMs: s,
              } = await zn(() => Kn(e, t));
              return { result: n, requestMs: s, requestTries: r };
            } catch ({ error: { error: n, requestTries: r }, requestMs: s }) {
              return Promise.reject({
                error: n,
                requestMs: s,
                requestTries: r,
              });
            }
          })(async () => {
            const e = await fetch("https://api.amplitude.com/2/httpapi", {
              method: "POST",
              body: JSON.stringify({
                api_key: this._gameConfig.amplitudeKey,
                events: i,
              }),
              headers: { Accept: "*/*", "Content-Type": "application/json" },
            });
            if (!e.ok) {
              let t;
              try {
                t = await e.text();
              } catch {}
              throw Error(
                "Request failed with status code "
                  .concat(e.status, ": ")
                  .concat(t)
              );
            }
          }).catch((e) => {
            let { error: t, requestMs: n, requestTries: r } = e;
            throw (
              ((function (e, t) {
                fr.pushError("SendRawAnalyticsEventFailure", e, t);
              })(t, { requestMs: n, requestTries: r }),
              t)
            );
          });
        }
        logEvent(e, t, n) {
          console.log(
            "FBInstant.logEvent()",
            "eventName:",
            e,
            "valueToSum:",
            t,
            "parameters:",
            n
          );
        }
        getChannel() {
          if (this.entryContextTournament) return "TOURNAMENT";
          const e = this.entryPointName;
          let t = this.entryData.$channel;
          if (!t)
            if ("ad" === e) t = "AD";
            else if ("bot_cta" === e || "bot_menu" === e) t = "CHATBOT";
            else if ("home_screen_shortcut" === e) t = "HOMESCREEN";
            else {
              if ("feed" === e) return "SHARE";
              if ("admin_message" === e) return "UPDATE";
              t =
                "ANDROID_APP" === this.osType || "IOS_APP" === this.osType
                  ? "HOMESCREEN"
                  : "NONVIRAL";
            }
          return t;
        }
        trackTimeTo(e) {
          this.timeTo[e] = Math.round(window.performance.now()) / 1e3;
        }
        throwIfNotInitialized() {
          if (!this._initialized)
            throw Error(
              "Not initialized, game must resolve Platform.initializeAsync first"
            );
        }
        throwIfStartGameAsyncIsCalledMultipleTimes() {
          if (this.didCallStartGameAsync)
            throw new Error(
              "Game should not call 'startGameAsync' more than once"
            );
          this.didCallStartGameAsync = !0;
        }
        throwIfSendEntryFinalAnalyticsIsCalledMultipleTimes() {
          if (this.didCallSendEntryFinalAnalytics)
            throw new Error(
              "Game should not call 'sendEntryFinalAnalytics' more than once"
            );
          this.didCallSendEntryFinalAnalytics = !0;
        }
        throwIfStorageAdapterIsNotConfigured() {
          if (!this.storage.hasAdapter() && !this._gameConfig.isDevelopment)
            throw Error(
              "Storage adapter must be configured before loading storage in production mode"
            );
        }
        throwIfStorageIsNotLoaded() {
          if (0 === this.storage.entry.count)
            throw Error("Analytics storage must be loaded before operation");
        }
        async createNativeBridge(e, t, n) {
          throw new Error("not implemented");
        }
        async initializeNativeBridge(e, t) {
          throw new Error("not implemented");
        }
        setCountry(e) {
          this.countryName = _i[e] || void 0;
        }
        setECPM(e) {
          this.eCPM = e;
        }
        setExchangeRates(e) {
          this.convertCurrency = (function (e) {
            return (t) => {
              var n;
              const { amount: r, fromCurrency: s, toCurrency: i } = t,
                o = s === i ? 1 : null == (n = e[i]) ? void 0 : n[s];
              if (void 0 !== o) return { exchangeRate: o, result: r / o };
            };
          })(e);
        }
        setExternalABTestsSource(e) {
          this.externalABTests.setSource(e);
        }
        setTime(e) {
          Nn.setNow(e);
        }
        tournamentWithPayloadDecoder(e) {
          return {
            getContextID: () => e.getContextID().toString(),
            getEndTime: () => e.getEndTime(),
            getTitle: () => e.getTitle(),
            getPayload: async () => {
              const t = e.getPayload();
              if (!t) return;
              let n;
              if ("string" === typeof t)
                try {
                  n = JSON.parse(t);
                } catch (r) {
                  return void ai(r, { rawPayload: t, type: "parseFailed" });
                }
              else n = t;
              return this.dataCodec.decode(n);
            },
          };
        }
        shouldIncreaseEntryCount() {
          return !0;
        }
      }
      function Ya(e, t) {
        return {
          filter: (t) => e.test(t),
          convert: (n) => n.replace(new RegExp(e, "g"), t),
        };
      }
      function Xa(e) {
        const t = new RegExp("[".concat(Object.keys(e).join(""), "]"), "g");
        return {
          filter: (e) => t.test(e),
          convert: (n) => n.replace(t, (t) => e[t] || t),
        };
      }
      function Za(e) {
        return {
          filter: (t) => t.includes(e),
          convert: (t) => t.replace(e, ""),
        };
      }
      function $a(e) {
        return Number(
          (function (e) {
            return "(none)" === e
              ? ""
              : ((t = [
                  Za("\u0433\u0440\u043d."),
                  Za("kr."),
                  Za("\u0644.\u0644."),
                  Za("\u062f.\u0623."),
                  Za("\u062c.\u0645."),
                  Xa({
                    "\u1040": "0",
                    "\u1041": "1",
                    "\u1042": "2",
                    "\u1043": "3",
                    "\u1044": "4",
                    "\u1045": "5",
                    "\u1046": "6",
                    "\u1047": "7",
                    "\u1048": "8",
                    "\u1049": "9",
                  }),
                  Xa({
                    "\u0660": "0",
                    "\u0661": "1",
                    "\u0662": "2",
                    "\u0663": "3",
                    "\u0664": "4",
                    "\u0665": "5",
                    "\u0666": "6",
                    "\u0667": "7",
                    "\u0668": "8",
                    "\u0669": "9",
                    "\u066c": ",",
                    "\u066b": ",",
                  }),
                  Ya(/\.(?=\d{3})/, ","),
                  Ya(/,(?=(\d{2})(?!\d))/, "."),
                  {
                    filter: () => !0,
                    convert: (e) => e.replace(/[^0-9.]/g, ""),
                  },
                ]),
                (n = e),
                t.reduce(
                  (e, t) =>
                    (function (e, t) {
                      return e.filter(t) ? e.convert(t) : t;
                    })(t, e),
                  n
                ));
            var t, n;
          })(e)
        );
      }
      Fa(Qa, "ERROR_NO_PROVISION"),
        (Qa.ERROR_NO_PROVISION =
          "Game must provide an onProvisionProductAsync callback");
      var ec = Object.defineProperty,
        tc = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? ec(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      const nc =
          "https://storage.googleapis.com/devkit-instant/avatar/animal_0001.png",
        rc = "playerID";
      function sc() {
        const e = Cn();
        return e.profile
          ? e.profile
          : za(rc, Math.floor(1e3 + 1e4 * Math.random()).toString());
      }
      const ic = class extends Qa {
        constructor(e) {
          var t;
          super("mock"),
            tc(this, "_context", null),
            (this.legacyNative =
              null !== (t = null == e ? void 0 : e.legacyNativeInterface) &&
              void 0 !== t
                ? t
                : (function () {
                    var e;
                    return null !== (e = $s.create()) && void 0 !== e
                      ? e
                      : is.create();
                  })()),
            (this.supportedAPIs = {
              isContextSizeBetween: !0,
              chooseContextAsync: !0,
              createContextAsync: !0,
              createShortcutAsync: !1,
              canSubscribeBotAsync: !1,
              subscribeBotAsync: !1,
              flushDataAsync: !0,
              filterFriendsAsync: !0,
              getDataAsync: !0,
              getEntryPointAsync: !1,
              getEntryPointData: !1,
              getFriendsAsync: !0,
              getInterstitialAdAsync: !1,
              getPlayersAsync: !0,
              getRewardedVideoAsync: !1,
              getSignedPlayerInfoAsync: !0,
              getLeaderboardAsync: !0,
              initializeAsync: !0,
              postSessionScoreAsync: !0,
              getTournamentAsync: !0,
              createTournamentAsync: !0,
              shareTournamentAsync: !0,
              postTournamentScoreAsync: !0,
              setDataAsync: !0,
              setSessionData: !0,
              shareAsync: !0,
              switchContextAsync: !0,
              switchGameAsync: !1,
              checkCanPlayerMatchAsync: !0,
              matchPlayerAsync: !0,
              updateAsync: !1,
              getCatalogAsync: !0,
              purchaseAsync: !0,
            });
          vr("style", void 0, document.head).appendChild(
            document.createTextNode(
              '.devkit-instant-mock-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  margin: 0;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.4);\n  z-index: 99999;\n  cursor: default;\n  overflow-x: hidden;\n  overflow-y: scroll;\n  font-size: 1.4rem;\n  font-family: arial, helvetica, sans-serif;\n}\n\n.devkit-instant-mock-overlay::-webkit-scrollbar {\n\twidth: 5px;\n\theight: 0px;\n}\n\n.devkit-instant-mock-closeBtn::before {\n  content: "\u2715";\n}\n\n.devkit-instant-mock-closeBtn {\n  position: absolute;\n  top: 0;\n  right: 0;\n  width: 50px;\n  color: #888;\n  font-size: 1.8rem;\n  font-weight: bolder;\n}\n\n.devkit-instant-mock-context-choose {\n  background-color: #fff;\n  color: #000;\n  border-radius: 6px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  margin: 16px 8px;\n  overflow: hidden;\n  position: relative;\n  font-family: arial;\n  padding-bottom: 30px;\n  top: 200px;\n  opacity: 0;\n  transition: top 0.2s ease-out 0s, opacity 0.1s;\n}\n\n.devkit-instant-mock-context-choose h1 {\n  margin: 0;\n  border-bottom: thin solid #dddfe2;\n  height: 3.6rem;\n  line-height: 3.6rem;\n  font-size: 1.8rem;\n  position: relative;\n  text-align: center;\n  font-weight: normal;\n}\n\n.devkit-instant-mock-context-choose h2 {\n  margin: 20px 0 0 0;\n  padding: 5px 17px;\n  font-size: 16px;\n  background-color: #f5f5f5;\n  color: #abaaaa;\n  font-weight: lighter;\n  text-align: left;\n}\n\n.devkit-instant-mock-context-choose-item {\n  margin: 20px 0 0 16px;\n  align-items: center;\n  display: flex;\n  outline: none;\n  overflow: hidden;\n  padding: 0 10px;\n  text-align: left;\n}\n\n.devkit-instant-mock-context-choose-item-icon {\n  width: 50px;\n  height: 50px;\n  border-radius: 50px;\n  background-color: #4d82f7;\n  display: inline-block;\n  background-size: cover;\n}\n\n.devkit-instant-mock-context-choose-item-title {\n  display: inline-block;\n  flex-grow: 1;\n  margin: 0 22px;\n}\n\n.devkit-instant-mock-context-choose-item-btn {\n  display: inline-block;\n  border: solid 1px #4d82f7;\n  color: #4d82f7;\n  font-size: 14px;\n  padding: 6px 12px;\n  border-radius: 4px;\n  background-color: #fff;\n}\n.devkit-instant-mock-context-switch {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  height: 100%;\n}\n\n.devkit-instant-mock-context-switch h1 {\n  font-size: 1.1em;\n  margin: 16px 0;\n}\n\n.devkit-instant-mock-context-switch-box {\n  margin: auto 10px;\n  background-color: #fff;\n  border-radius: 18px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n}\n\n.devkit-instant-mock-context-switch-icon {\n  width: 80px;\n  height: 80px;\n  border-radius: 80px;\n  background-size: cover;\n  background-color: #9dcab1;\n  display: inline-block;\n  border: solid 4px #fff;\n  margin-left: -12px;\n}\n\n.devkit-instant-mock-context-switch-btn {\n  font-size: 20px;\n  width: 150px;\n}\n\n/**\nPurchase confirmation style\n**/\n.devkit-instant-mock-purchase-confirmation {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  height: 100%;\n  width: 70%;\n  margin: auto;\n}\n\n.devkit-instant-mock-purchase-confirmation h1 {\n  font-size: 0.8em;\n  margin: 16px 0;\n}\n\n.devkit-instant-mock-purchase-confirmation h3 {\n  font-size: 0.8em;\n  margin: 16px 0;\n}\n\n.devkit-instant-mock-purchase-confirmation-box {\n  margin: auto 10px;\n  background-color: #fff;\n  border-radius: 18px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n}\n\n.devkit-instant-mock-purchase-confirmation-icon {\n  width: 80px;\n  height: 80px;\n  border-radius: 80px;\n  background-size: cover;\n  background-color: #9dcab1;\n  display: inline-block;\n  border: solid 4px #fff;\n  margin-left: -12px;\n}\n\n.devkit-instant-mock-purchase-confirmation-btn {\n  font-size: 20px;\n  width: 150px;\n  display: inline-block;\n  border: solid 1px #4d82f7;\n  color: #4d82f7;\n  font-size: 14px;\n  padding: 6px 12px;\n  border-radius: 4px;\n  background-color: #fff;\n}\n\n/**\n  MachMakingInfo dialog\n**/\n.devkit-instant-mock-matchmakingInfo {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  height: 100%;\n  width: 70%;\n  margin: auto;\n}\n\n.devkit-instant-mock-matchmakingInfo-box {\n  margin: auto 10px;\n  background-color: #fff;\n  border-radius: 18px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n  height: 500px;\n}\n\n.devkit-instant-mock-matchmakingInfo h1 {\n  font-size: 1em;\n  margin: 16px 0;\n}\n\n.devkit-instant-mock-matchmakingInfo p {\n  font-size: 17px;\n  margin: 16px 0;\n  margin-top: 60px;\n  margin-bottom: 60px;\n  text-align: justify;\n}\n\n.devkit-instant-mock-matchmakingInfo-btn {\n  font-size: 17px;\n  width: 200px;\n  display: inline-block;\n  border: solid 1px #4d82f7;\n  color: #fff;\n  font-size: 17px;\n  padding: 10px 12px;\n  border-radius: 4px;\n  background-color: #4d82f7;\n}\n\n/**\n  matchmakingSearch dialog\n**/\n.devkit-instant-mock-matchmakingSearch {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  height: 100%;\n  width: 70%;\n  margin: auto;\n}\n\n.devkit-instant-mock-matchmakingSearch-box {\n  margin: auto 10px;\n  background-color: #fff;\n  border-radius: 18px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n  height: 100px;\n}\n\n.devkit-instant-mock-matchmakingSearch h1 {\n  font-size: 1em;\n  margin: 16px 0;\n}\n\n.devkit-instant-mock-matchmakingSearch p {\n  font-size: 17px;\n  margin: 16px 0;\n  margin-top: 60px;\n  margin-bottom: 60px;\n  text-align: justify;\n}\n\n/**\n  Share async dialog\n**/\n\n.devkit-instant-mock-shareAsync {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  height: 90%;\n  width: 92%;\n  margin: auto;\n}\n\n.devkit-instant-mock-shareAsync-box {\n  margin: auto 10px;\n  background-color: #fff;\n  border-radius: 18px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n  height: 720px;\n}\n\n.devkit-instant-mock-shareAsync-image {\n  display: block;\n  width: 100%;\n  height: 90%;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n}\n\n.devkit-instant-mock-shareAsync-buttons {\n  display: flex;\n  justify-content: space-between;\n  padding: 1rem 0rem;\n}\n\n.devkit-instant-mock-shareAsync-button {\n  font-size: 1rem;\n  border: solid 1px #4d82f7;\n  color: #4d82f7;\n  text-align: center;\n  vertical-align: middle;\n  border-radius: 4px;\n  height: 100%;\n  max-height: 5rem;\n  width: 100%;\n  min-width: 4rem;\n  line-height: 2rem;\n  max-width: 6.6rem;\n  cursor: pointer;\n  transition-duration: 0.4s;\n}\n\n.devkit-instant-mock-shareAsync-button:hover {\n  background-color: #4d82f7;\n  color: #fff;\n}\n\n.button-blue {\n  background-color: #4d82f7;\n  color: #fff;\n}\n\n.button-blue:hover {\n  background-color: #fff;\n  color: #4d82f7;\n}\n\n/**\n  Share for tournaments\n**/\n\n.devkit-instant-mock-shareAsyncTournament {\n  color: #000;\n  border-radius: 6px;\n  display: block;\n  margin: 16px 8px;\n  overflow: hidden;\n  position: relative;\n  font-family: arial;\n  padding-bottom: 30px;\n  top: 10%;\n  transition: top 0.2s ease-out 0s, opacity 0.1s;\n}\n\n.devkit-instant-mock-shareAsyncTournament-box {\n  margin: auto 10px;\n  background-color: #fff;\n  border-radius: 18px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n}\n\n.devkit-instant-mock-shareAsyncTournament-buttons {\n  display: flex;\n  justify-content: space-between;\n  padding: 1rem 0rem;\n}\n\n.devkit-instant-mock-shareAsyncTournament-button {\n  font-size: 2rem;\n  border: solid 1px #4d82f7;\n  color: #4d82f7;\n  text-align: center;\n  vertical-align: middle;\n  border-radius: 4px;\n  height: 100%;\n  max-height: 5rem;\n  width: 100%;\n  min-width: 5rem;\n  line-height: 3rem;\n  max-width: 10.6rem;\n  cursor: pointer;\n  transition-duration: 0.4s;\n}\n\n.devkit-instant-mock-shareAsyncTournament-text h1 {\n  padding: 50px 0px;\n  font-size: 2rem;\n  font-weight: bolder;\n}\n\n.devkit-instant-mock-shareAsyncTournament-text p {\n  padding: 0px 0px 44px 0px;\n  font-size: 2rem;\n}\n\n.devkit-instant-mock-shareAsyncTournament-button:hover {\n  background-color: #4d82f7;\n  color: #fff;\n}\n\n.button-blue {\n  background-color: #4d82f7;\n  color: #fff;\n}\n\n.button-blue:hover {\n  background-color: #fff;\n  color: #4d82f7;\n}\n\n/**\n  Create squad\n**/\n\n.devkit-instant-mock-squad-create {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  height: 100%;\n}\n\n.devkit-instant-mock-squad-create h1 {\n  font-size: 1.1em;\n  margin: 16px 0;\n}\n\n.devkit-instant-mock-squad-create-box {\n  margin: auto 10px;\n  background-color: #fff;\n  border-radius: 18px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n}\n\n.devkit-instant-mock-squad-create-buttons {\n  display: flex;\n  justify-content: space-between;\n  padding: 1rem 0rem;\n}\n\n.devkit-instant-mock-squad-create-button-cancel {\n  font-size: 1rem;\n  border: solid 1px #4d82f7;\n  color: #4d82f7;\n  text-align: center;\n  vertical-align: middle;\n  border-radius: 4px;\n  height: 100%;\n  max-height: 5rem;\n  width: 100%;\n  min-width: 4rem;\n  line-height: 2rem;\n  max-width: 6.6rem;\n  cursor: pointer;\n  transition-duration: 0.4s;\n}\n\n.devkit-instant-mock-squad-create-button-cancel:hover {\n  background-color: #4d82f7;\n  color: #fff;\n}\n\n.devkit-instant-mock-squad-create-button-confirm {\n  font-size: 1rem;\n  border: solid 1px #4d82f7;\n  background-color: #4d82f7;\n  color: #fff;\n  text-align: center;\n  vertical-align: middle;\n  border-radius: 4px;\n  height: 100%;\n  max-height: 5rem;\n  width: 100%;\n  min-width: 4rem;\n  line-height: 2rem;\n  max-width: 6.6rem;\n  cursor: pointer;\n  transition-duration: 0.4s;\n}\n\n.devkit-instant-mock-squad-create-button-confirm:hover {\n  background-color: #fff;\n  color: #4d82f7;\n}\n\n/**\n  Join squad\n**/\n\n.devkit-instant-mock-squad-join {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  height: 100%;\n}\n\n.devkit-instant-mock-squad-join h1 {\n  font-size: 1.1em;\n  margin: 16px 0;\n}\n\n.devkit-instant-mock-squad-join-box {\n  margin: auto 10px;\n  background-color: #fff;\n  border-radius: 18px;\n  box-shadow: 0 2px 8px 2px rgba(0,0,0,.5);\n  display: block;\n  overflow: hidden;\n  position: relative;\n  text-align: center;\n  padding: 20px;\n  padding-top: 30px;\n}\n\n.devkit-instant-mock-squad-join-icon {\n  width: 80px;\n  height: 80px;\n  border-radius: 80px;\n  background-size: cover;\n  background-color: #9dcab1;\n  display: inline-block;\n  border: solid 4px #fff;\n  margin-left: -12px;\n}\n\n.devkit-instant-mock-squad-join-buttons {\n  display: flex;\n  justify-content: space-between;\n  padding: 1rem 0rem;\n}\n\n.devkit-instant-mock-squad-join-button-cancel {\n  font-size: 1rem;\n  border: solid 1px #4d82f7;\n  color: #4d82f7;\n  text-align: center;\n  vertical-align: middle;\n  border-radius: 4px;\n  height: 100%;\n  max-height: 5rem;\n  width: 100%;\n  min-width: 4rem;\n  line-height: 2rem;\n  max-width: 6.6rem;\n  cursor: pointer;\n  transition-duration: 0.4s;\n}\n\n.devkit-instant-mock-squad-join-button-cancel:hover {\n  background-color: #4d82f7;\n  color: #fff;\n}\n\n.devkit-instant-mock-squad-join-button-confirm {\n  font-size: 1rem;\n  border: solid 1px #4d82f7;\n  background-color: #4d82f7;\n  color: #fff;\n  text-align: center;\n  vertical-align: middle;\n  border-radius: 4px;\n  height: 100%;\n  max-height: 5rem;\n  width: 100%;\n  min-width: 4rem;\n  line-height: 2rem;\n  max-width: 6.6rem;\n  cursor: pointer;\n  transition-duration: 0.4s;\n}\n\n.devkit-instant-mock-squad-join-button-confirm:hover {\n  background-color: #fff;\n  color: #4d82f7;\n}'
            )
          );
        }
        async initializeAsync(e) {
          var t,
            n,
            r = this;
          if (null !== this._initialization) return this._initialization;
          const s = sc();
          this.readConfiguration(e),
            hr.initialize({
              ...this._gameConfig,
              appID: this.appID,
              convertCurrency: function () {
                return r.convertCurrency(...arguments);
              },
            }),
            (this._initialization = this._initialize(s)),
            await this._initialization,
            s in Ir.player
              ? ((this.playerName = Ir.player[s].name),
                (this.playerPhoto = Ir.player[s].photo))
              : ((this.playerName = "Test Name " + this.playerID),
                (this.playerPhoto = nc)),
            (this.entryData = this._getQueryEntryData()),
            (this.entryData.payload = this.entryData.payload || {}),
            (this.osType =
              "android" ===
              (null == (t = this.legacyNative) ? void 0 : t.platform.os)
                ? "ANDROID_APP"
                : "ios" ===
                  (null == (n = this.legacyNative) ? void 0 : n.platform.os)
                ? "IOS_APP"
                : l.os.isAndroid
                ? "ANDROID"
                : l.os.isIOS
                ? "IOS"
                : "WEB"),
            (this.isMobile = "WEB" !== this.osType),
            (this.insideNativeIOS =
              !!this.legacyNative || this.entryData._native_enabled),
            (this.canPlayerMatch = !0),
            (this._isPaymentsReady = !0),
            this._onPaymentsReady &&
              (this._onPaymentsReady(), (this._onPaymentsReady = null));
        }
        updateContext(e, t) {
          (this._context = t),
            super._updateContext(e, {
              getID: () => t.id,
              getType: () => t.type,
            });
        }
        async startGameAsyncInner() {
          this.trackTimeTo("startGameAsync"), await this._prepareEntryData();
        }
        _getEntryPointDataForce() {
          return this.entryData;
        }
        async _createEntryPromise() {
          await Promise.all([
            this.getFriendsAsync().then(() => {
              this.trackTimeTo("getFriendsAsync");
            }),
            this.canSubscribeBotAsync().then(() => {
              this.trackTimeTo("canSubscribeBotAsync");
            }),
            this.canCreateShortcutAsync().then(() => {
              this.trackTimeTo("canCreateShortcutAsync");
            }),
            this.checkCanPlayerMatchAsync().then(() => {
              this.trackTimeTo("checkCanPlayerMatchAsync");
            }),
            this.getEntryPointAsync().then(() => {
              this.trackTimeTo("getEntryPointAsync");
            }),
            this.getTournamentAsync()
              .then((e) => {
                this.entryContextTournament = e;
              })
              .catch(() => null)
              .then(() => {
                this.trackTimeTo("getTournamentAsync");
              }),
          ]);
        }
        async getFriendsAsync() {
          try {
            await this.getPlayersAsync(), this.resolveFriendsAvailable();
          } catch (e) {
            this.rejectFriendsAvailable(e);
          }
          return this.friends;
        }
        async getPlayersAsync() {
          if (this.friends.length > 0) return this.friends;
          const e = (e, t, n) => {
              const r = new Pr([e, t, n || nc]);
              (r.isPlayer = !0),
                this.friendIds.push(r.id),
                this.friends.push(r),
                (this.friendsMap[e] = r);
            },
            t = Cn();
          if (t.friends) {
            const n = t.friends.split(",");
            for (const t of n) {
              if (t === this.playerID)
                throw Error(
                  "Invalid friends query parameter value ".concat(
                    t,
                    ": cannot equal player ID"
                  )
                );
              const n = Ir.player[t];
              e(...(n ? [t, n.name, n.photo] : [t, t, nc]));
            }
            return this.friends;
          }
          for (const s in Ir.player)
            if (s !== this.playerID) {
              const t = Ir.player[s];
              e(s, t.name, t.photo);
            }
          const n = this.playerID in Ir.player,
            r = (function (e) {
              const t = u.Lr.getItem(Ba + ":" + e);
              return t ? JSON.parse(t) : void 0;
            })(rc);
          return (
            n && r && "string" === typeof r && e(r, "Test Name " + r),
            this.friends
          );
        }
        getSignedPlayerInfoAsync(e) {
          const t = new ka();
          return (
            (t.payload = e),
            (t.playerId = this.playerID),
            (t.signature =
              this._gameConfig.mockSignature ||
              [
                btoa(JSON.stringify({ alg: "HS256", typ: "JWT" })),
                btoa(
                  JSON.stringify({ issued_at: Math.floor(Nn.getNow() / 1e3) })
                ),
                btoa("mock-signature"),
              ].join(".")),
            Promise.resolve(t)
          );
        }
        isContextSizeBetween(e, t) {
          if (!this._context) return null;
          null === t && (t = 1 / 0);
          const n = { answer: !1, minSize: e, maxSize: t },
            r = this._context.players.length;
          return (n.answer = r >= e && r <= t), n;
        }
        async chooseContextAsync(e) {
          var t;
          null == (t = this.beforeContextSwitchCallback) || t.call(this);
          const n = await Or(this),
            r =
              "single" === n.type
                ? Rr.single(n.friend, this.playerID)
                : "group" === n.type
                ? Rr.group(n.players, n.id)
                : "tournament" === n.type
                ? Rr.tournament(n.id)
                : (function (e) {
                    throw new Error("Invalid value: ".concat(e));
                  })(n);
          this.updateContext("ChooseAsync", r),
            this.contextID &&
              this.contextID.startsWith("tournament") &&
              (await this.getTournamentAsync());
        }
        async createContextAsync(e) {
          var t;
          null == (t = this.beforeContextSwitchCallback) || t.call(this);
          const n = await Cr(e, this);
          if (!n) throw Sr("INVALID_PARAM");
          const r = Rr.single(n, this.playerID);
          if (this.contextID === r.id) throw Sr("SAME_CONTEXT");
          this.updateContext("CreateAsync", r);
        }
        switchContextAsync(e) {
          var t;
          return (
            null == (t = this.beforeContextSwitchCallback) || t.call(this),
            Br(e, this).then(
              (e) => (
                this.updateContext("SwitchAsync", e),
                this.contextID && this.contextID.startsWith("tournament")
                  ? this.getTournamentAsync().then(() => null)
                  : null
              )
            )
          );
        }
        checkCanPlayerMatchAsync() {
          return Promise.resolve(!0);
        }
        matchPlayerAsync(e, t, n) {
          var r;
          return (
            null == (r = this.beforeContextSwitchCallback) || r.call(this),
            Nr()
              .then(() => Dr())
              .then((e) => (this.updateContext("MatchPlayerAsync", e), null))
          );
        }
        getContextPlayersAsync() {
          return this._context
            ? Promise.resolve(this._context.players)
            : Promise.reject(new Error("INVALID_OPERATION"));
        }
        setSessionData(e) {}
        purchaseAsync(e, t) {
          var n = this;
          if (!this._onProvisionProductAsync)
            return Promise.reject(new Error(Qa.ERROR_NO_PROVISION));
          const r = this._getProduct(e);
          if (!r)
            return (
              console.log(
                "Product ".concat(
                  e,
                  " not found - did you populate Platform.catalog?"
                )
              ),
              Promise.resolve()
            );
          const s = {
            developerPayload: t,
            paymentID: "",
            productID: e,
            purchaseTime: Math.floor(Date.now() / 1e3).toString(),
            purchaseToken: Math.random().toString(36).substring(7),
            signedRequest: "",
          };
          s.signedRequest = JSON.stringify(s);
          const i = (function (e, t, n) {
            const r = (null == t ? void 0 : t.currencyCode) || "",
              s = $a((null == t ? void 0 : t.price) || ""),
              i = n({ amount: s, fromCurrency: r, toCurrency: "USD" });
            return {
              ...e,
              revenueGrossLocal: s,
              revenueGrossUSD: null == i ? void 0 : i.result,
              dollarToLocalRate: null == i ? void 0 : i.exchangeRate,
            };
          })(
            {
              platform: "fb",
              payload: (o = s).developerPayload,
              id: o.paymentID,
              productID: o.productID,
              timestamp: o.purchaseTime,
              token: o.purchaseToken,
              signedRequest: o.signedRequest,
              returnCode: o.returnCode,
              currency: o.currency,
              amount: o.amount,
              rawData: o,
            },
            r,
            function () {
              return n.convertCurrency(...arguments);
            }
          );
          var o;
          return Mr(r)
            .then(() =>
              this._onProvisionProductAsync(i, r, { consumedAtLaunch: !1 })
            )
            .then((e) => ({ purchase: i, product: r, result: e }));
        }
        shareAsync(e) {
          return (
            console.log("GCInstant.shareAsync()", e),
            this._setContextTournament(null),
            jr(e.image)
          );
        }
        async getSquadAsync(e) {
          let t = e;
          t.startsWith("squad:") && (t = t.substring(t.indexOf(":") + 1));
          const n = this.getSquadById(t);
          return (
            n.getContextID() === this.contextID && this._setContextSquad(n), n
          );
        }
        async createSquadAsync() {
          await Ur();
          const e = this.getSquadById(this.playerID);
          return (
            this.updateContext("CreateSquadAsync", Rr.squad(e.getID())),
            this._setContextSquad(e),
            e
          );
        }
        postSessionScoreAsync(e) {
          if (e < 1 || !Number.isInteger(e))
            throw Error("Score must be a positive integer");
          return (
            console.log("GCInstant.postSessionScoreAsync(", e, ")"),
            this.contextID && this.contextID.startsWith("tournament")
              ? this.getTournamentAsync()
                  .then(() => Wn(500))
                  .then(() => Lr())
              : Promise.resolve()
                  .then(() => Wn(500))
                  .then(() => {
                    const e = Rr.tournament();
                    this.updateContext("PostSessionScoreAsync", e);
                  })
                  .then(() => Wn(500))
                  .then(() => this.getTournamentAsync())
                  .then(() => Wn(500))
                  .then(() => Lr())
          );
        }
        async getTournamentAsync() {
          return new Promise((e, t) => {
            const n = Math.floor(Nn.getNow() / 1e3 / 3600);
            if (!this.contextID || !this.contextID.startsWith("tournament"))
              return (
                this._setContextTournament(null),
                void t(Sr("TOURNAMENT_NOT_FOUND"))
              );
            const [r, s] = this.contextID.split(":"),
              i = s || "" + n;
            this._setContextTournament({
              getContextID: () => "tournament:" + i,
              getEndTime: () => 3600 * n + 7200,
              getTitle: () => "",
              getPayload: () => Promise.resolve(void 0),
            }),
              e(this.contextTournament);
          });
        }
        async createTournamentAsync(e) {
          var t;
          console.log(
            "GCInstant.createTournamentAsync({",
            "initialScore: ".concat(e.initialScore, ","),
            "title: ".concat(e.title),
            "})"
          ),
            null == (t = this.beforeContextSwitchCallback) || t.call(this),
            await Wn(500);
          const n = Rr.tournament();
          this.updateContext("CreateTournamentAsync", n), await Wn(500);
          const r = await this.getTournamentAsync();
          return await Wn(500), await Lr(), r;
        }
        async shareTournamentAsync(e) {
          console.log("GCInstant.shareTournamentAsync(", e.score, ")"),
            await Wn(500);
          const t = await this.getTournamentAsync();
          return await Wn(500), await Lr(), t;
        }
        postTournamentScoreAsync(e, t) {
          if (e < 1 || !Number.isInteger(e))
            throw Error("Score must be a positive integer");
          return (
            console.log("GCInstant.postTournamentScoreAsync(", e, ")"),
            this.contextID && this.contextID.startsWith("tournament")
              ? this.getTournamentAsync().then(() => {
                  Wn(500);
                })
              : Promise.resolve()
                  .then(() => Wn(500))
                  .then(() => {
                    const e = Rr.tournament();
                    this.updateContext("PostTournamentScoreAsync", e);
                  })
                  .then(() => Wn(500))
                  .then(() => this.getTournamentAsync())
                  .then(() => {
                    Wn(500);
                  })
          );
        }
        async createNativeBridge(e, t, n) {
          await Wn(500);
        }
        async initializeNativeBridge(e, t) {
          await Wn(500);
        }
        getSquadById(e) {
          const t = {
            getContextID: () => "squad:".concat(e),
            getID: () => e,
            getName: () => "Squad ".concat(e),
            getImage: () =>
              "https://storage.googleapis.com/devkit-instant/avatar/animal_0001.png",
            joinSquadAsync: async () => {
              await Fr(t.getID(), this.playerPhoto),
                this.updateContext("JoinSquadAsync", Rr.squad(e)),
                this._setContextSquad(t);
            },
          };
          return t;
        }
      };
      var oc = Object.defineProperty,
        ac = (e, t, n) => (
          ((e, t, n) => {
            t in e
              ? oc(e, t, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: n,
                })
              : (e[t] = n);
          })(e, "symbol" !== typeof t ? t + "" : t, n),
          n
        );
      class cc extends Qa {
        constructor() {
          super("telegram"), ac(this, "telegramAuthorizationData");
        }
        getTelegramAuthorizationData() {
          return this.throwIfNotInitialized(), this.telegramAuthorizationData;
        }
        async initializeAsync(e) {
          return (
            null == this._initialization &&
              (this._initialization = this.doInit(e)),
            this._initialization
          );
        }
        async doInit(e) {
          var t = this;
          this.readConfiguration(e),
            pr.initialize({
              ...this._gameConfig,
              appID: this.appID,
              convertCurrency: function () {
                return t.convertCurrency(...arguments);
              },
            });
          try {
            if (
              ("undefined" === typeof Telegram &&
                (await new Promise((e, t) => {
                  const n = document.createElement("script");
                  (n.src = "https://telegram.org/js/telegram-web-app.js"),
                    n.addEventListener("load", () => {
                      e();
                    }),
                    n.addEventListener("error", (e) => {
                      t(e.error);
                    }),
                    document.body.appendChild(n);
                })),
              "undefined" === typeof Telegram)
            )
              throw new Error("Telegram SDK is not available");
            const e = Telegram.WebApp.initDataUnsafe,
              t = e.user;
            if (!t) throw new Error("Telegram user is not authenticated");
            await this._initialize("" + t.id),
              t.first_name && (this.playerName = t.first_name),
              t.photo_url && (this.playerPhoto = t.photo_url),
              t.language_code && (this.platformLocale = t.language_code),
              (this.telegramAuthorizationData = {
                auth_date: "" + e.auth_date,
                first_name: e.user.first_name,
                hash: e.hash,
                id: "" + e.user.id,
                last_name: e.user.last_name,
                photo_url: e.user.photo_url,
                username: e.user.username,
              });
          } catch (n) {
            throw (
              ((function (e) {
                fr.pushError("PlatformInitFailed", e);
              })(n),
              n)
            );
          }
          this._setIsSubscribedToBot(!0),
            this.trackTimeTo("initializeAsync"),
            this.resolveFriendsAvailable(),
            (this.osType = l.os.isAndroid
              ? "ANDROID"
              : l.os.isIOS
              ? "IOS"
              : "WEB"),
            (this.isMobile = "WEB" !== this.osType);
        }
        async inviteAsync(e) {
          const t = (function (e) {
            const { sourceChainTimestamps: t, tournamentAPI: n, ...r } = e;
            return r;
          })(this._populateNotificationPayload(e.data, "INVITE"));
          return (
            (function (e) {
              fr.pushEvent("InviteAsync", e);
            })(t),
            zn(function () {
              return new Promise((e, t) => {
                Telegram.WebView.postEvent("share_game", (n) => {
                  n ? t(n) : e();
                });
              });
            })
              .then((e) => {
                let { requestMs: n } = e;
                !(function (e) {
                  fr.pushEvent("InviteAsyncSuccess", e);
                })({ ...t, requestMs: n });
              })
              .catch((e) => {
                let { error: n, requestMs: r } = e;
                return (
                  (function (e, t) {
                    fr.pushError("InviteAsyncFailure", e, t);
                  })(n, { ...t, requestMs: r }),
                  Promise.reject(n)
                );
              })
          );
        }
        async startGameAsyncInner() {
          Telegram.WebApp.ready(),
            this.trackTimeTo("startGameAsync"),
            await this._prepareEntryData();
          const e = new URL(location.href);
          e.searchParams.has("payload") &&
            (e.searchParams.delete("payload"),
            history.replaceState(null, "", e.href));
        }
        _getEntryPointDataForce() {
          const e = Telegram.WebApp.initDataUnsafe.start_param;
          if (e) return { $key: e };
          try {
            const { payload: e } = Cn();
            if (e) return JSON.parse(e);
          } catch (t) {
            ai(t, { rawPayload: window.location.search, type: "parseFailed" });
          }
          return {};
        }
      }
      function lc() {
        return Math.random().toString(36).slice(2);
      }
      function uc(e) {
        if ("line" !== e.gcinstant.platformID)
          throw Error("Invalid platform: " + e.gcinstant.platformID);
        !(async function (e) {
          const t = await e.replicantClientPromise,
            n = t.asyncGetters;
          if (!(null == n ? void 0 : n.lineGetDebugFriendCounts))
            return void console.error(
              "Replicant async getter `lineGetDebugFriendCounts` is undefined. Extend Replicant configuration with `extendReplicantConfigForAnalytics`."
            );
          await e.gcinstant.waitForFriends();
          const r = e.gcinstant.socialFriends.map((e) => e.id),
            s = e.gcinstant.friendIds.length,
            { playingFriendCount: i } = await n.lineGetDebugFriendCounts({
              socialFriendIds: r,
            });
          e.analytics.pushEvent("DebugFriendCounts", {
            socialFriendCount: r.length,
            linePlayingFriendCount: s,
            replicantPlayingFriendCount: i,
          });
        })(e);
      }
      function dc(e, t, n) {
        var r;
        const s =
            null !== (r = null == n ? void 0 : n.generatePayloadKey) &&
            void 0 !== r
              ? r
              : (function (e) {
                  let t = 0;
                  return () => {
                    const n = e();
                    return [
                      n.userId,
                      n.getChatbotSessionData().sessionId,
                      n.now(),
                      t++,
                      Math.random().toString(36).slice(2, 10),
                    ].join("-");
                  };
                })(e),
          i = {
            encode: (n) => {
              const r = e(),
                i = s(),
                o = Ln({ days: 365 });
              return (
                r.kvStore
                  .send(i, JSON.stringify(n), { expiresInMs: o })
                  .catch((e) => {
                    !(function (e, t, n) {
                      e.pushError("PayloadWriteFailure", t, n);
                    })(t, e, {
                      key: i,
                      channel: n.$channel,
                      feature: n.feature,
                      subFeature: n.$subFeature,
                      playerID: n.playerID,
                    });
                  }),
                {
                  $key: i,
                  $channel: n.$channel,
                  feature: n.feature,
                  $subFeature: n.$subFeature,
                  playerID: n.playerID,
                }
              );
            },
            decode: async (n) => {
              const r = e(),
                s = n.$key;
              if (s) {
                const e = parseInt(s.split("-")[2]),
                  o = e
                    ? Math.floor((r.now() - e) / 1e3 / 60 / 60 / 24)
                    : void 0,
                  a = {
                    key: s,
                    channel: n.$channel,
                    feature: n.feature,
                    subFeature: n.$subFeature,
                    playerID: n.playerID,
                    daysElapsed: o,
                  };
                try {
                  const e = await r.kvStore.get(s);
                  if (!e) return void hc(t, void 0, { ...a, type: "notFound" });
                  try {
                    return JSON.parse(e);
                  } catch (i) {
                    hc(t, i, { ...a, type: "parseFailed" });
                  }
                } catch (i) {
                  hc(t, i, { ...a, type: "kvStoreFetchFailed" });
                }
              }
            },
          };
        return i;
      }
      function hc(e, t, n) {
        e.pushError("PayloadReadFailure", t, n);
      }
      function pc(e) {
        return { fn: e, type: "sync" };
      }
      function fc(e) {
        return { fn: e, type: "async" };
      }
      const mc = {
        gcinstant: _a.object({ platformStorage: _a.map(_a.unknown()) }),
      };
      _a.object(mc);
      const gc = (_a.object(mc), (e) => e)({
        internalSetPlatformStorage: pc((e, t) => {
          e.gcinstant.platformStorage = t;
        }),
      });
      const vc = (_a.unknown(), (e) => e)({
        internalSetWebPushSubscription: pc((e, t, n) => {
          n.chatbot.setWebPushSubscription(t.pushSubscription);
        }),
      });
      function yc() {
        return (
          arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : Math.random
        )()
          .toString(36)
          .substr(2, 9);
      }
      function bc(e) {
        return (
          !!e &&
          "object" === typeof e &&
          "then" in e &&
          "function" === typeof e.then
        );
      }
      function wc(e) {
        throw new Error("Invalid value: '".concat(e, "'"));
      }
      function Sc(e) {
        let {
          days: t = 0,
          hours: n = 0,
          minutes: r = 0,
          seconds: s = 0,
          ms: i = 0,
        } = e;
        const o = 36e5;
        return i + 1e3 * s + 6e4 * r + n * o + 864e5 * t;
      }
      const _c = "ChatbotMessageSuccess",
        Ec = "ChatbotMessageFailure",
        Ac = "PushNotificationSuccess",
        Tc = "PushNotificationFailure",
        Pc = "ChatbotSubscribe",
        Ic = "ChatbotUnsubscribe",
        Cc = "ChatbotWebhook",
        kc = "OTPVerificationSuccess",
        Oc = "OTPVerificationFailure";
      let xc = 0;
      function Nc(e, t) {
        return e + "-" + t + "-" + Date.now() + "-" + xc++ + "-" + yc();
      }
      class Rc extends Error {
        constructor(e, t) {
          super("Analytics Error: " + e),
            (this.name = "Analytics"),
            (this.eventNames = t.map((e) => e.event_type));
        }
      }
      const Dc = _a
          .union([_a.string(), _a.unknown()])
          .customValidator((e) =>
            null !== e && "string" !== typeof e
              ? "Not a string or null: " + e
              : null
          ),
        Mc = _a
          .object({
            $channel: _a.string(),
            feature: _a.string(),
            $subFeature: Dc,
          })
          .additionalProperties(),
        jc = {
          AFTER_CONTEXT_SWITCH: "afterContextSwitch",
          OAUTH_GET_ACCESS_TOKEN: "oauth/getAccessToken",
          REPLICATE: "replicate",
          LOGIN_OR_CREATE: "loginOrCreate",
          LOGIN_OR_CREATE_WEB_PLAYER: "loginOrCreateWebPlayer",
          TELEGRAM_WEBHOOK: "telegramWebhook",
          TOKEN: "token",
          TOKEN_WEB_PLAYER: "tokenWebPlayer",
          FETCH_STATES: "fetchStates",
          ASYNC_GETTER: "asyncGetter",
          FB_WEBHOOK: "fbwebhook",
          UPLOAD_USER_ASSET: "userAsset",
          READ_KEY_VALUES: "kv/read",
          WRITE_KEY_VALUES: "kv/write",
          READ_INTERNAL_KEY_VALUES: "ikv/read",
          IOS_POST_APN: "iosPostApn",
          ANDROID_POST_PUSH_NOTIFICATION: "androidPushFcm",
          PUSH_NOTIFICATION: "pushNotification",
          FB_MESSAGING_REFERRALS: "fbmessaging_referrals",
          USER_DATA_DELETE: "deletion",
          ATONE_WEBHOOK: "atoneWebhook",
          KOMOJU_WEBHOOK: "komojuWebhook",
          XSOLLA_WEBHOOK: "xsollaWebhook",
          LINE_WEBHOOK: "line-webhook",
          INFER_GENDER_FROM_NAME: "inferGenderFromName",
          OTP_INITIATE_ADD_RECEIVER: "otpInitiateAddReceiver",
          OTP_INITIATE_LOGIN: "otpInitiateLogin",
          SOCIAL_GRAPH_UPDATE_SELF: "socialGraphUpdateSelf",
          SOCIAL_GRAPH_TRACK_INTERACTIONS: "socialGraphTrackInteractions",
          STRIPE_WEBHOOK: "stripe_webhook",
          ZOOM_WEBHOOK: "zoomWebhook",
        },
        Lc = _a.object({
          alert: _a.union([
            _a.string(),
            _a.object({
              title: _a.string(),
              subtitle: _a.string().optional(),
              body: _a.string(),
              "launch-image": _a.string().optional(),
            }),
          ]),
          badge: _a.number().optional(),
          sound: _a.string().optional(),
        }),
        Uc = _a.object({
          title: _a.string(),
          icon: _a.string(),
          color: _a.string().optional(),
          body: _a.string().optional(),
          sound: _a.string().optional(),
        }),
        Fc = {
          _healthcheck: Vc(null),
          [jc.AFTER_CONTEXT_SWITCH]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string(),
              contextSwitchEventId: _a.string(),
            })
          ),
          [jc.OAUTH_GET_ACCESS_TOKEN]: qc(
            _a.object({
              code: _a.string(),
              clientId: _a.string().optional(),
              redirectUri: _a.string().optional(),
            })
          ),
          [jc.LOGIN_OR_CREATE]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              onLoginActionArgs: _a.unknown(),
              prefetchKeys: _a.array(_a.string()).optional(),
              prefetchInternalKeys: _a.array(_a.string()).optional(),
              sessionName: _a.string().optional(),
              sid: _a.string(),
              skipOnLoginAction: _a.boolean().optional(),
            })
          ),
          [jc.LOGIN_OR_CREATE_WEB_PLAYER]: qc(
            _a.object({
              clientAppName: _a.string().optional(),
              id: _a.string().optional(),
              auth: _a.string().optional(),
              loginToken: _a
                .object({ token: _a.string(), userId: _a.string() })
                .optional(),
              onLoginActionArgs: _a.unknown(),
              otp: _a
                .object({ code: _a.string(), verificationId: _a.string() })
                .optional(),
              prefetchKeys: _a.array(_a.string()).optional(),
              prefetchInternalKeys: _a.array(_a.string()).optional(),
              sessionName: _a.string().optional(),
              sid: _a.string(),
              skipOnLoginAction: _a.boolean().optional(),
            })
          ),
          [jc.REPLICATE]: qc(
            _a.object({
              abTestsDynamicConfig: _a.map(
                _a.object({
                  active: _a.boolean(),
                  rollOut: _a.number(),
                  stopAssignment: _a.boolean().optional(),
                })
              ),
              id: _a.string(),
              auth: _a.string().optional(),
              queue: _a.array(
                _a
                  .object({
                    fn: _a.string(),
                    args: _a.unknown().optional(),
                    async: _a.boolean(),
                    meta: _a.object({ now: _a.number() }).optional(),
                  })
                  .customValidator((e) =>
                    e.async && !e.meta
                      ? "Client time must be provided for async actions."
                      : null
                  )
              ),
              rev: _a.number(),
              clientRandomSeed: _a.number(),
              requestedProfileIds: _a.array(_a.string()).optional(),
              consistentFetchIds: _a.array(_a.string()),
              sessionName: _a.string().optional(),
              sid: _a.string(),
              crqid: _a.string(),
            })
          ),
          [jc.FETCH_STATES]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              ids: _a.array(_a.string()),
              consistentFetchIds: _a.array(_a.string()),
              friendRevs: _a.map(_a.number()),
            })
          ),
          [jc.ASYNC_GETTER]: qc(
            _a.object({
              id: _a.string(),
              sid: _a.string(),
              auth: _a.string().optional(),
              name: _a.string(),
              args: _a.unknown(),
              consistentFetchIds: _a.array(_a.string()),
            })
          ),
          [jc.FB_WEBHOOK]: Hc({ get: null, post: _a.map(_a.unknown()) }),
          [jc.TELEGRAM_WEBHOOK]: qc(_a.unknown()),
          [jc.USER_DATA_DELETE]: Hc({
            get: _a.object({ id: _a.string(), fbclid: _a.string().optional() }),
            post: null,
          }),
          [jc.UPLOAD_USER_ASSET]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              dataUrl: _a.string(),
            })
          ),
          [jc.READ_KEY_VALUES]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              keys: _a.array(_a.string()),
            })
          ),
          [jc.WRITE_KEY_VALUES]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              pairs: _a.map(_a.string()),
              opts: _a.object({ expiresInMs: _a.int().optional() }).optional(),
            })
          ),
          [jc.READ_INTERNAL_KEY_VALUES]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              keys: _a.array(_a.string()),
            })
          ),
          admin: qc(
            _a.object({
              auth: _a.string(),
              action: _a.string(),
              args: _a.unknown(),
            })
          ),
          "ios-bridge": Hc({
            get: _a.object({
              auth: _a.string(),
              id: _a.string(),
              uuid: _a.string(),
            }),
            post: _a.object({
              auth: _a.string(),
              id: _a.string(),
              uuid: _a.string(),
              payload: _a.string(),
            }),
          }),
          [jc.IOS_POST_APN]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              receiverId: _a.string(),
              notification: Lc,
              payload: Mc,
              imageUrl: _a.string().optional(),
              analyticsUserProps: _a.map(_a.unknown()).optional(),
            })
          ),
          [jc.ANDROID_POST_PUSH_NOTIFICATION]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              receiverId: _a.string(),
              notification: Uc,
              payload: Mc,
              imageUrl: _a.string().optional(),
              analyticsUserProps: _a.map(_a.unknown()).optional(),
            })
          ),
          [jc.PUSH_NOTIFICATION]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string().optional(),
              receiverId: _a.string(),
              notifications: _a.object({ ios: Lc, android: Uc }),
              payload: Mc,
              imageUrl: _a.string().optional(),
              analyticsUserProps: _a.map(_a.unknown()).optional(),
            })
          ),
          [jc.ATONE_WEBHOOK]: qc(_a.unknown()),
          [jc.KOMOJU_WEBHOOK]: qc(_a.unknown()),
          [jc.XSOLLA_WEBHOOK]: qc(_a.unknown()),
          [jc.LINE_WEBHOOK]: qc(
            _a.object({
              destination: _a.string(),
              events: _a.array(_a.unknown()),
            })
          ),
          [jc.TOKEN]: qc(
            _a.object({ id: _a.string(), auth: _a.string().optional() })
          ),
          [jc.TOKEN_WEB_PLAYER]: qc(
            _a.object({ id: _a.string(), auth: _a.string() })
          ),
          [jc.INFER_GENDER_FROM_NAME]: qc(
            _a.object({ id: _a.string(), auth: _a.string(), name: _a.string() })
          ),
          [jc.OTP_INITIATE_ADD_RECEIVER]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string(),
              consentText: _a
                .string()
                .customValidator((e) =>
                  0 === e.length ? "Value must be a non-empty string" : null
                ),
              receiver: _a.string(),
              templateId: _a.string().optional(),
              type: _a.tuple(["sms"]),
            })
          ),
          [jc.OTP_INITIATE_LOGIN]: qc(
            _a.object({
              clientAppName: _a.string().optional(),
              additionalTemplateData: _a.map(_a.string()).optional(),
              receiver: _a.string(),
              templateId: _a.string().optional(),
              type: _a.tuple(["sms"]),
            })
          ),
          [jc.SOCIAL_GRAPH_UPDATE_SELF]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string(),
              nonPlayerFriendIds: _a.array(_a.string()),
              meta: _a.map(_a.unknown()),
            })
          ),
          [jc.STRIPE_WEBHOOK]: qc(_a.unknown()),
          [jc.SOCIAL_GRAPH_TRACK_INTERACTIONS]: qc(
            _a.object({
              id: _a.string(),
              auth: _a.string(),
              interactions: _a.array(
                _a.object({
                  receiverId: _a.string(),
                  timestamp: _a.int(),
                  type: _a.string(),
                  meta: _a.map(_a.unknown()),
                })
              ),
            })
          ),
          [jc.ZOOM_WEBHOOK]: qc(_a.map(_a.unknown())),
        },
        Bc = {
          ...{
            nukeUser: Vc(
              _a.object({ id: _a.string(), secret: _a.tuple(["iamsure"]) })
            ),
            nukeDB: Vc(_a.object({ secret: _a.tuple(["iamsupersure"]) })),
            testUsers: qc(
              _a.object({
                id: _a.string(),
                auth: _a.string().optional(),
                states: _a.map(_a.unknown()),
              })
            ),
          },
          ...Fc,
        };
      function Vc(e) {
        return { get: { schema: e } };
      }
      function qc(e) {
        return { post: { schema: e } };
      }
      function Hc(e) {
        return { ...Vc(e.get), ...qc(e.post) };
      }
      function Wc(e) {
        const { apiAccess: t, delayedActions: n, id: r, sessionId: s } = e;
        return {
          reportError: (e, r) =>
            n.push({
              type: "action",
              action: () => t.reportError(e, r),
              apiMethodName: "api.reportError",
            }),
          sendAnalyticsEvents: (e) => {
            const t = [];
            for (const n of e)
              t.push({
                user_id: n.userId || r,
                event_type: n.eventType,
                event_properties: n.eventProperties,
                user_properties: n.userProperties,
                insert_id: Nc(r, s),
                time: n.time,
              });
            n.push({ type: "sendAnalyticsEvents", events: t });
          },
        };
      }
      const Kc = "_heartbeat",
        zc = "_applyMessages",
        Gc = 1e5,
        Jc = Sc({ seconds: 30 }),
        Qc = Sc({ seconds: 90 }),
        Yc = Sc({ minutes: 30 }),
        Xc = Sc({ seconds: 30 }),
        Zc = "psid_",
        $c = {
          network_error: "network_error",
          replication_error: "replication_error",
          version_error: "version_error",
          session_desync_error: "session_desync_error",
          authorization_error: "authorization_error",
          server_error: "server_error",
          unknown_error: "unknown_error",
        },
        el = {
          audience_mismatch: "audience_mismatch",
          id_mismatch: "id_mismatch",
          invalid_platform: "invalid_platform",
          invalid_otp_code: "invalid_otp_code",
          invalid_otp_receiver: "invalid_otp_receiver",
          invalid_scope: "invalid_scope",
          invalid_signature: "invalid_signature",
          token_expired: "token_expired",
        },
        tl = {
          ...el,
          action_args_too_large: "action_args_too_large",
          analytics_extra_properties_error: "analytics_extra_properties_error",
          db_error: "db_error",
          exceeded_message_reduction_threshold:
            "exceeded_message_reduction_threshold",
          gender_inference_error: "gender_inference_error",
          inapplicable_diff: "inapplicable_diff",
          index_doc_too_large: "index_doc_too_large",
          invalid_ecpm: "invalid_ecpm",
          invalid_state: "invalid_state",
          invalid_action: "invalid_action",
          invalid_message: "invalid_message",
          invalid_message_args: "invalid_message_args",
          invalid_state_after_message: "invalid_state_after_message",
          invalid_phone_number: "invalid_phone_number",
          lambda_high_memory_usage: "lambda_high_memory_usage",
          lambda_timeout: "lambda_timeout",
          message_args_too_large: "message_args_too_large",
          missing_messages: "missing_messages",
          client_time_invalid: "client_time_invalid",
          client_time_offset_too_large: "client_time_offset_too_large",
          random_seed_invalid: "random_seed_invalid",
          message_errored: "message_errored",
          async_action_api_error: "async_action_api_error",
          delayed_actions_error: "delayed_actions_error",
          async_getter_error: "async_getter_error",
          payment_signature_verification_error:
            "payment_signature_verification_error",
          payment_already_purchased_error: "payment_already_purchased_error",
          scheduled_action_args_too_large: "scheduled_action_args_too_large",
          shared_state_duplicate_id: "shared_state_duplicate_id",
          shared_state_too_large: "shared_state_too_large",
          unknown_message: "unknown_message",
          user_asset_upload_error: "user_asset_upload_error",
          scheduled_actions_error: "scheduled_actions_error",
          key_value_storage_error: "key_value_storage_error",
          admin_interface_error: "admin_interface_error",
          user_login_error: "user_login_error",
          payload_too_large: "payload_too_large",
          state_too_large: "state_too_large",
          rev_id_mismatch: "rev_id_mismatch",
          request_replayed: "request_replayed",
          retry_queue_mismatch: "retry_queue_mismatch",
          invoking_while_out_of_sync: "invoking_while_out_of_sync",
          push_notification_error: "push_notification_error",
          search_error: "search_error",
          ab_tests_error: "ab_tests_error",
          chatbot_receiver_not_found: "chatbot_receiver_not_found",
          chatbot_missing_player: "chatbot_missing_player",
          chatbot_missing_receiver: "chatbot_missing_receiver",
          chatbot_missing_sender: "chatbot_missing_sender",
          chatbot_missing_configuration: "chatbot_missing_configuration",
          chatbot_missing_asset: "chatbot_missing_asset",
          chatbot_missing_asset_url: "chatbot_missing_asset_url",
          chatbot_send_error: "chatbot_send_error",
          fb_comment_retrieval_error: "fb_comment_retrieval_error",
          webhook_authorization_failed: "webhook_authorization_failed",
          webhook_invalid_event: "webhook_invalid_event",
          webhook_referral_url_not_set: "webhook_referral_url_not_set",
          webhook_referral_player_not_found:
            "webhook_referral_player_not_found",
          webhook_postback_missing_params: "webhook_postback_missing_params",
          payment_subscription_invalid_otp: "payment_subscription_invalid_otp",
        };
      class nl extends Error {
        constructor(e, t, n, r, s, i) {
          super(e),
            (this.code = t),
            (this.subCode = n),
            (this.severity = r),
            (this.extras = s),
            (this.clientExtras = i),
            (this.name = "ReplicantError");
        }
      }
      function rl(e) {
        return new nl(
          "Action arguments size exceeds ".concat(
            Math.round(Gc / 1e3),
            " KB. Reduce arguments size to improve performance and to avoid hitting the database item limit."
          ),
          "server_error",
          "action_args_too_large",
          "warning",
          e
        );
      }
      function sl(e) {
        return new nl(
          "Index document size exceeds 200 KB. Reduce index document size to improve performance and to avoid hitting the 256KB hard limit.",
          "server_error",
          "index_doc_too_large",
          "warning",
          {
            description:
              "To reduce index document size either a) remove unused computed properties or b) shrink the indexed property values, for example by filter out old items in case of array properties.",
            docSize: e.docSize,
            sharedStateId: e.sharedStateId,
            userId: e.userId,
          }
        );
      }
      function il(e) {
        let t = 2166136261;
        if (e)
          for (let n = 0, r = e.length; n < r; n++) {
            t = (t ^ e.charCodeAt(n)) >>> 0;
            t =
              (t + ((t << 1) + (t << 4) + (t << 7) + (t << 8) + (t << 24))) >>>
              0;
          }
        return t;
      }
      function ol(e) {
        let t = e.v0,
          n = e.v1,
          r = 0;
        const s = 2654435769;
        (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >>> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >>> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >> 5))),
          (r += s),
          (t += (2738958700 + (n << 4)) ^ (n + r) ^ (3355524772 + (n >> 5))),
          (n += (2911926141 + (t << 4)) ^ (t + r) ^ (2123724318 + (t >> 5))),
          (e.v0 = t),
          (e.v1 = n);
      }
      function al(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        "string" === typeof e && (e = 0 | il(e));
        const n = { v0: e, v1: t };
        return ol(n), (16777215 & n.v0) / 16777216;
      }
      function cl(e, t) {
        const n = { v0: il(e), v1: t.n++ };
        return ol(n), (16777215 & n.v0) / 16777216;
      }
      function ll(e, t) {
        return t
          ? e.filter((n, r) => {
              const s = t(n);
              return e.findIndex((e) => t(e) === s) === r;
            })
          : e.filter((t, n) => e.indexOf(t) === n);
      }
      function ul(e, t) {
        for (let n = e.length - 1; n >= 0; n--) if (t(e[n])) return n;
        return -1;
      }
      function dl(e, t) {
        const n = {};
        for (const r of e) {
          const e = t(r);
          n[e] || (n[e] = []), n[e].push(r);
        }
        return n;
      }
      function hl(e, t) {
        const n = [],
          r = [];
        for (const s of e) t(s) ? n.push(s) : r.push(s);
        return [n, r];
      }
      const pl = _a.object({
          newUsersOnly: _a.boolean().optional(),
          assignManually: _a.boolean().optional(),
          assignIf: _a.unknown().optional(),
          dependsOn: _a.map(_a.array(_a.string())).optional(),
          buckets: _a
            .array(
              _a.object({
                id: _a.string(),
                weight: _a.number().min(0).optional(),
              })
            )
            .minLength(1)
            .customValidator((e) => {
              const [t, n] = hl(e, (e) => !!e && void 0 === e.weight);
              return t.length && n.length
                ? "Cannot mix weighted and non-weighted buckets"
                : null;
            }),
        }),
        fl = _a.object({ abTests: _a.map(pl).optional() });
      function ml(e, t, n) {
        const r = n[t].buckets,
          s = void 0 !== r[0].weight,
          i = al("".concat(e, "_").concat(t), 0);
        if (s) {
          let e = i * r.reduce((e, t) => e + t.weight, 0);
          for (let t = r.length - 1; t >= 0; t--) {
            const n = r[t];
            if (((e -= n.weight), e <= 0)) return n.id;
          }
          return r[0].id;
        }
        return r[Math.floor(i * r.length)].id;
      }
      function gl(e, t, n) {
        const r = t ? " to bucket '".concat(t, "'") : "";
        throw new nl(
          "Cannot assign test '".concat(e, "' to '").concat(r, "': ").concat(n),
          "replication_error",
          "ab_tests_error"
        );
      }
      function vl(e, t) {
        throw new nl(
          "Cannot unassign test '".concat(e, "': ").concat(t),
          "replication_error",
          "ab_tests_error"
        );
      }
      class yl {
        constructor(e) {
          this.opts = e;
        }
        getBucketID(e, t) {
          var n;
          return null === (n = e.abTestAssignments) ||
            void 0 === n ||
            null === (n = n[t]) ||
            void 0 === n
            ? void 0
            : n.bucketId;
        }
        assign(e, t, n, r) {
          const s = this.opts.abTests;
          s || gl(n, r, "No ab tests have been configured."),
            s[n] || gl(n, r, "Not configured.");
          const i = this.opts.dynamicConfig[n];
          if (null === i || void 0 === i || !i.active) return;
          if (null !== i && void 0 !== i && i.stopAssignment) return;
          if (!Sl({ rollOut: i.rollOut, testId: n, userId: t })) return;
          r || (r = ml(t, n, s)),
            s[n].buckets.find((e) => e.id === r) || gl(n, r, "Invalid bucket."),
            e.abTestAssignments || (e.abTestAssignments = {});
          const o = e.abTestAssignments[n],
            a = (() => {
              const e = null === o || void 0 === o ? void 0 : o.type;
              switch (e) {
                case "automatic":
                  return "manual-active";
                case "manual-active":
                case "manual-inactive":
                  return e;
                case void 0:
                  return "manual-inactive";
                case "stopped":
                  throw Error(
                    "A/B test `stopped` type should not be stored in metainfo"
                  );
                default:
                  wc(e);
              }
            })();
          e.abTestAssignments[n] = { ...o, bucketId: r, type: a };
        }
        unassign(e, t, n) {
          var r;
          const s = e.abTestAssignments;
          s || vl(n, "No tests assigned.");
          const i = s[n];
          i || vl(n, "Test not assigned.");
          var o;
          (null === (r = this.opts.dynamicConfig[n]) || void 0 === r
            ? void 0
            : r.stopAssignment) &&
            (null === (o = e.abTestAssignments) || void 0 === o || delete o[n]);
          switch (i.type) {
            case "automatic":
              break;
            case "manual-active": {
              const e = this.opts.abTests;
              e || vl(n, "No ab tests have been configured.");
              const r = ml(t, n, e);
              e[n].buckets.find((e) => e.id === r) ||
                gl(n, r, "Invalid bucket."),
                (i.bucketId = r);
              break;
            }
            case "manual-inactive":
              var a;
              null === (a = e.abTestAssignments) || void 0 === a || delete a[n];
              break;
            case "stopped":
              throw Error(
                "A/B test `stopped` type should not be stored in metainfo"
              );
            default:
              throw wc(i.type);
          }
        }
      }
      function bl(e) {
        const t = [
            ...Object.keys(e.newAssignments),
            ...Object.keys(e.oldAssignments),
          ],
          n = t.filter((e, n) => t.indexOf(e) === n);
        return n
          .map((t) => {
            const n = e.newAssignments[t],
              r = e.oldAssignments[t];
            return {
              testId: t,
              bucketId: null === n || void 0 === n ? void 0 : n.bucketId,
              previousBucketId:
                null === r || void 0 === r ? void 0 : r.bucketId,
              newUsersOnly:
                !(null === n || void 0 === n || !n.newUsersOnly) &&
                "automatic" === (null === n || void 0 === n ? void 0 : n.type),
            };
          })
          .filter((e) => {
            let { bucketId: t, previousBucketId: n } = e;
            return t !== n;
          });
      }
      function wl(e) {
        return e.startsWith("0000_placebo");
      }
      function Sl(e) {
        const t = al("".concat(e.userId, "_").concat(e.testId, "_roll_out"));
        return e.rollOut > t;
      }
      const _l = [
        "id",
        "createdAt",
        "updatedAt",
        "ruleset",
        "userSharedStates",
      ];
      function El(e, t, n) {
        return (
          Object.defineProperties(e, {
            id: { value: t.id, configurable: !0, enumerable: !0, writable: !0 },
            createdAt: {
              value: t.createdAt,
              configurable: !0,
              enumerable: !0,
              writable: !0,
            },
            updatedAt: {
              value: t.updatedAt,
              configurable: !0,
              enumerable: !0,
              writable: !0,
            },
            ruleset: {
              get: () => Il(t.metainfo),
              configurable: !0,
              enumerable: !0,
            },
            userSharedStates: {
              get: () => Pl(n.sharedStates, t.userSharedStates),
              configurable: !0,
              enumerable: !0,
            },
          }),
          e
        );
      }
      function Al(e, t, n) {
        return (
          Object.defineProperties(e, {
            id: { value: t.id, configurable: !0, enumerable: !1, writable: !0 },
            createdAt: {
              value: t.createdAt,
              configurable: !0,
              enumerable: !1,
              writable: !0,
            },
            updatedAt: {
              value: t.updatedAt,
              configurable: !0,
              enumerable: !1,
              writable: !0,
            },
            ruleset: {
              get: () => Il(t.metainfo),
              configurable: !0,
              enumerable: !1,
            },
            userSharedStates: {
              get: () => Pl(n.sharedStates, t.userSharedStates),
              configurable: !0,
              enumerable: !1,
            },
          }),
          e
        );
      }
      function Tl(e, t) {
        return {
          id: e,
          createdAt: t.createdAt,
          updatedAt: t.lastUpdated,
          userSharedStates: t.userSharedStates,
          metainfo: t.metainfo,
        };
      }
      function Pl(e, t) {
        const n = {};
        for (const s in e) {
          var r;
          if (null === (r = e[s]) || void 0 === r || !r.schema.user) continue;
          n[s] = {};
          const i = null === t || void 0 === t ? void 0 : t[s];
          for (const e in i) {
            const t = i[e];
            t && (n[s][e] = t.state);
          }
        }
        return n;
      }
      function Il(e) {
        var t;
        const n = Go(
          null !== (t = e.abTestAssignments) && void 0 !== t ? t : {},
          (e, t) => (t ? { bucketId: t.bucketId } : void 0)
        );
        return { abTests: n };
      }
      function Cl(e) {
        const {
            apiAccess: t,
            consistentFetchIds: n,
            entry: r,
            id: s,
            invokeTime: i,
            reportError: o,
            sendAnalyticsEvents: a,
            sessionId: c,
          } = e,
          l = r.metainfo.clockOffset || 0,
          u = {
            getOwnEntry: async () => {
              const t = Ho(r);
              return El(t.state, Tl(s, t), e.apiAccess.config), t;
            },
            id: s,
            sessionId: c,
            clockOffset: l,
            consistentFetchIds: n,
            dateNow: () => i,
            reportError: o,
            sendAnalyticsEvents: a,
          },
          d = {};
        for (const h in t.asyncGetters.asyncGetters) {
          const e = t.asyncGetters.asyncGetters[h];
          if ("function" === typeof e) d[h] = (t) => e(t, u);
          else {
            const t = {};
            for (const n in e) t[n] = (t) => e[n](t, u);
            d[h] = t;
          }
        }
        return d;
      }
      class kl extends Error {
        constructor(e, t) {
          super(e),
            (this.name = "ResponseError"),
            (this.responseBody = t.responseBody),
            (this.statusCode = t.statusCode),
            (this.url = t.url);
        }
        static async fromResponse(e, t) {
          let n = "";
          if ("text" in t)
            try {
              (n = await t.text()), (t.text = async () => n);
            } catch {}
          else n = t.body;
          const r = "status" in t ? t.status : t.statusCode,
            s = "".concat(e, ": ").concat(r, " ").concat(n);
          return new kl(s, { responseBody: n, statusCode: r, url: t.url });
        }
      }
      function Ol(e) {
        const {
          assetUploader: t,
          fetcher: n,
          telegramClient: r,
          userAssetsBaseUrl: s,
        } = e;
        return {
          async getProfilePictureUrl(e, i) {
            const o = await (async function (e, t) {
              const n = await r.getUserProfilePhotos({ userId: e }),
                [s, i] = {
                  "160x160": [160, 160],
                  "320x320": [320, 320],
                  "640x640": [640, 640],
                }[t];
              if (!s || !i) throw Error("Invalid size argument : ".concat(t));
              return (n || []).find((e) => e.width === s && e.height === i);
            })(e, i);
            if (!o) return;
            const a = "tg-profile-" + o.fileUniqueId,
              c = s + a;
            if (await t.assetExists(a)) return c;
            const { fileUrl: l } = await r.getFile(o.fileId),
              u = await n.fetch({
                binary: !0,
                method: "GET",
                url: l,
                timeout: 6e3,
                headers: {},
              });
            if (u.statusCode < 200 || u.statusCode >= 300)
              throw await kl.fromResponse(
                "Unexpected Telegram file API response",
                u
              );
            const d = Buffer.from(u.body, "binary"),
              h = (function (e) {
                const t = e.substr(e.lastIndexOf(".") + 1).toLowerCase();
                let n;
                if ("jpg" === t || "jpeg" === t) n = "image/jpeg";
                else if ("png" === t) n = "image/png";
                else if ("gif" === t) n = "image/gif";
                else if ("webp" === t) n = "image/webp";
                else {
                  if ("mp4" !== t)
                    throw new Error("Unsupported image extension: " + t);
                  n = "video/mp4";
                }
                return n;
              })(l);
            return (
              await t.uploadAsset({ assetId: a, body: d, contentType: h }), c
            );
          },
        };
      }
      function xl(e) {
        return {
          getProfilePictureUrl: () => {
            throw Error(
              null !== e && void 0 !== e
                ? e
                : "Configure the TELEGRAM_BOT_TOKEN environment variable to use `api.telegram.*`"
            );
          },
        };
      }
      const Nl = Sc({ days: 7 });
      function Rl(e, t) {
        const n = Math.random().toString().substr(2, 6);
        return [
          e + Math.floor(t / 1e3),
          (t % 1e3).toString().padStart(3, "0"),
          n.toString().padStart(6, "0"),
        ].join("");
      }
      async function Dl(e, t, n) {
        for (const r of e) {
          if (!r.args) continue;
          const e = JSON.stringify(r.args).length;
          if (e > Gc) {
            const s = new nl(
              "Message arguments size exceeds ".concat(
                Math.round(Gc / 1e3),
                " KB. Reduce arguments size to improve performance and to avoid hitting the database item limit."
              ),
              "server_error",
              "message_args_too_large",
              "warning",
              { argsSize: e, messageName: r.name, ...n }
            );
            await t.captureException(s, { user: { id: r.sender } });
          }
        }
      }
      function Ml(e, t) {
        const n = t.filter((e) => r(e));
        function r(t) {
          return t.timestamp + Nl < e;
        }
        const s = t.filter((e) => !r(e));
        if (s.length > 25)
          for (; s.length > 25; ) {
            const e = s.shift();
            n.push(e);
          }
        return n;
      }
      function jl(e, t) {
        var n;
        return !(
          null === e ||
          void 0 === e ||
          null === (n = e.recentMessageReductionLog) ||
          void 0 === n ||
          !n["" + t.id]
        );
      }
      function Ll(e, t, n) {
        var r;
        (t.recentMessageReductionLog = Object.entries(
          null !== (r = t.recentMessageReductionLog) && void 0 !== r ? r : {}
        ).reduce((t, n) => {
          let [r, s] = n;
          return s + Sc({ minutes: 1 }) > e && (t[r] = s), t;
        }, {})),
          n.forEach((n) => {
            t.recentMessageReductionLog[n.id] = e;
          });
      }
      function Ul(e, t, n) {
        const r = t.filter((t) => {
            if (Fl(t)) return !0;
            const r = Ko(e, t.name);
            if (!r)
              return null === n || void 0 === n || n.onUnknownMessage(t), !1;
            const s = r.schema.validate(t.args);
            return (
              !s || (null === n || void 0 === n || n.onInvalidArgs(t, s), !1)
            );
          }),
          s = [],
          i = [];
        for (const o of r) {
          Fl(o) &&
          !!o.lastAppliedMessageId &&
          r.find((e) => {
            let { id: t } = e;
            return t === o.lastAppliedMessageId;
          })
            ? i.push(o)
            : s.push(o);
        }
        for (const o of i) {
          const e = ul(
            s,
            (e) =>
              !!e &&
              (e.id === o.lastAppliedMessageId ||
                (Fl(e) && e.lastAppliedMessageId === o.lastAppliedMessageId))
          );
          if (-1 === e)
            throw Error(
              "Cannot find last applied message index for messages " +
                JSON.stringify(r)
            );
          s.splice(e + 1, 0, o);
        }
        return s;
      }
      function Fl(e) {
        return "event" in e;
      }
      function Bl(e, t) {
        return { schema: e, reducer: t };
      }
      function Vl(e) {
        const t = e.random().toString(36).substring(2);
        return ""
          .concat(e.userId, "-")
          .concat(e.stateName, "-")
          .concat(t, "-")
          .concat(e.now());
      }
      function ql(e) {
        return (
          !!e.schema.global &&
          Object.values(e.computedProperties || {}).some((e) => e._searchable)
        );
      }
      function Hl(e) {
        const t = {};
        for (const n in e.sharedState.messages)
          t[n] = (t, r) => {
            const s = Rl(
              e.dateNow() + e.getClockOffset(),
              e.delayedActions.length
            );
            e.delayedActions.push({
              type: "postSharedStateMessage",
              async: !!e.async,
              message: {
                id: s,
                args: r,
                sender: e.userId,
                name: n,
                senderClockOffset: e.getClockOffset(),
              },
              stateId: t,
              stateName: e.sharedStateName,
            });
          };
        return t;
      }
      class Wl {
        async fetch(e) {
          const t = await fetch(e.url, {
              method: e.method,
              headers: e.headers,
              body: "POST" === e.method ? e.body : null,
            }),
            n = await t.text(),
            r = {};
          return (
            t.headers.forEach((e, t) => (r[t] = e)),
            { body: n, headers: r, statusCode: t.status, url: e.url }
          );
        }
      }
      function Kl(e) {
        return e.purchaseHistory
          ? e.purchaseHistory.map((e) => {
              const t = { ...e };
              return (
                13 === e.purchase_time.toString().length
                  ? ((t.issued_at = Number(e.issued_at)),
                    (t.purchase_time = Number(e.purchase_time)))
                  : ((t.issued_at = 1e3 * Number(e.issued_at)),
                    (t.purchase_time = 1e3 * Number(e.purchase_time))),
                t
              );
            })
          : [];
      }
      function zl(e) {
        var t, n, r;
        const {
            apiAccess: s,
            id: i,
            entry: o,
            delayedActions: a,
            invokeTime: c,
            async: l,
            messages: u,
            consistentFetchIds: d,
            userAssetsBaseUrl: h,
          } = e,
          p = new yl({
            abTests:
              null !==
                (t =
                  null === (n = s.config.ruleset) || void 0 === n
                    ? void 0
                    : n.abTests) && void 0 !== t
                ? t
                : {},
            dynamicConfig: e.abTestsDynamicConfig,
          }),
          f = (function (e) {
            return async () => {
              const t = [],
                n = [];
              for (let r = e.delayedActions.length - 1; r >= 0; r--) {
                const s = e.delayedActions[r];
                if (
                  ("postMessage" === s.type ||
                    "postSharedStateMessage" === s.type) &&
                  s.async
                ) {
                  if ("postMessage" === s.type) {
                    const e = s.messages[0];
                    t.push({ ...s, messages: [{ ...e, skipIndexing: !0 }] }),
                      (e.skipDbWrite = !0);
                  } else (s.flushed = !0), n.push({ ...s, flushed: !1 });
                  const r = "postMessage" === s.type ? s.receiverId : s.stateId;
                  e.consistentFetchIds.includes(r) ||
                    e.consistentFetchIds.push(r);
                }
              }
              await Promise.all([
                e.apiAccess.resolveDelayedActions(t),
                e.apiAccess.sharedStates.resolveAllSharedStatesUpdates(n),
              ]);
            };
          })({ consistentFetchIds: d, delayedActions: a, apiAccess: s }),
          m = () => c,
          g = () => o.metainfo.clockOffset || 0,
          v = (function (e) {
            const {
                async: t,
                dateNow: n,
                delayedActions: r,
                getClockOffset: s,
                senderId: i,
                messages: o,
              } = e,
              a = {};
            if (!o) return a;
            function c(e, o) {
              return (a, c) => {
                o.schema.tryValidate(c);
                const l = Rl(n() + s(), r.length);
                r.push({
                  async: t,
                  type: "postMessage",
                  receiverId: a,
                  messages: [
                    {
                      id: l,
                      name: e,
                      args: c,
                      sender: i,
                      senderClockOffset: s(),
                    },
                  ],
                });
              };
            }
            for (const [l, u] of Object.entries(o))
              if ("isAdmin" in u && "schema" in u) {
                if (u.isAdmin) continue;
                a[l] = c(l, u);
              } else {
                const e = {};
                for (const [t, n] of Object.entries(u))
                  n.isAdmin || (e[t] = c("".concat(l, ".").concat(t), n));
                a[l] = e;
              }
            return a;
          })({
            senderId: i,
            dateNow: m,
            delayedActions: a,
            getClockOffset: g,
            async: !!l,
            messages: u,
          }),
          y = Wc({
            apiAccess: s,
            delayedActions: a,
            id: i,
            sessionId: e.sessionId,
          }),
          b = () => (l ? Math.random() : cl(i, o.metainfo.random)),
          w = (function (e) {
            if (!e.sharedStates) return {};
            const { entry: t, random: n, sharedStates: r, userId: s } = e,
              i = {};
            for (const o in r) {
              const a = o,
                c = r[a];
              i[a] = {
                create: (t) => {
                  if ("" === t)
                    throw Error(
                      "Invalid custom shared state ID: cannot be the empty string"
                    );
                  const r =
                    null !== t && void 0 !== t
                      ? t
                      : Vl({
                          userId: s,
                          now: e.dateNow,
                          random: n,
                          stateName: a,
                        });
                  return (
                    e.delayedActions.push({
                      type: "createSharedState",
                      stateId: r,
                      stateName: a,
                    }),
                    r
                  );
                },
                fetch: async (t) => {
                  const n = e.consistentFetchIds.includes(t),
                    r = await e.apiAccess.sharedStates.fetchSharedState({
                      stateName: a,
                      stateId: t,
                      consistentRead: n,
                    });
                  if (r) return { global: r.global, users: r.users };
                },
                fetchOrCreate: async (t) =>
                  e.apiAccess.sharedStates.fetchOrCreateSharedState({
                    stateId: t,
                    stateName: a,
                  }),
                setUserState: (n, r) => {
                  var i;
                  const o =
                      null === (i = t.userSharedStates[a]) ||
                      void 0 === i ||
                      null === (i = i[n]) ||
                      void 0 === i
                        ? void 0
                        : i.state,
                    c = e.apiAccess.sharedStates.setUserState({
                      entry: t,
                      state: r,
                      stateName: a,
                      stateId: n,
                      userId: s,
                    });
                  e.delayedActions.push({
                    type: "setUserSharedState",
                    previousStateValue: o ? JSON.stringify(o) : void 0,
                    stateId: n,
                    stateName: a,
                    userState: c,
                  });
                },
                deleteUserState: (n) => {
                  var r, i;
                  if (null === (r = e.sharedStates) || void 0 === r || !r[a])
                    throw Error(
                      "Cannot delete user shared state value for ".concat(
                        a,
                        ": invalid shared state name."
                      )
                    );
                  if (
                    null === (i = t.userSharedStates[a]) ||
                    void 0 === i ||
                    !i[n]
                  )
                    throw Error(
                      "Cannot delete user shared state value for "
                        .concat(a, " ")
                        .concat(n, ": user shared state does not exist.")
                    );
                  delete t.userSharedStates[a][n],
                    e.delayedActions.push({
                      type: "deleteUserSharedState",
                      stateId: n,
                      stateName: a,
                      userId: s,
                    });
                },
                postMessage: Hl({ ...e, sharedState: c, sharedStateName: a }),
                count: (t) => e.apiAccess.countSharedStates(a, t),
                search: (t) => e.apiAccess.searchSharedStates(a, t),
              };
            }
            return i;
          })({
            apiAccess: s,
            async: l,
            consistentFetchIds: d,
            dateNow: m,
            delayedActions: a,
            entry: e.entry,
            getClockOffset: g,
            random: b,
            sharedStates: e.sharedStates,
            userId: i,
          }),
          S = null !== (r = e.fetcher) && void 0 !== r ? r : new Wl(),
          _ = {
            isAsync: !!l,
            asyncGetters: Cl({
              apiAccess: s,
              consistentFetchIds: d,
              entry: o,
              id: i,
              invokeTime: c,
              sessionId: e.sessionId,
              ...y,
            }),
            math: {
              random: () => (l ? Math.random() : cl(i, o.metainfo.random)),
            },
            getUserID: () => i,
            getSessionID: () => e.sessionId,
            date: { now: () => c + (o.metainfo.clockOffset || 0) },
            searchPlayers: async (e) => s.searchPlayers(e),
            countPlayers: async (e) => s.countPlayers(e),
            getMentionCountForPagePost: async () => {
              throw new Error("Cannot get mention count in browser replicant");
            },
            fetch: function () {
              return S.fetch(...arguments);
            },
            fetchStates: async (e) => {
              const t = await s.fetchStates(e, { consistentFetchIds: d });
              if (t.unprocessedIds && t.unprocessedIds.length > 0)
                throw new Error("Requesting too many profiles in API");
              return t.states;
            },
            generateOrGetNativeBridgeSecret: () => {
              var e;
              if (
                null !== (e = o.chatbotMetainfo) &&
                void 0 !== e &&
                e.nativeBridgeSecret
              )
                return o.chatbotMetainfo.nativeBridgeSecret;
              const t = yc(b);
              return (
                a.push({
                  type: "action",
                  action: () => s.setNativeBridgeSecret(i, t),
                  apiMethodName: "api.generateOrGetNativeBridgeSecret",
                }),
                t
              );
            },
            kvStore: {
              get: function () {
                return e.apiAccess.kvStore.get(...arguments);
              },
              getBatch: function () {
                return e.apiAccess.kvStore.getBatch(...arguments);
              },
              send: function () {
                return e.apiAccess.kvStore.send(...arguments);
              },
              sendBatch: function () {
                return e.apiAccess.kvStore.sendBatch(...arguments);
              },
            },
            loginLinks: {
              createLoginToken() {
                throw Error("Login links are disabled in offline mode");
              },
              createWebPlayerToken() {
                throw Error("Login links are disabled in offline mode");
              },
            },
            abTests: {
              getBucketID: (e) => p.getBucketID(o.metainfo, e),
              assign: (e, t) => p.assign(o.metainfo, i, e, t),
              unassign: (e) => p.unassign(o.metainfo, i, e),
            },
            otp: {
              verifyOtp: () =>
                Promise.reject("OTP is disabled in offline mode"),
            },
            postMessage: v,
            flushMessages: f,
            scheduledActions: e.scheduledActionsApi,
            telegram: xl("Telegram API is disabled in offline mode"),
            payments: {
              createXsollaPaymentToken: () => {
                throw new Error("createXsollaPaymentToken is not implemented");
              },
              createCheckoutSession() {
                throw Error("Payments are disabled in offline mode");
              },
              createInvoice() {
                throw Error("Payments are disabled in offline mode");
              },
              createKomojuSession() {
                throw Error("Payments are disabled in offline mode");
              },
              createKomojuPayment() {
                throw Error("Payments are disabled in offline mode");
              },
              createPaymentIntent() {
                throw Error("Payments are disabled in offline mode");
              },
            },
            paymentSubscriptions: {
              getStatus: () => Promise.resolve(void 0),
              initiateWithOTPVerification() {
                throw new Error("not implemented");
              },
              verifyOTP() {
                throw new Error("not implemented");
              },
              initiate: (e) => {
                throw new Error("not implemented");
              },
              verify: () => {
                throw new Error("not implemented");
              },
              cancel: () => {
                throw new Error("not implemented");
              },
            },
            purchases: {
              getPurchaseHistory: () => Kl(o.metainfo),
              validatePurchase: async (e) => {
                var t;
                if ("ios" === e.paymentProcessor) {
                  if (!e.productId)
                    throw new nl(
                      "Property purchaseOpts.productId is required in offline Replicant",
                      "replication_error",
                      "payment_signature_verification_error"
                    );
                  return {
                    productId: e.productId,
                    purchaseToken: e.signedRequest,
                    developerPayload: {},
                  };
                }
                const n = JSON.parse(e.signedRequest);
                if (!n)
                  throw new nl(
                    "Wrong signedRequest",
                    "replication_error",
                    "payment_signature_verification_error"
                  );
                if (
                  ((n.purchase_token = n.purchaseToken),
                  o.metainfo.purchaseHistory &&
                    o.metainfo.purchaseHistory.some(
                      (e) => e.purchase_token === n.purchase_token
                    ))
                )
                  throw new nl(
                    "Purchase has already been logged before.",
                    "replication_error",
                    "payment_already_purchased_error"
                  );
                const r = {
                    algorithm: "HMAC-SHA256",
                    developer_payload: n.developerPayload,
                    is_consumed: !1,
                    issued_at: n.purchaseTime,
                    payment_id: "awsome_payment_id",
                    product_id: n.productID,
                    purchase_time: n.purchaseTime,
                    purchase_token: n.purchaseToken,
                  },
                  s =
                    13 === r.issued_at.toString().length
                      ? g()
                      : Math.round(g() / 1e3);
                return (
                  (r.issued_at = Number(r.issued_at) + s),
                  (r.purchase_time = Number(r.purchase_time) + s),
                  (o.metainfo.purchaseHistory =
                    null !== (t = o.metainfo.purchaseHistory) && void 0 !== t
                      ? t
                      : []),
                  o.metainfo.purchaseHistory.push(r),
                  {
                    productId: n.productID,
                    purchaseToken: n.purchaseToken,
                    developerPayload: n.developerPayload,
                  }
                );
              },
            },
            sharedStates: w,
            ...y,
            chatbot: e.chatbotApi,
            nukeUserMetainfo: () => {
              (o.metainfo = { random: { n: 0 } }),
                (o.chatbotMetainfo = void 0),
                (o.metainfoMVCC = {});
            },
            setClockOffset: (e) => {
              o.metainfo.clockOffset = Math.floor(e);
            },
            getClockOffset: g,
            getPushNotificationLastTargetedAt: () => {
              var e, t, n, r;
              return Math.max(
                null !==
                  (e =
                    null === (t = o.chatbotMetainfo) ||
                    void 0 === t ||
                    null === (t = t.channelLastTargetedAt) ||
                    void 0 === t
                      ? void 0
                      : t.android) && void 0 !== e
                  ? e
                  : 0,
                null !==
                  (n =
                    null === (r = o.chatbotMetainfo) ||
                    void 0 === r ||
                    null === (r = r.channelLastTargetedAt) ||
                    void 0 === r
                      ? void 0
                      : r.ios) && void 0 !== n
                  ? n
                  : 0
              );
            },
            getUserAssetUrl: (e) => h + e,
          };
        return _;
      }
      const Gl = (e) =>
        e instanceof Error
          ? e
          : JSON.stringify(
              e,
              (() => {
                const e = new WeakSet();
                return (t, n) => {
                  if ("object" === typeof n && null !== n) {
                    if (e.has(n)) return;
                    e.add(n);
                  }
                  return n;
                };
              })(),
              4
            );
      var Jl;
      !(function (e) {
        (e[(e.debug = 0)] = "debug"),
          (e[(e.info = 1)] = "info"),
          (e[(e.log = 2)] = "log"),
          (e[(e.warn = 3)] = "warn"),
          (e[(e.error = 4)] = "error"),
          (e[(e.fatal = 5)] = "fatal");
      })(Jl || (Jl = {}));
      let Ql = Jl.info;
      const Yl = (e, t) => (
          t || (t = Jl[e]),
          function () {
            if (e >= Ql) {
              const e = console[t];
              for (
                var n = arguments.length, r = new Array(n), s = 0;
                s < n;
                s++
              )
                r[s] = arguments[s];
              e.apply(
                null,
                r.map((e) => ("object" === typeof e ? Gl(e) : e))
              );
            }
          }
        ),
        Xl = {
          debug: Yl(Jl.debug, "log"),
          info: Yl(Jl.info),
          log: Yl(Jl.log),
          warn: Yl(Jl.warn),
          error: Yl(Jl.error),
          fatal: Yl(Jl.fatal, "error"),
          level: (e) => {
            if (void 0 === Jl[e])
              throw new Error(
                "Unknown log level" +
                  e +
                  ". Please use the LogLevel enum to set it"
              );
            Ql = e;
          },
        };
      class Zl extends Error {
        constructor(e) {
          super(
            "Cannot write DB item: revision number mismatch. This revision may have already been written due to a race condition."
          ),
            (this.newRevision = e),
            (this.code = "ConditionalCheckFailedException"),
            Object.setPrototypeOf(this, new.target.prototype);
        }
      }
      function $l(e) {
        return void 0 !== e.dbSchemaVersion && e.dbSchemaVersion >= 1;
      }
      function eu(e) {
        let { fetchMetainfos: t, writeChatbotMetainfo: n } = e;
        return {
          fetchMetainfo: (e) => t([e]).then((t) => t[e]),
          fetchMetainfos: t,
          markSubscribed: async (e, t, r) =>
            n(e, async (e) => tu(null !== e && void 0 !== e ? e : {}, t, r)),
          markSubscribedAndResetMessagingSession: async (e, t, r) =>
            n(e, async (e) =>
              nu(tu(null !== e && void 0 !== e ? e : {}, t, r), r)
            ),
          markMessageSent: async (e, t) =>
            n(e, async (n) => {
              if (!n) throw new Error("No chatbotMetainfo for id: " + e);
              return (
                (n.messagesSinceLastSession =
                  (n.messagesSinceLastSession || 0) + 1),
                (n.timeLastMessageSent = t),
                n
              );
            }),
          setInstagramMessengerId: (e) => {
            let { userId: t, instagramMessengerId: r } = e;
            return n(t, async (e) => ({ ...e, instagramMessengerId: r }));
          },
          setLastReceivedMessagePayload: (e, t) =>
            n(e, async (e) => ({ ...e, lastReceivedMessagePayload: t })),
          setMessengerId: async (e, t) =>
            n(
              e,
              async (e) => (
                e
                  ? (e.messengerId = t)
                  : (e = {
                      messengerId: t,
                      hasUnsubscribed: !1,
                      messagesSinceLastSession: 0,
                    }),
                e
              )
            ),
          setSessionId: async (e, t) =>
            n(
              e,
              async (e) => (
                e ? (e.lastSessionId = t) : (e = { lastSessionId: t }), e
              )
            ),
          resetMessagingSession: async (e, t) =>
            n(e, async (e) => nu(null !== e && void 0 !== e ? e : {}, t)),
          setAppleDeviceToken: async (e, t, r) =>
            n(
              e,
              async (e) => (
                e || (e = {}),
                t
                  ? ((e.appleDeviceToken = t),
                    (e.appleDeviceTokenUpdatedAt = r))
                  : (delete e.appleDeviceToken,
                    delete e.appleDeviceTokenUpdatedAt),
                e
              )
            ),
          setAndroidDeviceToken: async (e, t, r) =>
            n(
              e,
              async (e) => (
                e || (e = {}),
                t
                  ? ((e.androidDeviceToken = t),
                    (e.androidDeviceTokenUpdatedAt = r))
                  : (delete e.androidDeviceToken,
                    delete e.androidDeviceTokenUpdatedAt),
                e
              )
            ),
          updateTimeLastTargetedByChannelMessage: async (e, t, r) =>
            n(e, async (e) => {
              var n;
              e
                ? ((e.channelLastTargetedAt =
                    null !== (n = e.channelLastTargetedAt) && void 0 !== n
                      ? n
                      : {}),
                  (e.channelLastTargetedAt[t] = r))
                : (e = { channelLastTargetedAt: { [t]: r } });
              return e;
            }),
          setNativeBridgeSecret: async (e, t) =>
            n(
              e,
              async (e) => (
                e
                  ? (e.nativeBridgeSecret = t)
                  : (e = { nativeBridgeSecret: t }),
                e
              )
            ),
          setEmail: (e, t) =>
            n(e, async (e) => (e || (e = {}), (e.email = t), e)),
          setWebPushSubscription: (e, t) =>
            n(e, async (e) => (e || (e = {}), (e.webPushSubscription = t), e)),
          subscribeSms: (e) =>
            n(e, async (e) => (e || (e = {}), (e.smsSubscribed = !0), e)),
          unsubscribeSms: (e) =>
            n(e, async (e) => (e || (e = {}), (e.smsSubscribed = !1), e)),
        };
      }
      function tu(e, t, n) {
        const r = { ...e, subscribed: t };
        return (
          t && !e.timeFirstSubscribed && (r.timeFirstSubscribed = n),
          !t && e.timeFirstSubscribed && (r.hasUnsubscribed = !0),
          r
        );
      }
      function nu(e, t) {
        return { ...e, messagesSinceLastSession: 0, timeLastSessionEnded: t };
      }
      function ru(e, t) {
        return {
          addCancelledOnGameEndEventId: async (e, n) =>
            t(e, (e) => {
              var t;
              e.cancelledOnGameEndEventIds = (
                null !== (t = e.cancelledOnGameEndEventIds) && void 0 !== t
                  ? t
                  : []
              )
                .concat(n)
                .slice(-5);
            }),
          fetchMetainfoMVCC: async (t) => e(t),
          updateScheduledActionNotifications: async (e, n) => {
            t(e, (e) => {
              const t = [
                "systemScheduledActionNotifications",
                "scheduledActionNotifications",
              ];
              for (const r of t) {
                e[r] || (e[r] = {});
                for (const [t, s] of Object.entries(n[r]))
                  s ? (e[r][t] = s) : delete e[r][t];
              }
            });
          },
          setPaymentSubscriptionStatus: async (e, n) =>
            t(e, (e) => {
              e.paymentSubscription = n;
            }),
          unsetPaymentSubscriptionStatus: async (e) =>
            t(e, (e) => {
              delete e.paymentSubscription;
            }),
          getPaymentSubscriptionStatus: async (t) => e(t).paymentSubscription,
        };
      }
      const su = "Replicantdb",
        iu = (e, t) => e + "_scheduledactions_" + t;
      function ou(e) {
        const t = null !== e && void 0 !== e ? e : u.Lr,
          n = [];
        let r = 0,
          s = t.key(r++);
        const i = 5e3;
        for (; s && r < i; ) n.push(s), (s = t.key(r++));
        if (r === i) throw new Error("Reached 5000 for local storage");
        return n;
      }
      function au(e) {
        if (e.includes("_messages") || e.includes("_changesets"))
          throw new Error("Username is invalid to be stored in LocalStorage!");
      }
      const cu = function (e) {
        var t;
        const n = null !== (t = e.storage) && void 0 !== t ? t : u.Lr,
          r = su + (e.prefix ? "_" + e.prefix : ""),
          s = (e) => r + "_state_" + e,
          i = (e) => r + "_" + e + "_metainfomvcc",
          o = (e) => r + "_" + e + "_chatbot",
          a = (e, t) => r + "_" + e + "_messages_" + t,
          c = (e, t) => r + "_" + e + "_changesets_" + t,
          l = (e) => {
            let { stateId: t, stateName: n } = e;
            return "".concat(r, "_sharedStates_").concat(n, "_").concat(t);
          },
          d = (e, t) => r + "_" + e + "_snapshots_" + t,
          h = (e) => iu(r, e),
          p = r + "_lineChatbotBroadcasts",
          f = (e) => "_loginToken_".concat(e.userId, "_").concat(e.token),
          m = (e) => r + "_kv_" + e,
          g = (e) => r + "_ikv_" + e,
          v = (e) => r + "_task_" + e,
          y = r + "_ecpm",
          b = r + "_exchange_rates",
          w = r + "_ab_tests",
          S = r + "_ab_tests_user_lists";
        async function _(e) {
          au(e);
          return ou(n)
            .filter((t) => t.startsWith(r + "_" + e + "_messages_"))
            .sort()
            .map((e) => JSON.parse(n.getItem(e)));
        }
        const E = async (e, t) => {
            const r = await _(e),
              i = n.getItem(s(e));
            if (i) {
              const t = JSON.parse(i);
              return (
                await (async function (e, t) {
                  if (!t.createdAt) {
                    const n = await O.fetchChangeset(e, 1);
                    (t.createdAt = n ? n.date.getTime() : t.lastUpdated),
                      await C(e, t);
                  }
                })(e, t),
                {
                  consumedCapacity: 0,
                  entry: {
                    ...t,
                    lastMessageReceivedAt:
                      r.length > 0
                        ? Math.max(...r.map((e) => e.timestamp))
                        : void 0,
                    mainItemRev: t.rev,
                    metainfoMVCC: A(e),
                    chatbotMetainfo: await T(e),
                    userSharedStates: await I.fetchUserStates(e),
                  },
                  entryDiffs: [],
                  messages: r,
                }
              );
            }
            return {
              consumedCapacity: 0,
              entry: null,
              entryDiffs: [],
              messages: r,
            };
          },
          A = (e) => {
            const t = n.getItem(i(e));
            return t ? JSON.parse(t) : {};
          },
          T = async (e) => {
            const t = n.getItem(o(e));
            return t ? JSON.parse(t) : null;
          },
          P = {
            writeBatch: async (e) => {
              for (const { action: t, key: r } of e) {
                const e = r.timeslotId + "_" + r.actionId;
                n.setItem(h(e), JSON.stringify(t));
              }
            },
            delete: async (e) => {
              const t = e.timeslotId + "_" + e.actionId;
              n.removeItem(h(t));
            },
            deleteBatch: async (e) => {
              for (const t of e) {
                const e = t.timeslotId + "_" + t.actionId;
                n.removeItem(h(e));
              }
            },
            fetch: async (e) => {
              const t = e.timeslotId + "_" + e.actionId,
                r = n.getItem(h(t));
              return r ? JSON.parse(r) : null;
            },
            fetchAllForTimeslot: async (e) => {
              const t = ou(n)
                .filter((t) => t.startsWith(h(e + "_")))
                .map((t) => {
                  const r = t.substr(h(e + "_").length);
                  return { [r]: JSON.parse(n.getItem(t)) };
                })
                .reduce((e, t) => ({ ...e, ...t }), {});
              return { actions: t };
            },
          },
          I = (function (e) {
            return {
              deleteSharedStateMessages: async (t) => {
                for (const { messageId: n, stateId: r, stateName: s } of t) {
                  const t = e.getSharedState({ stateId: r, stateName: s });
                  t &&
                    ((t.sharedStateMessages = t.sharedStateMessages.filter(
                      (e) => e.id !== n
                    )),
                    e.setSharedState({
                      stateId: r,
                      stateName: s,
                      sharedState: t,
                    }));
                }
              },
              deleteUserSharedState: async (t) => {
                var n;
                let { stateId: r, stateName: s, userId: i } = t;
                const o = e.getSharedState({ stateId: r, stateName: s });
                null !== o &&
                  void 0 !== o &&
                  null !== (n = o.userSharedStates) &&
                  void 0 !== n &&
                  n[i] &&
                  (delete o.userSharedStates[i],
                  e.setSharedState({
                    stateId: r,
                    stateName: s,
                    sharedState: o,
                  }));
              },
              fetchGlobalSharedState: async (t) => {
                var n, r;
                let { stateId: s, stateName: i } = t;
                return null !==
                  (n =
                    null ===
                      (r = e.getSharedState({ stateId: s, stateName: i })) ||
                    void 0 === r
                      ? void 0
                      : r.globalSharedState) && void 0 !== n
                  ? n
                  : null;
              },
              fetchSharedState: async (t) => {
                let { stateId: n, stateName: r } = t;
                return {
                  consumedCapacity: 0,
                  sharedState: e.getSharedState({ stateId: n, stateName: r }),
                };
              },
              fetchUserStates: async (t) => {
                const n = {};
                for (const {
                  stateId: s,
                  stateName: i,
                } of e.getAllSharedStateIds()) {
                  var r;
                  const o =
                    null ===
                      (r = e.getSharedState({ stateId: s, stateName: i })) ||
                    void 0 === r
                      ? void 0
                      : r.userSharedStates[t];
                  o &&
                    (n[o.stateName] || (n[o.stateName] = {}),
                    (n[o.stateName][o.stateId] = o));
                }
                return n;
              },
              migrateLegacyUserSharedStates: async () => {},
              writeGlobalSharedState: async (t) => {
                var n, r;
                const s =
                    null !==
                      (n = e.getSharedState({
                        stateId: t.stateId,
                        stateName: t.stateName,
                      })) && void 0 !== n
                      ? n
                      : { sharedStateMessages: [], userSharedStates: {} },
                  i =
                    null === (r = s.globalSharedState) || void 0 === r
                      ? void 0
                      : r.rev;
                if (void 0 !== i && i !== t.rev - 1) throw new Zl(t.rev);
                (s.globalSharedState = t),
                  e.setSharedState({
                    stateId: t.stateId,
                    stateName: t.stateName,
                    sharedState: s,
                  });
              },
              writeSharedStateMessages: async (t) => {
                for (const r of t) {
                  var n;
                  const t =
                    null !==
                      (n = e.getSharedState({
                        stateId: r.stateId,
                        stateName: r.stateName,
                      })) && void 0 !== n
                      ? n
                      : { sharedStateMessages: [], userSharedStates: {} };
                  t.sharedStateMessages.push(r),
                    t.sharedStateMessages.sort((e, t) =>
                      e.id.localeCompare(t.id)
                    ),
                    e.setSharedState({
                      stateId: r.stateId,
                      stateName: r.stateName,
                      sharedState: t,
                    });
                }
              },
              writeUserSharedState: async (t) => {
                var n, r;
                const s =
                    null !==
                      (n = e.getSharedState({
                        stateId: t.stateId,
                        stateName: t.stateName,
                      })) && void 0 !== n
                      ? n
                      : { sharedStateMessages: [], userSharedStates: {} },
                  i =
                    null === (r = s.userSharedStates[t.userId]) || void 0 === r
                      ? void 0
                      : r.rev;
                if (void 0 !== i && i !== t.rev - 1) throw new Zl(t.rev);
                (s.userSharedStates[t.userId] = t),
                  e.setSharedState({
                    stateId: t.stateId,
                    stateName: t.stateName,
                    sharedState: s,
                  });
              },
            };
          })({
            deleteSharedState: (e) => {
              let { stateId: t, stateName: r } = e;
              return n.removeItem(l({ stateId: t, stateName: r }));
            },
            getAllSharedStateIds: () =>
              ou(n)
                .filter((e) => e.startsWith("".concat(r, "_sharedStates_")))
                .map((e) => {
                  const t = e.split("_"),
                    n = t.at(-1),
                    r = t.at(-2);
                  if (!n || !r)
                    throw Error("Invalid shared state key ".concat(e));
                  return { stateId: n, stateName: r };
                }),
            getSharedState: (e) => {
              let { stateId: t, stateName: r } = e;
              return (
                (s = l({ stateId: t, stateName: r })),
                JSON.parse(n.getItem(s) || "null")
              );
              var s;
            },
            setSharedState: (e) => {
              let { sharedState: t, stateId: r, stateName: s } = e;
              return (function (e, t) {
                n.setItem(e, JSON.stringify(t));
              })(l({ stateId: r, stateName: s }), t);
            },
          }),
          C = async (e, t) => {
            let { userSharedStates: r, ...i } = t;
            au(e), n.setItem(s(e), JSON.stringify(i));
          },
          k = async (e, t) => {
            au(e);
            const r = n.getItem(c(e, t));
            if (!r) return null;
            const s = JSON.parse(r);
            return (s.date = new Date(s.date)), s;
          },
          O = {
            fetch: E,
            write: async (e, t, r) => {
              if (
                null !== r &&
                void 0 !== r &&
                r.noOverwrite &&
                n.getItem(s(e))
              )
                throw new Error("Entry already exists for " + e);
              return C(e, t);
            },
            writeToDBConditionally: async (e, t, n) => {
              au(e);
              const { entry: r } = await E(e);
              if (!r) throw new Error("Could not load " + e);
              if (r.rev === n) return await C(e, t), JSON.stringify(t).length;
              throw new Zl(t.rev);
            },
            async writeEntryOrEntryDiff(e) {
              return {
                itemByteSize: await this.writeToDBConditionally(
                  e.userId,
                  e.entry,
                  e.entry.rev - 1
                ),
              };
            },
            writeMessages: async (e, t) => {
              au(e);
              for (const r of t) {
                if (n.getItem(a(e, r.id)))
                  throw new Error("Message " + r.id + " already exists!");
                n.setItem(a(e, r.id), JSON.stringify(r));
              }
            },
            writeEventHandlerMessage: async (e, t) => O.writeMessages(e, [t]),
            deleteMessages: async (e, t) => {
              au(e),
                t.forEach((e, n) => {
                  const r =
                    t.findIndex((t) => {
                      let { id: n } = t;
                      return n === e.id;
                    }) < n;
                  if (r) throw Error("Duplicate message ID ".concat(e.id));
                });
              for (const r of t) n.removeItem(a(e, r.id));
            },
            fetchMessages: _,
            writeChangeset: async (t) => {
              let {
                id: r,
                diff: s,
                entry: i,
                date: o,
                appVersion: a,
                replication: l,
                messages: u,
                snapshotUpdate: h,
              } = t;
              if (e.writeChangesets) {
                au(r);
                const e = u.map((e) => {
                    if (Fl(e)) {
                      const { metainfoDiff: t, stateDiff: n, ...r } = e;
                      return r;
                    }
                    return e;
                  }),
                  t = {
                    rev: i.rev,
                    version: i.version,
                    diff: s,
                    appVersion: a,
                    date: o,
                    replication: l,
                    messages: e,
                  };
                if (
                  (n.setItem(c(r, i.rev), JSON.stringify(t)),
                  null !== h && void 0 !== h && h.shouldWriteNewSnapshot)
                ) {
                  au(r);
                  const e = {
                    ...i,
                    lastInvokeTime: 0,
                    dailySnapshotAt: 0,
                    dailySnapshotRev: 0,
                    weeklySnapshotAt: 0,
                    weeklySnapshotRev: 0,
                    monthlySnapshotAt: 0,
                    monthlySnapshotRev: 0,
                  };
                  n.setItem(d(r, i.rev), JSON.stringify(e));
                }
              }
            },
            fetchChangeset: k,
            fetchChangesetsBetween: async (e, t, n) => {
              const r = [];
              for (let s = t; s <= n; s++) {
                const t = await k(e, s);
                t && r.push(t);
              }
              return r;
            },
            fetchChangesetsPage: async (e) => ({
              items: [],
              totalItemsCount: 0,
            }),
            fetchChangesetsPageByDate: async (e) => ({
              items: [],
              totalItemsCount: 0,
              currentPage: 1,
            }),
            delete: async (e) => {
              au(e),
                await (async function (e, t) {
                  const n = await e.metainfoMVCC.fetchMetainfoMVCC(t),
                    r = Object.values({
                      ...(null === n || void 0 === n
                        ? void 0
                        : n.scheduledActionNotifications),
                      ...(null === n || void 0 === n
                        ? void 0
                        : n.systemScheduledActionNotifications),
                    });
                  await e.scheduledActions.deleteBatch(r);
                })(O, e);
              ou(n)
                .filter(
                  (t) =>
                    t.startsWith(r + "_state_" + e) ||
                    t.startsWith(r + "_" + e + "_messages_") ||
                    t.startsWith(r + "_" + e + "_changesets_") ||
                    t.startsWith(r + "_" + e + "_snapshots_") ||
                    t.startsWith(r + "_" + e + "_chatbot") ||
                    t.startsWith(r + "_" + e + "_metainfomvcc") ||
                    t.startsWith(r + "_" + e + "_chatbot")
                )
                .forEach((e) => n.removeItem(e));
            },
            nukeDB: async () => {
              ou(n)
                .filter((e) => e.startsWith(r))
                .forEach((e) => n.removeItem(e));
            },
            accountLink: {
              getPhoneNumber: async () => null,
              getUserId: async () => null,
              linkUserId: async () => {},
              setNotificationConsentText: async () => {},
            },
            archive: {
              archiveUser: async () => {},
              restoreUserFromArchive: async () => null,
            },
            lineChatbotBroadcasts: {
              addBroadcast: async (e) => {
                const t = await O.lineChatbotBroadcasts.getBroadcasts(),
                  r = JSON.stringify([...t, e]);
                n.setItem(p, r);
              },
              getBroadcasts: async () => JSON.parse(n.getItem(p) || "[]"),
            },
            loginTokens: {
              writeLoginToken: async (e) => n.setItem(f(e), JSON.stringify(e)),
              fetchLoginToken: async (e) => JSON.parse(n.getItem(f(e))),
              deleteLoginToken: async (e) => n.removeItem(f(e)),
            },
            entryDiff: {
              write: async () => ({ itemByteSize: 0 }),
              deleteBatch: async () => {},
            },
            kvStore: {
              write: async (e, t, r) => {
                n.setItem(
                  m(e),
                  JSON.stringify({ key: e, value: t, timestamp: r })
                );
              },
              fetch: async (e) => {
                const t = n.getItem(m(e));
                return t ? JSON.parse(t).value : null;
              },
              delete: async (e) => {
                n.removeItem(m(e));
              },
            },
            internalKvStore: {
              write: async (e, t) => {
                n.setItem(g(e), t);
              },
              writeBatch: async (e) => {
                for (const t in e) n.setItem(g(t), e[t]);
              },
              fetch: async (e) => n.getItem(g(e)),
              delete: async (e) => {
                n.removeItem(g(e));
              },
            },
            lock: { acquireTimestampLock: async () => !0 },
            metainfoMVCC: ru(A, (e, t) => {
              const r = A(e);
              return t(r), n.setItem(i(e), JSON.stringify(r)), r;
            }),
            otp: {
              createVerification: async () => {},
              getVerification: async () => null,
            },
            chatbot: eu({
              fetchMetainfos: async (e) => {
                const t = {};
                for (const r of e) {
                  const { entry: e } = await E(r);
                  var n;
                  if (e)
                    t[r] =
                      null !== (n = e.chatbotMetainfo) && void 0 !== n
                        ? n
                        : null;
                }
                return t;
              },
              writeChatbotMetainfo: async (e, t) => {
                const r = await T(e),
                  s = await t(r);
                return n.setItem(o(e), JSON.stringify(s)), s;
              },
            }),
            scheduledActions: P,
            sharedStates: I,
            snapshots: {
              fetchSnapshot: async (e, t) => {
                au(e);
                const r = n.getItem(d(e, t));
                return r ? JSON.parse(r) : null;
              },
              fetchSnapshots: async (e) => (
                au(e),
                ou(n)
                  .filter((t) => t.startsWith(r + "_" + e + "_snapshots_"))
                  .map((e) => JSON.parse(n.getItem(e)))
              ),
            },
            tasks:
              ((x = (e) => JSON.parse(n.getItem(v(e)) || "null")),
              (N = (e, t) => n.setItem(v(e), JSON.stringify(t))),
              {
                completeTask: async (e, t) => {
                  const n = x(e);
                  if (!n) throw Error("Cannot complete non-existent task");
                  if ("COMPLETED" === n.status)
                    throw Error("Cannot complete an already completed task");
                  N(e, { status: "COMPLETED", updatedAt: t });
                },
                fetchTasks: async (e, t, n) => {
                  const r = {};
                  for (const s of e) {
                    const e = x(s);
                    "COMPLETED" ===
                    (null === e || void 0 === e ? void 0 : e.status)
                      ? (r[s] = "COMPLETED")
                      : "IN_PROGRESS" ===
                          (null === e || void 0 === e ? void 0 : e.status) &&
                        t < e.updatedAt + n &&
                        (r[s] = "IN_PROGRESS");
                  }
                  return r;
                },
                tryWriteLock: async (e, t, n) => {
                  const r = x(e);
                  return (
                    (!r ||
                      ("IN_PROGRESS" === r.status && r.updatedAt <= t - n)) &&
                    (N(e, { status: "IN_PROGRESS", updatedAt: t }), !0)
                  );
                },
              }),
            adminTasks: {},
            socialGraph: {
              addPlayerFriend: () => Promise.resolve(),
              createInteractions: () => Promise.resolve(),
              createOrUpdatePlayer: () => Promise.resolve(),
              getNonPlayers: () => Promise.resolve([]),
              getPlayer: () => Promise.resolve(null),
              getPlayers: () => Promise.resolve({}),
              removePlayerFriend: () => Promise.resolve(),
            },
            abTests: {
              userLists: {
                get: async () => JSON.parse(n.getItem(S) || "[]"),
                set: async (e) => n.setItem(S, JSON.stringify(e)),
              },
              get: async () => {
                const e = JSON.parse(n.getItem(w) || "{}");
                for (const t in e) {
                  const n = e[t];
                  void 0 === n.rollOut && (n.rollOut = n.active ? 1 : 0);
                }
                return e;
              },
              set: async (e) => n.setItem(w, JSON.stringify(e)),
            },
            ecpm: {
              get: async () => {
                const e = n.getItem(y);
                return e ? JSON.parse(e) : null;
              },
              set: async (e) => {
                n.setItem(y, JSON.stringify(e));
              },
            },
            exchangeRates: {
              get: async () => {
                const e = n.getItem(b);
                return e ? JSON.parse(e) : { rates: {}, timestamp: 0 };
              },
              set: async (e) => {
                n.setItem(b, JSON.stringify(e));
              },
              setTimestamp: async (e) => {
                const t = await O.exchangeRates.get();
                (t.timestamp = e), await O.exchangeRates.set(t);
              },
            },
          };
        var x, N;
        return (
          "undefined" !== typeof window &&
            (window.replicantNukeDevDB = () => {
              O.nukeDB().then(() => {
                Xl.info("LocalStorage DB Nuked.");
              });
            }),
          O
        );
      };
      function lu(e) {
        const t = {};
        for (const r in e) {
          var n;
          null !== (n = e[r]) &&
            void 0 !== n &&
            n._searchable &&
            (t[r] = e[r].type);
        }
        return t;
      }
      function uu(e) {
        const t = {};
        for (const [n, r] of Object.entries(e))
          (r._searchable || r._payload) && (t[n] = r.type);
        return t;
      }
      function du(e, t) {
        let n = {};
        for (const r in t) {
          const s = r,
            i = t[s];
          i.isObjectSchema()
            ? (n = { ...n, ...du(r, i.getFullSchema()) })
            : (n[e.length > 0 ? e + ">" + s : s] = i);
        }
        return n;
      }
      function hu(e) {
        if (null !== e && void 0 !== e && e.isArraySchema()) {
          const t = e.getItemSchema();
          if (t.isObjectSchema()) return t.getFullSchema();
        }
        return null;
      }
      function pu(e) {
        return { validates: !1, reason: e };
      }
      function fu(e, t, n) {
        const r = t.validate(e);
        return null != r
          ? pu("".concat(n, " failed to validate the argument: ").concat(r))
          : { validates: !0 };
      }
      function mu(e, t, n) {
        if (!t.isArraySchema())
          return pu("".concat(n, " schema must be of array type"));
        if (!Array.isArray(e))
          return pu("".concat(n, " values must be of array type"));
        for (const r of e) {
          const e = t.getItemSchema().validate(r);
          if (null != e)
            return pu(
              "".concat(n, " schema could not validate value: ").concat(e)
            );
        }
        return { validates: !0 };
      }
      function gu(e, t, n) {
        if (!Array.isArray(e))
          return pu("".concat(n, " values must be of array type"));
        for (const r of e) {
          const e = t.validate(r);
          if (null != e)
            return pu(
              "".concat(n, " schema could not validate value: ").concat(e)
            );
        }
        return { validates: !0 };
      }
      function vu(e, t, n) {
        const r = t.validate(e);
        return null != r
          ? pu("".concat(n, " failed to validate the argument: ").concat(r))
          : { validates: !0 };
      }
      const yu = {
        between: function (e, t) {
          if (!Array.isArray(e))
            return pu("between expects an array of two numbers");
          if (2 !== e.length)
            return pu("between expected exactly two numbers for the range");
          let n = t.validate(e[0]);
          return null != n
            ? pu("between failed to validate lowerbound: ".concat(n))
            : ((n = t.validate(e[1])),
              null != n
                ? pu("between failed to validate upperbound: ".concat(n))
                : { validates: !0 });
        },
        exists: function (e) {
          return !0 === e || !1 === e
            ? { validates: !0 }
            : pu("value must be a boolean");
        },
        greaterThan: function (e, t) {
          return fu(e, t, "greaterThan");
        },
        greaterThanOrEqual: function (e, t) {
          return fu(e, t, "greaterThanOrEqual");
        },
        lessThan: function (e, t) {
          return fu(e, t, "lessThan");
        },
        lessThanOrEqual: function (e, t) {
          return fu(e, t, "lessThanOrEqual");
        },
        containsAnyOf: function (e, t) {
          return mu(e, t, "containsAnyOf");
        },
        containsNoneOf: function (e, t) {
          return mu(e, t, "containsNoneOf");
        },
        isAnyOf: function (e, t) {
          return gu(e, t, "isAnyOf");
        },
        isNoneOf: function (e, t) {
          return gu(e, t, "isNoneOf");
        },
        isNot: function (e, t) {
          return vu(e, t, "isNotEquals");
        },
        is: function (e, t) {
          return vu(e, t, "isEquals");
        },
        matchesAnyOf: function (e) {
          return (function (e, t) {
            if (!Array.isArray(e) || 0 === e.length)
              return pu("".concat(t, " value must be a non-empty array"));
            const n = _a
              .string()
              .customValidator((e) =>
                e.length > 0 ? null : "String must be non-empty"
              );
            for (const r of e) {
              const e = n.validate(r);
              if (null != e)
                return pu("Invalid item in ".concat(t, " array: ").concat(e));
            }
            return { validates: !0 };
          })(e, "matchesAnyOf");
        },
      };
      function bu(e, t) {
        const n = (function (e, t) {
          const n = Su(e, t);
          return n.validates
            ? "limit" in t
              ? "number" !== typeof t.limit ||
                !Number.isInteger(t.limit) ||
                t.limit < 0 ||
                t.limit > 1e4
                ? pu("limit must be an integer between [0, 10_000]")
                : { validates: !0 }
              : pu("limit must be defined when searching")
            : n;
        })(e, t);
        if (!n.validates)
          throw Error("Unable to validate query: ".concat(n.reason));
      }
      function wu(e, t) {
        const n = (function (e, t) {
          const n = Su(e, t);
          return n.validates
            ? "limit" in t
              ? pu("limit must not be defined when counting")
              : { validates: !0 }
            : n;
        })(e, t);
        if (!n.validates)
          throw Error("Unable to validate query: ".concat(n.reason));
      }
      function Su(e, t) {
        let n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        if (null === t) return pu("query object must not be null");
        if (n > 1) return pu("deeply nested queries are not yet supported");
        if (t.scoring && t.sort)
          return pu("sort cannot be used when using scoring");
        if (t.sort && "random" !== t.sort) {
          if (!Array.isArray(t.sort))
            return pu(
              'Sort for the query must either be "random" or an array[]'
            );
          for (const n of t.sort) {
            if ("random" === n) continue;
            if (!n.order)
              return pu('sort missing order. Either "asc" or "desc"');
            if ("asc" !== n.order && "desc" !== n.order)
              return pu('sort order must be either "asc" or "desc"');
            if (n.script) {
              if ("function" !== typeof n.script)
                return pu("sort.script must be a function");
              continue;
            }
            if (!n.field) return pu("sort item missing field property");
            if ("string" !== typeof n.field)
              return pu("sort field must be a string");
            const t = n.field.split(".");
            if (t.length > 1) {
              if (t.join(">") in e) continue;
            }
            let r = e;
            for (let e = 0; e < t.length; e++) {
              const s = t[e];
              if (!(s in r))
                return pu(
                  "sort field not found in computed properties: " + n.field
                );
              if (((r = hu(r[s])), e < t.length - 1)) {
                if (!r)
                  return pu(
                    "sort field invalid: " + s + " is not a nested field."
                  );
              } else if (r)
                return pu("sort field invalid: " + s + " is a nested field.");
            }
          }
        }
        if (!t.where) return pu('First field of the query should be "where"');
        const r = Array.isArray(t.where) ? t.where : [t.where];
        let s = 0;
        for (const o of r) {
          let t = 0;
          for (const r in o) {
            if ("id" === r && 0 === n) {
              if (!o.id.isOneOf && !o.id.isNotOneOf)
                return pu(
                  "id must be filtered with either isOneOf or isNotOneOf"
                );
              if (
                Object.keys(o.id).some(
                  (e) => "isOneOf" !== e && "isNotOneOf" !== e
                )
              )
                return pu(
                  "id can only be filtered with either isOneOf or isNotOneOf"
                );
              if (o.id.isOneOf) {
                if (!Array.isArray(o.id.isOneOf))
                  return pu("isOneOf value must be an array type");
                if (o.id.isOneOf.some((e) => "string" !== typeof e))
                  return pu("id filters can only be strings");
              }
              if (o.id.isNotOneOf) {
                if (!Array.isArray(o.id.isNotOneOf))
                  return pu("isNotOneOf value must be an array type");
                if (o.id.isNotOneOf.some((e) => "string" !== typeof e))
                  return pu("id filters can only be strings");
              }
            } else {
              if (!(r in e))
                return pu(
                  "Field: ".concat(
                    r,
                    " not found in computed properties or is not searchable"
                  )
                );
              const s = e[r];
              let i = 0;
              const a = hu(s);
              if (a) {
                const e = Su(a, { where: o[r] }, ++n);
                if (!e.validates) return e;
                ++i, ++t;
                continue;
              }
              for (const e in o[r]) {
                if (!yu[e])
                  return pu('Filter "'.concat(e, '" not recognized!'));
                if (
                  "matchableString" === s._extendedType &&
                  "matchesAnyOf" !== e
                )
                  return pu(
                    "invalid query in where."
                      .concat(r, ".")
                      .concat(
                        e,
                        ", matchable string properties only support matchesAnyOf"
                      )
                  );
                const t = yu[e](o[r][e], s);
                if (!t.validates) return t;
                ++i;
              }
              if (0 === i) return pu("Empty filter block");
            }
            ++t;
          }
          if (0 === t) return pu("Empty `where` block in query");
          ++s;
        }
        const i = t.scoring;
        if (i)
          for (const o in i.functions) {
            if (i.functions[o].scale <= 0)
              return pu(
                "function for ".concat(o, " scale param must be greater than 0")
              );
          }
        return 0 === s ? pu("Empty") : { validates: !0 };
      }
      function _u(e) {
        switch (e) {
          case "isOneOf":
            return "idOneOf";
          case "isNotOneOf":
            return "idNotOneOf";
          case "notOneOf":
            throw new Error("notOneOf is invalid");
          default:
            return e;
        }
      }
      function Eu(e, t) {
        return Object.entries(e).reduce((e, n) => {
          let [r, s] = n;
          const i = t ? t + ">" + r : r;
          return (
            "object" !== typeof s || Array.isArray(s)
              ? (e[i] = s)
              : (e = { ...e, ...Eu(s, i) }),
            e
          );
        }, {});
      }
      function Au(e, t) {
        return Object.entries(t).reduce((t, n) => {
          let [r, s] = n;
          const i = (function (e) {
            return null !== e && void 0 !== e && e.isObjectSchema()
              ? e.getFullSchema()
              : null;
          })(e[r]);
          if (!hu(e[r]) && i) {
            const e = Au(i, s);
            for (const [n, s] of Object.entries(e)) t[r + ">" + n] = s;
          } else t[r] = s;
          return t;
        }, {});
      }
      function Tu(e, t) {
        const n = { ...t };
        return (
          (n.where = Array.isArray(t.where)
            ? t.where.map((t) => Au(e, t))
            : [Au(e, t.where)]),
          n
        );
      }
      function Pu(e, t) {
        const n = t.searchFields(),
          r = Array.isArray(e.where) ? e.where : [e.where],
          s = [];
        for (const i of r) {
          const e = [];
          for (const r in i) {
            const s = hu(n[r]);
            if (s) {
              t.pushStackFrame({ fields: s, path: r });
              const n = Pu({ where: i[r] }, t);
              e.push(n), t.popStackFrame();
            } else
              for (const n in i[r]) {
                const s = t[_u(n)];
                if (!s) throw new Error("Invalid filter name " + n);
                e.push(s(r, i[r][n]));
              }
          }
          s.push(e.length > 1 ? t.intersection(e) : e[0]);
        }
        return t.finalize(s.length > 1 ? t.union(s) : s[0]);
      }
      function Iu(e, t, n) {
        const r = uu(t),
          s = uu(t),
          i = du("", s),
          o = du("", lu(t)),
          a = _a.object({ ...s });
        async function c(t) {
          let r,
            s,
            a = [];
          const c = [{ fields: o, path: "" }];
          function l(e) {
            const t = c.length > 1,
              n = t ? c.slice(1).map((e) => e.path) : void 0;
            return () => {
              const s = ((e) => {
                let t = r;
                if (e) for (const n of e) t = t[n];
                return t;
              })(n);
              return t ? s.some((t) => e(t)) : e(s);
            };
          }
          const u = {
              searchFields: () => c[c.length - 1].fields,
              finalize: (e) => e,
              pushStackFrame: (e) => c.push(e),
              popStackFrame: () => c.pop(),
              exists: (e, t) => l((n) => (t ? !!n[e] : !n[e])),
              idOneOf: (e, t) => () => t.some((e) => e === s),
              idNotOneOf: (e, t) => () => t.every((e) => e !== s),
              between: (e, t) => l((n) => n[e] >= t[0] && n[e] <= t[1]),
              lessThan: (e, t) => l((n) => n[e] < t),
              lessThanOrEqual: (e, t) => l((n) => n[e] <= t),
              greaterThan: (e, t) => l((n) => n[e] > t),
              greaterThanOrEqual: (e, t) => l((n) => n[e] >= t),
              containsAnyOf: (e, t) =>
                l((n) => t.some((t) => n[e].some((e) => e === t))),
              containsNoneOf: (e, t) =>
                l((n) => t.every((t) => n[e].every((e) => e !== t))),
              isAnyOf: (e, t) => l((n) => t.some((t) => n[e] === t)),
              isNoneOf: (e, t) => l((n) => t.every((t) => n[e] !== t)),
              matchesAnyOf: (e, t) =>
                l((n) => {
                  const r = n[e];
                  if (!r) return !1;
                  if ("string" !== typeof r)
                    throw Error(
                      "Unexpected "
                        .concat(e, " value ")
                        .concat(r, ": expecting a string")
                    );
                  const s = (e) => e.trim().toLowerCase(),
                    i = s(r),
                    o = t.flatMap((e) => e.split(" ")).map(s);
                  return o.some((e) => i.includes(e));
                }),
              is: (e, t) => l((n) => n[e] === t),
              isNot: (e, t) => l((n) => n[e] !== t),
              intersection: (e) => () => e.every((e) => e()),
              union: (e) => () => e.some((e) => e()),
            },
            d = Pu(t, u);
          for (s of n.getAllIds(e))
            if (((r = n.getFromIndex(e, s)), d())) {
              const e = { ...r };
              for (const t in e) i[t] || delete e[t];
              a.push({ id: s, ...e });
            }
          const h = t.sort;
          return (
            h &&
              (a = a.sort((e, t) => {
                for (const n of "random" === h ? [h] : h) {
                  if ("random" === n) return Math.random() < 0.5 ? -1 : 1;
                  if ("script" in n) continue;
                  if ("asc" !== n.order && "desc" !== n.order)
                    throw new Error("Unknown sort order: " + n.order);
                  const s = n.field,
                    i = "asc" === n.order;
                  let a, c;
                  if (s.includes(".") && s.split(".").join(">") in o) {
                    const n = s.split(".").join(">");
                    (a = e[n]), (c = t[n]);
                  } else if (s.includes(".")) {
                    const n = s.split("."),
                      i = e[n[0]];
                    for (const t of i)
                      if (((r = { ...e, [n[0]]: [t] }), d())) {
                        a = n.slice(1).reduce((e, t) => e[t], t);
                        break;
                      }
                    if (void 0 === a)
                      throw new Error(
                        "Sorting on field ".concat(
                          s,
                          " failed as filtered results do not have this field"
                        )
                      );
                    const o = t[n[0]];
                    for (const e of o)
                      if (((r = { ...t, [n[0]]: [e] }), d())) {
                        c = n.slice(1).reduce((e, t) => e[t], e);
                        break;
                      }
                    if (void 0 === c)
                      throw new Error(
                        "Sorting on field ".concat(
                          s,
                          " failed as filtered results do not have this field"
                        )
                      );
                  } else (a = e[s]), (c = t[s]);
                  if (a > c) return i ? 1 : -1;
                  if (c > a) return i ? -1 : 1;
                }
                return 0;
              })),
            (a = a.slice(0, t.limit).map((e) =>
              (function (e) {
                const t = Object.entries(e).reduce((e, t) => {
                  let [n, r] = t;
                  const s = n.split(">");
                  let i = e;
                  for (const o of s.slice(0, s.length - 1))
                    i[o] || (i[o] = {}), (i = i[o]);
                  return (i[s[s.length - 1]] = r), e;
                }, {});
                return t;
              })(e)
            )),
            { results: a }
          );
        }
        return {
          batchPushDocuments: async (t) => {
            for (const r in t) {
              a.tryValidate(t[r]);
              const s = Eu(t[r]);
              n.pushToIndex(e, r, s);
            }
            return [];
          },
          async getMany(e) {
            const { results: t } = await this.query({
              where: { id: { isOneOf: e } },
              limit: e.length,
            });
            return t.reduce(
              (e, t) => ({ ...e, [t.id]: { indexedAt: 0, doc: t } }),
              {}
            );
          },
          initialize: () => Promise.resolve(),
          query: async (e) => (
            (e = Tu(r, e)), bu(o, e), 0 === e.limit ? { results: [] } : c(e)
          ),
          count: async (e) => {
            (e = Tu(r, e)), wu(o, e);
            const { results: t } = await c({ ...e, limit: 1e4 });
            return t.length;
          },
          scanIds: () => {
            throw Error("unimplemented");
          },
          recreateIndex: async () => {
            n.reset();
          },
          delete: async (t) =>
            !!n.getFromIndex(e, t) && (n.deleteFromIndex(e, t), !0),
          nukeIndex: async () => {
            n.reset();
          },
        };
      }
      function Cu(e, t, n) {
        var r;
        const s =
            su +
            (null !== n && void 0 !== n && n.prefix ? "_" + n.prefix : "") +
            "_index_",
          i =
            null !== (r = null === n || void 0 === n ? void 0 : n.storage) &&
            void 0 !== r
              ? r
              : u.Lr;
        function o(e) {
          const t = ou(i),
            n = s + e + "_";
          return t.filter((e) => e.startsWith(n)).map((e) => e.slice(n.length));
        }
        return Iu(e, t, {
          pushToIndex: (e, t, n) => {
            i.setItem(s + e + "_" + t, JSON.stringify(n));
          },
          getAllIds: (e) => o(e),
          getFromIndex: (e, t) => {
            const n = i.getItem(s + e + "_" + t);
            return n ? JSON.parse(n) : null;
          },
          reset: () => {
            o(e).forEach((t) => i.removeItem(s + e + "_" + t));
          },
          deleteFromIndex: (e, t) => {
            i.removeItem(s + e + "_" + t);
          },
        });
      }
      function ku(e) {
        return Object.entries(e).reduce((e, t) => {
          let [n, r] = t;
          return ql(r) ? { ...e, [n]: r } : e;
        }, {});
      }
      const Ou = "4.47.3";
      let xu,
        Nu,
        Ru,
        Du,
        Mu,
        ju,
        Lu,
        Uu,
        Fu,
        Bu = !1,
        Vu = null,
        qu = null,
        Hu = null,
        Wu = null;
      class Ku {
        constructor(e) {
          this.body = e;
        }
        get [Symbol.toStringTag]() {
          return "MultipartBody";
        }
      }
      xu ||
        (function (e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : { auto: !1 };
          if (Bu)
            throw new Error(
              "you must `import 'openai/shims/".concat(
                e.kind,
                "'` before importing anything else from openai"
              )
            );
          if (xu)
            throw new Error(
              "can't `import 'openai/shims/"
                .concat(e.kind, "'` after `import 'openai/shims/")
                .concat(xu, "'`")
            );
          (Bu = t.auto),
            (xu = e.kind),
            (Nu = e.fetch),
            (Vu = e.Request),
            (qu = e.Response),
            (Hu = e.Headers),
            (Ru = e.FormData),
            (Wu = e.Blob),
            (Du = e.File),
            (Mu = e.ReadableStream),
            (ju = e.getMultipartRequestOptions),
            (Lu = e.getDefaultAgent),
            (Uu = e.fileFromPath),
            (Fu = e.isFsReadStream);
        })(
          (function () {
            let { manuallyImported: e } =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {};
            const t = e
              ? "You may need to use polyfills"
              : "Add one of these imports before your first `import \u2026 from 'openai'`:\n- `import 'openai/shims/node'` (if you're running on Node)\n- `import 'openai/shims/web'` (otherwise)\n";
            let n, r, s, i;
            try {
              (n = fetch), (r = Request), (s = Response), (i = Headers);
            } catch (o) {
              throw new Error(
                "this environment is missing the following Web Fetch API type: "
                  .concat(o.message, ". ")
                  .concat(t)
              );
            }
            return {
              kind: "web",
              fetch: n,
              Request: r,
              Response: s,
              Headers: i,
              FormData:
                "undefined" !== typeof FormData
                  ? FormData
                  : class {
                      constructor() {
                        throw new Error(
                          "file uploads aren't supported in this environment yet as 'FormData' is undefined. ".concat(
                            t
                          )
                        );
                      }
                    },
              Blob:
                "undefined" !== typeof Blob
                  ? Blob
                  : class {
                      constructor() {
                        throw new Error(
                          "file uploads aren't supported in this environment yet as 'Blob' is undefined. ".concat(
                            t
                          )
                        );
                      }
                    },
              File:
                "undefined" !== typeof File
                  ? File
                  : class {
                      constructor() {
                        throw new Error(
                          "file uploads aren't supported in this environment yet as 'File' is undefined. ".concat(
                            t
                          )
                        );
                      }
                    },
              ReadableStream:
                "undefined" !== typeof ReadableStream
                  ? ReadableStream
                  : class {
                      constructor() {
                        throw new Error(
                          "streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ".concat(
                            t
                          )
                        );
                      }
                    },
              getMultipartRequestOptions: async (e, t) => ({
                ...t,
                body: new Ku(e),
              }),
              getDefaultAgent: (e) => {},
              fileFromPath: () => {
                throw new Error(
                  "The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/openai/openai-node#file-uploads"
                );
              },
              isFsReadStream: (e) => !1,
            };
          })(),
          { auto: !0 }
        );
      class zu extends Error {}
      class Gu extends zu {
        constructor(e, t, n, r) {
          super("".concat(Gu.makeMessage(e, t, n))),
            (this.status = e),
            (this.headers = r),
            (this.request_id =
              null === r || void 0 === r ? void 0 : r["x-request-id"]);
          const s = t;
          (this.error = s),
            (this.code = null === s || void 0 === s ? void 0 : s.code),
            (this.param = null === s || void 0 === s ? void 0 : s.param),
            (this.type = null === s || void 0 === s ? void 0 : s.type);
        }
        static makeMessage(e, t, n) {
          const r =
            null !== t && void 0 !== t && t.message
              ? "string" === typeof t.message
                ? t.message
                : JSON.stringify(t.message)
              : t
              ? JSON.stringify(t)
              : n;
          return e && r
            ? "".concat(e, " ").concat(r)
            : e
            ? "".concat(e, " status code (no body)")
            : r || "(no status code or body)";
        }
        static generate(e, t, n, r) {
          if (!e) return new Qu({ cause: qd(t) });
          const s = null === t || void 0 === t ? void 0 : t.error;
          return 400 === e
            ? new Xu(e, s, n, r)
            : 401 === e
            ? new Zu(e, s, n, r)
            : 403 === e
            ? new $u(e, s, n, r)
            : 404 === e
            ? new ed(e, s, n, r)
            : 409 === e
            ? new td(e, s, n, r)
            : 422 === e
            ? new nd(e, s, n, r)
            : 429 === e
            ? new rd(e, s, n, r)
            : e >= 500
            ? new sd(e, s, n, r)
            : new Gu(e, s, n, r);
        }
      }
      class Ju extends Gu {
        constructor() {
          let { message: e } =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          super(void 0, void 0, e || "Request was aborted.", void 0),
            (this.status = void 0);
        }
      }
      class Qu extends Gu {
        constructor(e) {
          let { message: t, cause: n } = e;
          super(void 0, void 0, t || "Connection error.", void 0),
            (this.status = void 0),
            n && (this.cause = n);
        }
      }
      class Yu extends Qu {
        constructor() {
          let { message: e } =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          super({
            message: null !== e && void 0 !== e ? e : "Request timed out.",
          });
        }
      }
      class Xu extends Gu {
        constructor() {
          super(...arguments), (this.status = 400);
        }
      }
      class Zu extends Gu {
        constructor() {
          super(...arguments), (this.status = 401);
        }
      }
      class $u extends Gu {
        constructor() {
          super(...arguments), (this.status = 403);
        }
      }
      class ed extends Gu {
        constructor() {
          super(...arguments), (this.status = 404);
        }
      }
      class td extends Gu {
        constructor() {
          super(...arguments), (this.status = 409);
        }
      }
      class nd extends Gu {
        constructor() {
          super(...arguments), (this.status = 422);
        }
      }
      class rd extends Gu {
        constructor() {
          super(...arguments), (this.status = 429);
        }
      }
      class sd extends Gu {}
      class id {
        constructor(e, t) {
          (this.iterator = e), (this.controller = t);
        }
        static fromSSEResponse(e, t) {
          let n = !1;
          return new id(async function* () {
            if (n)
              throw new Error(
                "Cannot iterate over a consumed stream, use `.tee()` to split the stream."
              );
            n = !0;
            let r = !1;
            try {
              for await (const n of (async function* (e, t) {
                if (!e.body)
                  throw (
                    (t.abort(),
                    new zu("Attempted to iterate over a response with no body"))
                  );
                const n = new ad(),
                  r = new cd(),
                  s = ld(e.body);
                for await (const i of (async function* (e) {
                  let t = new Uint8Array();
                  for await (const n of e) {
                    if (null == n) continue;
                    const e =
                      n instanceof ArrayBuffer
                        ? new Uint8Array(n)
                        : "string" === typeof n
                        ? new TextEncoder().encode(n)
                        : n;
                    let r,
                      s = new Uint8Array(t.length + e.length);
                    for (
                      s.set(t), s.set(e, t.length), t = s;
                      -1 !== (r = od(t));

                    )
                      yield t.slice(0, r), (t = t.slice(r));
                  }
                  t.length > 0 && (yield t);
                })(s))
                  for (const e of r.decode(i)) {
                    const t = n.decode(e);
                    t && (yield t);
                  }
                for (const i of r.flush()) {
                  const e = n.decode(i);
                  e && (yield e);
                }
              })(e, t))
                if (!r)
                  if (n.data.startsWith("[DONE]")) r = !0;
                  else if (null === n.event) {
                    let e;
                    try {
                      e = JSON.parse(n.data);
                    } catch (a_) {
                      throw (
                        (console.error(
                          "Could not parse message into JSON:",
                          n.data
                        ),
                        console.error("From chunk:", n.raw),
                        a_)
                      );
                    }
                    if (e && e.error)
                      throw new Gu(void 0, e.error, void 0, void 0);
                    yield e;
                  } else {
                    let e;
                    try {
                      e = JSON.parse(n.data);
                    } catch (a_) {
                      throw (
                        (console.error(
                          "Could not parse message into JSON:",
                          n.data
                        ),
                        console.error("From chunk:", n.raw),
                        a_)
                      );
                    }
                    if ("error" == n.event)
                      throw new Gu(void 0, e.error, e.message, void 0);
                    yield { event: n.event, data: e };
                  }
              r = !0;
            } catch (a_) {
              if (a_ instanceof Error && "AbortError" === a_.name) return;
              throw a_;
            } finally {
              r || t.abort();
            }
          }, t);
        }
        static fromReadableStream(e, t) {
          let n = !1;
          return new id(async function* () {
            if (n)
              throw new Error(
                "Cannot iterate over a consumed stream, use `.tee()` to split the stream."
              );
            n = !0;
            let r = !1;
            try {
              for await (const t of (async function* () {
                const t = new cd(),
                  n = ld(e);
                for await (const e of n) for (const n of t.decode(e)) yield n;
                for (const e of t.flush()) yield e;
              })())
                r || (t && (yield JSON.parse(t)));
              r = !0;
            } catch (a_) {
              if (a_ instanceof Error && "AbortError" === a_.name) return;
              throw a_;
            } finally {
              r || t.abort();
            }
          }, t);
        }
        [Symbol.asyncIterator]() {
          return this.iterator();
        }
        tee() {
          const e = [],
            t = [],
            n = this.iterator(),
            r = (r) => ({
              next: () => {
                if (0 === r.length) {
                  const r = n.next();
                  e.push(r), t.push(r);
                }
                return r.shift();
              },
            });
          return [
            new id(() => r(e), this.controller),
            new id(() => r(t), this.controller),
          ];
        }
        toReadableStream() {
          const e = this;
          let t;
          const n = new TextEncoder();
          return new Mu({
            async start() {
              t = e[Symbol.asyncIterator]();
            },
            async pull(e) {
              try {
                const { value: r, done: s } = await t.next();
                if (s) return e.close();
                const i = n.encode(JSON.stringify(r) + "\n");
                e.enqueue(i);
              } catch (r) {
                e.error(r);
              }
            },
            async cancel() {
              var e, n;
              await (null === (e = (n = t).return) || void 0 === e
                ? void 0
                : e.call(n));
            },
          });
        }
      }
      function od(e) {
        for (let t = 0; t < e.length - 2; t++) {
          if (10 === e[t] && 10 === e[t + 1]) return t + 2;
          if (13 === e[t] && 13 === e[t + 1]) return t + 2;
          if (
            13 === e[t] &&
            10 === e[t + 1] &&
            t + 3 < e.length &&
            13 === e[t + 2] &&
            10 === e[t + 3]
          )
            return t + 4;
        }
        return -1;
      }
      class ad {
        constructor() {
          (this.event = null), (this.data = []), (this.chunks = []);
        }
        decode(e) {
          if ((e.endsWith("\r") && (e = e.substring(0, e.length - 1)), !e)) {
            if (!this.event && !this.data.length) return null;
            const e = {
              event: this.event,
              data: this.data.join("\n"),
              raw: this.chunks,
            };
            return (this.event = null), (this.data = []), (this.chunks = []), e;
          }
          if ((this.chunks.push(e), e.startsWith(":"))) return null;
          let [t, n, r] = (function (e, t) {
            const n = e.indexOf(t);
            if (-1 !== n)
              return [e.substring(0, n), t, e.substring(n + t.length)];
            return [e, "", ""];
          })(e, ":");
          return (
            r.startsWith(" ") && (r = r.substring(1)),
            "event" === t
              ? (this.event = r)
              : "data" === t && this.data.push(r),
            null
          );
        }
      }
      class cd {
        constructor() {
          (this.buffer = []), (this.trailingCR = !1);
        }
        decode(e) {
          let t = this.decodeText(e);
          if (
            (this.trailingCR && ((t = "\r" + t), (this.trailingCR = !1)),
            t.endsWith("\r") && ((this.trailingCR = !0), (t = t.slice(0, -1))),
            !t)
          )
            return [];
          const n = cd.NEWLINE_CHARS.has(t[t.length - 1] || "");
          let r = t.split(cd.NEWLINE_REGEXP);
          return (
            n && r.pop(),
            1 !== r.length || n
              ? (this.buffer.length > 0 &&
                  ((r = [this.buffer.join("") + r[0], ...r.slice(1)]),
                  (this.buffer = [])),
                n || (this.buffer = [r.pop() || ""]),
                r)
              : (this.buffer.push(r[0]), [])
          );
        }
        decodeText(e) {
          if (null == e) return "";
          if ("string" === typeof e) return e;
          if ("undefined" !== typeof Buffer) {
            if (e instanceof Buffer) return e.toString();
            if (e instanceof Uint8Array) return Buffer.from(e).toString();
            throw new zu(
              "Unexpected: received non-Uint8Array (".concat(
                e.constructor.name,
                ') stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.'
              )
            );
          }
          if ("undefined" !== typeof TextDecoder) {
            var t;
            if (e instanceof Uint8Array || e instanceof ArrayBuffer)
              return (
                (null !== (t = this.textDecoder) && void 0 !== t) ||
                  (this.textDecoder = new TextDecoder("utf8")),
                this.textDecoder.decode(e)
              );
            throw new zu(
              "Unexpected: received non-Uint8Array/ArrayBuffer (".concat(
                e.constructor.name,
                ") in a web platform. Please report this error."
              )
            );
          }
          throw new zu(
            "Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error."
          );
        }
        flush() {
          if (!this.buffer.length && !this.trailingCR) return [];
          const e = [this.buffer.join("")];
          return (this.buffer = []), (this.trailingCR = !1), e;
        }
      }
      function ld(e) {
        if (e[Symbol.asyncIterator]) return e;
        const t = e.getReader();
        return {
          async next() {
            try {
              const e = await t.read();
              return null !== e && void 0 !== e && e.done && t.releaseLock(), e;
            } catch (a_) {
              throw (t.releaseLock(), a_);
            }
          },
          async return() {
            const e = t.cancel();
            return t.releaseLock(), await e, { done: !0, value: void 0 };
          },
          [Symbol.asyncIterator]() {
            return this;
          },
        };
      }
      (cd.NEWLINE_CHARS = new Set(["\n", "\r"])),
        (cd.NEWLINE_REGEXP = /\r\n|[\n\r]/g);
      const ud = (e) =>
          null != e &&
          "object" === typeof e &&
          "string" === typeof e.url &&
          "function" === typeof e.blob,
        dd = (e) =>
          null != e &&
          "object" === typeof e &&
          "string" === typeof e.name &&
          "number" === typeof e.lastModified &&
          hd(e),
        hd = (e) =>
          null != e &&
          "object" === typeof e &&
          "number" === typeof e.size &&
          "string" === typeof e.type &&
          "function" === typeof e.text &&
          "function" === typeof e.slice &&
          "function" === typeof e.arrayBuffer,
        pd = (e) => dd(e) || ud(e) || Fu(e);
      async function fd(e, t, n) {
        var r, s;
        if (
          ((e = await e),
          (null !== (r = n) && void 0 !== r) ||
            (n = dd(e) ? { lastModified: e.lastModified, type: e.type } : {}),
          ud(e))
        ) {
          var i;
          const r = await e.blob();
          return (
            t ||
              (t =
                null !== (i = new URL(e.url).pathname.split(/[\\/]/).pop()) &&
                void 0 !== i
                  ? i
                  : "unknown_file"),
            new Du([r], t, n)
          );
        }
        const o = await (async function (e) {
          let t = [];
          if (
            "string" === typeof e ||
            ArrayBuffer.isView(e) ||
            e instanceof ArrayBuffer
          )
            t.push(e);
          else if (hd(e)) t.push(await e.arrayBuffer());
          else {
            var n;
            if (!gd(e))
              throw new Error(
                "Unexpected data type: "
                  .concat(typeof e, "; constructor: ")
                  .concat(
                    null === e ||
                      void 0 === e ||
                      null === (n = e.constructor) ||
                      void 0 === n
                      ? void 0
                      : n.name,
                    "; props: "
                  )
                  .concat(
                    (function (e) {
                      const t = Object.getOwnPropertyNames(e);
                      return "[".concat(
                        t.map((e) => '"'.concat(e, '"')).join(", "),
                        "]"
                      );
                    })(e)
                  )
              );
            for await (const n of e) t.push(n);
          }
          return t;
        })(e);
        if (
          (t ||
            (t =
              null !==
                (s = (function (e) {
                  var t;
                  return (
                    md(e.name) ||
                    md(e.filename) ||
                    (null === (t = md(e.path)) || void 0 === t
                      ? void 0
                      : t.split(/[\\/]/).pop())
                  );
                })(e)) && void 0 !== s
                ? s
                : "unknown_file"),
          !n.type)
        ) {
          var a;
          const e = null === (a = o[0]) || void 0 === a ? void 0 : a.type;
          "string" === typeof e && (n = { ...n, type: e });
        }
        return new Du(o, t, n);
      }
      const md = (e) =>
          "string" === typeof e
            ? e
            : "undefined" !== typeof Buffer && e instanceof Buffer
            ? String(e)
            : void 0,
        gd = (e) =>
          null != e &&
          "object" === typeof e &&
          "function" === typeof e[Symbol.asyncIterator],
        vd = (e) =>
          e &&
          "object" === typeof e &&
          e.body &&
          "MultipartBody" === e[Symbol.toStringTag],
        yd = async (e) => {
          const t = await bd(e.body);
          return ju(t, e);
        },
        bd = async (e) => {
          const t = new Ru();
          return (
            await Promise.all(
              Object.entries(e || {}).map((e) => {
                let [n, r] = e;
                return wd(t, n, r);
              })
            ),
            t
          );
        },
        wd = async (e, t, n) => {
          if (void 0 !== n) {
            if (null == n)
              throw new TypeError(
                'Received null for "'.concat(
                  t,
                  "\"; to pass null in FormData, you must use the string 'null'"
                )
              );
            if (
              "string" === typeof n ||
              "number" === typeof n ||
              "boolean" === typeof n
            )
              e.append(t, String(n));
            else if (pd(n)) {
              const r = await fd(n);
              e.append(t, r);
            } else if (Array.isArray(n))
              await Promise.all(n.map((n) => wd(e, t + "[]", n)));
            else {
              if ("object" !== typeof n)
                throw new TypeError(
                  "Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ".concat(
                    n,
                    " instead"
                  )
                );
              await Promise.all(
                Object.entries(n).map((n) => {
                  let [r, s] = n;
                  return wd(e, "".concat(t, "[").concat(r, "]"), s);
                })
              );
            }
          }
        };
      var Sd,
        _d = function (e, t, n, r, s) {
          if ("m" === r) throw new TypeError("Private method is not writable");
          if ("a" === r && !s)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if ("function" === typeof t ? e !== t || !s : !t.has(e))
            throw new TypeError(
              "Cannot write private member to an object whose class did not declare it"
            );
          return "a" === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
        },
        Ed = function (e, t, n, r) {
          if ("a" === n && !r)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if ("function" === typeof t ? e !== t || !r : !t.has(e))
            throw new TypeError(
              "Cannot read private member from an object whose class did not declare it"
            );
          return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e);
        };
      async function Ad(e) {
        const { response: t } = e;
        if (e.options.stream)
          return (
            Gd("response", t.status, t.url, t.headers, t.body),
            e.options.__streamClass
              ? e.options.__streamClass.fromSSEResponse(t, e.controller)
              : id.fromSSEResponse(t, e.controller)
          );
        if (204 === t.status) return null;
        if (e.options.__binaryResponse) return t;
        const n = t.headers.get("content-type");
        if (
          (null === n || void 0 === n
            ? void 0
            : n.includes("application/json")) ||
          (null === n || void 0 === n
            ? void 0
            : n.includes("application/vnd.api+json"))
        ) {
          const e = await t.json();
          return Gd("response", t.status, t.url, t.headers, e), e;
        }
        const r = await t.text();
        return Gd("response", t.status, t.url, t.headers, r), r;
      }
      class Td extends Promise {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ad;
          super((e) => {
            e(null);
          }),
            (this.responsePromise = e),
            (this.parseResponse = t);
        }
        _thenUnwrap(e) {
          return new Td(this.responsePromise, async (t) =>
            e(await this.parseResponse(t))
          );
        }
        asResponse() {
          return this.responsePromise.then((e) => e.response);
        }
        async withResponse() {
          const [e, t] = await Promise.all([this.parse(), this.asResponse()]);
          return { data: e, response: t };
        }
        parse() {
          return (
            this.parsedPromise ||
              (this.parsedPromise = this.responsePromise.then(
                this.parseResponse
              )),
            this.parsedPromise
          );
        }
        then(e, t) {
          return this.parse().then(e, t);
        }
        catch(e) {
          return this.parse().catch(e);
        }
        finally(e) {
          return this.parse().finally(e);
        }
      }
      class Pd {
        constructor(e) {
          let {
            baseURL: t,
            maxRetries: n = 2,
            timeout: r = 6e5,
            httpAgent: s,
            fetch: i,
          } = e;
          (this.baseURL = t),
            (this.maxRetries = Vd("maxRetries", n)),
            (this.timeout = Vd("timeout", r)),
            (this.httpAgent = s),
            (this.fetch = null !== i && void 0 !== i ? i : Nu);
        }
        authHeaders(e) {
          return {};
        }
        defaultHeaders(e) {
          return {
            Accept: "application/json",
            "Content-Type": "application/json",
            "User-Agent": this.getUserAgent(),
            ...jd(),
            ...this.authHeaders(e),
          };
        }
        validateHeaders(e, t) {}
        defaultIdempotencyKey() {
          return "stainless-node-retry-".concat(Jd());
        }
        get(e, t) {
          return this.methodRequest("get", e, t);
        }
        post(e, t) {
          return this.methodRequest("post", e, t);
        }
        patch(e, t) {
          return this.methodRequest("patch", e, t);
        }
        put(e, t) {
          return this.methodRequest("put", e, t);
        }
        delete(e, t) {
          return this.methodRequest("delete", e, t);
        }
        methodRequest(e, t, n) {
          return this.request(
            Promise.resolve(n).then((n) => ({ method: e, path: t, ...n }))
          );
        }
        getAPIList(e, t, n) {
          return this.requestAPIList(t, { method: "get", path: e, ...n });
        }
        calculateContentLength(e) {
          if ("string" === typeof e) {
            if ("undefined" !== typeof Buffer)
              return Buffer.byteLength(e, "utf8").toString();
            if ("undefined" !== typeof TextEncoder) {
              return new TextEncoder().encode(e).length.toString();
            }
          }
          return null;
        }
        buildRequest(e) {
          var t, n, r, s, i, o;
          const { method: a, path: c, query: l, headers: u = {} } = e,
            d = vd(e.body)
              ? e.body.body
              : e.body
              ? JSON.stringify(e.body, null, 2)
              : null,
            h = this.calculateContentLength(d),
            p = this.buildURL(c, l);
          "timeout" in e && Vd("timeout", e.timeout);
          const f = null !== (t = e.timeout) && void 0 !== t ? t : this.timeout,
            m =
              null !==
                (n =
                  null !== (r = e.httpAgent) && void 0 !== r
                    ? r
                    : this.httpAgent) && void 0 !== n
                ? n
                : Lu(p),
            g = f + 1e3;
          "number" ===
            typeof (null === m ||
            void 0 === m ||
            null === (s = m.options) ||
            void 0 === s
              ? void 0
              : s.timeout) &&
            g > (null !== (i = m.options.timeout) && void 0 !== i ? i : 0) &&
            (m.options.timeout = g),
            this.idempotencyHeader &&
              "get" !== a &&
              (e.idempotencyKey ||
                (e.idempotencyKey = this.defaultIdempotencyKey()),
              (u[this.idempotencyHeader] = e.idempotencyKey));
          return {
            req: {
              method: a,
              ...(d && { body: d }),
              headers: this.buildHeaders({
                options: e,
                headers: u,
                contentLength: h,
              }),
              ...(m && { agent: m }),
              signal: null !== (o = e.signal) && void 0 !== o ? o : null,
            },
            url: p,
            timeout: f,
          };
        }
        buildHeaders(e) {
          let { options: t, headers: n, contentLength: r } = e;
          const s = {};
          r && (s["content-length"] = r);
          return (
            zd(s, this.defaultHeaders(t)),
            zd(s, n),
            vd(t.body) && "node" !== xu && delete s["content-type"],
            this.validateHeaders(s, n),
            s
          );
        }
        async prepareOptions(e) {}
        async prepareRequest(e, t) {
          let { url: n, options: r } = t;
        }
        parseHeaders(e) {
          return e
            ? Symbol.iterator in e
              ? Object.fromEntries(Array.from(e).map((e) => [...e]))
              : { ...e }
            : {};
        }
        makeStatusError(e, t, n, r) {
          return Gu.generate(e, t, n, r);
        }
        request(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null;
          return new Td(this.makeRequest(e, t));
        }
        async makeRequest(e, t) {
          var n;
          const r = await e;
          var s;
          null == t &&
            (t =
              null !== (s = r.maxRetries) && void 0 !== s
                ? s
                : this.maxRetries);
          await this.prepareOptions(r);
          const { req: i, url: o, timeout: a } = this.buildRequest(r);
          if (
            (await this.prepareRequest(i, { url: o, options: r }),
            Gd("request", o, r, i.headers),
            null !== (n = r.signal) && void 0 !== n && n.aborted)
          )
            throw new Ju();
          const c = new AbortController(),
            l = await this.fetchWithTimeout(o, i, a, c).catch(qd);
          if (l instanceof Error) {
            var u;
            if (null !== (u = r.signal) && void 0 !== u && u.aborted)
              throw new Ju();
            if (t) return this.retryRequest(r, t);
            if ("AbortError" === l.name) throw new Yu();
            throw new Qu({ cause: l });
          }
          const d = kd(l.headers);
          if (!l.ok) {
            if (t && this.shouldRetry(l)) {
              const e = "retrying, ".concat(t, " attempts remaining");
              return (
                Gd("response (error; ".concat(e, ")"), l.status, o, d),
                this.retryRequest(r, t, d)
              );
            }
            const e = await l.text().catch((e) => qd(e).message),
              n = Ld(e),
              s = n ? void 0 : e;
            Gd(
              "response (error; ".concat(
                t ? "(error; no more retries left)" : "(error; not retryable)",
                ")"
              ),
              l.status,
              o,
              d,
              s
            );
            throw this.makeStatusError(l.status, n, s, d);
          }
          return { response: l, options: r, controller: c };
        }
        requestAPIList(e, t) {
          const n = this.makeRequest(t, null);
          return new Cd(this, n, e);
        }
        buildURL(e, t) {
          const n = Fd(e)
              ? new URL(e)
              : new URL(
                  this.baseURL +
                    (this.baseURL.endsWith("/") && e.startsWith("/")
                      ? e.slice(1)
                      : e)
                ),
            r = this.defaultQuery();
          return (
            Wd(r) || (t = { ...r, ...t }),
            "object" === typeof t &&
              t &&
              !Array.isArray(t) &&
              (n.search = this.stringifyQuery(t)),
            n.toString()
          );
        }
        stringifyQuery(e) {
          return Object.entries(e)
            .filter((e) => {
              let [t, n] = e;
              return "undefined" !== typeof n;
            })
            .map((e) => {
              let [t, n] = e;
              if (
                "string" === typeof n ||
                "number" === typeof n ||
                "boolean" === typeof n
              )
                return ""
                  .concat(encodeURIComponent(t), "=")
                  .concat(encodeURIComponent(n));
              if (null === n) return "".concat(encodeURIComponent(t), "=");
              throw new zu(
                "Cannot stringify type ".concat(
                  typeof n,
                  "; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case."
                )
              );
            })
            .join("&");
        }
        async fetchWithTimeout(e, t, n, r) {
          const { signal: s, ...i } = t || {};
          s && s.addEventListener("abort", () => r.abort());
          const o = setTimeout(() => r.abort(), n);
          return this.getRequestClient()
            .fetch.call(void 0, e, { signal: r.signal, ...i })
            .finally(() => {
              clearTimeout(o);
            });
        }
        getRequestClient() {
          return { fetch: this.fetch };
        }
        shouldRetry(e) {
          const t = e.headers.get("x-should-retry");
          return (
            "true" === t ||
            ("false" !== t &&
              (408 === e.status ||
                409 === e.status ||
                429 === e.status ||
                e.status >= 500))
          );
        }
        async retryRequest(e, t, n) {
          let r;
          const s = null === n || void 0 === n ? void 0 : n["retry-after-ms"];
          if (s) {
            const e = parseFloat(s);
            Number.isNaN(e) || (r = e);
          }
          const i = null === n || void 0 === n ? void 0 : n["retry-after"];
          if (i && !r) {
            const e = parseFloat(i);
            r = Number.isNaN(e) ? Date.parse(i) - Date.now() : 1e3 * e;
          }
          if (!(r && 0 <= r && r < 6e4)) {
            var o;
            const n =
              null !== (o = e.maxRetries) && void 0 !== o ? o : this.maxRetries;
            r = this.calculateDefaultRetryTimeoutMillis(t, n);
          }
          return await Bd(r), this.makeRequest(e, t - 1);
        }
        calculateDefaultRetryTimeoutMillis(e, t) {
          const n = t - e;
          return (
            Math.min(0.5 * Math.pow(2, n), 8) * (1 - 0.25 * Math.random()) * 1e3
          );
        }
        getUserAgent() {
          return "".concat(this.constructor.name, "/JS ").concat(Ou);
        }
      }
      class Id {
        constructor(e, t, n, r) {
          Sd.set(this, void 0),
            _d(this, Sd, e, "f"),
            (this.options = r),
            (this.response = t),
            (this.body = n);
        }
        hasNextPage() {
          return (
            !!this.getPaginatedItems().length && null != this.nextPageInfo()
          );
        }
        async getNextPage() {
          const e = this.nextPageInfo();
          if (!e)
            throw new zu(
              "No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`."
            );
          const t = { ...this.options };
          if ("params" in e && "object" === typeof t.query)
            t.query = { ...t.query, ...e.params };
          else if ("url" in e) {
            const n = [
              ...Object.entries(t.query || {}),
              ...e.url.searchParams.entries(),
            ];
            for (const [t, r] of n) e.url.searchParams.set(t, r);
            (t.query = void 0), (t.path = e.url.toString());
          }
          return await Ed(this, Sd, "f").requestAPIList(this.constructor, t);
        }
        async *iterPages() {
          let e = this;
          for (yield e; e.hasNextPage(); ) (e = await e.getNextPage()), yield e;
        }
        async *[((Sd = new WeakMap()), Symbol.asyncIterator)]() {
          for await (const e of this.iterPages())
            for (const t of e.getPaginatedItems()) yield t;
        }
      }
      class Cd extends Td {
        constructor(e, t, n) {
          super(t, async (t) => new n(e, t.response, await Ad(t), t.options));
        }
        async *[Symbol.asyncIterator]() {
          const e = await this;
          for await (const t of e) yield t;
        }
      }
      const kd = (e) =>
          new Proxy(Object.fromEntries(e.entries()), {
            get(e, t) {
              const n = t.toString();
              return e[n.toLowerCase()] || e[n];
            },
          }),
        Od = {
          method: !0,
          path: !0,
          query: !0,
          body: !0,
          headers: !0,
          maxRetries: !0,
          stream: !0,
          timeout: !0,
          httpAgent: !0,
          signal: !0,
          idempotencyKey: !0,
          __binaryResponse: !0,
          __streamClass: !0,
        },
        xd = (e) =>
          "object" === typeof e &&
          null !== e &&
          !Wd(e) &&
          Object.keys(e).every((e) => Kd(Od, e)),
        Nd = () => {
          var e, t;
          if ("undefined" !== typeof Deno && null != Deno.build)
            return {
              "X-Stainless-Lang": "js",
              "X-Stainless-Package-Version": Ou,
              "X-Stainless-OS": Dd(Deno.build.os),
              "X-Stainless-Arch": Rd(Deno.build.arch),
              "X-Stainless-Runtime": "deno",
              "X-Stainless-Runtime-Version":
                "string" === typeof Deno.version
                  ? Deno.version
                  : null !==
                      (e =
                        null === (t = Deno.version) || void 0 === t
                          ? void 0
                          : t.deno) && void 0 !== e
                  ? e
                  : "unknown",
            };
          if ("undefined" !== typeof EdgeRuntime)
            return {
              "X-Stainless-Lang": "js",
              "X-Stainless-Package-Version": Ou,
              "X-Stainless-OS": "Unknown",
              "X-Stainless-Arch": "other:".concat(EdgeRuntime),
              "X-Stainless-Runtime": "edge",
              "X-Stainless-Runtime-Version": process.version,
            };
          if (
            "[object process]" ===
            Object.prototype.toString.call(
              "undefined" !== typeof process ? process : 0
            )
          )
            return {
              "X-Stainless-Lang": "js",
              "X-Stainless-Package-Version": Ou,
              "X-Stainless-OS": Dd(process.platform),
              "X-Stainless-Arch": Rd(process.arch),
              "X-Stainless-Runtime": "node",
              "X-Stainless-Runtime-Version": process.version,
            };
          const n = (function () {
            if ("undefined" === typeof navigator || !navigator) return null;
            const e = [
              { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
              { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
              {
                key: "ie",
                pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/,
              },
              {
                key: "chrome",
                pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/,
              },
              {
                key: "firefox",
                pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/,
              },
              {
                key: "safari",
                pattern:
                  /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/,
              },
            ];
            for (const { key: t, pattern: n } of e) {
              const e = n.exec(navigator.userAgent);
              if (e) {
                const n = e[1] || 0,
                  r = e[2] || 0,
                  s = e[3] || 0;
                return {
                  browser: t,
                  version: "".concat(n, ".").concat(r, ".").concat(s),
                };
              }
            }
            return null;
          })();
          return n
            ? {
                "X-Stainless-Lang": "js",
                "X-Stainless-Package-Version": Ou,
                "X-Stainless-OS": "Unknown",
                "X-Stainless-Arch": "unknown",
                "X-Stainless-Runtime": "browser:".concat(n.browser),
                "X-Stainless-Runtime-Version": n.version,
              }
            : {
                "X-Stainless-Lang": "js",
                "X-Stainless-Package-Version": Ou,
                "X-Stainless-OS": "Unknown",
                "X-Stainless-Arch": "unknown",
                "X-Stainless-Runtime": "unknown",
                "X-Stainless-Runtime-Version": "unknown",
              };
        };
      const Rd = (e) =>
          "x32" === e
            ? "x32"
            : "x86_64" === e || "x64" === e
            ? "x64"
            : "arm" === e
            ? "arm"
            : "aarch64" === e || "arm64" === e
            ? "arm64"
            : e
            ? "other:".concat(e)
            : "unknown",
        Dd = (e) =>
          (e = e.toLowerCase()).includes("ios")
            ? "iOS"
            : "android" === e
            ? "Android"
            : "darwin" === e
            ? "MacOS"
            : "win32" === e
            ? "Windows"
            : "freebsd" === e
            ? "FreeBSD"
            : "openbsd" === e
            ? "OpenBSD"
            : "linux" === e
            ? "Linux"
            : e
            ? "Other:".concat(e)
            : "Unknown";
      let Md;
      const jd = () => {
          var e;
          return null !== (e = Md) && void 0 !== e ? e : (Md = Nd());
        },
        Ld = (e) => {
          try {
            return JSON.parse(e);
          } catch (t) {
            return;
          }
        },
        Ud = new RegExp("^(?:[a-z]+:)?//", "i"),
        Fd = (e) => Ud.test(e),
        Bd = (e) => new Promise((t) => setTimeout(t, e)),
        Vd = (e, t) => {
          if ("number" !== typeof t || !Number.isInteger(t))
            throw new zu("".concat(e, " must be an integer"));
          if (t < 0) throw new zu("".concat(e, " must be a positive integer"));
          return t;
        },
        qd = (e) => (e instanceof Error ? e : new Error(e)),
        Hd = (e) => {
          var t, n, r, s;
          return "undefined" !== typeof process
            ? null !==
                (t =
                  null ===
                    (n = {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }) ||
                  void 0 === n ||
                  null === (n = n[e]) ||
                  void 0 === n
                    ? void 0
                    : n.trim()) && void 0 !== t
              ? t
              : void 0
            : "undefined" !== typeof Deno
            ? null === (r = Deno.env) ||
              void 0 === r ||
              null === (s = r.get) ||
              void 0 === s ||
              null === (s = s.call(r, e)) ||
              void 0 === s
              ? void 0
              : s.trim()
            : void 0;
        };
      function Wd(e) {
        if (!e) return !0;
        for (const t in e) return !1;
        return !0;
      }
      function Kd(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }
      function zd(e, t) {
        for (const n in t) {
          if (!Kd(t, n)) continue;
          const r = n.toLowerCase();
          if (!r) continue;
          const s = t[n];
          null === s ? delete e[r] : void 0 !== s && (e[r] = s);
        }
      }
      function Gd(e) {
        var t;
        if (
          "undefined" !== typeof process &&
          "true" ===
            (null === (t = process) ||
            void 0 === t ||
            null ===
              (t = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }) ||
            void 0 === t
              ? void 0
              : t.DEBUG)
        ) {
          for (
            var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), s = 1;
            s < n;
            s++
          )
            r[s - 1] = arguments[s];
          console.log("OpenAI:DEBUG:".concat(e), ...r);
        }
      }
      const Jd = () =>
        "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e) => {
          const t = (16 * Math.random()) | 0;
          return ("x" === e ? t : (3 & t) | 8).toString(16);
        });
      function Qd(e) {
        return null != e && "object" === typeof e && !Array.isArray(e);
      }
      class Yd extends Id {
        constructor(e, t, n, r) {
          super(e, t, n, r),
            (this.data = n.data || []),
            (this.object = n.object);
        }
        getPaginatedItems() {
          var e;
          return null !== (e = this.data) && void 0 !== e ? e : [];
        }
        nextPageParams() {
          return null;
        }
        nextPageInfo() {
          return null;
        }
      }
      class Xd extends Id {
        constructor(e, t, n, r) {
          super(e, t, n, r), (this.data = n.data || []);
        }
        getPaginatedItems() {
          var e;
          return null !== (e = this.data) && void 0 !== e ? e : [];
        }
        nextPageParams() {
          const e = this.nextPageInfo();
          if (!e) return null;
          if ("params" in e) return e.params;
          const t = Object.fromEntries(e.url.searchParams);
          return Object.keys(t).length ? t : null;
        }
        nextPageInfo() {
          var e;
          const t = this.getPaginatedItems();
          if (!t.length) return null;
          const n =
            null === (e = t[t.length - 1]) || void 0 === e ? void 0 : e.id;
          return n ? { params: { after: n } } : null;
        }
      }
      class Zd {
        constructor(e) {
          this._client = e;
        }
      }
      class $d extends Zd {
        create(e, t) {
          var n;
          return this._client.post("/completions", {
            body: e,
            ...t,
            stream: null !== (n = e.stream) && void 0 !== n && n,
          });
        }
      }
      $d || ($d = {});
      class eh extends Zd {
        create(e, t) {
          var n;
          return this._client.post("/chat/completions", {
            body: e,
            ...t,
            stream: null !== (n = e.stream) && void 0 !== n && n,
          });
        }
      }
      eh || (eh = {});
      class th extends Zd {
        constructor() {
          super(...arguments), (this.completions = new eh(this._client));
        }
      }
      !(function (e) {
        e.Completions = eh;
      })(th || (th = {}));
      class nh extends Zd {
        create(e, t) {
          return this._client.post("/embeddings", { body: e, ...t });
        }
      }
      nh || (nh = {});
      class rh extends Zd {
        create(e, t) {
          return this._client.post("/files", yd({ body: e, ...t }));
        }
        retrieve(e, t) {
          return this._client.get("/files/".concat(e), t);
        }
        list() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
          return xd(e)
            ? this.list({}, e)
            : this._client.getAPIList("/files", sh, { query: e, ...t });
        }
        del(e, t) {
          return this._client.delete("/files/".concat(e), t);
        }
        content(e, t) {
          return this._client.get("/files/".concat(e, "/content"), {
            ...t,
            __binaryResponse: !0,
          });
        }
        retrieveContent(e, t) {
          return this._client.get("/files/".concat(e, "/content"), {
            ...t,
            headers: {
              Accept: "application/json",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
        async waitForProcessing(e) {
          let { pollInterval: t = 5e3, maxWait: n = 18e5 } =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          const r = new Set(["processed", "error", "deleted"]),
            s = Date.now();
          let i = await this.retrieve(e);
          for (; !i.status || !r.has(i.status); )
            if ((await Bd(t), (i = await this.retrieve(e)), Date.now() - s > n))
              throw new Yu({
                message: "Giving up on waiting for file "
                  .concat(e, " to finish processing after ")
                  .concat(n, " milliseconds."),
              });
          return i;
        }
      }
      class sh extends Yd {}
      !(function (e) {
        e.FileObjectsPage = sh;
      })(rh || (rh = {}));
      class ih extends Zd {
        createVariation(e, t) {
          return this._client.post("/images/variations", yd({ body: e, ...t }));
        }
        edit(e, t) {
          return this._client.post("/images/edits", yd({ body: e, ...t }));
        }
        generate(e, t) {
          return this._client.post("/images/generations", { body: e, ...t });
        }
      }
      ih || (ih = {});
      class oh extends Zd {
        create(e, t) {
          return this._client.post("/audio/speech", {
            body: e,
            ...t,
            __binaryResponse: !0,
          });
        }
      }
      oh || (oh = {});
      class ah extends Zd {
        create(e, t) {
          return this._client.post(
            "/audio/transcriptions",
            yd({ body: e, ...t })
          );
        }
      }
      ah || (ah = {});
      class ch extends Zd {
        create(e, t) {
          return this._client.post(
            "/audio/translations",
            yd({ body: e, ...t })
          );
        }
      }
      ch || (ch = {});
      class lh extends Zd {
        constructor() {
          super(...arguments),
            (this.transcriptions = new ah(this._client)),
            (this.translations = new ch(this._client)),
            (this.speech = new oh(this._client));
        }
      }
      !(function (e) {
        (e.Transcriptions = ah), (e.Translations = ch), (e.Speech = oh);
      })(lh || (lh = {}));
      class uh extends Zd {
        create(e, t) {
          return this._client.post("/moderations", { body: e, ...t });
        }
      }
      uh || (uh = {});
      class dh extends Zd {
        retrieve(e, t) {
          return this._client.get("/models/".concat(e), t);
        }
        list(e) {
          return this._client.getAPIList("/models", hh, e);
        }
        del(e, t) {
          return this._client.delete("/models/".concat(e), t);
        }
      }
      class hh extends Yd {}
      !(function (e) {
        e.ModelsPage = hh;
      })(dh || (dh = {}));
      class ph extends Zd {
        list(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0;
          return xd(t)
            ? this.list(e, {}, t)
            : this._client.getAPIList(
                "/fine_tuning/jobs/".concat(e, "/checkpoints"),
                fh,
                { query: t, ...n }
              );
        }
      }
      class fh extends Xd {}
      !(function (e) {
        e.FineTuningJobCheckpointsPage = fh;
      })(ph || (ph = {}));
      class mh extends Zd {
        constructor() {
          super(...arguments), (this.checkpoints = new ph(this._client));
        }
        create(e, t) {
          return this._client.post("/fine_tuning/jobs", { body: e, ...t });
        }
        retrieve(e, t) {
          return this._client.get("/fine_tuning/jobs/".concat(e), t);
        }
        list() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
          return xd(e)
            ? this.list({}, e)
            : this._client.getAPIList("/fine_tuning/jobs", gh, {
                query: e,
                ...t,
              });
        }
        cancel(e, t) {
          return this._client.post(
            "/fine_tuning/jobs/".concat(e, "/cancel"),
            t
          );
        }
        listEvents(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0;
          return xd(t)
            ? this.listEvents(e, {}, t)
            : this._client.getAPIList(
                "/fine_tuning/jobs/".concat(e, "/events"),
                vh,
                { query: t, ...n }
              );
        }
      }
      class gh extends Xd {}
      class vh extends Xd {}
      !(function (e) {
        (e.FineTuningJobsPage = gh),
          (e.FineTuningJobEventsPage = vh),
          (e.Checkpoints = ph),
          (e.FineTuningJobCheckpointsPage = fh);
      })(mh || (mh = {}));
      class yh extends Zd {
        constructor() {
          super(...arguments), (this.jobs = new mh(this._client));
        }
      }
      !(function (e) {
        (e.Jobs = mh),
          (e.FineTuningJobsPage = gh),
          (e.FineTuningJobEventsPage = vh);
      })(yh || (yh = {}));
      class bh extends Zd {
        create(e, t) {
          return this._client.post("/assistants", {
            body: e,
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
        retrieve(e, t) {
          return this._client.get("/assistants/".concat(e), {
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
        update(e, t, n) {
          return this._client.post("/assistants/".concat(e), {
            body: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === n || void 0 === n ? void 0 : n.headers),
            },
          });
        }
        list() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
          return xd(e)
            ? this.list({}, e)
            : this._client.getAPIList("/assistants", wh, {
                query: e,
                ...t,
                headers: {
                  "OpenAI-Beta": "assistants=v2",
                  ...(null === t || void 0 === t ? void 0 : t.headers),
                },
              });
        }
        del(e, t) {
          return this._client.delete("/assistants/".concat(e), {
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
      }
      class wh extends Xd {}
      function Sh(e) {
        return "function" === typeof e.parse;
      }
      !(function (e) {
        e.AssistantsPage = wh;
      })(bh || (bh = {}));
      const _h = (e) =>
          "assistant" === (null === e || void 0 === e ? void 0 : e.role),
        Eh = (e) =>
          "function" === (null === e || void 0 === e ? void 0 : e.role),
        Ah = (e) => "tool" === (null === e || void 0 === e ? void 0 : e.role);
      var Th,
        Ph,
        Ih,
        Ch,
        kh,
        Oh,
        xh,
        Nh,
        Rh,
        Dh,
        Mh,
        jh,
        Lh,
        Uh,
        Fh,
        Bh,
        Vh,
        qh,
        Hh,
        Wh,
        Kh = function (e, t, n, r, s) {
          if ("m" === r) throw new TypeError("Private method is not writable");
          if ("a" === r && !s)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if ("function" === typeof t ? e !== t || !s : !t.has(e))
            throw new TypeError(
              "Cannot write private member to an object whose class did not declare it"
            );
          return "a" === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
        },
        zh = function (e, t, n, r) {
          if ("a" === n && !r)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if ("function" === typeof t ? e !== t || !r : !t.has(e))
            throw new TypeError(
              "Cannot read private member from an object whose class did not declare it"
            );
          return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e);
        };
      const Gh = 10;
      class Jh {
        constructor() {
          Th.add(this),
            (this.controller = new AbortController()),
            Ph.set(this, void 0),
            Ih.set(this, () => {}),
            Ch.set(this, () => {}),
            kh.set(this, void 0),
            Oh.set(this, () => {}),
            xh.set(this, () => {}),
            Nh.set(this, {}),
            (this._chatCompletions = []),
            (this.messages = []),
            Rh.set(this, !1),
            Dh.set(this, !1),
            Mh.set(this, !1),
            jh.set(this, !1),
            qh.set(this, (e) => {
              if (
                (Kh(this, Dh, !0, "f"),
                e instanceof Error && "AbortError" === e.name && (e = new Ju()),
                e instanceof Ju)
              )
                return Kh(this, Mh, !0, "f"), this._emit("abort", e);
              if (e instanceof zu) return this._emit("error", e);
              if (e instanceof Error) {
                const t = new zu(e.message);
                return (t.cause = e), this._emit("error", t);
              }
              return this._emit("error", new zu(String(e)));
            }),
            Kh(
              this,
              Ph,
              new Promise((e, t) => {
                Kh(this, Ih, e, "f"), Kh(this, Ch, t, "f");
              }),
              "f"
            ),
            Kh(
              this,
              kh,
              new Promise((e, t) => {
                Kh(this, Oh, e, "f"), Kh(this, xh, t, "f");
              }),
              "f"
            ),
            zh(this, Ph, "f").catch(() => {}),
            zh(this, kh, "f").catch(() => {});
        }
        _run(e) {
          setTimeout(() => {
            e().then(() => {
              this._emitFinal(), this._emit("end");
            }, zh(this, qh, "f"));
          }, 0);
        }
        _addChatCompletion(e) {
          var t;
          this._chatCompletions.push(e), this._emit("chatCompletion", e);
          const n =
            null === (t = e.choices[0]) || void 0 === t ? void 0 : t.message;
          return n && this._addMessage(n), e;
        }
        _addMessage(e) {
          let t =
            !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (("content" in e || (e.content = null), this.messages.push(e), t))
            if ((this._emit("message", e), (Eh(e) || Ah(e)) && e.content))
              this._emit("functionCallResult", e.content);
            else if (_h(e) && e.function_call)
              this._emit("functionCall", e.function_call);
            else if (_h(e) && e.tool_calls)
              for (const n of e.tool_calls)
                "function" === n.type && this._emit("functionCall", n.function);
        }
        _connected() {
          this.ended || (zh(this, Ih, "f").call(this), this._emit("connect"));
        }
        get ended() {
          return zh(this, Rh, "f");
        }
        get errored() {
          return zh(this, Dh, "f");
        }
        get aborted() {
          return zh(this, Mh, "f");
        }
        abort() {
          this.controller.abort();
        }
        on(e, t) {
          return (
            (zh(this, Nh, "f")[e] || (zh(this, Nh, "f")[e] = [])).push({
              listener: t,
            }),
            this
          );
        }
        off(e, t) {
          const n = zh(this, Nh, "f")[e];
          if (!n) return this;
          const r = n.findIndex((e) => e.listener === t);
          return r >= 0 && n.splice(r, 1), this;
        }
        once(e, t) {
          return (
            (zh(this, Nh, "f")[e] || (zh(this, Nh, "f")[e] = [])).push({
              listener: t,
              once: !0,
            }),
            this
          );
        }
        emitted(e) {
          return new Promise((t, n) => {
            Kh(this, jh, !0, "f"),
              "error" !== e && this.once("error", n),
              this.once(e, t);
          });
        }
        async done() {
          Kh(this, jh, !0, "f"), await zh(this, kh, "f");
        }
        async finalChatCompletion() {
          await this.done();
          const e = this._chatCompletions[this._chatCompletions.length - 1];
          if (!e)
            throw new zu("stream ended without producing a ChatCompletion");
          return e;
        }
        async finalContent() {
          return await this.done(), zh(this, Th, "m", Lh).call(this);
        }
        async finalMessage() {
          return await this.done(), zh(this, Th, "m", Uh).call(this);
        }
        async finalFunctionCall() {
          return await this.done(), zh(this, Th, "m", Fh).call(this);
        }
        async finalFunctionCallResult() {
          return await this.done(), zh(this, Th, "m", Bh).call(this);
        }
        async totalUsage() {
          return await this.done(), zh(this, Th, "m", Vh).call(this);
        }
        allChatCompletions() {
          return [...this._chatCompletions];
        }
        _emit(e) {
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (zh(this, Rh, "f")) return;
          "end" === e && (Kh(this, Rh, !0, "f"), zh(this, Oh, "f").call(this));
          const s = zh(this, Nh, "f")[e];
          if (
            (s &&
              ((zh(this, Nh, "f")[e] = s.filter((e) => !e.once)),
              s.forEach((e) => {
                let { listener: t } = e;
                return t(...n);
              })),
            "abort" === e)
          ) {
            const e = n[0];
            return (
              zh(this, jh, "f") ||
                (null !== s && void 0 !== s && s.length) ||
                Promise.reject(e),
              zh(this, Ch, "f").call(this, e),
              zh(this, xh, "f").call(this, e),
              void this._emit("end")
            );
          }
          if ("error" === e) {
            const e = n[0];
            zh(this, jh, "f") ||
              (null !== s && void 0 !== s && s.length) ||
              Promise.reject(e),
              zh(this, Ch, "f").call(this, e),
              zh(this, xh, "f").call(this, e),
              this._emit("end");
          }
        }
        _emitFinal() {
          const e = this._chatCompletions[this._chatCompletions.length - 1];
          e && this._emit("finalChatCompletion", e);
          const t = zh(this, Th, "m", Uh).call(this);
          t && this._emit("finalMessage", t);
          const n = zh(this, Th, "m", Lh).call(this);
          n && this._emit("finalContent", n);
          const r = zh(this, Th, "m", Fh).call(this);
          r && this._emit("finalFunctionCall", r);
          const s = zh(this, Th, "m", Bh).call(this);
          null != s && this._emit("finalFunctionCallResult", s),
            this._chatCompletions.some((e) => e.usage) &&
              this._emit("totalUsage", zh(this, Th, "m", Vh).call(this));
        }
        async _createChatCompletion(e, t, n) {
          const r = null === n || void 0 === n ? void 0 : n.signal;
          r &&
            (r.aborted && this.controller.abort(),
            r.addEventListener("abort", () => this.controller.abort())),
            zh(this, Th, "m", Hh).call(this, t);
          const s = await e.create(
            { ...t, stream: !1 },
            { ...n, signal: this.controller.signal }
          );
          return this._connected(), this._addChatCompletion(s);
        }
        async _runChatCompletion(e, t, n) {
          for (const r of t.messages) this._addMessage(r, !1);
          return await this._createChatCompletion(e, t, n);
        }
        async _runFunctions(e, t, n) {
          const r = "function",
            { function_call: s = "auto", stream: i, ...o } = t,
            a =
              "string" !== typeof s &&
              (null === s || void 0 === s ? void 0 : s.name),
            { maxChatCompletions: c = Gh } = n || {},
            l = {};
          for (const p of t.functions) l[p.name || p.function.name] = p;
          const u = t.functions.map((e) => ({
            name: e.name || e.function.name,
            parameters: e.parameters,
            description: e.description,
          }));
          for (const p of t.messages) this._addMessage(p, !1);
          for (let p = 0; p < c; ++p) {
            var d;
            const t =
              null ===
                (d = (
                  await this._createChatCompletion(
                    e,
                    {
                      ...o,
                      function_call: s,
                      functions: u,
                      messages: [...this.messages],
                    },
                    n
                  )
                ).choices[0]) || void 0 === d
                ? void 0
                : d.message;
            if (!t) throw new zu("missing message in ChatCompletion response");
            if (!t.function_call) return;
            const { name: i, arguments: c } = t.function_call,
              p = l[i];
            if (!p) {
              const e = "Invalid function_call: "
                .concat(JSON.stringify(i), ". Available options are: ")
                .concat(
                  u.map((e) => JSON.stringify(e.name)).join(", "),
                  ". Please try again"
                );
              this._addMessage({ role: r, name: i, content: e });
              continue;
            }
            if (a && a !== i) {
              const e = "Invalid function_call: "
                .concat(JSON.stringify(i), ". ")
                .concat(JSON.stringify(a), " requested. Please try again");
              this._addMessage({ role: r, name: i, content: e });
              continue;
            }
            let f;
            try {
              f = Sh(p) ? await p.parse(c) : c;
            } catch (h) {
              this._addMessage({
                role: r,
                name: i,
                content: h instanceof Error ? h.message : String(h),
              });
              continue;
            }
            const m = await p.function(f, this),
              g = zh(this, Th, "m", Wh).call(this, m);
            if ((this._addMessage({ role: r, name: i, content: g }), a)) return;
          }
        }
        async _runTools(e, t, n) {
          var r;
          const s = "tool",
            { tool_choice: i = "auto", stream: o, ...a } = t,
            c =
              "string" !== typeof i &&
              (null === i ||
              void 0 === i ||
              null === (r = i.function) ||
              void 0 === r
                ? void 0
                : r.name),
            { maxChatCompletions: l = Gh } = n || {},
            u = {};
          for (const f of t.tools)
            "function" === f.type &&
              (u[f.function.name || f.function.function.name] = f.function);
          const d =
            "tools" in t
              ? t.tools.map((e) =>
                  "function" === e.type
                    ? {
                        type: "function",
                        function: {
                          name: e.function.name || e.function.function.name,
                          parameters: e.function.parameters,
                          description: e.function.description,
                        },
                      }
                    : e
                )
              : void 0;
          for (const f of t.messages) this._addMessage(f, !1);
          for (let f = 0; f < l; ++f) {
            var h;
            const t =
              null ===
                (h = (
                  await this._createChatCompletion(
                    e,
                    {
                      ...a,
                      tool_choice: i,
                      tools: d,
                      messages: [...this.messages],
                    },
                    n
                  )
                ).choices[0]) || void 0 === h
                ? void 0
                : h.message;
            if (!t) throw new zu("missing message in ChatCompletion response");
            if (!t.tool_calls) return;
            for (const e of t.tool_calls) {
              if ("function" !== e.type) continue;
              const t = e.id,
                { name: n, arguments: r } = e.function,
                i = u[n];
              if (!i) {
                const e = "Invalid tool_call: "
                  .concat(JSON.stringify(n), ". Available options are: ")
                  .concat(
                    d.map((e) => JSON.stringify(e.function.name)).join(", "),
                    ". Please try again"
                  );
                this._addMessage({ role: s, tool_call_id: t, content: e });
                continue;
              }
              if (c && c !== n) {
                const e = "Invalid tool_call: "
                  .concat(JSON.stringify(n), ". ")
                  .concat(JSON.stringify(c), " requested. Please try again");
                this._addMessage({ role: s, tool_call_id: t, content: e });
                continue;
              }
              let o;
              try {
                o = Sh(i) ? await i.parse(r) : r;
              } catch (p) {
                const e = p instanceof Error ? p.message : String(p);
                this._addMessage({ role: s, tool_call_id: t, content: e });
                continue;
              }
              const a = await i.function(o, this),
                l = zh(this, Th, "m", Wh).call(this, a);
              if (
                (this._addMessage({ role: s, tool_call_id: t, content: l }), c)
              )
                return;
            }
          }
        }
      }
      (Ph = new WeakMap()),
        (Ih = new WeakMap()),
        (Ch = new WeakMap()),
        (kh = new WeakMap()),
        (Oh = new WeakMap()),
        (xh = new WeakMap()),
        (Nh = new WeakMap()),
        (Rh = new WeakMap()),
        (Dh = new WeakMap()),
        (Mh = new WeakMap()),
        (jh = new WeakMap()),
        (qh = new WeakMap()),
        (Th = new WeakSet()),
        (Lh = function () {
          var e;
          return null !== (e = zh(this, Th, "m", Uh).call(this).content) &&
            void 0 !== e
            ? e
            : null;
        }),
        (Uh = function () {
          let e = this.messages.length;
          for (; e-- > 0; ) {
            const n = this.messages[e];
            var t;
            if (_h(n))
              return {
                ...n,
                content: null !== (t = n.content) && void 0 !== t ? t : null,
              };
          }
          throw new zu(
            "stream ended without producing a ChatCompletionMessage with role=assistant"
          );
        }),
        (Fh = function () {
          for (let n = this.messages.length - 1; n >= 0; n--) {
            var e;
            const r = this.messages[n];
            if (_h(r) && null !== r && void 0 !== r && r.function_call)
              return r.function_call;
            var t;
            if (
              _h(r) &&
              null !== r &&
              void 0 !== r &&
              null !== (e = r.tool_calls) &&
              void 0 !== e &&
              e.length
            )
              return null === (t = r.tool_calls.at(-1)) || void 0 === t
                ? void 0
                : t.function;
          }
        }),
        (Bh = function () {
          for (let e = this.messages.length - 1; e >= 0; e--) {
            const t = this.messages[e];
            if (Eh(t) && null != t.content) return t.content;
            if (
              Ah(t) &&
              null != t.content &&
              this.messages.some((e) => {
                var n;
                return (
                  "assistant" === e.role &&
                  (null === (n = e.tool_calls) || void 0 === n
                    ? void 0
                    : n.some(
                        (e) => "function" === e.type && e.id === t.tool_call_id
                      ))
                );
              })
            )
              return t.content;
          }
        }),
        (Vh = function () {
          const e = { completion_tokens: 0, prompt_tokens: 0, total_tokens: 0 };
          for (const { usage: t } of this._chatCompletions)
            t &&
              ((e.completion_tokens += t.completion_tokens),
              (e.prompt_tokens += t.prompt_tokens),
              (e.total_tokens += t.total_tokens));
          return e;
        }),
        (Hh = function (e) {
          if (null != e.n && e.n > 1)
            throw new zu(
              "ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly."
            );
        }),
        (Wh = function (e) {
          return "string" === typeof e
            ? e
            : void 0 === e
            ? "undefined"
            : JSON.stringify(e);
        });
      class Qh extends Jh {
        static runFunctions(e, t, n) {
          const r = new Qh(),
            s = {
              ...n,
              headers: {
                ...(null === n || void 0 === n ? void 0 : n.headers),
                "X-Stainless-Helper-Method": "runFunctions",
              },
            };
          return r._run(() => r._runFunctions(e, t, s)), r;
        }
        static runTools(e, t, n) {
          const r = new Qh(),
            s = {
              ...n,
              headers: {
                ...(null === n || void 0 === n ? void 0 : n.headers),
                "X-Stainless-Helper-Method": "runTools",
              },
            };
          return r._run(() => r._runTools(e, t, s)), r;
        }
        _addMessage(e) {
          super._addMessage(e),
            _h(e) && e.content && this._emit("content", e.content);
        }
      }
      var Yh,
        Xh,
        Zh,
        $h,
        ep,
        tp,
        np = function (e, t, n, r) {
          if ("a" === n && !r)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if ("function" === typeof t ? e !== t || !r : !t.has(e))
            throw new TypeError(
              "Cannot read private member from an object whose class did not declare it"
            );
          return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e);
        },
        rp = function (e, t, n, r, s) {
          if ("m" === r) throw new TypeError("Private method is not writable");
          if ("a" === r && !s)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if ("function" === typeof t ? e !== t || !s : !t.has(e))
            throw new TypeError(
              "Cannot write private member to an object whose class did not declare it"
            );
          return "a" === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
        };
      class sp extends Jh {
        constructor() {
          super(...arguments), Yh.add(this), Xh.set(this, void 0);
        }
        get currentChatCompletionSnapshot() {
          return np(this, Xh, "f");
        }
        static fromReadableStream(e) {
          const t = new sp();
          return t._run(() => t._fromReadableStream(e)), t;
        }
        static createChatCompletion(e, t, n) {
          const r = new sp();
          return (
            r._run(() =>
              r._runChatCompletion(
                e,
                { ...t, stream: !0 },
                {
                  ...n,
                  headers: {
                    ...(null === n || void 0 === n ? void 0 : n.headers),
                    "X-Stainless-Helper-Method": "stream",
                  },
                }
              )
            ),
            r
          );
        }
        async _createChatCompletion(e, t, n) {
          var r;
          const s = null === n || void 0 === n ? void 0 : n.signal;
          s &&
            (s.aborted && this.controller.abort(),
            s.addEventListener("abort", () => this.controller.abort())),
            np(this, Yh, "m", Zh).call(this);
          const i = await e.create(
            { ...t, stream: !0 },
            { ...n, signal: this.controller.signal }
          );
          this._connected();
          for await (const o of i) np(this, Yh, "m", $h).call(this, o);
          if (null !== (r = i.controller.signal) && void 0 !== r && r.aborted)
            throw new Ju();
          return this._addChatCompletion(np(this, Yh, "m", ep).call(this));
        }
        async _fromReadableStream(e, t) {
          var n;
          const r = null === t || void 0 === t ? void 0 : t.signal;
          r &&
            (r.aborted && this.controller.abort(),
            r.addEventListener("abort", () => this.controller.abort())),
            np(this, Yh, "m", Zh).call(this),
            this._connected();
          const s = id.fromReadableStream(e, this.controller);
          let i;
          for await (const o of s)
            i &&
              i !== o.id &&
              this._addChatCompletion(np(this, Yh, "m", ep).call(this)),
              np(this, Yh, "m", $h).call(this, o),
              (i = o.id);
          if (null !== (n = s.controller.signal) && void 0 !== n && n.aborted)
            throw new Ju();
          return this._addChatCompletion(np(this, Yh, "m", ep).call(this));
        }
        [((Xh = new WeakMap()),
        (Yh = new WeakSet()),
        (Zh = function () {
          this.ended || rp(this, Xh, void 0, "f");
        }),
        ($h = function (e) {
          var t, n;
          if (this.ended) return;
          const r = np(this, Yh, "m", tp).call(this, e);
          this._emit("chunk", e, r);
          const s =
              null === (t = e.choices[0]) ||
              void 0 === t ||
              null === (t = t.delta) ||
              void 0 === t
                ? void 0
                : t.content,
            i =
              null === (n = r.choices[0]) || void 0 === n ? void 0 : n.message;
          null != s &&
            "assistant" === (null === i || void 0 === i ? void 0 : i.role) &&
            null !== i &&
            void 0 !== i &&
            i.content &&
            this._emit("content", s, i.content);
        }),
        (ep = function () {
          if (this.ended)
            throw new zu("stream has ended, this shouldn't happen");
          const e = np(this, Xh, "f");
          if (!e) throw new zu("request ended without sending any chunks");
          return (
            rp(this, Xh, void 0, "f"),
            (function (e) {
              const {
                id: t,
                choices: n,
                created: r,
                model: s,
                system_fingerprint: i,
                ...o
              } = e;
              return {
                ...o,
                id: t,
                choices: n.map((t) => {
                  let {
                    message: n,
                    finish_reason: r,
                    index: s,
                    logprobs: i,
                    ...o
                  } = t;
                  if (!r)
                    throw new zu("missing finish_reason for choice ".concat(s));
                  const {
                      content: a = null,
                      function_call: c,
                      tool_calls: l,
                      ...u
                    } = n,
                    d = n.role;
                  if (!d) throw new zu("missing role for choice ".concat(s));
                  if (c) {
                    const { arguments: e, name: t } = c;
                    if (null == e)
                      throw new zu(
                        "missing function_call.arguments for choice ".concat(s)
                      );
                    if (!t)
                      throw new zu(
                        "missing function_call.name for choice ".concat(s)
                      );
                    return {
                      ...o,
                      message: {
                        content: a,
                        function_call: { arguments: e, name: t },
                        role: d,
                      },
                      finish_reason: r,
                      index: s,
                      logprobs: i,
                    };
                  }
                  return l
                    ? {
                        ...o,
                        index: s,
                        finish_reason: r,
                        logprobs: i,
                        message: {
                          ...u,
                          role: d,
                          content: a,
                          tool_calls: l.map((t, n) => {
                            const { function: r, type: i, id: o, ...a } = t,
                              { arguments: c, name: l, ...u } = r || {};
                            if (null == o)
                              throw new zu(
                                "missing choices["
                                  .concat(s, "].tool_calls[")
                                  .concat(n, "].id\n")
                                  .concat(ip(e))
                              );
                            if (null == i)
                              throw new zu(
                                "missing choices["
                                  .concat(s, "].tool_calls[")
                                  .concat(n, "].type\n")
                                  .concat(ip(e))
                              );
                            if (null == l)
                              throw new zu(
                                "missing choices["
                                  .concat(s, "].tool_calls[")
                                  .concat(n, "].function.name\n")
                                  .concat(ip(e))
                              );
                            if (null == c)
                              throw new zu(
                                "missing choices["
                                  .concat(s, "].tool_calls[")
                                  .concat(n, "].function.arguments\n")
                                  .concat(ip(e))
                              );
                            return {
                              ...a,
                              id: o,
                              type: i,
                              function: { ...u, name: l, arguments: c },
                            };
                          }),
                        },
                      }
                    : {
                        ...o,
                        message: { ...u, content: a, role: d },
                        finish_reason: r,
                        index: s,
                        logprobs: i,
                      };
                }),
                created: r,
                model: s,
                object: "chat.completion",
                ...(i ? { system_fingerprint: i } : {}),
              };
            })(e)
          );
        }),
        (tp = function (e) {
          var t, n, r;
          let s = np(this, Xh, "f");
          const { choices: i, ...o } = e;
          s
            ? Object.assign(s, o)
            : (s = rp(this, Xh, { ...o, choices: [] }, "f"));
          for (const {
            delta: d,
            finish_reason: h,
            index: p,
            logprobs: f = null,
            ...m
          } of e.choices) {
            let e = s.choices[p];
            if (
              (e ||
                (e = s.choices[p] =
                  {
                    finish_reason: h,
                    index: p,
                    message: {},
                    logprobs: f,
                    ...m,
                  }),
              f)
            )
              if (e.logprobs) {
                const { content: n, ...r } = f;
                var a;
                if ((Object.assign(e.logprobs, r), n))
                  (null !== (a = (t = e.logprobs).content) && void 0 !== a) ||
                    (t.content = []),
                    e.logprobs.content.push(...n);
              } else e.logprobs = Object.assign({}, f);
            if ((h && (e.finish_reason = h), Object.assign(e, m), !d)) continue;
            const {
              content: i,
              function_call: o,
              role: g,
              tool_calls: v,
              ...y
            } = d;
            var c;
            if (
              (Object.assign(e.message, y),
              i && (e.message.content = (e.message.content || "") + i),
              g && (e.message.role = g),
              o)
            )
              if (e.message.function_call) {
                if (
                  (o.name && (e.message.function_call.name = o.name),
                  o.arguments)
                )
                  (null !== (c = (n = e.message.function_call).arguments) &&
                    void 0 !== c) ||
                    (n.arguments = ""),
                    (e.message.function_call.arguments += o.arguments);
              } else e.message.function_call = o;
            if (v) {
              e.message.tool_calls || (e.message.tool_calls = []);
              for (const { index: t, id: n, type: s, function: i, ...o } of v) {
                var l, u;
                const a =
                  null !== (l = (r = e.message.tool_calls)[t]) && void 0 !== l
                    ? l
                    : (r[t] = {});
                Object.assign(a, o),
                  n && (a.id = n),
                  s && (a.type = s),
                  i &&
                    ((null !== (u = a.function) && void 0 !== u) ||
                      (a.function = { arguments: "" })),
                  null !== i &&
                    void 0 !== i &&
                    i.name &&
                    (a.function.name = i.name),
                  null !== i &&
                    void 0 !== i &&
                    i.arguments &&
                    (a.function.arguments += i.arguments);
              }
            }
          }
          return s;
        }),
        Symbol.asyncIterator)]() {
          const e = [],
            t = [];
          let n = !1;
          return (
            this.on("chunk", (n) => {
              const r = t.shift();
              r ? r.resolve(n) : e.push(n);
            }),
            this.on("end", () => {
              n = !0;
              for (const e of t) e.resolve(void 0);
              t.length = 0;
            }),
            this.on("abort", (e) => {
              n = !0;
              for (const n of t) n.reject(e);
              t.length = 0;
            }),
            this.on("error", (e) => {
              n = !0;
              for (const n of t) n.reject(e);
              t.length = 0;
            }),
            {
              next: async () => {
                if (!e.length)
                  return n
                    ? { value: void 0, done: !0 }
                    : new Promise((e, n) =>
                        t.push({ resolve: e, reject: n })
                      ).then((e) =>
                        e ? { value: e, done: !1 } : { value: void 0, done: !0 }
                      );
                return { value: e.shift(), done: !1 };
              },
              return: async () => (this.abort(), { value: void 0, done: !0 }),
            }
          );
        }
        toReadableStream() {
          return new id(
            this[Symbol.asyncIterator].bind(this),
            this.controller
          ).toReadableStream();
        }
      }
      function ip(e) {
        return JSON.stringify(e);
      }
      class op extends sp {
        static fromReadableStream(e) {
          const t = new op();
          return t._run(() => t._fromReadableStream(e)), t;
        }
        static runFunctions(e, t, n) {
          const r = new op(),
            s = {
              ...n,
              headers: {
                ...(null === n || void 0 === n ? void 0 : n.headers),
                "X-Stainless-Helper-Method": "runFunctions",
              },
            };
          return r._run(() => r._runFunctions(e, t, s)), r;
        }
        static runTools(e, t, n) {
          const r = new op(),
            s = {
              ...n,
              headers: {
                ...(null === n || void 0 === n ? void 0 : n.headers),
                "X-Stainless-Helper-Method": "runTools",
              },
            };
          return r._run(() => r._runTools(e, t, s)), r;
        }
      }
      class ap extends Zd {
        runFunctions(e, t) {
          return e.stream
            ? op.runFunctions(this._client.chat.completions, e, t)
            : Qh.runFunctions(this._client.chat.completions, e, t);
        }
        runTools(e, t) {
          return e.stream
            ? op.runTools(this._client.chat.completions, e, t)
            : Qh.runTools(this._client.chat.completions, e, t);
        }
        stream(e, t) {
          return sp.createChatCompletion(this._client.chat.completions, e, t);
        }
      }
      class cp extends Zd {
        constructor() {
          super(...arguments), (this.completions = new ap(this._client));
        }
      }
      !(function (e) {
        e.Completions = ap;
      })(cp || (cp = {}));
      var lp,
        up,
        dp,
        hp,
        pp,
        fp,
        mp,
        gp,
        vp,
        yp,
        bp,
        wp,
        Sp = function (e, t, n, r, s) {
          if ("m" === r) throw new TypeError("Private method is not writable");
          if ("a" === r && !s)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if ("function" === typeof t ? e !== t || !s : !t.has(e))
            throw new TypeError(
              "Cannot write private member to an object whose class did not declare it"
            );
          return "a" === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
        },
        _p = function (e, t, n, r) {
          if ("a" === n && !r)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if ("function" === typeof t ? e !== t || !r : !t.has(e))
            throw new TypeError(
              "Cannot read private member from an object whose class did not declare it"
            );
          return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e);
        };
      class Ep {
        constructor() {
          (this.controller = new AbortController()),
            lp.set(this, void 0),
            up.set(this, () => {}),
            dp.set(this, () => {}),
            hp.set(this, void 0),
            pp.set(this, () => {}),
            fp.set(this, () => {}),
            mp.set(this, {}),
            gp.set(this, !1),
            vp.set(this, !1),
            yp.set(this, !1),
            bp.set(this, !1),
            wp.set(this, (e) => {
              if (
                (Sp(this, vp, !0, "f"),
                e instanceof Error && "AbortError" === e.name && (e = new Ju()),
                e instanceof Ju)
              )
                return Sp(this, yp, !0, "f"), this._emit("abort", e);
              if (e instanceof zu) return this._emit("error", e);
              if (e instanceof Error) {
                const t = new zu(e.message);
                return (t.cause = e), this._emit("error", t);
              }
              return this._emit("error", new zu(String(e)));
            }),
            Sp(
              this,
              lp,
              new Promise((e, t) => {
                Sp(this, up, e, "f"), Sp(this, dp, t, "f");
              }),
              "f"
            ),
            Sp(
              this,
              hp,
              new Promise((e, t) => {
                Sp(this, pp, e, "f"), Sp(this, fp, t, "f");
              }),
              "f"
            ),
            _p(this, lp, "f").catch(() => {}),
            _p(this, hp, "f").catch(() => {});
        }
        _run(e) {
          setTimeout(() => {
            e().then(() => {
              this._emit("end");
            }, _p(this, wp, "f"));
          }, 0);
        }
        _addRun(e) {
          return e;
        }
        _connected() {
          this.ended || (_p(this, up, "f").call(this), this._emit("connect"));
        }
        get ended() {
          return _p(this, gp, "f");
        }
        get errored() {
          return _p(this, vp, "f");
        }
        get aborted() {
          return _p(this, yp, "f");
        }
        abort() {
          this.controller.abort();
        }
        on(e, t) {
          return (
            (_p(this, mp, "f")[e] || (_p(this, mp, "f")[e] = [])).push({
              listener: t,
            }),
            this
          );
        }
        off(e, t) {
          const n = _p(this, mp, "f")[e];
          if (!n) return this;
          const r = n.findIndex((e) => e.listener === t);
          return r >= 0 && n.splice(r, 1), this;
        }
        once(e, t) {
          return (
            (_p(this, mp, "f")[e] || (_p(this, mp, "f")[e] = [])).push({
              listener: t,
              once: !0,
            }),
            this
          );
        }
        emitted(e) {
          return new Promise((t, n) => {
            Sp(this, bp, !0, "f"),
              "error" !== e && this.once("error", n),
              this.once(e, t);
          });
        }
        async done() {
          Sp(this, bp, !0, "f"), await _p(this, hp, "f");
        }
        _emit(e) {
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (_p(this, gp, "f")) return;
          "end" === e && (Sp(this, gp, !0, "f"), _p(this, pp, "f").call(this));
          const s = _p(this, mp, "f")[e];
          if (
            (s &&
              ((_p(this, mp, "f")[e] = s.filter((e) => !e.once)),
              s.forEach((e) => {
                let { listener: t } = e;
                return t(...n);
              })),
            "abort" === e)
          ) {
            const e = n[0];
            return (
              _p(this, bp, "f") ||
                (null !== s && void 0 !== s && s.length) ||
                Promise.reject(e),
              _p(this, dp, "f").call(this, e),
              _p(this, fp, "f").call(this, e),
              void this._emit("end")
            );
          }
          if ("error" === e) {
            const e = n[0];
            _p(this, bp, "f") ||
              (null !== s && void 0 !== s && s.length) ||
              Promise.reject(e),
              _p(this, dp, "f").call(this, e),
              _p(this, fp, "f").call(this, e),
              this._emit("end");
          }
        }
        async _threadAssistantStream(e, t, n) {
          return await this._createThreadAssistantStream(t, e, n);
        }
        async _runAssistantStream(e, t, n, r) {
          return await this._createAssistantStream(t, e, n, r);
        }
        async _runToolAssistantStream(e, t, n, r, s) {
          return await this._createToolAssistantStream(n, e, t, r, s);
        }
        async _createThreadAssistantStream(e, t, n) {
          const r = null === n || void 0 === n ? void 0 : n.signal;
          r &&
            (r.aborted && this.controller.abort(),
            r.addEventListener("abort", () => this.controller.abort()));
          const s = await e.createAndRun(
            { ...t, stream: !1 },
            { ...n, signal: this.controller.signal }
          );
          return this._connected(), this._addRun(s);
        }
        async _createToolAssistantStream(e, t, n, r, s) {
          const i = null === s || void 0 === s ? void 0 : s.signal;
          i &&
            (i.aborted && this.controller.abort(),
            i.addEventListener("abort", () => this.controller.abort()));
          const o = await e.submitToolOutputs(
            t,
            n,
            { ...r, stream: !1 },
            { ...s, signal: this.controller.signal }
          );
          return this._connected(), this._addRun(o);
        }
        async _createAssistantStream(e, t, n, r) {
          const s = null === r || void 0 === r ? void 0 : r.signal;
          s &&
            (s.aborted && this.controller.abort(),
            s.addEventListener("abort", () => this.controller.abort()));
          const i = await e.create(
            t,
            { ...n, stream: !1 },
            { ...r, signal: this.controller.signal }
          );
          return this._connected(), this._addRun(i);
        }
      }
      (lp = new WeakMap()),
        (up = new WeakMap()),
        (dp = new WeakMap()),
        (hp = new WeakMap()),
        (pp = new WeakMap()),
        (fp = new WeakMap()),
        (mp = new WeakMap()),
        (gp = new WeakMap()),
        (vp = new WeakMap()),
        (yp = new WeakMap()),
        (bp = new WeakMap()),
        (wp = new WeakMap());
      var Ap,
        Tp,
        Pp,
        Ip,
        Cp,
        kp,
        Op,
        xp,
        Np,
        Rp,
        Dp,
        Mp,
        jp,
        Lp,
        Up,
        Fp,
        Bp,
        Vp,
        qp,
        Hp,
        Wp,
        Kp,
        zp = function (e, t, n, r) {
          if ("a" === n && !r)
            throw new TypeError(
              "Private accessor was defined without a getter"
            );
          if ("function" === typeof t ? e !== t || !r : !t.has(e))
            throw new TypeError(
              "Cannot read private member from an object whose class did not declare it"
            );
          return "m" === n ? r : "a" === n ? r.call(e) : r ? r.value : t.get(e);
        },
        Gp = function (e, t, n, r, s) {
          if ("m" === r) throw new TypeError("Private method is not writable");
          if ("a" === r && !s)
            throw new TypeError(
              "Private accessor was defined without a setter"
            );
          if ("function" === typeof t ? e !== t || !s : !t.has(e))
            throw new TypeError(
              "Cannot write private member to an object whose class did not declare it"
            );
          return "a" === r ? s.call(e, n) : s ? (s.value = n) : t.set(e, n), n;
        };
      class Jp extends Ep {
        constructor() {
          super(...arguments),
            Ap.add(this),
            Tp.set(this, []),
            Pp.set(this, {}),
            Ip.set(this, {}),
            Cp.set(this, void 0),
            kp.set(this, void 0),
            Op.set(this, void 0),
            xp.set(this, void 0),
            Np.set(this, void 0),
            Rp.set(this, void 0),
            Dp.set(this, void 0),
            Mp.set(this, void 0),
            jp.set(this, void 0);
        }
        [((Tp = new WeakMap()),
        (Pp = new WeakMap()),
        (Ip = new WeakMap()),
        (Cp = new WeakMap()),
        (kp = new WeakMap()),
        (Op = new WeakMap()),
        (xp = new WeakMap()),
        (Np = new WeakMap()),
        (Rp = new WeakMap()),
        (Dp = new WeakMap()),
        (Mp = new WeakMap()),
        (jp = new WeakMap()),
        (Ap = new WeakSet()),
        Symbol.asyncIterator)]() {
          const e = [],
            t = [];
          let n = !1;
          return (
            this.on("event", (n) => {
              const r = t.shift();
              r ? r.resolve(n) : e.push(n);
            }),
            this.on("end", () => {
              n = !0;
              for (const e of t) e.resolve(void 0);
              t.length = 0;
            }),
            this.on("abort", (e) => {
              n = !0;
              for (const n of t) n.reject(e);
              t.length = 0;
            }),
            this.on("error", (e) => {
              n = !0;
              for (const n of t) n.reject(e);
              t.length = 0;
            }),
            {
              next: async () => {
                if (!e.length)
                  return n
                    ? { value: void 0, done: !0 }
                    : new Promise((e, n) =>
                        t.push({ resolve: e, reject: n })
                      ).then((e) =>
                        e ? { value: e, done: !1 } : { value: void 0, done: !0 }
                      );
                return { value: e.shift(), done: !1 };
              },
              return: async () => (this.abort(), { value: void 0, done: !0 }),
            }
          );
        }
        static fromReadableStream(e) {
          const t = new Jp();
          return t._run(() => t._fromReadableStream(e)), t;
        }
        async _fromReadableStream(e, t) {
          var n;
          const r = null === t || void 0 === t ? void 0 : t.signal;
          r &&
            (r.aborted && this.controller.abort(),
            r.addEventListener("abort", () => this.controller.abort())),
            this._connected();
          const s = id.fromReadableStream(e, this.controller);
          for await (const i of s) zp(this, Ap, "m", Lp).call(this, i);
          if (null !== (n = s.controller.signal) && void 0 !== n && n.aborted)
            throw new Ju();
          return this._addRun(zp(this, Ap, "m", Up).call(this));
        }
        toReadableStream() {
          return new id(
            this[Symbol.asyncIterator].bind(this),
            this.controller
          ).toReadableStream();
        }
        static createToolAssistantStream(e, t, n, r, s) {
          const i = new Jp();
          return (
            i._run(() =>
              i._runToolAssistantStream(e, t, n, r, {
                ...s,
                headers: {
                  ...(null === s || void 0 === s ? void 0 : s.headers),
                  "X-Stainless-Helper-Method": "stream",
                },
              })
            ),
            i
          );
        }
        async _createToolAssistantStream(e, t, n, r, s) {
          var i;
          const o = null === s || void 0 === s ? void 0 : s.signal;
          o &&
            (o.aborted && this.controller.abort(),
            o.addEventListener("abort", () => this.controller.abort()));
          const a = { ...r, stream: !0 },
            c = await e.submitToolOutputs(t, n, a, {
              ...s,
              signal: this.controller.signal,
            });
          this._connected();
          for await (const l of c) zp(this, Ap, "m", Lp).call(this, l);
          if (null !== (i = c.controller.signal) && void 0 !== i && i.aborted)
            throw new Ju();
          return this._addRun(zp(this, Ap, "m", Up).call(this));
        }
        static createThreadAssistantStream(e, t, n) {
          const r = new Jp();
          return (
            r._run(() =>
              r._threadAssistantStream(e, t, {
                ...n,
                headers: {
                  ...(null === n || void 0 === n ? void 0 : n.headers),
                  "X-Stainless-Helper-Method": "stream",
                },
              })
            ),
            r
          );
        }
        static createAssistantStream(e, t, n, r) {
          const s = new Jp();
          return (
            s._run(() =>
              s._runAssistantStream(e, t, n, {
                ...r,
                headers: {
                  ...(null === r || void 0 === r ? void 0 : r.headers),
                  "X-Stainless-Helper-Method": "stream",
                },
              })
            ),
            s
          );
        }
        currentEvent() {
          return zp(this, Dp, "f");
        }
        currentRun() {
          return zp(this, Mp, "f");
        }
        currentMessageSnapshot() {
          return zp(this, Cp, "f");
        }
        currentRunStepSnapshot() {
          return zp(this, jp, "f");
        }
        async finalRunSteps() {
          return await this.done(), Object.values(zp(this, Pp, "f"));
        }
        async finalMessages() {
          return await this.done(), Object.values(zp(this, Ip, "f"));
        }
        async finalRun() {
          if ((await this.done(), !zp(this, kp, "f")))
            throw Error("Final run was not received.");
          return zp(this, kp, "f");
        }
        async _createThreadAssistantStream(e, t, n) {
          var r;
          const s = null === n || void 0 === n ? void 0 : n.signal;
          s &&
            (s.aborted && this.controller.abort(),
            s.addEventListener("abort", () => this.controller.abort()));
          const i = { ...t, stream: !0 },
            o = await e.createAndRun(i, {
              ...n,
              signal: this.controller.signal,
            });
          this._connected();
          for await (const a of o) zp(this, Ap, "m", Lp).call(this, a);
          if (null !== (r = o.controller.signal) && void 0 !== r && r.aborted)
            throw new Ju();
          return this._addRun(zp(this, Ap, "m", Up).call(this));
        }
        async _createAssistantStream(e, t, n, r) {
          var s;
          const i = null === r || void 0 === r ? void 0 : r.signal;
          i &&
            (i.aborted && this.controller.abort(),
            i.addEventListener("abort", () => this.controller.abort()));
          const o = { ...n, stream: !0 },
            a = await e.create(t, o, { ...r, signal: this.controller.signal });
          this._connected();
          for await (const c of a) zp(this, Ap, "m", Lp).call(this, c);
          if (null !== (s = a.controller.signal) && void 0 !== s && s.aborted)
            throw new Ju();
          return this._addRun(zp(this, Ap, "m", Up).call(this));
        }
        static accumulateDelta(e, t) {
          for (const [n, r] of Object.entries(t)) {
            if (!e.hasOwnProperty(n)) {
              e[n] = r;
              continue;
            }
            let t = e[n];
            if (null !== t && void 0 !== t)
              if ("index" !== n && "type" !== n) {
                if ("string" === typeof t && "string" === typeof r) t += r;
                else if ("number" === typeof t && "number" === typeof r) t += r;
                else if (Qd(t) && Qd(r)) t = this.accumulateDelta(t, r);
                else {
                  if (!Array.isArray(t) || !Array.isArray(r))
                    throw Error(
                      "Unhandled record type: "
                        .concat(n, ", deltaValue: ")
                        .concat(r, ", accValue: ")
                        .concat(t)
                    );
                  if (
                    t.every(
                      (e) => "string" === typeof e || "number" === typeof e
                    )
                  ) {
                    t.push(...r);
                    continue;
                  }
                }
                e[n] = t;
              } else e[n] = r;
            else e[n] = r;
          }
          return e;
        }
      }
      (Lp = function (e) {
        if (!this.ended)
          switch (
            (Gp(this, Dp, e, "f"), zp(this, Ap, "m", Vp).call(this, e), e.event)
          ) {
            case "thread.created":
              break;
            case "thread.run.created":
            case "thread.run.queued":
            case "thread.run.in_progress":
            case "thread.run.requires_action":
            case "thread.run.completed":
            case "thread.run.failed":
            case "thread.run.cancelling":
            case "thread.run.cancelled":
            case "thread.run.expired":
              zp(this, Ap, "m", Kp).call(this, e);
              break;
            case "thread.run.step.created":
            case "thread.run.step.in_progress":
            case "thread.run.step.delta":
            case "thread.run.step.completed":
            case "thread.run.step.failed":
            case "thread.run.step.cancelled":
            case "thread.run.step.expired":
              zp(this, Ap, "m", Bp).call(this, e);
              break;
            case "thread.message.created":
            case "thread.message.in_progress":
            case "thread.message.delta":
            case "thread.message.completed":
            case "thread.message.incomplete":
              zp(this, Ap, "m", Fp).call(this, e);
              break;
            case "error":
              throw new Error(
                "Encountered an error event in event processing - errors should be processed earlier"
              );
          }
      }),
        (Up = function () {
          if (this.ended)
            throw new zu("stream has ended, this shouldn't happen");
          if (!zp(this, kp, "f"))
            throw Error("Final run has not been received");
          return zp(this, kp, "f");
        }),
        (Fp = function (e) {
          const [t, n] = zp(this, Ap, "m", Hp).call(this, e, zp(this, Cp, "f"));
          Gp(this, Cp, t, "f"), (zp(this, Ip, "f")[t.id] = t);
          for (const r of n) {
            const e = t.content[r.index];
            "text" == (null === e || void 0 === e ? void 0 : e.type) &&
              this._emit("textCreated", e.text);
          }
          switch (e.event) {
            case "thread.message.created":
              this._emit("messageCreated", e.data);
              break;
            case "thread.message.in_progress":
              break;
            case "thread.message.delta":
              if (
                (this._emit("messageDelta", e.data.delta, t),
                e.data.delta.content)
              )
                for (const n of e.data.delta.content) {
                  if ("text" == n.type && n.text) {
                    let e = n.text,
                      r = t.content[n.index];
                    if (!r || "text" != r.type)
                      throw Error(
                        "The snapshot associated with this text delta is not text or missing"
                      );
                    this._emit("textDelta", e, r.text);
                  }
                  if (n.index != zp(this, Op, "f")) {
                    if (zp(this, xp, "f"))
                      switch (zp(this, xp, "f").type) {
                        case "text":
                          this._emit(
                            "textDone",
                            zp(this, xp, "f").text,
                            zp(this, Cp, "f")
                          );
                          break;
                        case "image_file":
                          this._emit(
                            "imageFileDone",
                            zp(this, xp, "f").image_file,
                            zp(this, Cp, "f")
                          );
                      }
                    Gp(this, Op, n.index, "f");
                  }
                  Gp(this, xp, t.content[n.index], "f");
                }
              break;
            case "thread.message.completed":
            case "thread.message.incomplete":
              if (void 0 !== zp(this, Op, "f")) {
                const t = e.data.content[zp(this, Op, "f")];
                if (t)
                  switch (t.type) {
                    case "image_file":
                      this._emit(
                        "imageFileDone",
                        t.image_file,
                        zp(this, Cp, "f")
                      );
                      break;
                    case "text":
                      this._emit("textDone", t.text, zp(this, Cp, "f"));
                  }
              }
              zp(this, Cp, "f") && this._emit("messageDone", e.data),
                Gp(this, Cp, void 0, "f");
          }
        }),
        (Bp = function (e) {
          const t = zp(this, Ap, "m", qp).call(this, e);
          switch ((Gp(this, jp, t, "f"), e.event)) {
            case "thread.run.step.created":
              this._emit("runStepCreated", e.data);
              break;
            case "thread.run.step.delta":
              const n = e.data.delta;
              if (
                n.step_details &&
                "tool_calls" == n.step_details.type &&
                n.step_details.tool_calls &&
                "tool_calls" == t.step_details.type
              )
                for (const e of n.step_details.tool_calls)
                  e.index == zp(this, Np, "f")
                    ? this._emit(
                        "toolCallDelta",
                        e,
                        t.step_details.tool_calls[e.index]
                      )
                    : (zp(this, Rp, "f") &&
                        this._emit("toolCallDone", zp(this, Rp, "f")),
                      Gp(this, Np, e.index, "f"),
                      Gp(this, Rp, t.step_details.tool_calls[e.index], "f"),
                      zp(this, Rp, "f") &&
                        this._emit("toolCallCreated", zp(this, Rp, "f")));
              this._emit("runStepDelta", e.data.delta, t);
              break;
            case "thread.run.step.completed":
            case "thread.run.step.failed":
            case "thread.run.step.cancelled":
            case "thread.run.step.expired":
              Gp(this, jp, void 0, "f");
              "tool_calls" == e.data.step_details.type &&
                zp(this, Rp, "f") &&
                (this._emit("toolCallDone", zp(this, Rp, "f")),
                Gp(this, Rp, void 0, "f")),
                this._emit("runStepDone", e.data, t);
          }
        }),
        (Vp = function (e) {
          zp(this, Tp, "f").push(e), this._emit("event", e);
        }),
        (qp = function (e) {
          switch (e.event) {
            case "thread.run.step.created":
              return (zp(this, Pp, "f")[e.data.id] = e.data), e.data;
            case "thread.run.step.delta":
              let t = zp(this, Pp, "f")[e.data.id];
              if (!t)
                throw Error(
                  "Received a RunStepDelta before creation of a snapshot"
                );
              let n = e.data;
              if (n.delta) {
                const r = Jp.accumulateDelta(t, n.delta);
                zp(this, Pp, "f")[e.data.id] = r;
              }
              return zp(this, Pp, "f")[e.data.id];
            case "thread.run.step.completed":
            case "thread.run.step.failed":
            case "thread.run.step.cancelled":
            case "thread.run.step.expired":
            case "thread.run.step.in_progress":
              zp(this, Pp, "f")[e.data.id] = e.data;
          }
          if (zp(this, Pp, "f")[e.data.id]) return zp(this, Pp, "f")[e.data.id];
          throw new Error("No snapshot available");
        }),
        (Hp = function (e, t) {
          let n = [];
          switch (e.event) {
            case "thread.message.created":
              return [e.data, n];
            case "thread.message.delta":
              if (!t)
                throw Error(
                  "Received a delta with no existing snapshot (there should be one from message creation)"
                );
              let r = e.data;
              if (r.delta.content)
                for (const e of r.delta.content)
                  if (e.index in t.content) {
                    let n = t.content[e.index];
                    t.content[e.index] = zp(this, Ap, "m", Wp).call(this, e, n);
                  } else (t.content[e.index] = e), n.push(e);
              return [t, n];
            case "thread.message.in_progress":
            case "thread.message.completed":
            case "thread.message.incomplete":
              if (t) return [t, n];
              throw Error(
                "Received thread message event with no existing snapshot"
              );
          }
          throw Error("Tried to accumulate a non-message event");
        }),
        (Wp = function (e, t) {
          return Jp.accumulateDelta(t, e);
        }),
        (Kp = function (e) {
          switch ((Gp(this, Mp, e.data, "f"), e.event)) {
            case "thread.run.created":
            case "thread.run.queued":
            case "thread.run.in_progress":
            case "thread.run.cancelling":
              break;
            case "thread.run.requires_action":
            case "thread.run.cancelled":
            case "thread.run.failed":
            case "thread.run.completed":
            case "thread.run.expired":
              Gp(this, kp, e.data, "f"),
                zp(this, Rp, "f") &&
                  (this._emit("toolCallDone", zp(this, Rp, "f")),
                  Gp(this, Rp, void 0, "f"));
          }
        });
      class Qp extends Zd {
        create(e, t, n) {
          return this._client.post("/threads/".concat(e, "/messages"), {
            body: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === n || void 0 === n ? void 0 : n.headers),
            },
          });
        }
        retrieve(e, t, n) {
          return this._client.get(
            "/threads/".concat(e, "/messages/").concat(t),
            {
              ...n,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === n || void 0 === n ? void 0 : n.headers),
              },
            }
          );
        }
        update(e, t, n, r) {
          return this._client.post(
            "/threads/".concat(e, "/messages/").concat(t),
            {
              body: n,
              ...r,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === r || void 0 === r ? void 0 : r.headers),
              },
            }
          );
        }
        list(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0;
          return xd(t)
            ? this.list(e, {}, t)
            : this._client.getAPIList("/threads/".concat(e, "/messages"), Yp, {
                query: t,
                ...n,
                headers: {
                  "OpenAI-Beta": "assistants=v2",
                  ...(null === n || void 0 === n ? void 0 : n.headers),
                },
              });
        }
        del(e, t, n) {
          return this._client.delete(
            "/threads/".concat(e, "/messages/").concat(t),
            {
              ...n,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === n || void 0 === n ? void 0 : n.headers),
              },
            }
          );
        }
      }
      class Yp extends Xd {}
      !(function (e) {
        e.MessagesPage = Yp;
      })(Qp || (Qp = {}));
      class Xp extends Zd {
        retrieve(e, t, n, r) {
          return this._client.get(
            "/threads/".concat(e, "/runs/").concat(t, "/steps/").concat(n),
            {
              ...r,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === r || void 0 === r ? void 0 : r.headers),
              },
            }
          );
        }
        list(e, t) {
          let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {},
            r = arguments.length > 3 ? arguments[3] : void 0;
          return xd(n)
            ? this.list(e, t, {}, n)
            : this._client.getAPIList(
                "/threads/".concat(e, "/runs/").concat(t, "/steps"),
                Zp,
                {
                  query: n,
                  ...r,
                  headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...(null === r || void 0 === r ? void 0 : r.headers),
                  },
                }
              );
        }
      }
      class Zp extends Xd {}
      !(function (e) {
        e.RunStepsPage = Zp;
      })(Xp || (Xp = {}));
      class $p extends Zd {
        constructor() {
          super(...arguments), (this.steps = new Xp(this._client));
        }
        create(e, t, n) {
          var r;
          return this._client.post("/threads/".concat(e, "/runs"), {
            body: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === n || void 0 === n ? void 0 : n.headers),
            },
            stream: null !== (r = t.stream) && void 0 !== r && r,
          });
        }
        retrieve(e, t, n) {
          return this._client.get("/threads/".concat(e, "/runs/").concat(t), {
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === n || void 0 === n ? void 0 : n.headers),
            },
          });
        }
        update(e, t, n, r) {
          return this._client.post("/threads/".concat(e, "/runs/").concat(t), {
            body: n,
            ...r,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === r || void 0 === r ? void 0 : r.headers),
            },
          });
        }
        list(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0;
          return xd(t)
            ? this.list(e, {}, t)
            : this._client.getAPIList("/threads/".concat(e, "/runs"), ef, {
                query: t,
                ...n,
                headers: {
                  "OpenAI-Beta": "assistants=v2",
                  ...(null === n || void 0 === n ? void 0 : n.headers),
                },
              });
        }
        cancel(e, t, n) {
          return this._client.post(
            "/threads/".concat(e, "/runs/").concat(t, "/cancel"),
            {
              ...n,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === n || void 0 === n ? void 0 : n.headers),
              },
            }
          );
        }
        async createAndPoll(e, t, n) {
          const r = await this.create(e, t, n);
          return await this.poll(e, r.id, n);
        }
        createAndStream(e, t, n) {
          return Jp.createAssistantStream(
            e,
            this._client.beta.threads.runs,
            t,
            n
          );
        }
        async poll(e, t, n) {
          const r = {
            ...(null === n || void 0 === n ? void 0 : n.headers),
            "X-Stainless-Poll-Helper": "true",
          };
          for (
            null !== n &&
            void 0 !== n &&
            n.pollIntervalMs &&
            (r["X-Stainless-Custom-Poll-Interval"] =
              n.pollIntervalMs.toString());
            ;

          ) {
            const { data: s, response: i } = await this.retrieve(e, t, {
              ...n,
              headers: {
                ...(null === n || void 0 === n ? void 0 : n.headers),
                ...r,
              },
            }).withResponse();
            switch (s.status) {
              case "queued":
              case "in_progress":
              case "cancelling":
                let e = 5e3;
                if (null !== n && void 0 !== n && n.pollIntervalMs)
                  e = n.pollIntervalMs;
                else {
                  const t = i.headers.get("openai-poll-after-ms");
                  if (t) {
                    const n = parseInt(t);
                    isNaN(n) || (e = n);
                  }
                }
                await Bd(e);
                break;
              case "requires_action":
              case "incomplete":
              case "cancelled":
              case "completed":
              case "failed":
              case "expired":
                return s;
            }
          }
        }
        stream(e, t, n) {
          return Jp.createAssistantStream(
            e,
            this._client.beta.threads.runs,
            t,
            n
          );
        }
        submitToolOutputs(e, t, n, r) {
          var s;
          return this._client.post(
            "/threads/".concat(e, "/runs/").concat(t, "/submit_tool_outputs"),
            {
              body: n,
              ...r,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === r || void 0 === r ? void 0 : r.headers),
              },
              stream: null !== (s = n.stream) && void 0 !== s && s,
            }
          );
        }
        async submitToolOutputsAndPoll(e, t, n, r) {
          const s = await this.submitToolOutputs(e, t, n, r);
          return await this.poll(e, s.id, r);
        }
        submitToolOutputsStream(e, t, n, r) {
          return Jp.createToolAssistantStream(
            e,
            t,
            this._client.beta.threads.runs,
            n,
            r
          );
        }
      }
      class ef extends Xd {}
      !(function (e) {
        (e.RunsPage = ef), (e.Steps = Xp), (e.RunStepsPage = Zp);
      })($p || ($p = {}));
      class tf extends Zd {
        constructor() {
          super(...arguments),
            (this.runs = new $p(this._client)),
            (this.messages = new Qp(this._client));
        }
        create() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
          return xd(e)
            ? this.create({}, e)
            : this._client.post("/threads", {
                body: e,
                ...t,
                headers: {
                  "OpenAI-Beta": "assistants=v2",
                  ...(null === t || void 0 === t ? void 0 : t.headers),
                },
              });
        }
        retrieve(e, t) {
          return this._client.get("/threads/".concat(e), {
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
        update(e, t, n) {
          return this._client.post("/threads/".concat(e), {
            body: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === n || void 0 === n ? void 0 : n.headers),
            },
          });
        }
        del(e, t) {
          return this._client.delete("/threads/".concat(e), {
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
        createAndRun(e, t) {
          var n;
          return this._client.post("/threads/runs", {
            body: e,
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
            stream: null !== (n = e.stream) && void 0 !== n && n,
          });
        }
        async createAndRunPoll(e, t) {
          const n = await this.createAndRun(e, t);
          return await this.runs.poll(n.thread_id, n.id, t);
        }
        createAndRunStream(e, t) {
          return Jp.createThreadAssistantStream(
            e,
            this._client.beta.threads,
            t
          );
        }
      }
      !(function (e) {
        (e.Runs = $p),
          (e.RunsPage = ef),
          (e.Messages = Qp),
          (e.MessagesPage = Yp);
      })(tf || (tf = {}));
      class nf extends Zd {
        create(e, t, n) {
          return this._client.post("/vector_stores/".concat(e, "/files"), {
            body: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === n || void 0 === n ? void 0 : n.headers),
            },
          });
        }
        retrieve(e, t, n) {
          return this._client.get(
            "/vector_stores/".concat(e, "/files/").concat(t),
            {
              ...n,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === n || void 0 === n ? void 0 : n.headers),
              },
            }
          );
        }
        list(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0;
          return xd(t)
            ? this.list(e, {}, t)
            : this._client.getAPIList(
                "/vector_stores/".concat(e, "/files"),
                rf,
                {
                  query: t,
                  ...n,
                  headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...(null === n || void 0 === n ? void 0 : n.headers),
                  },
                }
              );
        }
        del(e, t, n) {
          return this._client.delete(
            "/vector_stores/".concat(e, "/files/").concat(t),
            {
              ...n,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === n || void 0 === n ? void 0 : n.headers),
              },
            }
          );
        }
        async createAndPoll(e, t, n) {
          const r = await this.create(e, t, n);
          return await this.poll(e, r.id, n);
        }
        async poll(e, t, n) {
          const r = {
            ...(null === n || void 0 === n ? void 0 : n.headers),
            "X-Stainless-Poll-Helper": "true",
          };
          for (
            null !== n &&
            void 0 !== n &&
            n.pollIntervalMs &&
            (r["X-Stainless-Custom-Poll-Interval"] =
              n.pollIntervalMs.toString());
            ;

          ) {
            const s = await this.retrieve(e, t, {
                ...n,
                headers: r,
              }).withResponse(),
              i = s.data;
            switch (i.status) {
              case "in_progress":
                let e = 5e3;
                if (null !== n && void 0 !== n && n.pollIntervalMs)
                  e = n.pollIntervalMs;
                else {
                  const t = s.response.headers.get("openai-poll-after-ms");
                  if (t) {
                    const n = parseInt(t);
                    isNaN(n) || (e = n);
                  }
                }
                await Bd(e);
                break;
              case "failed":
              case "completed":
                return i;
            }
          }
        }
        async upload(e, t, n) {
          const r = await this._client.files.create(
            { file: t, purpose: "assistants" },
            n
          );
          return this.create(e, { file_id: r.id }, n);
        }
        async uploadAndPoll(e, t, n) {
          const r = await this.upload(e, t, n);
          return await this.poll(e, r.id, n);
        }
      }
      class rf extends Xd {}
      !(function (e) {
        e.VectorStoreFilesPage = rf;
      })(nf || (nf = {}));
      class sf extends Zd {
        create(e, t, n) {
          return this._client.post(
            "/vector_stores/".concat(e, "/file_batches"),
            {
              body: t,
              ...n,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === n || void 0 === n ? void 0 : n.headers),
              },
            }
          );
        }
        retrieve(e, t, n) {
          return this._client.get(
            "/vector_stores/".concat(e, "/file_batches/").concat(t),
            {
              ...n,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === n || void 0 === n ? void 0 : n.headers),
              },
            }
          );
        }
        cancel(e, t, n) {
          return this._client.post(
            "/vector_stores/".concat(e, "/file_batches/").concat(t, "/cancel"),
            {
              ...n,
              headers: {
                "OpenAI-Beta": "assistants=v2",
                ...(null === n || void 0 === n ? void 0 : n.headers),
              },
            }
          );
        }
        async createAndPoll(e, t, n) {
          const r = await this.create(e, t);
          return await this.poll(e, r.id, n);
        }
        listFiles(e, t) {
          let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {},
            r = arguments.length > 3 ? arguments[3] : void 0;
          return xd(n)
            ? this.listFiles(e, t, {}, n)
            : this._client.getAPIList(
                "/vector_stores/"
                  .concat(e, "/file_batches/")
                  .concat(t, "/files"),
                rf,
                {
                  query: n,
                  ...r,
                  headers: {
                    "OpenAI-Beta": "assistants=v2",
                    ...(null === r || void 0 === r ? void 0 : r.headers),
                  },
                }
              );
        }
        async poll(e, t, n) {
          const r = {
            ...(null === n || void 0 === n ? void 0 : n.headers),
            "X-Stainless-Poll-Helper": "true",
          };
          for (
            null !== n &&
            void 0 !== n &&
            n.pollIntervalMs &&
            (r["X-Stainless-Custom-Poll-Interval"] =
              n.pollIntervalMs.toString());
            ;

          ) {
            const { data: s, response: i } = await this.retrieve(e, t, {
              ...n,
              headers: r,
            }).withResponse();
            switch (s.status) {
              case "in_progress":
                let e = 5e3;
                if (null !== n && void 0 !== n && n.pollIntervalMs)
                  e = n.pollIntervalMs;
                else {
                  const t = i.headers.get("openai-poll-after-ms");
                  if (t) {
                    const n = parseInt(t);
                    isNaN(n) || (e = n);
                  }
                }
                await Bd(e);
                break;
              case "failed":
              case "cancelled":
              case "completed":
                return s;
            }
          }
        }
        async uploadAndPoll(e, t, n) {
          var r;
          let { files: s, fileIds: i = [] } = t;
          if (null === s || 0 == s.length)
            throw new Error("No files provided to process.");
          const o =
              null !==
                (r = null === n || void 0 === n ? void 0 : n.maxConcurrency) &&
              void 0 !== r
                ? r
                : 5,
            a = Math.min(o, s.length),
            c = this._client,
            l = s.values(),
            u = [...i];
          const d = Array(a)
            .fill(l)
            .map(async function (e) {
              for (let t of e) {
                const e = await c.files.create(
                  { file: t, purpose: "assistants" },
                  n
                );
                u.push(e.id);
              }
            });
          return (
            await (async (e) => {
              const t = await Promise.allSettled(e),
                n = t.filter((e) => "rejected" === e.status);
              if (n.length) {
                for (const e of n) console.error(e.reason);
                throw new Error(
                  "".concat(
                    n.length,
                    " promise(s) failed - see the above errors"
                  )
                );
              }
              const r = [];
              for (const s of t) "fulfilled" === s.status && r.push(s.value);
              return r;
            })(d),
            await this.createAndPoll(e, { file_ids: u })
          );
        }
      }
      sf || (sf = {});
      class of extends Zd {
        constructor() {
          super(...arguments),
            (this.files = new nf(this._client)),
            (this.fileBatches = new sf(this._client));
        }
        create(e, t) {
          return this._client.post("/vector_stores", {
            body: e,
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
        retrieve(e, t) {
          return this._client.get("/vector_stores/".concat(e), {
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
        update(e, t, n) {
          return this._client.post("/vector_stores/".concat(e), {
            body: t,
            ...n,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === n || void 0 === n ? void 0 : n.headers),
            },
          });
        }
        list() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
          return xd(e)
            ? this.list({}, e)
            : this._client.getAPIList("/vector_stores", af, {
                query: e,
                ...t,
                headers: {
                  "OpenAI-Beta": "assistants=v2",
                  ...(null === t || void 0 === t ? void 0 : t.headers),
                },
              });
        }
        del(e, t) {
          return this._client.delete("/vector_stores/".concat(e), {
            ...t,
            headers: {
              "OpenAI-Beta": "assistants=v2",
              ...(null === t || void 0 === t ? void 0 : t.headers),
            },
          });
        }
      }
      class af extends Xd {}
      !(function (e) {
        (e.VectorStoresPage = af),
          (e.Files = nf),
          (e.VectorStoreFilesPage = rf),
          (e.FileBatches = sf);
      })(of || (of = {}));
      class cf extends Zd {
        constructor() {
          super(...arguments),
            (this.vectorStores = new of(this._client)),
            (this.chat = new cp(this._client)),
            (this.assistants = new bh(this._client)),
            (this.threads = new tf(this._client));
        }
      }
      !(function (e) {
        (e.VectorStores = of),
          (e.VectorStoresPage = af),
          (e.Chat = cp),
          (e.Assistants = bh),
          (e.AssistantsPage = wh),
          (e.Threads = tf);
      })(cf || (cf = {}));
      class lf extends Zd {
        create(e, t) {
          return this._client.post("/batches", { body: e, ...t });
        }
        retrieve(e, t) {
          return this._client.get("/batches/".concat(e), t);
        }
        list() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
          return xd(e)
            ? this.list({}, e)
            : this._client.getAPIList("/batches", uf, { query: e, ...t });
        }
        cancel(e, t) {
          return this._client.post("/batches/".concat(e, "/cancel"), t);
        }
      }
      class uf extends Xd {}
      var df;
      !(function (e) {
        e.BatchesPage = uf;
      })(lf || (lf = {}));
      class hf extends Pd {
        constructor() {
          var e, t, n;
          let {
            baseURL: r = Hd("OPENAI_BASE_URL"),
            apiKey: s = Hd("OPENAI_API_KEY"),
            organization: i = null !== (e = Hd("OPENAI_ORG_ID")) && void 0 !== e
              ? e
              : null,
            project: o = null !== (t = Hd("OPENAI_PROJECT_ID")) && void 0 !== t
              ? t
              : null,
            ...a
          } = arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : {};
          if (void 0 === s)
            throw new zu(
              "The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: 'My API Key' })."
            );
          const c = {
            apiKey: s,
            organization: i,
            project: o,
            ...a,
            baseURL: r || "https://api.openai.com/v1",
          };
          if (
            !c.dangerouslyAllowBrowser &&
            "undefined" !== typeof window &&
            "undefined" !== typeof window.document &&
            "undefined" !== typeof navigator
          )
            throw new zu(
              "It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n"
            );
          super({
            baseURL: c.baseURL,
            timeout: null !== (n = c.timeout) && void 0 !== n ? n : 6e5,
            httpAgent: c.httpAgent,
            maxRetries: c.maxRetries,
            fetch: c.fetch,
          }),
            (this.completions = new $d(this)),
            (this.chat = new th(this)),
            (this.embeddings = new nh(this)),
            (this.files = new rh(this)),
            (this.images = new ih(this)),
            (this.audio = new lh(this)),
            (this.moderations = new uh(this)),
            (this.models = new dh(this)),
            (this.fineTuning = new yh(this)),
            (this.beta = new cf(this)),
            (this.batches = new lf(this)),
            (this._options = c),
            (this.apiKey = s),
            (this.organization = i),
            (this.project = o);
        }
        defaultQuery() {
          return this._options.defaultQuery;
        }
        defaultHeaders(e) {
          return {
            ...super.defaultHeaders(e),
            "OpenAI-Organization": this.organization,
            "OpenAI-Project": this.project,
            ...this._options.defaultHeaders,
          };
        }
        authHeaders(e) {
          return { Authorization: "Bearer ".concat(this.apiKey) };
        }
      }
      (df = hf),
        (hf.OpenAI = df),
        (hf.OpenAIError = zu),
        (hf.APIError = Gu),
        (hf.APIConnectionError = Qu),
        (hf.APIConnectionTimeoutError = Yu),
        (hf.APIUserAbortError = Ju),
        (hf.NotFoundError = ed),
        (hf.ConflictError = td),
        (hf.RateLimitError = rd),
        (hf.BadRequestError = Xu),
        (hf.AuthenticationError = Zu),
        (hf.InternalServerError = sd),
        (hf.PermissionDeniedError = $u),
        (hf.UnprocessableEntityError = nd),
        (hf.toFile = fd),
        (hf.fileFromPath = Uu);
      const {
        OpenAIError: pf,
        APIError: ff,
        APIConnectionError: mf,
        APIConnectionTimeoutError: gf,
        APIUserAbortError: vf,
        NotFoundError: yf,
        ConflictError: bf,
        RateLimitError: wf,
        BadRequestError: Sf,
        AuthenticationError: _f,
        InternalServerError: Ef,
        PermissionDeniedError: Af,
        UnprocessableEntityError: Tf,
      } = r;
      !(function (e) {
        (e.Page = Yd),
          (e.CursorPage = Xd),
          (e.Completions = $d),
          (e.Chat = th),
          (e.Embeddings = nh),
          (e.Files = rh),
          (e.FileObjectsPage = sh),
          (e.Images = ih),
          (e.Audio = lh),
          (e.Moderations = uh),
          (e.Models = dh),
          (e.ModelsPage = hh),
          (e.FineTuning = yh),
          (e.Beta = cf),
          (e.Batches = lf),
          (e.BatchesPage = uf);
      })(hf || (hf = {}));
      new Set([
        "/completions",
        "/chat/completions",
        "/embeddings",
        "/audio/transcriptions",
        "/audio/translations",
        "/audio/speech",
        "/images/generations",
      ]);
      const Pf = hf,
        If = (e) => {
          const { apiKey: t, dangerouslyAllowBrowser: n, organization: r } = e;
          return t
            ? new Cf(
                new Pf({
                  apiKey: t,
                  dangerouslyAllowBrowser: n,
                  organization: r,
                })
              )
            : ((s =
                "Missing OpenAI environment variables: define OPENAI_API_KEY"),
              { textCompletion: (e) => Promise.reject(s) });
          var s;
        };
      class Cf {
        constructor(e) {
          this.openAIApi = e;
        }
        async textCompletion(e, t) {
          var n;
          let r;
          try {
            r = await this.openAIApi.completions.create({
              model: "text-davinci-003",
              prompt: e,
              ...t,
            });
          } catch (a_) {
            throw Error("OpenAI text completion failed: " + JSON.stringify(a_));
          }
          const s =
            null === (n = r.choices) ||
            void 0 === n ||
            null === (n = n[0]) ||
            void 0 === n
              ? void 0
              : n.text;
          if (!s)
            throw Error(
              "Invalid OpenAI text completion response: " + JSON.stringify(r)
            );
          return s.trimStart();
        }
      }
      function kf(e) {
        return {
          getNarrowcastMessageStatus: async () => {
            throw Error(e);
          },
          sendNarrowcastMessage: async () => {
            throw Error(e);
          },
          validateNarrowcastMessages: async () => {
            throw Error(e);
          },
        };
      }
      const Of = Sc({ days: 30 }),
        xf = 1 / 0;
      function Nf(e, t) {
        let n = Of;
        try {
          n =
            Number(
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.APPLE_DEVICE_TOKEN_EXPIRY_IN_MS
            ) || Of;
        } catch {}
        return e + n < t;
      }
      function Rf(e, t) {
        let n = xf;
        try {
          n =
            Number(
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.ANDROID_DEVICE_TOKEN_EXPIRY_IN_MS
            ) || xf;
        } catch {}
        return e + n < t;
      }
      const Df = (e, t) => ({
          user_id: e,
          event_type: t ? Pc : Ic,
          event_properties: {},
          user_properties: { isSubscribed: t },
        }),
        Mf = async (e) => {
          var t, n;
          const {
            entry: r,
            userId: s,
            invokeTime: i,
            messageToSend: o,
            db: a,
            sendChatbotMessage: c,
            isDev: l,
            sendAnalyticsEvents: u,
          } = e;
          if (!r)
            throw new Error(
              "Cannot validate subscription as user does not exist! " + s
            );
          if (
            null !== (t = r.chatbotMetainfo) &&
            void 0 !== t &&
            t.timeFirstSubscribed
          ) {
            const e = 864e5;
            if (l) return !1;
            if (r.chatbotMetainfo.messengerId) {
              if (i - (r.chatbotMetainfo.timeLastMessageSent || 0) >= e && o)
                try {
                  if (!(await c({ receiverId: s, senderId: s, message: o })))
                    throw (
                      ((r.chatbotMetainfo = await a.chatbot.markSubscribed(
                        s,
                        !1,
                        i
                      )),
                      await u([Df(s, !1)]),
                      new Error(
                        "Could not send a message when validating subscription."
                      ))
                    );
                  r.chatbotMetainfo = await a.chatbot.markMessageSent(s, i);
                } catch (a_) {
                  if (a_.code !== $c.network_error) throw a_;
                }
            } else if (i - r.chatbotMetainfo.timeFirstSubscribed >= e)
              throw (
                ((r.chatbotMetainfo = await a.chatbot.markSubscribed(s, !1, i)),
                await u([Df(s, !1)]),
                new Error("Have not received messengerId in 24hr."))
              );
          } else
            (r.chatbotMetainfo = await a.chatbot.markSubscribed(s, !0, i)),
              await u([Df(s, !0)]);
          return (
            (null === (n = r.chatbotMetainfo) || void 0 === n
              ? void 0
              : n.subscribed) || !1
          );
        };
      function jf(e) {
        const {
          db: t,
          entry: n,
          invokeTime: r,
          delayedActions: s,
          platform: i,
          richMenuAPIClient: o,
          validateChatbotSubscription: a,
          sendAnalyticsEvents: c,
        } = e;
        function l() {
          var e;
          return null !==
            (e = null === n || void 0 === n ? void 0 : n.chatbotMetainfo) &&
            void 0 !== e
            ? e
            : null;
        }
        return {
          sendMessage: (t, n, r) => {
            s.push({
              type: "action",
              action: () =>
                e.sendChatbotMessage({
                  receiverId: t,
                  senderId: e.userId,
                  message: n,
                  forceChannel:
                    null === r || void 0 === r ? void 0 : r.forceChannel,
                }),
              apiMethodName: "api.chatbot.sendMessage",
            });
          },
          sendLineMessage: function (t, n) {
            let { replyToken: r } =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            const i = e.makeLineMessageReservation(),
              o =
                void 0 === r
                  ? {
                      type: "push",
                      receiverId: t,
                      senderId: e.userId,
                      message: n,
                      sendMessageToLine: i.fulfill,
                    }
                  : {
                      type: "reply",
                      receiverId: t,
                      senderId: e.userId,
                      replyToken: r,
                      message: n,
                      sendMessageToLine: i.fulfill,
                    };
            s.push({
              type: "action",
              action: () => e.sendLineChatbotMessage(o).finally(i.cancel),
              apiMethodName: "api.chatbot.sendLineMessage",
            });
          },
          sendInstagramMessage: (t, n, r) => {
            s.push({
              type: "action",
              action: () =>
                e.sendInstagramChatbotMessage({
                  commentId: null === r || void 0 === r ? void 0 : r.commentId,
                  receiverId: t,
                  senderId: e.userId,
                  message: n,
                }),
              apiMethodName: "api.chatbot.sendInstagramMessage",
            });
          },
          sendMessengerMessage: (t, n) => {
            s.push({
              type: "action",
              action: () =>
                e.sendMessengerChatbotMessage({
                  receiverId: t,
                  senderId: e.userId,
                  message: n,
                }),
              apiMethodName: "api.chatbot.sendMessengerMessage",
            });
          },
          sendTelegramMessage: (t) => {
            let {
              chatId: n,
              message: r,
              receiverId: i,
              replyToMessageId: o,
            } = t;
            s.push({
              type: "action",
              action: () =>
                e.sendTelegramChatbotMessage({
                  chatId: n,
                  message: r,
                  receiverId: i,
                  senderId: e.userId,
                  replyToMessageId: o,
                }),
              apiMethodName: "api.chatbot.sendTelegramMessage",
            });
          },
          validateSubscription: function (n) {
            const i = e.userId;
            s.push({
              type: "action",
              action: async () => {
                await a({
                  entry: e.entry,
                  sendChatbotMessage: e.sendChatbotMessage,
                  userId: i,
                  invokeTime: r,
                  db: t,
                  isDev: false,
                  fetcher: e.fetcher,
                  messageToSend: n,
                  sendAnalyticsEvents: c,
                }).catch(async (t) => {
                  var r;
                  "object" === typeof t &&
                    (t.name = "ChatbotSubscriptionValidationError"),
                    await (null === (r = e.errorReporter) || void 0 === r
                      ? void 0
                      : r.captureException(t, void 0, {
                          userId: i,
                          messageToSend: n,
                        }));
                });
              },
              apiMethodName: "api.chatbot.validateSubscription",
            });
          },
          getAppleDeviceTokenUpdatedAt: function () {
            var e;
            return (
              (null === (e = l()) || void 0 === e
                ? void 0
                : e.appleDeviceTokenUpdatedAt) || 0
            );
          },
          getAndroidDeviceTokenUpdatedAt: function () {
            var e;
            return (
              (null === (e = l()) || void 0 === e
                ? void 0
                : e.androidDeviceTokenUpdatedAt) || 0
            );
          },
          unsubscribe: function () {
            const i = e.userId;
            s.push({
              type: "action",
              apiMethodName: "api.chatbot.unsubscribe",
              action: async () => {
                if (!n)
                  throw new Error(
                    "Cannot mark user as unsubscribed as the user does not exist: " +
                      i
                  );
                n.chatbotMetainfo = await t.chatbot.markSubscribed(i, !1, r);
              },
            }),
              s.push({ type: "sendAnalyticsEvents", events: [Df(i, !1)] });
          },
          setAppleDeviceToken: function (r) {
            var i;
            const o = e.userId,
              a = e.dateNow();
            if (!n) throw new Error("User does not exist: " + o);
            (n.chatbotMetainfo =
              null !== (i = n.chatbotMetainfo) && void 0 !== i ? i : {}),
              r
                ? ((n.chatbotMetainfo.appleDeviceToken = r),
                  (n.chatbotMetainfo.appleDeviceTokenUpdatedAt = a))
                : (delete n.chatbotMetainfo.appleDeviceToken,
                  delete n.chatbotMetainfo.appleDeviceTokenUpdatedAt),
              s.push({
                type: "action",
                action: async () => {
                  n.chatbotMetainfo = await t.chatbot.setAppleDeviceToken(
                    o,
                    r,
                    a
                  );
                },
                apiMethodName: "api.chatbot.setAppleDeviceToken",
              });
          },
          appleDeviceTokenIsValid: function () {
            var t, r;
            if (!n) throw new Error("User does not exist: ".concat(e.userId));
            return (
              !(
                !(
                  null === (t = n.chatbotMetainfo) ||
                  void 0 === t ||
                  !t.appleDeviceTokenUpdatedAt
                ) &&
                Nf(n.chatbotMetainfo.appleDeviceTokenUpdatedAt, e.dateNow())
              ) &&
              !(
                null === (r = n.chatbotMetainfo) ||
                void 0 === r ||
                !r.appleDeviceToken
              )
            );
          },
          setAndroidDeviceToken: function (r) {
            var i;
            const o = e.userId,
              a = e.dateNow();
            if (!n) throw new Error("User does not exist: " + o);
            (n.chatbotMetainfo =
              null !== (i = n.chatbotMetainfo) && void 0 !== i ? i : {}),
              r
                ? ((n.chatbotMetainfo.androidDeviceToken = r),
                  (n.chatbotMetainfo.androidDeviceTokenUpdatedAt = a))
                : (delete n.chatbotMetainfo.androidDeviceToken,
                  delete n.chatbotMetainfo.androidDeviceTokenUpdatedAt),
              s.push({
                type: "action",
                action: async () => {
                  n.chatbotMetainfo = await t.chatbot.setAndroidDeviceToken(
                    o,
                    r,
                    a
                  );
                },
                apiMethodName: "api.chatbot.setAndroidDeviceToken",
              });
          },
          androidDeviceTokenIsValid: function () {
            var t, r;
            if (!n) throw new Error("User does not exist: ".concat(e.userId));
            return (
              !(
                !(
                  null === (t = n.chatbotMetainfo) ||
                  void 0 === t ||
                  !t.androidDeviceTokenUpdatedAt
                ) &&
                Rf(n.chatbotMetainfo.androidDeviceTokenUpdatedAt, e.dateNow())
              ) &&
              !(
                null === (r = n.chatbotMetainfo) ||
                void 0 === r ||
                !r.androidDeviceToken
              )
            );
          },
          linkRichMenuToUser: function (e) {
            if ("line" !== i)
              throw Error(
                "Rich menu linking is only enabled on the LINE platform"
              );
            if (!o)
              throw Error(
                "Rich menu API client is undefined. Make sure to configure the LINE_CHANNEL_ACCESS_TOKEN environment variable: https://docs.dev.gc-internal.net/replicant/Environment/."
              );
            s.push({
              type: "action",
              action: () => o.linkRichMenuToUser(e),
              apiMethodName: "api.chatbot.linkRichMenuToUser",
            });
          },
          unlinkRichMenuFromUser: function (e) {
            if ("line" !== i)
              throw Error(
                "Rich menu linking is only enabled on the LINE platform"
              );
            if (!o)
              throw Error(
                "Rich menu API client is undefined. Make sure to configure the LINE_CHANNEL_ACCESS_TOKEN environment variable: https://docs.dev.gc-internal.net/replicant/Environment/."
              );
            s.push({
              type: "action",
              action: () => o.unlinkRichMenuFromUser(e),
              apiMethodName: "api.chatbot.unlinkRichMenuFromUser",
            });
          },
          setEmail: function (r) {
            const i = e.userId;
            s.push({
              type: "action",
              action: async () => {
                if (!n) throw new Error("User does not exist: " + i);
                n.chatbotMetainfo = await t.chatbot.setEmail(i, r);
              },
              apiMethodName: "api.chatbot.setEmail",
            });
          },
          setWebPushSubscription: function (r) {
            const i = e.userId;
            s.push({
              type: "action",
              action: async () => {
                if (!n) throw new Error("User does not exist: " + i);
                n.chatbotMetainfo = await t.chatbot.setWebPushSubscription(
                  i,
                  r
                );
              },
              apiMethodName: "api.chatbot.setWebPushSubscription",
            });
          },
          subscribeSms: function (r) {
            const i = e.userId;
            s.push({
              type: "action",
              action: async () => {
                if (!r)
                  throw new Error("Cannot subscribe SMS without consent text");
                if (!n) throw new Error("User does not exist: " + i);
                if (!n.metainfo.hasPhoneNumber)
                  throw new Error("Cannot subscribe SMS without phone number");
                (n.chatbotMetainfo = await t.chatbot.subscribeSms(i)),
                  await t.accountLink.setNotificationConsentText({
                    userId: i,
                    notificationConsentText: r,
                  });
              },
              apiMethodName: "api.chatbot.subscribeSms",
            });
          },
          unsubscribeSms: function () {
            const r = e.userId;
            s.push({
              type: "action",
              action: async () => {
                if (!n) throw new Error("User does not exist: " + r);
                n.chatbotMetainfo = await t.chatbot.unsubscribeSms(r);
              },
              apiMethodName: "api.chatbot.unsubscribeSms",
            });
          },
        };
      }
      var Lf = n(424);
      async function Uf(e) {
        const t = dl(e.scheduleUpdates, (e) => e.userId),
          n = { deletedActions: [], newActions: [], notificationUpdates: {} };
        return (
          await Promise.all(
            Object.values(t).map(async (t) => {
              const { userId: r, metainfoMVCC: s } = t[0],
                i = await (async function (e) {
                  var t, n;
                  const {
                    errorReporter: r,
                    metainfoMVCC: s,
                    now: i,
                    scheduleUpdates: o,
                    userId: a,
                  } = e;
                  if (0 === o.length)
                    return {
                      deletedActions: [],
                      newActions: [],
                      notificationUpdates: {
                        [a]: {
                          scheduledActionNotifications: {},
                          systemScheduledActionNotifications: {},
                        },
                      },
                    };
                  const c = {},
                    l = {},
                    u =
                      null !== (t = s.scheduledActionNotifications) &&
                      void 0 !== t
                        ? t
                        : {},
                    d =
                      null !== (n = s.systemScheduledActionNotifications) &&
                      void 0 !== n
                        ? n
                        : {};
                  for (const m of o) {
                    const [e, t] = m.isSystemAction ? [l, d] : [c, u];
                    if ("scheduleAction" === m.type) {
                      await Vf({ ...m, errorReporter: r, userId: a });
                      const n = await Ff(a, m),
                        s = {
                          userId: a,
                          actionName: m.actionName,
                          actionArgs: m.actionArgs,
                          notificationId: m.notificationId,
                          whenToExecute: m.whenToExecute,
                          isSystemAction: m.isSystemAction,
                        },
                        i = t[m.notificationId];
                      ((null === i || void 0 === i ? void 0 : i.actionId) ===
                        n.actionId &&
                        (null === i || void 0 === i ? void 0 : i.timeslotId) ===
                          n.timeslotId) ||
                        (e[m.notificationId] = [n, s]);
                    } else if ("unscheduleAction" === m.type) {
                      t[m.notificationId]
                        ? (e[m.notificationId] = null)
                        : delete e[m.notificationId];
                    } else wc(m);
                  }
                  const h = [],
                    p = [];
                  for (const m of ["normal", "system"]) {
                    const [e, t] = "normal" === m ? [c, u] : [l, d];
                    for (const r in e) {
                      const n = t[r];
                      n && h.push(n);
                      const s = e[r];
                      s && p.push(s);
                    }
                    const n = Object.entries(t)
                      .filter((t) => {
                        let [n, { timeslotId: r }] = t;
                        return !e[n] && Bf(r) < i - Sc({ minutes: 10 });
                      })
                      .map((e) => {
                        let [t] = e;
                        return t;
                      });
                    for (const r of n) e[r] = null;
                  }
                  const f = {
                    scheduledActionNotifications: Go(c, (e, t) =>
                      t ? t[0] : null
                    ),
                    systemScheduledActionNotifications: Go(l, (e, t) =>
                      t ? t[0] : null
                    ),
                  };
                  return {
                    deletedActions: h,
                    newActions: p,
                    notificationUpdates: { [a]: f },
                  };
                })({
                  ...e,
                  scheduleUpdates: t,
                  userId: r,
                  metainfoMVCC:
                    null !== s && void 0 !== s
                      ? s
                      : await e.db.metainfoMVCC.fetchMetainfoMVCC(r),
                });
              n.deletedActions.push(...i.deletedActions),
                n.newActions.push(...i.newActions),
                (n.notificationUpdates[r] = i.notificationUpdates[r]);
            })
          ),
          await (async function (e, t) {
            const {
              deletedActions: n,
              newActions: r,
              notificationUpdates: s,
            } = t;
            n.length > 0 && (await e.scheduledActions.deleteBatch(n));
            r.length > 0 &&
              (await e.scheduledActions.writeBatch(
                r.map((e) => {
                  let [t, n] = e;
                  return { key: t, action: n };
                })
              ));
            const i = Object.entries(s).map(async (t) => {
              let [n, r] = t;
              (Object.keys(r.scheduledActionNotifications).length > 0 ||
                Object.keys(r.systemScheduledActionNotifications).length > 0) &&
                (await e.metainfoMVCC.updateScheduledActionNotifications(n, r));
            });
            await Promise.all(i);
          })(e.db, n),
          { actionsScheduledCount: n.newActions.length }
        );
      }
      async function Ff(e, t) {
        const n = ((r = t.whenToExecute), Math.floor(r / 1e3 / 60) + 1);
        var r;
        const s =
            e +
            t.notificationId +
            (t.isSystemAction ? "system" : "user") +
            JSON.stringify(t.actionArgs),
          i = (await (0, Lf.sc)(s)).slice(0, 16);
        return { timeslotId: n, actionId: BigInt("0x" + i).toString() };
      }
      function Bf(e) {
        return e * Sc({ minutes: 1 });
      }
      async function Vf(e) {
        const { actionArgs: t, actionName: n, errorReporter: r, userId: s } = e;
        if (t) {
          const e = JSON.stringify(t).length;
          if (e > Gc) {
            const t = (function (e) {
              return new nl(
                "Scheduled action arguments size exceeds ".concat(
                  Math.round(Gc / 1e3),
                  " KB. Reduce arguments size to improve performance and to avoid hitting the database item limit."
                ),
                "server_error",
                "scheduled_action_args_too_large",
                "warning",
                e
              );
            })({ argsSize: e, scheduledActionName: n });
            await r.captureException(t, { user: { id: s } });
          }
        }
      }
      function qf(e) {
        const {
            errorReporter: t,
            userId: n,
            userData: r,
            db: s,
            scheduledActions: i,
            invokeTime: o,
            delayedActions: a,
          } = e,
          c = {};
        for (const l in i)
          i.hasOwnProperty(l) &&
            (c[l] = (t) => {
              let {
                args: s,
                notificationId: i,
                delayInMS: c,
                targetUserId: u,
              } = t;
              e.scheduledActions[l].schema.tryValidate(s);
              if (
                !(
                  "number" === typeof c &&
                  !Number.isNaN(c) &&
                  c >= 0 &&
                  c < Number.MAX_SAFE_INTEGER
                )
              )
                throw Error(
                  "Invalid delayInMS in api.scheduledActions.schedule."
                    .concat(l, ": ")
                    .concat(c, ". delayInMS must be a safe positive integer.")
                );
              a.push({
                type: "scheduleAction",
                actionArgs: s,
                actionName: l,
                metainfoMVCC: u ? void 0 : r.metainfoMVCC,
                notificationId: i,
                userId: u || n,
                whenToExecute: o + c,
                isSystemAction: e.isSystemAction,
              });
            });
        return {
          schedule: c,
          unschedule: function (t) {
            const s = "object" === typeof t ? t : { notificationId: t };
            a.push({
              type: "unscheduleAction",
              metainfoMVCC: s.targetUserId ? void 0 : r.metainfoMVCC,
              notificationId: s.notificationId,
              userId: s.targetUserId || n,
              isSystemAction: e.isSystemAction,
            });
          },
          rescheduleAllBy: function (i) {
            a.push({
              type: "action",
              action: async () => {
                const a =
                    null !== e && void 0 !== e && e.isSystemAction
                      ? r.metainfoMVCC.systemScheduledActionNotifications
                      : r.metainfoMVCC.scheduledActionNotifications,
                  c = (
                    await Promise.all(
                      Object.values(null !== a && void 0 !== a ? a : {}).map(
                        async (e) => s.scheduledActions.fetch(e)
                      )
                    )
                  )
                    .filter((e) => !!e)
                    .map((e) => ({
                      actionArgs: e.actionArgs,
                      actionName: e.actionName,
                      metainfoMVCC: r.metainfoMVCC,
                      notificationId: e.notificationId,
                      type: "scheduleAction",
                      userId: n,
                      whenToExecute: e.whenToExecute + i,
                      isSystemAction: e.isSystemAction,
                    }));
                await Uf({
                  db: s,
                  errorReporter: t,
                  now: o,
                  scheduleUpdates: c,
                });
              },
              apiMethodName: "api.scheduledActions.rescheduleAllBy",
            });
          },
        };
      }
      function Hf(e) {
        return {
          sendMessage: () => null,
          sendLineMessage: () => null,
          sendInstagramMessage: () => null,
          sendTelegramMessage: () => null,
          sendMessengerMessage: () => null,
          validateSubscription: () => null,
          unsubscribe: () => null,
          setAppleDeviceToken: () => null,
          getAppleDeviceTokenUpdatedAt: () => 0,
          appleDeviceTokenIsValid: () => !1,
          setAndroidDeviceToken: () => null,
          getAndroidDeviceTokenUpdatedAt: () => 0,
          androidDeviceTokenIsValid: () => !1,
          linkRichMenuToUser: () => {},
          unlinkRichMenuFromUser: () => {},
          setEmail: () => null,
          setWebPushSubscription: () => null,
          subscribeSms: () => null,
          unsubscribeSms: () => null,
        };
      }
      async function Wf(e) {
        const {
            dateNow: t,
            db: n,
            metainfoMVCC: r,
            reportError: s,
            stripe: i,
            userId: o,
          } = e,
          a = r.paymentSubscription;
        if (
          a &&
          (function (e, t) {
            return !e.lastUpdated || e.lastUpdated + Sc({ hours: 12 }) < t;
          })(a, t())
        )
          try {
            const e = await i.getSubscription({
                stripeAccountId: a.stripeAccountId,
                subscriptionId: a.status.id,
              }),
              r = {
                lastUpdated: t(),
                status: i.subscriptionToStatus(e),
                stripeAccountId: a.stripeAccountId,
              };
            if (Wo(r.status, a.status)) return;
            return await n.metainfoMVCC.setPaymentSubscriptionStatus(o, r), r;
          } catch (c) {
            (c.message = "Stripe subscription failed to refresh: ".concat(
              c.message
            )),
              await s(c);
          }
      }
      const Kf = {
        addBreadcrumb: () => {},
        captureException: async () => {},
        setErrorContext: () => {},
      };
      function zf(e, t) {
        if ("matchableString" === e._extendedType)
          throw Error(
            "matchableString is an invalid type for a payload computed property: use searchableComputedProperty instead"
          );
        return { type: e, getter: t, _payload: !0 };
      }
      function Gf(e, t) {
        return { type: e, getter: t, _searchable: !0 };
      }
      function Jf(e) {
        const { entry: t, now: n, userId: r } = e;
        return {
          date: { now: () => Zf(r, n()) },
          chatbot: {
            getAppleDeviceTokenUpdatedAt: () => {
              var e;
              return (
                (null === (e = t.chatbotMetainfo) || void 0 === e
                  ? void 0
                  : e.appleDeviceTokenUpdatedAt) || 0
              );
            },
            getAndroidDeviceTokenUpdatedAt: () => {
              var e;
              return (
                (null === (e = t.chatbotMetainfo) || void 0 === e
                  ? void 0
                  : e.androidDeviceTokenUpdatedAt) || 0
              );
            },
          },
          getClockOffset: () => {
            var e;
            return (
              (null === (e = t.metainfo) || void 0 === e
                ? void 0
                : e.clockOffset) || 0
            );
          },
          purchases: { getPurchaseHistory: () => Kl(t.metainfo) },
        };
      }
      function Qf(e) {
        const { api: t, computedProperties: n, docId: r, state: s } = e,
          i = {};
        for (const [a, c] of Object.entries(
          null !== n && void 0 !== n ? n : {}
        )) {
          try {
            i[a] = c.getter(s, t);
          } catch (o) {
            throw (
              ((o.message = "Failed to generate computed property '"
                .concat(a, "' in document ")
                .concat(r, ": ")
                .concat(o.message)),
              o)
            );
          }
          try {
            c.type.tryValidate(i[a]);
          } catch (o) {
            throw (
              ((o.message = "Invalid computed property '"
                .concat(a, "' value of ")
                .concat(JSON.stringify(i[a]), " in document ")
                .concat(r, ": ")
                .concat(o.message)),
              o)
            );
          }
        }
        return i;
      }
      function Yf(e, t, n, r) {
        const s = Zf(e, t.lastUpdated),
          i = { ...t, lastUpdated: Math.max(t.createdAt, s) };
        (function (e) {
          return _l.every((t) => t in e);
        })(t.state) || Al(t.state, Tl(e, i), n);
        return Qf({
          api: Jf({ entry: t, now: r, userId: e }),
          computedProperties: Xf(n.computedProperties),
          docId: e,
          state: t.state,
        });
      }
      function Xf(e) {
        const t = { ...e };
        for (const [n, { _payload: r, _searchable: s }] of Object.entries(t))
          r || s || delete t[n];
        return t;
      }
      function Zf(e, t) {
        const n = Math.floor(60 * al(e) * 1e3);
        return new Date(t - n).setSeconds(0, 0);
      }
      const $f = {
        name: _a.string(),
        picture: _a.string(),
        friendIds: _a.array(_a.string()),
      };
      function em(e, t) {
        !(function (e, t) {
          const n = new Set(),
            r = [
              "actions",
              "messages",
              "asyncGetters",
              "computedProperties",
              "scheduledActions",
              "sharedStates",
            ];
          for (const { name: s } of t) {
            if (n.has(s))
              throw Error(
                "Duplicate module name in Replicant configuration: `".concat(
                  s,
                  "`. Try renaming the module."
                )
              );
            if ((n.add(s), !e.stateSchema.isObjectSchema()))
              throw Error(
                "Unexpected stateSchema type: ".concat(e.stateSchema._type)
              );
            if (s in e.stateSchema.getFullSchema())
              throw Error(
                "Module name `"
                  .concat(s, "` conflicts with `stateSchema.")
                  .concat(s, "`. Try renaming the module.")
              );
            for (const t of r)
              if (e[t] && s in e[t])
                throw Error(
                  "Module name `"
                    .concat(s, "` conflicts with `")
                    .concat(t, ".")
                    .concat(s, "`. Try renaming the module.")
                );
          }
        })(e, null !== t && void 0 !== t ? t : []);
        const n = {},
          r = {},
          s = {},
          i = {};
        for (const { config: o, name: a } of null !== t && void 0 !== t
          ? t
          : []) {
          if (!o.stateSchema.isObjectSchema())
            throw Error(
              "Invalid module configuration: `modules.".concat(
                a,
                ".stateSchema` is not an object schema"
              )
            );
          Object.assign(n, o.stateSchema.getFullSchema()),
            Object.assign(r, o.actions),
            Object.assign(s, o.messages),
            Object.assign(i, o.asyncGetters);
        }
        if (!e.stateSchema.isObjectSchema())
          throw Error(
            "Invalid Replicant configuration: `stateSchema` is not an object schema"
          );
        return {
          ...e,
          actions: { ...e.actions, ...r },
          messages: { ...e.messages, ...s },
          asyncGetters: { ...e.asyncGetters, ...i },
          stateSchema: _a.object({ ...e.stateSchema.getFullSchema(), ...n }),
        };
      }
      function tm(e) {
        var t, n;
        function r(e) {
          throw new Error(e);
        }
        e ||
          r(
            "Replicant config not present. Make sure to make default export of the config module."
          ),
          "object" === typeof e || r("Replicant config not an object."),
          "stateSchema" in e || r("No stateSchema in Replicant config"),
          "object" === typeof e.stateSchema ||
            r("stateSchema is not an object."),
          e.stateSchema.__schema || r("stateSchema not a SchemaBuilder object"),
          "actions" in e ||
            r("No actions in Replicant config. Keys: ".concat(Object.keys(e))),
          "migrator" in e || r("No migrator in Replicant config"),
          "version" in e || r("Version missing in Replicant config"),
          "appName" in e || r("appName missing in Replicant config"),
          "string" === typeof e.appName ||
            r("appName not a string in Replicant config"),
          "string" === typeof e.version ||
            r("Version not a string in Replicant config: " + e.version);
        for (const a in e.stateSchema.getDefault())
          _l.includes(a) &&
            r(
              "stateSchema.".concat(
                a,
                " is a reserved property - try using another name"
              )
            );
        function s(e, t) {
          !t.startsWith("_") || r("Action name cannot start with _"),
            "string" === typeof e.type ||
              r("Type flag in actions.".concat(t, " not a string.")),
            "function" === typeof e.fn ||
              r("Function in actions.".concat(t, " not a function."));
        }
        for (const a in e.actions)
          if (e.actions.hasOwnProperty(a)) {
            const t = e.actions[a];
            if (!("type" in t && "fn" in t)) for (const e in t) s(t[e], e);
            else s(t, a);
          }
        if (
          "undefined" !== typeof e.chatbot &&
          ("undefined" !== typeof e.chatbot.events &&
            ("onGameEnd" in e.chatbot.events &&
              ("function" === typeof e.chatbot.events.onGameEnd ||
                r(
                  "chatbot.events.onGameEnd not a function: " +
                    typeof e.chatbot.events.onGameEnd
                )),
            "onWebhook" in e.chatbot.events &&
              ("function" === typeof e.chatbot.events.onWebhook ||
                r(
                  "chatbot.events.onWebhook not a function: " +
                    typeof e.chatbot.events.onWebhook
                ))),
          "assets" in e.chatbot)
        ) {
          "object" === typeof e.chatbot.assets ||
            r(
              "chatbot.assets is not an object, use the renderTemplatesWithAssets helper to create this configuration."
            );
          const t = Object.values(e.chatbot.assets).flatMap((e) =>
            "string" === typeof e ? [e] : Object.values(e)
          );
          for (const e of t)
            e.includes("\\") &&
              r("chatbot.assets contains invalid path separator: " + e);
        }
        if ("undefined" !== typeof e.asyncGetters) {
          ("object" === typeof e.asyncGetters &&
            !Array.isArray(e.asyncGetters)) ||
            r("asyncGetters is not an object");
          for (const t in e.asyncGetters) {
            const n = e.asyncGetters[t];
            if ("function" !== typeof n)
              if ("object" === typeof n && n)
                for (const e in n)
                  "function" !== typeof n[e] &&
                    r(
                      "asyncGetters."
                        .concat(t, ".")
                        .concat(e, " is not a function")
                    );
              else
                r(
                  "asyncGetters.".concat(
                    t,
                    " is not a function or a map of functions"
                  )
                );
          }
        }
        if (
          ("undefined" !== typeof e.onError &&
            ("function" === typeof e.onError ||
              r("onError is not a function.")),
          e.onLoginAction &&
            !(e.onLoginAction in e.actions) &&
            r("onLoginAction is not a valid action"),
          "undefined" !== typeof e.computedProperties)
        ) {
          const t = e.computedProperties;
          for (const [e, n] of Object.entries(t)) {
            if (
              ((e.includes(".") || e.includes(">")) &&
                r(
                  "computed property name '".concat(
                    e,
                    "' contains illegal characters"
                  )
                ),
              n.type.isObjectSchema())
            ) {
              0 === Object.keys(n.type.getFullSchema()).length &&
                r("object schema must have at least one property");
              for (const t in n.type.getFullSchema()) {
                const s = n.type.getFullSchema()[t];
                if (s.isArraySchema()) {
                  const n = s.getItemSchema();
                  (n.isArraySchema() || n.isObjectSchema()) &&
                    r(
                      "invalid nested object in computedProperties: "
                        .concat(e, ".")
                        .concat(t, " array must only include primitive items")
                    );
                }
                s.isObjectSchema() &&
                  r(
                    "invalid nested object in computedProperties: "
                      .concat(e, ".")
                      .concat(t, " cannot be an object")
                  );
              }
            }
            if (n.type.isArraySchema()) {
              const t = n.type.getItemSchema();
              if (t.isObjectSchema())
                for (const n in t.getFullSchema()) {
                  const s = t.getFullSchema()[n];
                  if (s.isArraySchema()) {
                    const t = s.getItemSchema();
                    (t.isArraySchema() || t.isObjectSchema()) &&
                      r(
                        "invalid nested object in computedProperties: "
                          .concat(e, "[].")
                          .concat(n, " array must only include primitive items")
                      );
                  }
                  s.isObjectSchema() &&
                    r(
                      "invalid nested object in computedProperties: "
                        .concat(e, "[].")
                        .concat(n, " cannot be an object")
                    );
                }
            }
          }
        }
        (
          (null === (t = e.adminTool) || void 0 === t ? void 0 : t.profile) ||
          []
        ).forEach((t, n) => {
          var s;
          "object" === typeof t ||
            r("adminTool.profile[".concat(n, "] is not an object")),
            "string" === typeof t.property ||
              r("adminTool.profile[".concat(n, "].property is not a string"));
          const i =
            null === (s = e.computedProperties) || void 0 === s
              ? void 0
              : s[t.property];
          if (
            (i ||
              r(
                "adminTool.profile[".concat(
                  n,
                  "].property is not found among computedProperties"
                )
              ),
            t.role)
          ) {
            t.role in $f ||
              r("adminTool.profile[".concat(n, "].role is not supported"));
            const e = $f[t.role],
              s = JSON.stringify(e.serialize()),
              o = JSON.stringify(i.type.serialize());
            s === o ||
              r(
                "adminTool.profile[".concat(
                  n,
                  "].property type does not match the role requirement."
                ) +
                  "The role expects "
                    .concat(s, ", but the computed property type is ")
                    .concat(o)
              );
          }
        });
        const i = [];
        if (e.messages)
          for (const a in e.messages)
            e.messages.hasOwnProperty(a) && e.messages[a].isAdmin && i.push(a);
        const o =
          (null === (n = e.adminTool) || void 0 === n
            ? void 0
            : n.adminMessageGroups) || {};
        Object.keys(o).length &&
          !e.messages &&
          r(
            "adminTool.adminMessageGroups contains grouped messages, while there's no messages provided in config.messages"
          );
        for (const a in o) {
          if (!o.hasOwnProperty(a)) continue;
          const e = o[a];
          Array.isArray(e) ||
            r(
              "adminTool.adminMessageGroups[".concat(
                a,
                "].messages is not an array"
              )
            );
          for (const t of e)
            i.includes(t) ||
              r(
                "adminTool.adminMessageGroups["
                  .concat(a, "].messages contains message ")
                  .concat(t, ", which is not an admin message")
              );
        }
        if (e.otp && e.otp.smsTemplates) {
          "object" !== typeof e.otp.smsTemplates &&
            r("otp.smsTemplates must be an object");
          for (const t in e.otp.smsTemplates) {
            "function" !== typeof e.otp.smsTemplates[t] &&
              r(
                "otp.smsTemplates.".concat(
                  t,
                  " must be a function of type (otpCode: string, vars?: Record<string, string>) => string"
                )
              );
            const n = "123456",
              s = e.otp.smsTemplates[t](n);
            ("string" === typeof s && s.includes(n)) ||
              r(
                "otp.smsTemplates.".concat(
                  t,
                  " must return a string that includes the OTP code argument"
                )
              );
          }
        }
        if (e.ruleset) {
          fl.tryValidate(e.ruleset);
          const t = e.ruleset;
          if (t.abTests)
            for (const [e, n] of Object.entries(t.abTests))
              if (n.dependsOn)
                for (const [s, i] of Object.entries(n.dependsOn)) {
                  const n = t.abTests[s];
                  n ||
                    r(
                      "ruleset.abTests."
                        .concat(e, ".dependsOn.")
                        .concat(
                          s,
                          " refers to a parent test ID that does not exist."
                        )
                    );
                  for (const t of i)
                    n.buckets.some((e) => e.id === t) ||
                      r(
                        "ruleset.abTests."
                          .concat(e, ".dependsOn.")
                          .concat(
                            s,
                            " refers to a bucket ID that does not exist in the parent test."
                          )
                      );
                }
        }
        if (e.sharedStates)
          for (const a in e.sharedStates)
            a.includes("-") &&
              r(
                "sharedStates['".concat(
                  a,
                  "']: shared state name must not include dashes."
                )
              );
        e.stateSchema.getDefault();
      }
      var nm = (function () {
          var e = function (t, n) {
            return (
              (e =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (e, t) {
                    e.__proto__ = t;
                  }) ||
                function (e, t) {
                  for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
                }),
              e(t, n)
            );
          };
          return function (t, n) {
            function r() {
              this.constructor = t;
            }
            e(t, n),
              (t.prototype =
                null === n
                  ? Object.create(n)
                  : ((r.prototype = n.prototype), new r()));
          };
        })(),
        rm = Object.prototype.hasOwnProperty;
      function sm(e, t) {
        return rm.call(e, t);
      }
      function im(e) {
        if (Array.isArray(e)) {
          for (var t = new Array(e.length), n = 0; n < t.length; n++)
            t[n] = "" + n;
          return t;
        }
        if (Object.keys) return Object.keys(e);
        var r = [];
        for (var s in e) sm(e, s) && r.push(s);
        return r;
      }
      function om(e) {
        switch (typeof e) {
          case "object":
            return JSON.parse(JSON.stringify(e));
          case "undefined":
            return null;
          default:
            return e;
        }
      }
      function am(e) {
        for (var t, n = 0, r = e.length; n < r; ) {
          if (!((t = e.charCodeAt(n)) >= 48 && t <= 57)) return !1;
          n++;
        }
        return !0;
      }
      function cm(e) {
        return -1 === e.indexOf("/") && -1 === e.indexOf("~")
          ? e
          : e.replace(/~/g, "~0").replace(/\//g, "~1");
      }
      function lm(e) {
        return e.replace(/~1/g, "/").replace(/~0/g, "~");
      }
      function um(e) {
        if (void 0 === e) return !0;
        if (e)
          if (Array.isArray(e)) {
            for (var t = 0, n = e.length; t < n; t++) if (um(e[t])) return !0;
          } else if ("object" === typeof e)
            for (var r = im(e), s = r.length, i = 0; i < s; i++)
              if (um(e[r[i]])) return !0;
        return !1;
      }
      function dm(e, t) {
        var n = [e];
        for (var r in t) {
          var s =
            "object" === typeof t[r] ? JSON.stringify(t[r], null, 2) : t[r];
          "undefined" !== typeof s && n.push(r + ": " + s);
        }
        return n.join("\n");
      }
      var hm = (function (e) {
          function t(t, n, r, s, i) {
            var o = this.constructor,
              a =
                e.call(
                  this,
                  dm(t, { name: n, index: r, operation: s, tree: i })
                ) || this;
            return (
              (a.name = n),
              (a.index = r),
              (a.operation = s),
              (a.tree = i),
              Object.setPrototypeOf(a, o.prototype),
              (a.message = dm(t, { name: n, index: r, operation: s, tree: i })),
              a
            );
          }
          return nm(t, e), t;
        })(Error),
        pm = hm,
        fm = om,
        mm = {
          add: function (e, t, n) {
            return (e[t] = this.value), { newDocument: n };
          },
          remove: function (e, t, n) {
            var r = e[t];
            return delete e[t], { newDocument: n, removed: r };
          },
          replace: function (e, t, n) {
            var r = e[t];
            return (e[t] = this.value), { newDocument: n, removed: r };
          },
          move: function (e, t, n) {
            var r = vm(n, this.path);
            r && (r = om(r));
            var s = ym(n, { op: "remove", path: this.from }).removed;
            return (
              ym(n, { op: "add", path: this.path, value: s }),
              { newDocument: n, removed: r }
            );
          },
          copy: function (e, t, n) {
            var r = vm(n, this.from);
            return (
              ym(n, { op: "add", path: this.path, value: om(r) }),
              { newDocument: n }
            );
          },
          test: function (e, t, n) {
            return { newDocument: n, test: Em(e[t], this.value) };
          },
          _get: function (e, t, n) {
            return (this.value = e[t]), { newDocument: n };
          },
        },
        gm = {
          add: function (e, t, n) {
            return (
              am(t) ? e.splice(t, 0, this.value) : (e[t] = this.value),
              { newDocument: n, index: t }
            );
          },
          remove: function (e, t, n) {
            return { newDocument: n, removed: e.splice(t, 1)[0] };
          },
          replace: function (e, t, n) {
            var r = e[t];
            return (e[t] = this.value), { newDocument: n, removed: r };
          },
          move: mm.move,
          copy: mm.copy,
          test: mm.test,
          _get: mm._get,
        };
      function vm(e, t) {
        if ("" == t) return e;
        var n = { op: "_get", path: t };
        return ym(e, n), n.value;
      }
      function ym(e, t, n, r, s, i) {
        if (
          (void 0 === n && (n = !1),
          void 0 === r && (r = !0),
          void 0 === s && (s = !0),
          void 0 === i && (i = 0),
          n && ("function" == typeof n ? n(t, 0, e, t.path) : Sm(t, 0)),
          "" === t.path)
        ) {
          var o = { newDocument: e };
          if ("add" === t.op) return (o.newDocument = t.value), o;
          if ("replace" === t.op)
            return (o.newDocument = t.value), (o.removed = e), o;
          if ("move" === t.op || "copy" === t.op)
            return (
              (o.newDocument = vm(e, t.from)),
              "move" === t.op && (o.removed = e),
              o
            );
          if ("test" === t.op) {
            if (((o.test = Em(e, t.value)), !1 === o.test))
              throw new pm(
                "Test operation failed",
                "TEST_OPERATION_FAILED",
                i,
                t,
                e
              );
            return (o.newDocument = e), o;
          }
          if ("remove" === t.op)
            return (o.removed = e), (o.newDocument = null), o;
          if ("_get" === t.op) return (t.value = e), o;
          if (n)
            throw new pm(
              "Operation `op` property is not one of operations defined in RFC-6902",
              "OPERATION_OP_INVALID",
              i,
              t,
              e
            );
          return o;
        }
        r || (e = om(e));
        var a = (t.path || "").split("/"),
          c = e,
          l = 1,
          u = a.length,
          d = void 0,
          h = void 0,
          p = void 0;
        for (p = "function" == typeof n ? n : Sm; ; ) {
          if (
            ((h = a[l]) && -1 != h.indexOf("~") && (h = lm(h)),
            s &&
              ("__proto__" == h ||
                ("prototype" == h && l > 0 && "constructor" == a[l - 1])))
          )
            throw new TypeError(
              "JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README"
            );
          if (
            (n &&
              void 0 === d &&
              (void 0 === c[h]
                ? (d = a.slice(0, l).join("/"))
                : l == u - 1 && (d = t.path),
              void 0 !== d && p(t, 0, e, d)),
            l++,
            Array.isArray(c))
          ) {
            if ("-" === h) h = c.length;
            else {
              if (n && !am(h))
                throw new pm(
                  "Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index",
                  "OPERATION_PATH_ILLEGAL_ARRAY_INDEX",
                  i,
                  t,
                  e
                );
              am(h) && (h = ~~h);
            }
            if (l >= u) {
              if (n && "add" === t.op && h > c.length)
                throw new pm(
                  "The specified index MUST NOT be greater than the number of elements in the array",
                  "OPERATION_VALUE_OUT_OF_BOUNDS",
                  i,
                  t,
                  e
                );
              if (!1 === (o = gm[t.op].call(t, c, h, e)).test)
                throw new pm(
                  "Test operation failed",
                  "TEST_OPERATION_FAILED",
                  i,
                  t,
                  e
                );
              return o;
            }
          } else if (l >= u) {
            if (!1 === (o = mm[t.op].call(t, c, h, e)).test)
              throw new pm(
                "Test operation failed",
                "TEST_OPERATION_FAILED",
                i,
                t,
                e
              );
            return o;
          }
          if (((c = c[h]), n && l < u && (!c || "object" !== typeof c)))
            throw new pm(
              "Cannot perform operation at the desired path",
              "OPERATION_PATH_UNRESOLVABLE",
              i,
              t,
              e
            );
        }
      }
      function bm(e, t, n, r, s) {
        if (
          (void 0 === r && (r = !0),
          void 0 === s && (s = !0),
          n && !Array.isArray(t))
        )
          throw new pm(
            "Patch sequence must be an array",
            "SEQUENCE_NOT_AN_ARRAY"
          );
        r || (e = om(e));
        for (var i = new Array(t.length), o = 0, a = t.length; o < a; o++)
          (i[o] = ym(e, t[o], n, !0, s, o)), (e = i[o].newDocument);
        return (i.newDocument = e), i;
      }
      function wm(e, t, n) {
        var r = ym(e, t);
        if (!1 === r.test)
          throw new pm(
            "Test operation failed",
            "TEST_OPERATION_FAILED",
            n,
            t,
            e
          );
        return r.newDocument;
      }
      function Sm(e, t, n, r) {
        if ("object" !== typeof e || null === e || Array.isArray(e))
          throw new pm(
            "Operation is not an object",
            "OPERATION_NOT_AN_OBJECT",
            t,
            e,
            n
          );
        if (!mm[e.op])
          throw new pm(
            "Operation `op` property is not one of operations defined in RFC-6902",
            "OPERATION_OP_INVALID",
            t,
            e,
            n
          );
        if ("string" !== typeof e.path)
          throw new pm(
            "Operation `path` property is not a string",
            "OPERATION_PATH_INVALID",
            t,
            e,
            n
          );
        if (0 !== e.path.indexOf("/") && e.path.length > 0)
          throw new pm(
            'Operation `path` property must start with "/"',
            "OPERATION_PATH_INVALID",
            t,
            e,
            n
          );
        if (("move" === e.op || "copy" === e.op) && "string" !== typeof e.from)
          throw new pm(
            "Operation `from` property is not present (applicable in `move` and `copy` operations)",
            "OPERATION_FROM_REQUIRED",
            t,
            e,
            n
          );
        if (
          ("add" === e.op || "replace" === e.op || "test" === e.op) &&
          void 0 === e.value
        )
          throw new pm(
            "Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)",
            "OPERATION_VALUE_REQUIRED",
            t,
            e,
            n
          );
        if (
          ("add" === e.op || "replace" === e.op || "test" === e.op) &&
          um(e.value)
        )
          throw new pm(
            "Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)",
            "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED",
            t,
            e,
            n
          );
        if (n)
          if ("add" == e.op) {
            var s = e.path.split("/").length,
              i = r.split("/").length;
            if (s !== i + 1 && s !== i)
              throw new pm(
                "Cannot perform an `add` operation at the desired path",
                "OPERATION_PATH_CANNOT_ADD",
                t,
                e,
                n
              );
          } else if (
            "replace" === e.op ||
            "remove" === e.op ||
            "_get" === e.op
          ) {
            if (e.path !== r)
              throw new pm(
                "Cannot perform the operation at a path that does not exist",
                "OPERATION_PATH_UNRESOLVABLE",
                t,
                e,
                n
              );
          } else if ("move" === e.op || "copy" === e.op) {
            var o = _m([{ op: "_get", path: e.from, value: void 0 }], n);
            if (o && "OPERATION_PATH_UNRESOLVABLE" === o.name)
              throw new pm(
                "Cannot perform the operation from a path that does not exist",
                "OPERATION_FROM_UNRESOLVABLE",
                t,
                e,
                n
              );
          }
      }
      function _m(e, t, n) {
        try {
          if (!Array.isArray(e))
            throw new pm(
              "Patch sequence must be an array",
              "SEQUENCE_NOT_AN_ARRAY"
            );
          if (t) bm(om(t), om(e), n || !0);
          else {
            n = n || Sm;
            for (var r = 0; r < e.length; r++) n(e[r], r, t, void 0);
          }
        } catch (a_) {
          if (a_ instanceof pm) return a_;
          throw a_;
        }
      }
      function Em(e, t) {
        if (e === t) return !0;
        if (e && t && "object" == typeof e && "object" == typeof t) {
          var n,
            r,
            s,
            i = Array.isArray(e),
            o = Array.isArray(t);
          if (i && o) {
            if ((r = e.length) != t.length) return !1;
            for (n = r; 0 !== n--; ) if (!Em(e[n], t[n])) return !1;
            return !0;
          }
          if (i != o) return !1;
          var a = Object.keys(e);
          if ((r = a.length) !== Object.keys(t).length) return !1;
          for (n = r; 0 !== n--; ) if (!t.hasOwnProperty(a[n])) return !1;
          for (n = r; 0 !== n--; ) if (!Em(e[(s = a[n])], t[s])) return !1;
          return !0;
        }
        return e !== e && t !== t;
      }
      var Am = new WeakMap(),
        Tm = function (e) {
          (this.observers = new Map()), (this.obj = e);
        },
        Pm = function (e, t) {
          (this.callback = e), (this.observer = t);
        };
      function Im(e, t) {
        t.unobserve();
      }
      function Cm(e, t) {
        var n,
          r = (function (e) {
            return Am.get(e);
          })(e);
        if (r) {
          var s = (function (e, t) {
            return e.observers.get(t);
          })(r, t);
          n = s && s.observer;
        } else (r = new Tm(e)), Am.set(e, r);
        if (n) return n;
        if (((n = {}), (r.value = om(e)), t)) {
          (n.callback = t), (n.next = null);
          var i = function () {
              km(n);
            },
            o = function () {
              clearTimeout(n.next), (n.next = setTimeout(i));
            };
          "undefined" !== typeof window &&
            (window.addEventListener("mouseup", o),
            window.addEventListener("keyup", o),
            window.addEventListener("mousedown", o),
            window.addEventListener("keydown", o),
            window.addEventListener("change", o));
        }
        return (
          (n.patches = []),
          (n.object = e),
          (n.unobserve = function () {
            km(n),
              clearTimeout(n.next),
              (function (e, t) {
                e.observers.delete(t.callback);
              })(r, n),
              "undefined" !== typeof window &&
                (window.removeEventListener("mouseup", o),
                window.removeEventListener("keyup", o),
                window.removeEventListener("mousedown", o),
                window.removeEventListener("keydown", o),
                window.removeEventListener("change", o));
          }),
          r.observers.set(t, new Pm(t, n)),
          n
        );
      }
      function km(e, t) {
        void 0 === t && (t = !1);
        var n = Am.get(e.object);
        Om(n.value, e.object, e.patches, "", t),
          e.patches.length && bm(n.value, e.patches);
        var r = e.patches;
        return (
          r.length > 0 && ((e.patches = []), e.callback && e.callback(r)), r
        );
      }
      function Om(e, t, n, r, s) {
        if (t !== e) {
          "function" === typeof t.toJSON && (t = t.toJSON());
          for (
            var i = im(t), o = im(e), a = !1, c = o.length - 1;
            c >= 0;
            c--
          ) {
            var l = e[(d = o[c])];
            if (
              !sm(t, d) ||
              (void 0 === t[d] && void 0 !== l && !1 === Array.isArray(t))
            )
              Array.isArray(e) === Array.isArray(t)
                ? (s &&
                    n.push({ op: "test", path: r + "/" + cm(d), value: om(l) }),
                  n.push({ op: "remove", path: r + "/" + cm(d) }),
                  (a = !0))
                : (s && n.push({ op: "test", path: r, value: e }),
                  n.push({ op: "replace", path: r, value: t }),
                  !0);
            else {
              var u = t[d];
              "object" == typeof l &&
              null != l &&
              "object" == typeof u &&
              null != u &&
              Array.isArray(l) === Array.isArray(u)
                ? Om(l, u, n, r + "/" + cm(d), s)
                : l !== u &&
                  (!0,
                  s &&
                    n.push({ op: "test", path: r + "/" + cm(d), value: om(l) }),
                  n.push({
                    op: "replace",
                    path: r + "/" + cm(d),
                    value: om(u),
                  }));
            }
          }
          if (a || i.length != o.length)
            for (c = 0; c < i.length; c++) {
              var d;
              sm(e, (d = i[c])) ||
                void 0 === t[d] ||
                n.push({ op: "add", path: r + "/" + cm(d), value: om(t[d]) });
            }
        }
      }
      function xm(e, t, n) {
        void 0 === n && (n = !1);
        var r = [];
        return Om(e, t, r, "", n), r;
      }
      Object.assign({}, s, i, {
        JsonPatchError: hm,
        deepClone: om,
        escapePathComponent: cm,
        unescapePathComponent: lm,
      });
      function Nm(e, t) {
        const n = Ho(e);
        try {
          t();
        } catch (r) {
          const t = xm(e, n, !0);
          try {
            bm(e, t, !0);
          } catch (s) {
            throw ((s.cause = r), s);
          }
          throw r;
        }
      }
      function Rm(e, t) {
        const n = Cm(e);
        t();
        const r = km(n);
        return n.unobserve(), r;
      }
      async function Dm(e) {
        const [t, n] = await (async function (e, t) {
            const n = e.map(Ho);
            await t();
            const r = [];
            for (let s = 0; s < e.length; s++) {
              const t = e[s],
                i = n[s],
                o = xm(i, t, !1);
              for (const e of o) {
                const t = /\/\d+$/;
                if ("add" === e.op && t.test(e.path)) {
                  const t = e.path.split("/"),
                    n = Number(t.pop()),
                    r = t.join("/"),
                    s = vm(i, r);
                  Array.isArray(s) &&
                    Number.isSafeInteger(n) &&
                    s.length === n &&
                    (e.path = r + "/-");
                }
                ym(i, Ho(e));
              }
              r.push(o);
            }
            return r;
          })([e.entry.state, e.entry.metainfo], e.eventHandler),
          r = (null !== t && void 0 !== t ? t : []).filter(
            (e) =>
              !((e) => _l.some((t) => e.path.startsWith("/".concat(t, "/"))))(e)
          );
        if (!n || (0 === r.length && 0 === n.length)) return;
        const s = {
          event: e.event,
          id: Rl(e.now, e.counter || 0),
          lastAppliedMessageId: e.entry.lastAppliedMessageId,
          metainfoDiff: n,
          stateDiff: r,
          timestamp: e.now,
        };
        await e.db.writeEventHandlerMessage(e.userId, s);
      }
      function Mm(e, t, n) {
        try {
          Nm(e, () => {
            bm(e.metainfo, Ho(t.metainfoDiff), !0),
              bm(e.state, Ho(t.stateDiff), !0),
              null === n || void 0 === n || n();
          });
        } catch (s) {
          var r;
          if (s instanceof _a.ValidationError) throw s;
          const e =
              "Cannot apply event handler message diff: " +
              (null === (r = s.message) || void 0 === r
                ? void 0
                : r.split("\n")[0]),
            n = {
              index: s.index,
              message: t,
              operation: s.operation,
              tree: s.tree,
            };
          throw new nl(e, "replication_error", "inapplicable_diff", "error", n);
        }
      }
      function jm(e) {
        try {
          return (
            {
              NODE_ENV: "production",
              PUBLIC_URL: "",
              WDS_SOCKET_HOST: void 0,
              WDS_SOCKET_PATH: void 0,
              WDS_SOCKET_PORT: void 0,
              FAST_REFRESH: !0,
              REACT_APP_STAGE: "prod",
              REACT_APP_ENV: "prod",
              REACT_APP_APP_VERSION: "2.8.0",
            }.APP_NAME || e.appName
          );
        } catch (a_) {
          return e.appName;
        }
      }
      function Lm() {
        let e, t;
        return {
          promise: new Promise((n, r) => {
            (t = r), (e = n);
          }),
          callback: (n, r) => {
            n ? t(n) : e(r);
          },
        };
      }
      async function Um(e) {
        if (0 !== e) return new Promise((t) => setTimeout(t, e));
      }
      async function Fm(e, t) {
        if (t.linearBackoff && t.exponentialBackoff)
          throw new Error(
            "Cannot set linearBackoff and exponentialBackoff at the same time"
          );
        const n = t.retries,
          r = (null === t || void 0 === t ? void 0 : t.linearBackoff) || 0;
        let s = 0;
        for (;;)
          try {
            return await e();
          } catch (a_) {
            if (
              null !== t &&
              void 0 !== t &&
              t.retryOnlyIf &&
              !t.retryOnlyIf(a_)
            )
              throw a_;
            if (s >= n) throw a_;
            s++,
              null !== t && void 0 !== t && t.exponentialBackoff
                ? await Um(
                    Math.pow(2, s) * t.exponentialBackoff +
                      (Math.random() * t.exponentialBackoff -
                        t.exponentialBackoff)
                  )
                : await Um(s * r);
          }
      }
      function Bm(e, t) {
        return t instanceof Vm ? t : new Vm(t, e.migrator, e.stateSchema);
      }
      class Vm {
        constructor(e, t, n) {
          (this.originalLastLoginAt = e.lastLoginAt),
            (this.originalVersion = e.version);
          const { migratedEntry: r, migrationOperations: s } = this.migrate(
            e,
            t
          );
          (this.migrated = r),
            (this.decoded = {
              ...this.migrated,
              state: n.tryDecode(this.migrated.state),
              metainfo: om(this.migrated.metainfo),
            });
          const i = xm(this.migrated.state, this.decoded.state).filter((e) => {
            let { op: t } = e;
            return "remove" !== t;
          });
          i.length && bm(this.migrated.state, i, !1, !0),
            (this.backfillOperations = [...s, ...i]),
            (this.stateObserver = Cm(this.decoded.state));
        }
        get entry() {
          return this.decoded;
        }
        snapshot() {
          const e = km(this.stateObserver),
            t = xm(this.migrated.metainfo, this.decoded.metainfo),
            n = {
              ...this.decoded,
              state: bm(this.migrated.state, e, !1, !1).newDocument,
              metainfo: bm(this.migrated.metainfo, t, !1, !1).newDocument,
            };
          return new qm(n, {
            state: this.backfillOperations.concat(e),
            metainfo: t,
            lastLoginAt:
              this.decoded.lastLoginAt !== this.originalLastLoginAt
                ? this.decoded.lastLoginAt
                : void 0,
            migratedToVersion:
              this.decoded.version > this.originalVersion
                ? this.decoded.version
                : void 0,
          });
        }
        migrate(e, t) {
          const n = om(e);
          let r = [];
          const s = () => n.version < t.getLatestVersion();
          return (
            s() &&
              (r = Rm(n.state, () => {
                for (; s(); )
                  t.applyMigration(n.state, n.version), (n.version += 1);
              })),
            { migratedEntry: n, migrationOperations: r }
          );
        }
      }
      class qm {
        constructor(e, t) {
          (this.entry = e), (this.opts = t);
        }
        get diff() {
          const e = {
            lastLoginAt: this.opts.lastLoginAt,
            migratedToVersion: this.opts.migratedToVersion,
          };
          return (
            this.opts.state.length && (e.state = this.opts.state),
            this.opts.metainfo.length && (e.metainfo = this.opts.metainfo),
            e
          );
        }
      }
      const Hm = { 400: "Bad Request", 404: "Not Found" };
      class Wm extends Error {
        constructor(e, t) {
          super(e),
            (this.status =
              "number" === typeof t
                ? { statusCode: t, statusDescription: Hm[t] }
                : t);
        }
        static withCode(e, t, n) {
          return new this(JSON.stringify({ message: e, code: t, subCode: n }));
        }
      }
      class Km {
        constructor(e) {
          this.opts = e;
        }
        fetchAccessToken(e) {
          switch (this.opts.platform) {
            case "discord":
              return this.getDiscordAccessToken(e.code);
            case "line":
              return this.getLineAccessToken(e);
            default:
              throw Error(
                "Cannot fetch OAuth access token: platform ".concat(
                  this.opts.platform,
                  " is not supported"
                )
              );
          }
        }
        getDiscordAccessToken(e) {
          if (!this.opts.discordClient)
            throw Error(
              "Cannot fetch OAuth access token: Discord client is not defined"
            );
          const t = {
              NODE_ENV: "production",
              PUBLIC_URL: "",
              WDS_SOCKET_HOST: void 0,
              WDS_SOCKET_PATH: void 0,
              WDS_SOCKET_PORT: void 0,
              FAST_REFRESH: !0,
              REACT_APP_STAGE: "prod",
              REACT_APP_ENV: "prod",
              REACT_APP_APP_VERSION: "2.8.0",
            }.APP_ID,
            n = {
              NODE_ENV: "production",
              PUBLIC_URL: "",
              WDS_SOCKET_HOST: void 0,
              WDS_SOCKET_PATH: void 0,
              WDS_SOCKET_PORT: void 0,
              FAST_REFRESH: !0,
              REACT_APP_STAGE: "prod",
              REACT_APP_ENV: "prod",
              REACT_APP_APP_VERSION: "2.8.0",
            }.APP_SECRET;
          if (!t || !n)
            throw Error(
              "Cannot fetch OAuth access token: missing environment variables APP_ID or APP_SECRET"
            );
          return this.opts.discordClient.getAccessToken({
            accessCode: e,
            clientId: t,
            clientSecret: n,
          });
        }
        async getLineAccessToken(e) {
          if (!this.opts.lineOAuthClient)
            throw Error(
              "Cannot fetch OAuth access token: LINE client is not defined"
            );
          const { code: t, redirectUri: n } = e;
          if (!n)
            throw Error(
              "Cannot fetch OAuth access token: redirectUri is missing"
            );
          const { clientId: r, clientSecret: s } = (function (e) {
            const t = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LINE_LOGIN_CHANNEL_ID,
              n = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LINE_LOGIN_CHANNEL_SECRET,
              r = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.NEW_LINE_LOGIN_CHANNEL_ID,
              s = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.NEW_LINE_LOGIN_CHANNEL_SECRET;
            if (e) {
              if (e !== t && e !== r)
                throw Error("Unsupported clientId in OAuth request");
              if (e === r) {
                if (!s)
                  throw Error(
                    "Missing environment variable NEW_LINE_LOGIN_CHANNEL_SECRET"
                  );
                return { clientId: r, clientSecret: s };
              }
            }
            if (!t)
              throw Error("Missing environment variable LINE_LOGIN_CHANNEL_ID");
            if (!n)
              throw Error(
                "Missing environment variable LINE_LOGIN_CHANNEL_SECRET"
              );
            return { clientId: t, clientSecret: n };
          })(e.clientId);
          try {
            return await this.opts.lineOAuthClient.getAccessToken({
              code: t,
              redirectUri: n,
              clientId: r,
              clientSecret: s,
            });
          } catch (i) {
            if (i instanceof kl && 400 === i.statusCode)
              throw Wm.withCode(
                i.responseBody,
                "authorization_error",
                "invalid_signature"
              );
            throw i;
          }
        }
      }
      function zm() {
        return "undefined" !== typeof window;
      }
      const Gm = (e) =>
          zm() ? window.atob(e) : Buffer.from(e, "base64").toString("binary"),
        Jm = (e, t) =>
          zm() ? window.setTimeout(e, t) : n.g.setTimeout(e, t).unref();
      function Qm(e, t, n, r) {
        if (zm()) return e;
        return function () {
          const s = performance.now(),
            i = e(...arguments);
          if (bc(i))
            return i.then((e) => {
              const r = Math.round(performance.now() - s);
              return Ym({ context: t, durationMs: r, apiMethodName: n }), e;
            });
          if (!0 !== (null === r || void 0 === r ? void 0 : r.asyncOnly)) {
            const e = Math.round(performance.now() - s);
            Ym({ context: t, durationMs: e, apiMethodName: n });
          }
          return i;
        };
      }
      function Ym(e) {
        Xl.log({
          logType: "perf",
          context: e.context,
          durationMs: e.durationMs,
          apiMethodName: e.apiMethodName,
        });
      }
      function Xm(e, t) {
        let n =
          arguments.length > 2 && void 0 !== arguments[2]
            ? arguments[2]
            : "api.";
        if (!zm())
          for (const r in e) {
            const s = e[r];
            "object" !== typeof s || null === s || Array.isArray(s)
              ? "function" === typeof s &&
                (e[r] = Qm(s, t, n + r, { asyncOnly: !0 }))
              : Xm(s, t, "".concat(n).concat(r, "."));
          }
      }
      function Zm() {
        return (
          Math.random() <=
          (function () {
            if (void 0 !== $m) return $m;
            let e;
            try {
              e = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.PERFORMANCE_TRACKING_SAMPLE_RATE;
            } catch {}
            if (e) {
              const t = Number(e);
              if (!(t >= 0 && t <= 1))
                throw Error(
                  "Invalid PERFORMANCE_TRACKING_SAMPLE_RATE env var value: ".concat(
                    e,
                    ". Enter a number between 0 and 1, inclusive."
                  )
                );
              $m = t;
            } else $m = 0.001;
            return $m;
          })()
        );
      }
      let $m;
      class eg {
        constructor(e) {
          this.opts = e;
        }
        async getAssignments(e) {
          var t;
          const {
              isNewUser: n,
              userId: r,
              currentAssignments: s,
              userState: i,
            } = e,
            o =
              null === (t = this.opts.config.ruleset) || void 0 === t
                ? void 0
                : t.abTests;
          if (!o) return;
          const a = {},
            c = await this.getDynamicConfig();
          for (const l in o) {
            const e = this.getAssignment({
              dynamicConfig: c,
              isNewUser: n,
              userId: r,
              testId: l,
              ruleset: o[l],
              currentAssignments: s,
              userState: i,
            });
            void 0 !== e && (a[l] = e);
          }
          return a;
        }
        async getDynamicConfig() {
          const e = this.opts.devOpts.dateNow();
          if (
            !this.cache ||
            e - this.cache.timestamp > this.opts.devOpts.abTestsCacheExpiresInMs
          ) {
            const t = Promise.all([
              this.opts.db.abTests.get(),
              this.opts.db.abTests.userLists.get(),
            ])
              .then((e) => {
                let [t, n] = e;
                return { abTests: t, userLists: n };
              })
              .catch((e) => {
                throw (delete this.cache, e);
              });
            this.cache = { promise: t, timestamp: e };
          }
          return this.cache.promise;
        }
        getAssignment(e) {
          const { testId: t, userId: n } = e,
            r = !wl(t),
            s = e.dynamicConfig.abTests[t];
          if (r) {
            if (null === s || void 0 === s || !s.active) return;
            if (s.stopAssignment) return { type: "stopped", bucketId: "" };
            for (const s of e.dynamicConfig.userLists) {
              if (!s.userIds.includes(n)) continue;
              if (void 0 === s.testIds || s.testIds.includes(t))
                for (const t of s.bucketIds)
                  if (e.ruleset.buckets.find((e) => e.id === t))
                    return {
                      type: "automatic",
                      bucketId: t,
                      isByUserList: !0,
                      newUsersOnly: !1,
                    };
            }
            if (
              !Sl({
                rollOut:
                  e.isNewUser && void 0 !== s.newUsersRollOut
                    ? s.newUsersRollOut
                    : s.rollOut,
                testId: t,
                userId: n,
              })
            ) {
              if (
                !(
                  void 0 !== s.newUsersRollOut &&
                  Sl({ rollOut: s.newUsersRollOut, testId: t, userId: n })
                )
              )
                return;
            }
            const r = e.currentAssignments[t];
            if (
              "manual-active" ===
                (null === r || void 0 === r ? void 0 : r.type) &&
              !(null === r || void 0 === r || !r.newUsersOnly) === e.isNewUser
            )
              return r;
            if (e.ruleset.dependsOn) {
              if (
                !Object.entries(e.ruleset.dependsOn).every((t) => {
                  var r;
                  let [s, i] = t;
                  const o =
                      null === (r = this.opts.config.ruleset) || void 0 === r
                        ? void 0
                        : r.abTests,
                    a = null === o || void 0 === o ? void 0 : o[s];
                  if (!a)
                    throw new Error("Parent test does not exist: ".concat(s));
                  const c = this.getAssignment({
                    isNewUser: e.isNewUser,
                    userId: n,
                    testId: s,
                    ruleset: a,
                    dynamicConfig: e.dynamicConfig,
                    currentAssignments: e.currentAssignments,
                    userState: e.userState,
                  });
                  return c && i.includes(c.bucketId);
                })
              )
                return;
            }
            if (e.ruleset.assignManually)
              return {
                type: "manual-inactive",
                bucketId: e.ruleset.buckets[0].id,
                newUsersOnly: !!e.ruleset.newUsersOnly,
              };
            if (
              e.ruleset.assignIf &&
              !r &&
              (void 0 === e.userState || !1 === e.ruleset.assignIf(e.userState))
            )
              return;
          }
          const i = ml(n, t, { [t]: e.ruleset }),
            o =
              r &&
              void 0 !==
                (null === s || void 0 === s ? void 0 : s.newUsersRollOut) &&
              !Sl({ rollOut: s.rollOut, testId: t, userId: n });
          return {
            type: "automatic",
            bucketId: i,
            newUsersOnly: e.ruleset.newUsersOnly || o,
          };
        }
      }
      function tg(e) {
        const t = Ho(e.snapshot);
        for (const s of e.changesets) {
          var n, r;
          if (s.rev !== t.rev + 1)
            throw new Error(
              "Cannot apply changeset revision "
                .concat(s.rev, " to entry revision ")
                .concat(t.rev)
            );
          if (s.version !== t.version && s.version !== t.version + 1)
            throw new Error(
              "Cannot apply changeset version "
                .concat(s.version, " to entry version ")
                .concat(t.version)
            );
          s.version === t.version + 1 &&
            (e.migrator.applyMigration(t.state, t.version),
            (t.version = s.version)),
            null !== (n = s.diff) &&
              void 0 !== n &&
              n.metainfo &&
              bm(t.metainfo, s.diff.metainfo, !0),
            null !== (r = s.diff) &&
              void 0 !== r &&
              r.state &&
              bm(t.state, s.diff.state, !0),
            (t.rev = s.rev),
            (t.mainItemRev = s.rev),
            (t.lastUpdated = s.date.getTime());
        }
        return t;
      }
      function ng(e) {
        const { entry: t, now: n } = e,
          { dailySnapshotAt: r, weeklySnapshotAt: s, monthlySnapshotAt: i } = t,
          o = { shouldWriteNewSnapshot: !1, expirationsMs: {} };
        if (!r || n >= r + Sc({ days: 1 })) {
          o.shouldWriteNewSnapshot = !0;
          const {
            dailySnapshotRev: e,
            weeklySnapshotRev: a,
            monthlySnapshotRev: c,
          } = t;
          if (e) {
            const t =
              e === c
                ? i + Sc({ days: 90 })
                : e === a
                ? s + Sc({ days: 30 })
                : r + Sc({ days: 7 });
            t < n + Sc({ hours: 1 })
              ? (o.expirationsMs[e] = n + Sc({ days: 7 }))
              : (o.expirationsMs[e] = t);
          }
          (t.dailySnapshotAt = n),
            (t.dailySnapshotRev = t.rev),
            (o.dailySnapshotAt = n),
            (o.dailySnapshotRev = t.rev);
        }
        return (
          (!i || n >= i + Sc({ days: 30 })) &&
            ((o.shouldWriteNewSnapshot = !0),
            (t.monthlySnapshotAt = n),
            (t.monthlySnapshotRev = t.rev),
            (o.monthlySnapshotAt = n),
            (o.monthlySnapshotRev = t.rev)),
          (!s || n >= s + Sc({ days: 7 })) &&
            ((o.shouldWriteNewSnapshot = !0),
            (t.weeklySnapshotAt = n),
            (t.weeklySnapshotRev = t.rev),
            (o.weeklySnapshotAt = n),
            (o.weeklySnapshotRev = t.rev)),
          o
        );
      }
      function rg(e) {
        let t;
        try {
          t = e.getDefault();
        } catch {}
        const n = { default: t };
        switch (e._type) {
          case "null":
            return { ...n, type: "null" };
          case "boolean":
            return { ...n, type: "boolean" };
          case "number": {
            const { minVal: t, maxVal: r } = e.serialize();
            return {
              ...n,
              type: "number",
              ...(Number.isSafeInteger(t) ? { minimum: t } : {}),
              ...(Number.isSafeInteger(r) ? { maximum: r } : {}),
            };
          }
          case "integer": {
            const { minVal: t, maxVal: r } = e.serialize();
            return {
              ...n,
              type: "integer",
              ...(Number.isSafeInteger(t) ? { minimum: t } : {}),
              ...(Number.isSafeInteger(r) ? { maximum: r } : {}),
            };
          }
          case "string":
            return { ...n, type: e._type };
          case "tuple": {
            const { values: t } = e.serialize();
            return { ...n, type: "string", enum: t };
          }
          case "array": {
            const t = e,
              r = t.getItemSchema(),
              { minLengthVal: s, maxLengthVal: i } = t.serialize();
            return {
              ...n,
              type: "array",
              items: rg(r),
              ...(Number.isSafeInteger(s) ? { minItems: s } : {}),
              ...(Number.isSafeInteger(i) ? { maxItems: i } : {}),
            };
          }
          case "object": {
            const t = e,
              r = t.getAdditionalPropertyValuesSchema(),
              s = t.getFullSchema();
            return {
              ...n,
              type: "object",
              additionalProperties: !!r && rg(r),
              properties: Go(s, (e, t) => rg(t)),
              required: Object.entries(s)
                .filter((e) => {
                  let [t, n] = e;
                  return n.required;
                })
                .map((e) => {
                  let [t, n] = e;
                  return t;
                }),
            };
          }
          case "map": {
            const t = e.getItemSchema();
            return { ...n, type: "object", additionalProperties: rg(t) };
          }
          case "union": {
            const t = e.getItemSchemas();
            return { ...n, oneOf: t.map(rg) };
          }
          case "unknown":
            return { ...n };
          default:
            wc(e._type);
        }
      }
      function sg(e) {
        const t = {
            ...ag,
            description: "Indexing search/count API query object",
            properties: {
              id: {
                ...ag,
                properties: {
                  isOneOf: { type: "array", items: { type: "string" } },
                  isNotOneOf: { type: "array", items: { type: "string" } },
                },
              },
            },
          },
          n = lu(e);
        for (const r in n) t.properties[r] = ig(n[r]);
        return {
          $schema: "http://json-schema.org/draft-07/schema#",
          definitions: {
            where: t,
            booleanFilter: {
              ...ag,
              properties: {
                is: { type: "boolean" },
                isNot: { type: "boolean" },
              },
            },
            numberFilter: {
              ...ag,
              properties: {
                between: {
                  type: "array",
                  items: { type: "number" },
                  maxItems: 2,
                },
                lessThan: { type: "number" },
                greaterThan: { type: "number" },
                lessThanOrEqual: { type: "number" },
                greaterThanOrEqual: { type: "number" },
              },
            },
            integerFilter: {
              ...ag,
              properties: {
                between: {
                  type: "array",
                  items: { type: "integer" },
                  maxItems: 2,
                },
                lessThan: { type: "integer" },
                greaterThan: { type: "integer" },
                lessThanOrEqual: { type: "integer" },
                greaterThanOrEqual: { type: "integer" },
              },
            },
            stringFilter: {
              ...ag,
              properties: {
                isAnyOf: { type: "array", items: { type: "string" } },
                isNoneOf: { type: "array", items: { type: "string" } },
              },
            },
          },
          ...ag,
          properties: {
            where: {
              type: "array",
              items: { $ref: "#/definitions/where" },
              minItems: 1,
            },
          },
        };
      }
      function ig(e) {
        switch (e._type) {
          case "boolean":
            return { $ref: "#/definitions/booleanFilter" };
          case "number":
            return { $ref: "#/definitions/numberFilter" };
          case "integer":
            return { $ref: "#/definitions/integerFilter" };
          case "string":
            return { $ref: "#/definitions/stringFilter" };
          case "tuple": {
            const t = og(e);
            return {
              ...ag,
              properties: {
                isAnyOf: { type: "array", items: t },
                isNoneOf: { type: "array", items: t },
              },
            };
          }
          case "array": {
            const t = e.getItemSchema();
            if ("object" === t._type) return ig(t);
            {
              const e = og(t);
              return {
                ...ag,
                properties: {
                  containsAnyOf: { type: "array", items: e },
                  containsNoneOf: { type: "array", items: e },
                },
              };
            }
          }
          case "object": {
            const t = { ...ag, properties: {} },
              n = e.getFullSchema();
            for (const e in n) {
              const r = ig(n[e]);
              t.properties[e] = r;
            }
            return t;
          }
          default:
            wc(e._type);
        }
      }
      function og(e) {
        switch (e._type) {
          case "boolean":
          case "number":
          case "integer":
          case "string":
          case "tuple":
            return rg(e);
          case "array":
          case "object":
            throw Error("deeply nested arrays/objects are not supported");
          default:
            wc(e._type);
        }
      }
      const ag = { type: "object", additionalProperties: !1 },
        cg = {
          archiveInactiveUsers: _a.object({
            count: _a.number().default(1).min(1).max(25),
            concurrency: _a.number().default(2).min(1).max(100),
            dryRun: _a.boolean().default(!1),
            where: _a.array(_a.map(_a.unknown())),
          }),
          chatbotBroadcast: _a.object({
            count: _a.number().default(1).min(1).max(25),
            concurrency: _a.number().default(10).min(2).max(100),
            easing: _a.number().default(0).min(0),
            forceChannel: _a
              .tuple([
                "android",
                "chatbot",
                "ios",
                "nativepush",
                "sms",
                "webpush",
              ])
              .optional(),
            messageTemplateArgs: _a.unknown(),
            messageTemplateName: _a.string(),
            payload: _a
              .string()
              .default(
                JSON.stringify({ feature: "broadcast", $channel: "CHATBOT" })
              )
              .customValidator((e) => {
                const t = JSON.parse(e);
                return t && "object" === typeof t
                  ? null
                  : "Enter a JSON-encoded object";
              }),
            where: _a.array(_a.map(_a.unknown())),
          }),
          populateMessengerIdMapping: _a.object({
            count: _a.number().default(1).min(1).max(25),
            concurrency: _a.number().default(2).min(1).max(100),
            easing: _a
              .number()
              .default(Sc({ minutes: 10 }))
              .min(0),
            esReadCapacity: _a.number().default(1e3).min(1).max(5e4),
          }),
          reindex: _a.object({
            count: _a.number().default(1).min(1).max(25),
            concurrency: _a.number().default(1).min(1).max(100),
            easing: _a
              .number()
              .default(Sc({ minutes: 10 }))
              .min(0),
            esPushCapacity: _a.number().default(1e3).min(1).max(5e4),
            dbReadCapacity: _a.number().default(1e3).min(1).max(5e5),
          }),
          reindexIndexed: _a.object({
            count: _a.number().default(1).min(1).max(25),
            concurrency: _a.number().default(2).min(2).max(100),
            easing: _a
              .number()
              .default(Sc({ minutes: 10 }))
              .min(0),
            esPushCapacity: _a.number().default(1e3).min(1).max(5e4),
            dbReadCapacity: _a.number().default(1e3).min(1).max(5e5),
          }),
          scheduleActionToMany: _a.object({
            actionArgs: _a.unknown(),
            actionName: _a.string(),
            concurrency: _a.number().default(2).min(2).max(100),
            count: _a.number().default(1).min(1).max(25),
            delayMs: _a
              .int()
              .default(Sc({ minutes: 1 }))
              .min(Sc({ minutes: 1 })),
            notificationId: _a
              .string()
              .customValidator((e) =>
                0 === e.length ? "notificationId length must be >0" : null
              ),
            userIdsS3Path: _a.string().optional(),
            where: _a.array(_a.map(_a.unknown())).optional(),
          }),
        },
        lg = Object.keys(cg);
      _a.object({
        now: _a.int(),
        taskId: _a.string(),
        taskIndex: _a.int(),
        taskType: _a.tuple(lg),
      });
      class ug {
        constructor(e) {
          (this.opts = e),
            (this.availableTasks = [
              { name: "chatbotBroadcast", params: dg(e.config) },
              { name: "reindex", params: {} },
              { name: "reindexIndexed", params: {} },
              { name: "scheduleActionToMany", params: hg(e.config) },
            ]);
        }
        async handleListTasks() {
          const e = await this.opts.db.adminTasks.listTasks(),
            t = e.reduce((e, t) => [...e, ...t.ecsIds], []),
            n =
              t.length > 0 ? await this.opts.taskRunnerClient.getTasks(t) : {},
            r = await Promise.all(
              e.map(async (e) => {
                let { args: t, createdAt: r, ecsIds: s, id: i, task: o } = e;
                const a = (
                  await this.opts.db.adminTasks.listWorkerProgresses({
                    taskId: i,
                  })
                ).reduce((e, t) => e + t.itemsProcessed, 0);
                return {
                  args: t,
                  createdAt: r,
                  id: i,
                  task: o,
                  ecsTasks: Object.assign({}, ...s.map((e) => ({ [e]: n[e] }))),
                  itemsProcessed: a,
                };
              })
            );
          return { availableTasks: this.availableTasks, activeTasks: r };
        }
        async handleRunTask(e) {
          const t =
            this.opts.dateNow() +
            Math.floor(1e13 + 1e13 * Math.random()).toString();
          return this.runTask({ args: e.args, id: t, task: e.task });
        }
        async handleStopTask(e) {
          const t = await this.opts.db.adminTasks.getTask(e.id);
          if (!t)
            throw new Wm("Task not found", {
              statusCode: 404,
              statusDescription: "Not Found",
            });
          await Promise.all(
            t.ecsIds.map((e) =>
              this.opts.taskRunnerClient.stopTask(e).catch(() => {})
            )
          );
        }
        async handleRestartTask(e) {
          const t = await this.opts.db.adminTasks.getTask(e.id);
          if (!t)
            throw new Wm("Task not found", {
              statusCode: 404,
              statusDescription: "Not Found",
            });
          const n = await this.opts.taskRunnerClient.getTasks(t.ecsIds);
          for (const r in n) {
            const { status: e } = n[r];
            if ("STOPPED" !== e)
              throw new Wm(
                "Cannot restart non-stopped ECS Task "
                  .concat(r, ": ")
                  .concat(e),
                { statusCode: 409, statusDescription: "Conflict" }
              );
          }
          return this.runTask({ args: t.args, id: t.id, task: t.task });
        }
        async runTask(e) {
          const t = await this.opts.taskRunnerClient.runTask({
              args: e.args,
              id: e.id,
              task: e.task,
            }),
            {
              args: n,
              createdAt: r,
              id: s,
              task: i,
            } = await this.opts.db.adminTasks.createTask({
              id: e.id,
              ecsIds: Object.keys(t),
              args: e.args,
              task: e.task,
              now: this.opts.dateNow(),
            });
          return {
            args: n,
            createdAt: r,
            id: s,
            task: i,
            ecsTasks: t,
            itemsProcessed: 0,
          };
        }
      }
      function dg(e) {
        var t, n, r, s;
        const i = rg(cg.chatbotBroadcast);
        delete i.default;
        const { assets: o, ...a } =
            null !==
              (t =
                null === (n = e.adminTool) || void 0 === n
                  ? void 0
                  : n.chatbotMessageTemplates) && void 0 !== t
              ? t
              : {},
          c = Object.keys(a).map((e) => {
            const t = a[e].argsSchema,
              n = "unknown" !== t._type;
            return {
              title: e,
              properties: {
                messageTemplateName: {
                  const: e,
                  default: e,
                  description:
                    "Name of the chatbot message template. Define the available templates in the game's `adminTool.chatbotMessageTemplates` Replicant configuration property.",
                },
                messageTemplateArgs: {
                  ...(n ? rg(t) : void 0),
                  description: "Chatbot message template arguments.",
                },
              },
              required: n
                ? ["messageTemplateArgs", "messageTemplateName"]
                : ["messageTemplateName"],
            };
          });
        delete i.properties.messageTemplateName,
          delete i.properties.messageTemplateArgs,
          (i.anyOf = c);
        const l = null !== (r = e.computedProperties) && void 0 !== r ? r : {};
        null === (s = i.properties) || void 0 === s || delete s.where;
        const u = Qo(sg(l), i),
          d =
            (cg.chatbotBroadcast.getFullSchema(),
            {
              count: "Number of parallel ECS Task instances.",
              concurrency:
                "Number of concurrent workers per ECS Task instance.",
              payload:
                "Payload attached to the chatbot message entry point. Enter a JSON-encoded object.",
              forceChannel:
                'Force the chatbot message to be sent to a specific channel. Use "nativepush" for push notifications.',
            });
        for (const [p, f] of Object.entries(d)) {
          var h;
          const e = null === (h = u.properties) || void 0 === h ? void 0 : h[p];
          "object" === typeof e && (e.description = f);
        }
        return u;
      }
      function hg(e) {
        var t, n;
        const r = null !== (t = e.scheduledActions) && void 0 !== t ? t : {},
          s = Object.keys(r).map((e) => {
            const t = r[e].schema,
              n = "unknown" !== t._type;
            return {
              title: e,
              properties: {
                actionName: {
                  const: e,
                  default: e,
                  description: "Scheduled action name.",
                },
                actionArgs: n
                  ? { ...rg(t), description: "Scheduled action arguments." }
                  : {},
              },
              required: n ? ["actionArgs", "actionName"] : ["actionName"],
            };
          }),
          i = rg(cg.scheduleActionToMany);
        delete i.properties.actionName,
          delete i.properties.actionArgs,
          (i.anyOf = s),
          delete i.properties.where;
        const o = Qo(
          sg(null !== (n = e.computedProperties) && void 0 !== n ? n : {}),
          i
        );
        delete o.additionalProperties;
        cg.scheduleActionToMany.getFullSchema();
        const a = {
          count: "Number of parallel ECS Task instances.",
          concurrency: "Number of concurrent workers per ECS Task instance.",
          delayMs: "Scheduled action delay in milliseconds.",
          notificationId:
            "Scheduled action notification ID. Use an identical notification ID to reschedule a previously scheduled action.",
        };
        for (const [l, u] of Object.entries(a)) {
          var c;
          const e = null === (c = o.properties) || void 0 === c ? void 0 : c[l];
          "object" === typeof e && (e.description = u);
        }
        return o;
      }
      const pg = "_globalSystemScheduledActionUser",
        fg = "onGameEnd",
        mg = "onSessionEnd",
        gg = "lineChatbotBroadcast",
        vg = {
          [fg]: _a.object({
            eventData: _a.object({
              contextId: _a.string().optional(),
              contextType: _a.string().optional(),
              messengerId: _a.string(),
              payload: _a.map(_a.unknown()).optional(),
              playerId: _a.string(),
              score: _a.int().optional(),
            }),
            isFirstInSession: _a.boolean(),
          }),
          [mg]: _a.object({}),
          [gg]: _a.object({
            broadcastId: _a.string(),
            broadcastOpts: _a.map(_a.unknown()),
          }),
        };
      function yg(e) {
        return {
          onGameEnd: {
            schema: vg.onGameEnd,
            action: async (t, n, r) => {
              var s, i;
              if (
                null === (s = e.config.chatbot) ||
                void 0 === s ||
                !s.events.onGameEnd
              )
                throw Error(
                  "No `onGameEnd` handler defined in chatbot configuration"
                );
              await e.config.chatbot.events.onGameEnd(
                t,
                n.eventData,
                r,
                n.isFirstInSession
              ),
                null !== (i = n.eventData.payload) &&
                  void 0 !== i &&
                  i.sessionId &&
                  "string" === typeof n.eventData.payload.sessionId &&
                  (await e.db.chatbot.setSessionId(
                    n.eventData.playerId,
                    n.eventData.payload.sessionId
                  ));
            },
          },
          onSessionEnd: {
            schema: vg.onSessionEnd,
            action: async (t, n, r) => {
              var s;
              const i =
                null === (s = e.config.eventHandlers) || void 0 === s
                  ? void 0
                  : s.onSessionEnd;
              if (!i)
                throw Error("`eventHandlers.onSessionEnd` is not configured");
              await i(t, n, r);
            },
          },
          lineChatbotBroadcast: {
            schema: vg.lineChatbotBroadcast,
            action: () => {},
          },
        };
      }
      class bg {
        constructor(e) {
          (this.opts = e), (this.schedule = {}), (this.scheduleGlobal = {});
          const t = [gg],
            n = yg({ config: e.config, db: e.db });
          for (const r in n) {
            const e = r;
            this.schedule[e] = async (r) => {
              let {
                args: s,
                delayInMS: i,
                notificationId: o,
                userData: a,
                userId: c,
              } = r;
              n[e].schema.tryValidate(s);
              const l = [];
              if (t.includes(e) && c !== pg)
                throw Error(
                  "Cannot schedule global system scheduled action "
                    .concat(e, " for user ")
                    .concat(c)
                );
              qf({
                db: this.opts.db,
                delayedActions: l,
                errorReporter: this.opts.errorReporter,
                invokeTime: this.opts.dateNow(),
                isSystemAction: !0,
                scheduledActions: n,
                userData: { metainfoMVCC: Ho(a.metainfoMVCC) },
                userId: c,
              }).schedule[e]({ args: s, delayInMS: i, notificationId: o }),
                await this.opts.resolveDelayedActions(l);
            };
          }
          for (const r of t)
            this.scheduleGlobal[r] = async (e) => {
              let { args: t, delayInMS: n, notificationId: s } = e;
              const i = await this.opts.db.metainfoMVCC.fetchMetainfoMVCC(pg);
              await this.schedule[r]({
                args: t,
                delayInMS: n,
                notificationId: s,
                userData: { metainfoMVCC: i },
                userId: pg,
              });
            };
        }
        async unschedule(e) {
          const t = [];
          qf({
            db: this.opts.db,
            delayedActions: t,
            errorReporter: this.opts.errorReporter,
            invokeTime: this.opts.dateNow(),
            isSystemAction: !0,
            scheduledActions: {},
            userData: { metainfoMVCC: Ho(e.userData.metainfoMVCC) },
            userId: e.userId,
          }).unschedule(e.notificationId),
            await this.opts.resolveDelayedActions(t);
        }
        async unscheduleGlobal(e) {
          const t = await this.opts.db.metainfoMVCC.fetchMetainfoMVCC(pg);
          await this.unschedule({
            notificationId: e,
            userData: { metainfoMVCC: t },
            userId: pg,
          });
        }
      }
      const wg = "lineChatbotBroadcast-",
        Sg = {
          fetchProfile: _a.object({ id: _a.string() }),
          fetchUserAtRevision: _a.object({ id: _a.string(), rev: _a.int() }),
          postAdminMessage: _a.object({
            id: _a.string(),
            message: _a.object({ name: _a.string(), args: _a.unknown() }),
          }),
          postAdminMessageToMultiple: _a.object({
            ids: _a.array(_a.string()),
            message: _a.object({ name: _a.string(), args: _a.unknown() }),
          }),
          getAdminMessages: _a.object({}),
          fetchChangesets: _a.object({
            id: _a.string(),
            num: _a.number().optional(),
            page: _a.number().optional(),
            date: _a.string().optional(),
          }),
          listTasks: _a.object({}),
          runTask: _a.union([
            _a.object({
              task: _a.tuple(["chatbotBroadcast"]),
              args: cg.chatbotBroadcast,
            }),
            _a.object({ task: _a.tuple(["reindex"]), args: cg.reindex }),
            _a.object({
              task: _a.tuple(["reindexIndexed"]),
              args: cg.reindexIndexed,
            }),
            _a.object({
              task: _a.tuple(["scheduleActionToMany"]),
              args: cg.scheduleActionToMany,
            }),
          ]),
          stopTask: _a.object({ id: _a.string() }),
          restartTask: _a.object({ id: _a.string() }),
          countPlayers: _a.object({ where: _a.map(_a.unknown()) }),
          fetchFromIndexDB: _a.object({ id: _a.string() }),
          fetchESQuerySchema: _a.object({}),
          runESQuery: _a.object({
            where: _a.map(_a.unknown()),
            limit: _a.number().optional(),
          }),
          getChatbotMessageTemplates: _a.object({}),
          sendChatbotMessage: _a.object({
            receiverId: _a.string(),
            payload: _a.map(_a.unknown()),
            analyticsUserProperties: _a.map(_a.unknown()),
            template: _a.object({ name: _a.string(), args: _a.unknown() }),
            forceChannel: _a.tuple(["ios", "chatbot"]).optional(),
          }),
          fetchABTests: _a.object({}),
          updateABTests: _a.map(
            _a.object({
              active: _a.boolean().optional(),
              rollOut: _a.number().range(0, 1).optional(),
              newUsersRollOut: _a.union([
                _a.number().range(0, 1).optional(),
                _a.null(),
              ]),
              stopAssignment: _a.boolean().optional(),
            })
          ),
          fetchUserLists: _a.object({}),
          updateUserLists: _a.array(
            _a.union([
              _a
                .object({
                  type: _a.tuple(["add"]),
                  userList: _a.object({
                    id: _a.string(),
                    name: _a.string(),
                    testIds: _a.array(_a.string()).optional(),
                    userIds: _a.array(_a.string()),
                    bucketIds: _a.array(_a.string()),
                  }),
                  before: _a.string().optional(),
                })
                .customValidator((e) =>
                  e.userList.id === e.before
                    ? "Cannot add user list ".concat(
                        e.userList.id,
                        " before itself"
                      )
                    : null
                ),
              _a.object({
                type: _a.tuple(["remove"]),
                userListId: _a.string(),
              }),
              _a
                .object({
                  type: _a.tuple(["move"]),
                  userListId: _a.string(),
                  before: _a.string().optional(),
                })
                .customValidator((e) =>
                  e.userListId === e.before
                    ? "Cannot move user list ".concat(
                        e.userListId,
                        " before itself"
                      )
                    : null
                ),
              _a.object({
                type: _a.tuple(["update"]),
                userList: _a.object({
                  id: _a.string(),
                  name: _a.string().optional(),
                  testIds: _a
                    .union([_a.null(), _a.array(_a.string())])
                    .optional(),
                  userIds: _a.array(_a.string()).optional(),
                  bucketIds: _a.array(_a.string()).optional(),
                }),
              }),
            ])
          ),
          deleteUsers: _a.array(_a.string()),
          deleteUserData: _a.object({
            userIds: _a.array(_a.string()),
            sources: _a
              .object({
                amplitude: _a.boolean(),
                sentry: _a.boolean(),
                replicant: _a.boolean(),
                indexDB: _a.boolean(),
              })
              .optional(),
          }),
          fetchConfig: _a.object({}),
          getScheduledLineChatbotBroadcasts: _a.object({}),
          scheduleLineChatbotBroadcasts: _a.array(
            _a.object({
              id: _a.string(),
              opts: _a.map(_a.unknown()),
              sendAt: _a.int(),
            })
          ),
          unscheduleLineChatbotBroadcasts: _a.array(_a.string()),
          fetchSharedState: _a.object({
            stateId: _a.string(),
            stateName: _a.string(),
          }),
        },
        _g = (e, t) => {
          try {
            const n = Sg[e].tryValidateAndFillDefaults(t);
            null !== n && (t = n);
          } catch (a_) {
            throw new nl(
              "Could not validate args for action " + e + ": " + a_.message,
              "replication_error",
              "admin_interface_error"
            );
          }
          return t;
        };
      class Eg {
        constructor(e) {
          (this.opts = e),
            e.taskRunnerClient &&
              (this.adminTasks = new ug({
                config: e.apiAccess.config,
                dateNow: e.dateNow,
                db: e.db,
                taskRunnerClient: e.taskRunnerClient,
              }));
        }
        async handleAdminAction(e) {
          const t = ((e) => {
            if (!(e in Sg))
              throw new nl(
                "Unknown action: " + e,
                "replication_error",
                "admin_interface_error"
              );
            return e;
          })(e.action);
          switch (t) {
            case "fetchProfile": {
              const n = _g(t, e.args);
              return this.handleAdminFetchProfile(n.id);
            }
            case "fetchUserAtRevision": {
              const n = _g(t, e.args);
              return this.handleAdminFetchUserAtRevision(n);
            }
            case "postAdminMessage": {
              const n = _g(t, e.args);
              return this.handleAdminPostAdminMessage(n.id, n.message);
            }
            case "postAdminMessageToMultiple": {
              const n = _g(t, e.args);
              return this.handleAdminPostAdminMessageToMultiple(
                n.ids,
                n.message
              );
            }
            case "getAdminMessages":
              return this.handleAdminGetAdminMessages();
            case "fetchChangesets": {
              const n = _g(t, e.args);
              return this.handleAdminFetchChangesets(
                n.id,
                n.num,
                n.page,
                n.date
              );
            }
            case "listTasks":
              if (!this.adminTasks) throw new Wm("Tasks not configured");
              return this.adminTasks.handleListTasks();
            case "runTask": {
              if (!this.adminTasks) throw new Wm("Tasks not configured");
              const n = _g(t, e.args);
              return this.adminTasks.handleRunTask(n);
            }
            case "stopTask": {
              if (!this.adminTasks) throw new Wm("Tasks not configured");
              const n = _g(t, e.args);
              return this.adminTasks.handleStopTask(n);
            }
            case "restartTask": {
              if (!this.adminTasks) throw new Wm("Tasks not configured");
              const n = _g(t, e.args);
              return this.adminTasks.handleRestartTask(n);
            }
            case "countPlayers": {
              const n = _g(t, e.args);
              return this.handleCountPlayers(n.where);
            }
            case "fetchFromIndexDB": {
              const n = _g(t, e.args);
              return this.handleAdminFetchFromIndexDB(n.id);
            }
            case "fetchESQuerySchema":
              return this.handleFetchESQuerySchema();
            case "runESQuery": {
              const n = _g(t, e.args);
              return this.handleRunESQuery(n.where, n.limit);
            }
            case "getChatbotMessageTemplates":
              return this.handleGetChatbotMessageTemplates();
            case "sendChatbotMessage": {
              const n = _g(t, e.args);
              return this.handleSendChatbotMessage(n);
            }
            case "fetchABTests":
              return this.handleFetchABTests();
            case "updateABTests": {
              const n = _g(t, e.args);
              return this.handleUpdateABTests(n);
            }
            case "fetchUserLists":
              return this.handleFetchUserLists();
            case "updateUserLists": {
              const n = _g(t, e.args);
              return this.handleUpdateUserLists(n);
            }
            case "deleteUsers": {
              const n = _g(t, e.args);
              return this.handleDeleteUsers(n);
            }
            case "deleteUserData": {
              const n = _g(t, e.args);
              return this.handleDeleteUserData(n);
            }
            case "fetchConfig":
              return this.opts.apiAccess.config;
            case "getScheduledLineChatbotBroadcasts":
              return this.handleGetScheduledLineChatbotBroadcasts();
            case "scheduleLineChatbotBroadcasts": {
              const n = _g(t, e.args);
              return this.handleScheduleLineChatbotBroadcasts(n);
            }
            case "unscheduleLineChatbotBroadcasts": {
              const n = _g(t, e.args);
              return this.handleUnscheduleLineChatbotBroadcasts(n);
            }
            case "fetchSharedState": {
              const n = _g(t, e.args);
              return this.handleFetchSharedState(n);
            }
            default:
              return wc(t);
          }
        }
        async handleAdminFetchProfile(e) {
          var t, n;
          const r =
            null === (t = await this.opts.apiAccess.getReadOnlyEntry(e)) ||
            void 0 === t
              ? void 0
              : t.entry;
          if (!r)
            throw new Wm("Profile for " + e + " not found!", {
              statusCode: 404,
              statusDescription: "Not Found",
            });
          const s = [];
          if (
            null !== (n = this.opts.apiAccess.config.adminTool) &&
            void 0 !== n &&
            null !== (n = n.profile) &&
            void 0 !== n &&
            n.length
          ) {
            const t = Qf({
              api: Jf({ entry: r, now: this.opts.dateNow, userId: e }),
              computedProperties: this.opts.apiAccess.config.computedProperties,
              docId: e,
              state: r.state,
            });
            for (const { caption: e, property: n, role: r } of this.opts
              .apiAccess.config.adminTool.profile) {
              const i = this.opts.apiAccess.config.computedProperties[n];
              r && $f[r].tryValidate(t[n]),
                s.push({
                  caption: e,
                  type: i.type._type,
                  value: t[n],
                  role: r,
                });
            }
          }
          return { entry: r, messages: [], profile: s };
        }
        async handleAdminFetchUserAtRevision(e) {
          const t = await this.opts.db.snapshots.fetchSnapshots(e.id);
          let n;
          for (const a of t.reverse())
            if (a.rev <= e.rev) {
              n = a;
              break;
            }
          if (!n)
            throw new Wm("No snapshot found", {
              statusCode: 404,
              statusDescription: "Not Found",
            });
          const r =
            e.rev > n.rev
              ? await this.opts.db.fetchChangesetsBetween(
                  e.id,
                  n.rev + 1,
                  e.rev
                )
              : [];
          if (r.length !== e.rev - n.rev)
            throw new Wm(
              "Missing changesets between snapshot and target revision",
              { statusCode: 404, statusDescription: "Not Found" }
            );
          const {
            metainfo: s,
            state: i,
            version: o,
          } = tg({
            changesets: r,
            migrator: this.opts.apiAccess.config.migrator,
            snapshot: n,
          });
          return { metainfo: s, state: i, version: o };
        }
        async handleAdminPostAdminMessage(e, t) {
          if (!!!(await this.opts.db.fetch(e)).entry)
            throw new Wm("Could not find user with id: " + e);
          await this.handleAdminPostAdminMessageToMultiple([e], t);
        }
        async handleAdminPostAdminMessageToMultiple(e, t) {
          this.validateAdminMessage(t);
          const n = {
              id: Rl(this.opts.dateNow(), 0),
              name: t.name,
              args: t.args,
              sender: "admin",
              senderClockOffset: 0,
            },
            r = {},
            s = (function (e, t) {
              if (t <= 0) throw Error("chunk size must be >0");
              const n = [];
              for (let r = 0; r < e.length; r += t) n.push(e.slice(r, r + t));
              return n;
            })(e, 100);
          for (const i of s) {
            const e = i.map(async (e) => {
              try {
                await this.opts.postMessages({ receiverId: e, messages: [n] }),
                  (r[e] = { success: !0 });
              } catch (a_) {
                r[e] = { success: !1, reason: a_.message ? a_.message : a_ };
              }
            });
            await Promise.all(e);
          }
          return r;
        }
        validateAdminMessage(e) {
          const t = this.opts.apiAccess.config;
          if (!t.messages) throw new Wm("No messages configured for this app");
          const n = e.name;
          if (!t.messages[n])
            throw new Wm("Could not find message with name: " + n);
          const r = t.messages[n];
          if (!r.isAdmin)
            throw new Wm("Cannot post message that is not admin.");
          const s = r.schema.validate(e.args);
          if (s) throw new Wm("Message arguments could not be validated: " + s);
        }
        async handleAdminGetAdminMessages() {
          var e, t;
          const n = this.opts.apiAccess.config;
          if (!n.messages) throw new Wm("No messages configured for this app");
          const r = [];
          for (const s in n.messages) {
            if (!n.messages.hasOwnProperty(s)) continue;
            const e = n.messages[s];
            e.isAdmin &&
              r.push({
                name: s,
                args: e.schema.serialize(),
                description: e.description,
              });
          }
          return {
            messages: r,
            messageGroups:
              null !==
                (e =
                  null === (t = this.opts.apiAccess.config.adminTool) ||
                  void 0 === t
                    ? void 0
                    : t.adminMessageGroups) && void 0 !== e
                ? e
                : [],
          };
        }
        async handleAdminFetchChangesets(e, t, n, r) {
          let s, i, o;
          if (r) {
            const {
              items: n,
              totalItemsCount: a,
              currentPage: c,
            } = await this.opts.db.fetchChangesetsPageByDate(e, r, t);
            (s = n), (i = a), (o = c);
          } else {
            const { items: r, totalItemsCount: a } =
              await this.opts.db.fetchChangesetsPage(e, n, t);
            (s = r), (i = a), (o = n);
          }
          if (!s || 0 === s.length)
            throw new Wm("Changesets for profile id `" + e + "` not found!", {
              statusCode: 404,
              statusDescription: "Not Found",
            });
          return {
            items: s.map((e) => (delete e.diff, e)),
            totalItemsCount: i,
            currentPage: o,
          };
        }
        async handleCountPlayers(e) {
          return {
            playersNum: await this.opts.apiAccess.countPlayers({ where: e }),
          };
        }
        async handleAdminFetchFromIndexDB(e) {
          if (!this.opts.indexDB)
            throw new Wm("Index DB is not available on replicant.", {
              statusCode: 418,
              statusDescription: "Not available",
            });
          return this.opts.indexDB.getMany([e]);
        }
        async handleFetchESQuerySchema() {
          const e = this.opts.apiAccess.config;
          if (!e.computedProperties)
            throw new Wm("No computed properties configured for this app");
          return { esQuerySchema: sg(e.computedProperties) };
        }
        async handleRunESQuery(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : 100;
          try {
            return await this.opts.apiAccess.searchPlayers({
              where: e,
              limit: t,
            });
          } catch (a_) {
            throw new Wm("Search players failed: " + a_.message);
          }
        }
        handleGetChatbotMessageTemplates() {
          var e, t;
          const { assets: n, ...r } =
            null !==
              (e =
                null === (t = this.opts.apiAccess.config.adminTool) ||
                void 0 === t
                  ? void 0
                  : t.chatbotMessageTemplates) && void 0 !== e
              ? e
              : {};
          return Object.entries(r).map((e) => {
            let [t, n] = e;
            const r = n({ args: n.argsSchema.getDefault(), payload: {} });
            return {
              name: t,
              argsSchema: rg(n.argsSchema),
              renderers: Object.keys(r.renderers),
            };
          });
        }
        async handleSendChatbotMessage(e) {
          var t;
          const n =
            null === (t = this.opts.apiAccess.config.adminTool) ||
            void 0 === t ||
            null === (t = t.chatbotMessageTemplates) ||
            void 0 === t
              ? void 0
              : t[e.template.name];
          if (!n)
            throw Error(
              "Template '".concat(
                e.template.name,
                "' not found in config.adminTool.chatbotMessageTemplates"
              )
            );
          const r = n({
            args: e.template.args,
            payload: {
              $channel: "CHATBOT",
              feature: "cstool_admin_test_chatbot",
              $subFeature: null,
              ...e.payload,
            },
            analyticsUserProperties: e.analyticsUserProperties,
          });
          try {
            return await this.opts.chatbot.sendChatbotMessage({
              senderId: "admin",
              receiverId: e.receiverId,
              message: r,
              forceChannel: e.forceChannel,
            });
          } catch (s) {
            return { ok: !1, reason: s.message, channels: {} };
          }
        }
        async handleFetchABTests() {
          var e;
          const t =
            null === (e = this.opts.apiAccess.config.ruleset) || void 0 === e
              ? void 0
              : e.abTests;
          if (!t) return {};
          const n = await this.opts.db.abTests.get(),
            r = {};
          for (const i in t) {
            var s;
            if (wl(i)) continue;
            const { buckets: e, assignManually: o } = t[i],
              {
                active: a,
                rollOut: c,
                newUsersRollOut: l,
                stopAssignment: u,
              } = null !== (s = n[i]) && void 0 !== s
                ? s
                : { active: !1, rollOut: 0 };
            r[i] = {
              buckets: e,
              assignManually: o,
              active: a,
              rollOut: c,
              newUsersRollOut: l,
              stopAssignment: u,
            };
          }
          return r;
        }
        async handleUpdateABTests(e) {
          var t;
          const n =
            null === (t = this.opts.apiAccess.config.ruleset) || void 0 === t
              ? void 0
              : t.abTests;
          if (!n) throw new Wm("AB Tests not configured. Cannot update.");
          for (const i in e) {
            if (wl(i)) throw new Wm("Cannot update placebo test ".concat(i));
            if (!n[i]) throw new Wm("Unexpected test id '".concat(i, "'."));
          }
          const r = await this.opts.db.abTests.get();
          for (const i in e) {
            const t = e[i];
            void 0 === t.newUsersRollOut && delete t.newUsersRollOut,
              null === t.newUsersRollOut && (t.newUsersRollOut = void 0),
              r[i] || (r[i] = { active: !1, rollOut: 0 });
          }
          const s = Qo(Ho(r), e);
          if (
            (await this.opts.db.abTests.set(s),
            {
              NODE_ENV: "production",
              PUBLIC_URL: "",
              WDS_SOCKET_HOST: void 0,
              WDS_SOCKET_PATH: void 0,
              WDS_SOCKET_PORT: void 0,
              FAST_REFRESH: !0,
              REACT_APP_STAGE: "prod",
              REACT_APP_ENV: "prod",
              REACT_APP_APP_VERSION: "2.8.0",
            }.SLACK_OAUTH_TOKEN &&
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.SLACK_CHANNEL_ID)
          ) {
            const t = ["U01G4FCDBPU", "U066JQDR1H7"]
                .map((e) => "<@".concat(e, ">"))
                .join(", "),
              n = ["Changes were made to A/B tests: (cc ".concat(t, ")"), ""],
              i = (e, t) => {
                var r;
                const s = (e) => (void 0 !== e ? ":point_right: " : "");
                n.push(
                  "\u2022 "
                    .concat(
                      s(null === t || void 0 === t ? void 0 : t.active),
                      "active: "
                    )
                    .concat(e.active ? "\u2611" : "\u25fb")
                ),
                  n.push(
                    "\u2022 "
                      .concat(
                        s(null === t || void 0 === t ? void 0 : t.rollOut),
                        "roll-out: "
                      )
                      .concat(Math.ceil(100 * e.rollOut), "%")
                  ),
                  n.push(
                    "\u2022 "
                      .concat(
                        s(
                          null === t || void 0 === t
                            ? void 0
                            : t.newUsersRollOut
                        ),
                        "new users roll-out: "
                      )
                      .concat(
                        Math.ceil(
                          100 *
                            (null !== (r = e.newUsersRollOut) && void 0 !== r
                              ? r
                              : 0)
                        ),
                        "%"
                      )
                  ),
                  n.push(
                    "\u2022 "
                      .concat(
                        s(
                          null === t || void 0 === t ? void 0 : t.stopAssignment
                        ),
                        "stop assignment: "
                      )
                      .concat(e.stopAssignment ? "\u2611" : "\u25fb")
                  );
              };
            for (const o in e)
              n.push("`".concat(o, "` before:")),
                i(r[o]),
                n.push(""),
                n.push("`".concat(o, "` after:")),
                i(s[o], e[o]),
                n.push("");
            await (async function (e) {
              const t = { channel: e.channelId, text: e.text },
                n = await e.fetcher.fetch({
                  body: JSON.stringify(t),
                  headers: {
                    Authorization: "Bearer ".concat(e.authToken),
                    "Content-Type": "application/json; charset=utf-8",
                  },
                  method: "POST",
                  url: "https://slack.com/api/chat.postMessage",
                });
              if (200 !== n.statusCode)
                throw Error(
                  "Slack message API request failed: "
                    .concat(n.statusCode, " ")
                    .concat(n.body)
                );
              if (JSON.parse(n.body).error)
                throw new Error(
                  "Slack message API error response: ".concat(n.body)
                );
            })({
              fetcher: this.opts.fetcher,
              authToken: {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.SLACK_OAUTH_TOKEN,
              channelId: {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.SLACK_CHANNEL_ID,
              text: n.join("\n"),
            });
          }
        }
        handleFetchUserLists() {
          return this.opts.db.abTests.userLists.get();
        }
        async handleUpdateUserLists(e) {
          const t = await this.opts.db.abTests.userLists.get(),
            n = (e, n) => {
              if (
                t.find((t) => {
                  let { id: n } = t;
                  return n === e.id;
                })
              )
                throw new Wm(
                  "updateUserLists: Cannot add '".concat(
                    e.id,
                    "' which already exists."
                  )
                );
              if (n) {
                const r = t.findIndex((e) => {
                  let { id: t } = e;
                  return t === n;
                });
                if (r < 0)
                  throw new Wm(
                    "updateUserLists: Cannot add '"
                      .concat(e.id, "' before '")
                      .concat(n, "' which doesn't exist.")
                  );
                t.splice(r, 0, e);
              } else t.push(e);
            },
            r = (e) => {
              const n = t.findIndex((t) => {
                let { id: n } = t;
                return n === e;
              });
              if (n < 0)
                throw new Wm(
                  "updateUserLists: Cannot remove '".concat(
                    e,
                    "' which doesn't exist."
                  )
                );
              const [r] = t.splice(n, 1);
              if (!r)
                throw new Error(
                  "updateUserLists: Unexpected lack of removed user list '".concat(
                    e,
                    "'."
                  )
                );
              return r;
            };
          for (const s of e)
            switch (s.type) {
              case "add":
                n(s.userList, s.before);
                break;
              case "remove":
                r(s.userListId);
                break;
              case "move":
                n(r(s.userListId), s.before);
                break;
              case "update": {
                const e = t.findIndex((e) => {
                  let { id: t } = e;
                  return t === s.userList.id;
                });
                if (e < 0)
                  throw new Wm(
                    "updateUserLists: Cannot update '".concat(
                      s.userList.id,
                      "' which doesn't exist."
                    )
                  );
                (t[e] = Qo(t[e], s.userList)),
                  null === s.userList.testIds && delete t[e].testIds;
                break;
              }
              default:
                wc(s);
            }
          await this.opts.db.abTests.userLists.set(t);
        }
        async handleDeleteUsers(e) {
          return this.handleDeleteUserData({
            userIds: e,
            sources: { amplitude: !1, sentry: !1, replicant: !0, indexDB: !1 },
          });
        }
        async handleDeleteUserData(e) {
          const t = {};
          for (const r of e.userIds)
            try {
              await this.opts.deleteUserData({ userId: r, sources: e.sources }),
                (t[r] = { success: !0 });
            } catch (a_) {
              let s;
              if (a_ instanceof Error) s = a_.message;
              else {
                s = "Unknown error";
                try {
                  Xl.warn(JSON.stringify(a_));
                } catch (n) {
                  Xl.warn(
                    "Could not parse unknown admin delete request error."
                  );
                }
              }
              t[r] = { success: !1, reason: s };
            }
          return t;
        }
        async handleGetScheduledLineChatbotBroadcasts() {
          var e;
          const t = await this.opts.db.metainfoMVCC.fetchMetainfoMVCC(pg),
            n = Object.values(
              null !== (e = t.systemScheduledActionNotifications) &&
                void 0 !== e
                ? e
                : []
            ),
            r = await Promise.all(
              n.map((e) => this.opts.db.scheduledActions.fetch(e))
            ),
            s = r.filter(
              (e) => (null === e || void 0 === e ? void 0 : e.actionName) === gg
            ),
            i = s.map((e) => ({
              id: e.notificationId.substring(21),
              opts: e.actionArgs.broadcastOpts,
              sendAt: e.whenToExecute,
            })),
            o = await this.opts.db.lineChatbotBroadcasts.getBroadcasts();
          return (function (e, t) {
            return [...e].sort((e, n) => {
              const r = t(e),
                s = t(n);
              return r < s ? -1 : r === s ? 0 : 1;
            });
          })(
            [
              ...i,
              ...(await Promise.all(
                o.map(async (e) => {
                  const t = {
                    error: e.error,
                    id: e.broadcastId,
                    opts: e.broadcastOpts,
                    sendAt: e.createdAt,
                    status: void 0,
                  };
                  return (
                    e.requestId &&
                      (t.status =
                        await this.opts.narrowcastAPIClient.getNarrowcastMessageStatus(
                          e.requestId
                        )),
                    t
                  );
                })
              )),
            ],
            (e) => e.sendAt
          );
        }
        async handleScheduleLineChatbotBroadcasts(e) {
          const t = this.opts.dateNow();
          await Promise.all(
            e.map(async (e) => {
              if (e.sendAt - t < 0)
                throw Error(
                  "Invalid sendAt value in ".concat(
                    JSON.stringify(e),
                    ": cannot schedule into the past"
                  )
                );
              const n =
                await this.opts.narrowcastAPIClient.validateNarrowcastMessages(
                  e.opts
                );
              if (!n.isValid) throw new Wm(JSON.stringify(n.error), 400);
            })
          );
          const n = [];
          try {
            for (const r of e) {
              const e = r.sendAt - t,
                s = wg + r.id;
              await this.opts.apiAccess.systemScheduledActions.scheduleGlobal.lineChatbotBroadcast(
                {
                  args: { broadcastId: r.id, broadcastOpts: r.opts },
                  delayInMS: e,
                  notificationId: s,
                }
              ),
                n.push(s);
            }
          } catch (r) {
            for (const e of n)
              try {
                await this.opts.apiAccess.systemScheduledActions.unscheduleGlobal(
                  e
                );
              } catch {}
            throw r;
          }
        }
        async handleUnscheduleLineChatbotBroadcasts(e) {
          for (const t of e) {
            const e = wg + t;
            await this.opts.apiAccess.systemScheduledActions.unscheduleGlobal(
              e
            );
          }
        }
        async handleFetchSharedState(e) {
          const { stateId: t, stateName: n } = e,
            r = await this.opts.apiAccess.sharedStates.fetchSharedState({
              stateId: t,
              stateName: n,
            });
          if (!r) throw new Wm("Shared state not found", 404);
          return { global: r.global, users: r.users };
        }
      }
      const Ag = "airtable_",
        Tg = Sc({ minutes: 15 }),
        Pg = Sc({ minutes: 1 });
      class Ig {
        constructor(e) {
          (this.opts = e), (this.cache = {});
        }
        async getTable(e) {
          var t, n;
          try {
            if (
              this.isCacheExpired(e) &&
              (await this.updateCacheFromDB(e), this.isCacheExpired(e))
            ) {
              if (!(await this.updateCacheFromAPI(e))) {
                const t = 5;
                for (let n = 0; n < t; n++) {
                  var r;
                  await Um(
                    (null !== (r = this.opts.dbRetryBackoffMs) && void 0 !== r
                      ? r
                      : 1e3) * n
                  );
                  if (await this.updateCacheFromDB(e, { consistentRead: !0 }))
                    break;
                }
              }
            }
          } catch (i) {
            var s;
            await (null === (s = this.opts.errorReporter) || void 0 === s
              ? void 0
              : s.captureException(i));
          }
          return null !==
            (t =
              null === (n = this.cache[e]) || void 0 === n
                ? void 0
                : n.items) && void 0 !== t
            ? t
            : null;
        }
        isCacheExpired(e) {
          const t = this.cache[e];
          return !t || t.expiresAt < this.opts.dateNow();
        }
        async updateCacheFromDB(e, t) {
          const n = await this.opts.db.internalKvStore.fetch(Ag + e, {
            consistentRead:
              null === t || void 0 === t ? void 0 : t.consistentRead,
          });
          return !!n && ((this.cache[e] = JSON.parse(n)), !0);
        }
        async updateCacheFromAPI(e) {
          var t, n;
          this.cache[e] = {
            items:
              null !==
                (t =
                  null === (n = this.cache[e]) || void 0 === n
                    ? void 0
                    : n.items) && void 0 !== t
                ? t
                : null,
            expiresAt: this.opts.dateNow() + Pg,
          };
          if (
            !(await this.opts.db.lock.acquireTimestampLock(
              Ag + e,
              this.opts.dateNow(),
              Pg
            ))
          )
            return !1;
          const r = {
            items: await this.opts.airtable.getTable(e),
            expiresAt: this.opts.dateNow() + Tg,
          };
          return (
            (this.cache[e] = r),
            await this.opts.db.internalKvStore.write(Ag + e, JSON.stringify(r)),
            !0
          );
        }
      }
      class Cg {
        constructor(e) {
          this.opts = e;
        }
        async sendAnalyticsEvents(e, t) {
          try {
            const n = await this.withExtraEventAndUserProperties(e, t);
            await this.opts.postAnalytics(n);
          } catch (a_) {
            await this.opts.errorReporter.captureException(a_);
          }
        }
        async withExtraEventAndUserProperties(e, t) {
          const n = this.opts.dateNow();
          try {
            const r = await this.getExtraPropsPerReceiver(e, t);
            return e.map((e) => {
              var t;
              if (!("user_id" in e)) return e;
              const { lastLoginAt: s, userProperties: i } =
                  null !== (t = r[e.user_id]) && void 0 !== t ? t : {},
                o = {
                  timestamp: new Date(n).toISOString(),
                  version: this.opts.config.version,
                };
              return (
                s && (o.sessionElapsedTime = n - s),
                {
                  ...e,
                  event_properties: { ...o, ...e.event_properties },
                  user_properties: { ...i, ...e.user_properties },
                }
              );
            });
          } catch (a_) {
            return (
              await this.opts.errorReporter.captureException(
                new nl(
                  "Resolving analytics extra properties failed: " + a_.message,
                  "server_error",
                  "analytics_extra_properties_error",
                  void 0,
                  { events: e, cause: a_ }
                )
              ),
              e
            );
          }
        }
        async getExtraPropsPerReceiver(e, t) {
          const n = Array.from(
              new Set(
                e
                  .map((e) => ("user_id" in e ? e.user_id : ""))
                  .filter((e) => !!e)
              )
            ),
            r = {};
          await Promise.all(
            n.map(async (e) => {
              const { entryPromises: n } =
                null !== t && void 0 !== t ? t : { entryPromises: {} };
              n[e] ||
                (n[e] = this.opts
                  .getReadOnlyEntry(e, { skipWrites: !0 })
                  .then((e) => {
                    var t;
                    return null !==
                      (t = null === e || void 0 === e ? void 0 : e.entry) &&
                      void 0 !== t
                      ? t
                      : null;
                  }));
              const s = await n[e];
              s && (r[e] = s);
            })
          );
          const s = {},
            i = this.opts.dateNow(),
            o = { date: { now: () => i } };
          for (const u of n) {
            const e = r[u];
            var a, c, l;
            if (e)
              s[u] = {
                lastLoginAt: e.lastLoginAt,
                userProperties:
                  null !==
                    (a =
                      null ===
                        (c = (l = this.opts.config)
                          .getReceiverUserProperties) || void 0 === c
                        ? void 0
                        : c.call(l, e.state, o)) && void 0 !== a
                    ? a
                    : {},
              };
          }
          return s;
        }
      }
      class kg {
        constructor(e) {
          (this.opts = e),
            (this.sendAndroidPushNotification = async (e) => {
              const {
                receiverId: t,
                androidDeviceToken: n,
                notification: r,
                payload: s,
                analyticsEventProperties: i,
                analyticsUserProperties: o,
                userSessionId: a,
              } = e;
              let c, l;
              try {
                const e = await this.opts.postFirebaseCloudMessage(n, r, s);
                (c = e.success),
                  c
                    ? await this.opts.db.chatbot.updateTimeLastTargetedByChannelMessage(
                        t,
                        "android",
                        this.opts.dateNow()
                      )
                    : (l = e.reason);
              } catch (a_) {
                (c = !1),
                  (l = a_.message),
                  this.opts.errorReporter &&
                    (await this.opts.errorReporter.captureException(
                      new nl(
                        l || "Sending firebase cloud message failed",
                        $c.server_error,
                        tl.push_notification_error,
                        "error"
                      )
                    ));
              }
              const u = [];
              if (c) {
                const e = {
                  user_id: t,
                  event_type: Ac,
                  event_properties: { ...i, platform: "ANDROID_APP" },
                  user_properties: o,
                  insert_id: Nc(t, a),
                };
                u.push(e);
              } else {
                const e = {
                  user_id: t,
                  event_type: Tc,
                  event_properties: {
                    ...i,
                    reason: l,
                    platform: "ANDROID_APP",
                  },
                  insert_id: Nc(t, a),
                };
                u.push(e),
                  l &&
                    [
                      "InvalidRegistration",
                      "NotRegistered",
                      "MismatchSenderId",
                    ].includes(l) &&
                    (await this.opts.db.chatbot.setAndroidDeviceToken(
                      t,
                      "",
                      0
                    ));
              }
              return (
                await this.opts.sendAnalyticsEvents(u),
                { success: c, reason: l }
              );
            });
        }
      }
      class Og {
        constructor(e) {
          var t;
          this.asyncGetters = {};
          const n =
              null !== (t = e.apiAccess.config.asyncGetters) && void 0 !== t
                ? t
                : {},
            r = {
              airtable: { getTable: (t) => e.apiAccess.airtable.getTable(t) },
              searchPlayers: (t) => e.apiAccess.searchPlayers(t),
              telegram: {
                getProfilePictureUrl: (e.telegramClient
                  ? Ol({
                      assetUploader: e.apiAccess.assetUploader,
                      fetcher: e.fetcher,
                      telegramClient: e.telegramClient,
                      userAssetsBaseUrl: e.userAssetsBaseUrl,
                    })
                  : xl()
                ).getProfilePictureUrl,
              },
              countPlayers: (t) => e.apiAccess.countPlayers(t),
              math: { random: () => Math.random() },
              kvStore: {
                get: function () {
                  return e.apiAccess.kvStore.get(...arguments);
                },
                getBatch: function () {
                  return e.apiAccess.kvStore.getBatch(...arguments);
                },
                send: function () {
                  return e.apiAccess.kvStore.send(...arguments);
                },
                sendBatch: function () {
                  return e.apiAccess.kvStore.sendBatch(...arguments);
                },
              },
              socialGraph: {
                getNonPlayers: (t) => e.apiAccess.socialGraph.getNonPlayers(t),
              },
              ai: { completeText: (t, n) => e.aiClient.textCompletion(t, n) },
            };
          function s(t) {
            return (s, i) => {
              var o;
              const {
                  consistentFetchIds: a,
                  getOwnEntry: c,
                  id: l,
                  reportError: u,
                  sendAnalyticsEvents: d,
                  sessionId: h,
                  clockOffset: p,
                  dateNow: f,
                } = i,
                m = {
                  now: () =>
                    (null !== f && void 0 !== f ? f : e.dateNow)() + (p || 0),
                };
              let g;
              const v = () => {
                  var e;
                  return (g = null !== (e = g) && void 0 !== e ? e : c());
                },
                y = {
                  ...Ho(r),
                  chatbot: {
                    isSubscribed: async () => {
                      if ("line" !== e.apiAccess.platform)
                        throw Error(
                          "Operation is not supported on ".concat(
                            e.apiAccess.platform,
                            " platform"
                          )
                        );
                      try {
                        return await e.validateChatbotSubscription({
                          db: e.db,
                          invokeTime: m.now(),
                          userId: l,
                          entry: {},
                          isDev: !1,
                          sendChatbotMessage: () => {},
                          fetcher: e.fetcher,
                          sendAnalyticsEvents: e.sendAnalyticsEvents,
                        });
                      } catch (t) {
                        return u(t, { userId: l }), !1;
                      }
                    },
                  },
                  date: m,
                  getOwnPurchaseHistory: async () => {
                    var e;
                    return null !==
                      (e = (await v()).metainfo.purchaseHistory) && void 0 !== e
                      ? e
                      : [];
                  },
                  getOwnState: async () => (await v()).state,
                  getSessionID: () => h,
                  getSnapshots: () => e.db.snapshots.fetchSnapshots(l),
                  getUserID: () => l,
                  getUserAssetUrl: (t) => e.userAssetsBaseUrl + t,
                  fetch: (t) => e.fetcher.fetch(t),
                  fetchStates: (t) =>
                    e.apiAccess
                      .fetchStates(t, {
                        consistentFetchIds: a,
                        disablePagination: !0,
                      })
                      .then((e) => e.states),
                  payments: {
                    generateAtonePaymentChecksum: (t) => {
                      if (!e.atoneClient)
                        throw Error(
                          "Atone client is not configured. Make sure to define the ATONE_SECRET_KEY environment variable."
                        );
                      return e.atoneClient.generatePaymentChecksum(t);
                    },
                    getAtoneTransaction: async (t, n) => {
                      if (!e.atoneClient)
                        throw Error(
                          "Atone client is not configured. Make sure to define the ATONE_SECRET_KEY environment variable."
                        );
                      return e.atoneClient.getTransaction(t, n);
                    },
                    getCheckoutSessionStatus: async (t) => {
                      var n;
                      let { checkoutSessionId: r } = t;
                      if (!e.stripe)
                        throw Error("Not implemented in offline mode");
                      const s =
                        null === (n = (await v()).metainfo.payments) ||
                        void 0 === n
                          ? void 0
                          : n.customerId;
                      if (!s) throw Error("User has no Stripe customer ID");
                      const i = await e.stripe.getCheckoutSession({
                        checkoutSessionId: r,
                      });
                      if (!i) return null;
                      const { customer: o, payment_status: a, status: c } = i;
                      if (!o || "string" !== typeof o)
                        throw Error(
                          "Invalid customer in Stripe Checkout Session: " +
                            JSON.stringify(i)
                        );
                      if (o !== s) return null;
                      if (!c)
                        throw Error(
                          "Missing status in Stripe Checkout Session: " +
                            JSON.stringify(i)
                        );
                      if ("no_payment_required" === a)
                        throw Error(
                          "Invalid payment_status in Stripe Checkout session: " +
                            JSON.stringify(i)
                        );
                      return { paymentStatus: a, status: c };
                    },
                    getKomojuPayment: async (t) => {
                      if (!e.komojuClient)
                        throw Error(
                          "Komoju client is not configured. Make sure to define the KOMOJU_SECRET_KEY environment variable."
                        );
                      return e.komojuClient.getPayment(t);
                    },
                    getXsollaOrder: async (t) => {
                      let { token: n, orderId: r } = t;
                      if (!e.xsollaClient)
                        throw Error(
                          "Xsolla client is not configured. Make sure to define the XSOLLA_PROJECT_ID and XSOLLA_API_KEY environment variables."
                        );
                      try {
                        return await e.xsollaClient.getOrder({
                          token: n,
                          orderId: r,
                        });
                      } catch (s) {
                        return void u(s, { userId: l, orderId: r });
                      }
                    },
                    getPaymentStatus: async (t) => {
                      var n, r;
                      let { paymentIntentId: s, stripeAccountId: i } = t;
                      if (!e.stripe)
                        throw Error("Not implemented in offline mode");
                      const o = await e.stripe.getPaymentIntent({
                        expandPaymentMethod: !0,
                        paymentIntentId: s,
                        stripeAccountId: i,
                      });
                      if (!o) return null;
                      const a = o.payment_method;
                      if ("string" === typeof a)
                        throw Error("payment_method failed to expand");
                      return {
                        creditCardBrand:
                          null === a ||
                          void 0 === a ||
                          null === (n = a.card) ||
                          void 0 === n
                            ? void 0
                            : n.brand,
                        paymentMethod:
                          null === a || void 0 === a ? void 0 : a.type,
                        paymentStatus: o.status,
                        wallet:
                          null === a ||
                          void 0 === a ||
                          null === (r = a.card) ||
                          void 0 === r ||
                          null === (r = r.wallet) ||
                          void 0 === r
                            ? void 0
                            : r.type,
                      };
                    },
                  },
                  reportError: u,
                  sendAnalyticsEvents: d,
                  sharedStates: Object.keys(
                    null !== (o = e.apiAccess.config.sharedStates) &&
                      void 0 !== o
                      ? o
                      : {}
                  ).reduce((t, n) => {
                    const r = n;
                    return (
                      (t[r] = {
                        fetch: async (t) => {
                          const n = a.includes(t),
                            s = await e.apiAccess.sharedStates.fetchSharedState(
                              { consistentRead: n, stateName: r, stateId: t }
                            );
                          if (s) return { global: s.global, users: s.users };
                        },
                        count: (t) => e.apiAccess.countSharedStates(r, t),
                        search: (t) => e.apiAccess.searchSharedStates(r, t),
                      }),
                      t
                    );
                  }, {}),
                  abTests: {
                    getBucketID: async (t) => {
                      var n, r;
                      const [{ metainfo: s }, { abTests: i }] =
                        await Promise.all([
                          v(),
                          e.apiAccess.abTests.getDynamicConfig(),
                        ]);
                      return new yl({
                        abTests:
                          null !==
                            (n =
                              null === (r = e.apiAccess.config.ruleset) ||
                              void 0 === r
                                ? void 0
                                : r.abTests) && void 0 !== n
                            ? n
                            : {},
                        dynamicConfig: i,
                      }).getBucketID(s, t);
                    },
                  },
                },
                b = Zm(),
                w = Ko(n, t);
              if (!w)
                throw Error(
                  "Async getter not found in configuration: ".concat(t)
                );
              if (b) {
                const e = { name: t, type: "asyncGetter", userId: l };
                Xm(y, e);
                return Qm(w, e)(s, y);
              }
              return w(s, y);
            };
          }
          for (const i in n) {
            const e = n[i];
            if ("function" === typeof e) this.asyncGetters[i] = s(i);
            else {
              const t = {};
              for (const n in e) t[n] = s("".concat(i, ".").concat(n));
              this.asyncGetters[i] = t;
            }
          }
        }
      }
      const xg = "onGameEnd";
      class Ng {
        constructor(e) {
          (this.opts = e),
            (this.sendInstagramChatbotMessage = async (e) => {
              if (!this.opts.instagramClient)
                throw Error(
                  "Instagram client not configured. Make sure to set the INSTAGRAM_PAGE_* environment variables."
                );
              const t = e.message.renderers.instagram;
              if (!t)
                throw Error(
                  "No instagram renderer in message template ".concat(
                    e.message.name
                  )
                );
              const n = await this.db.chatbot.fetchMetainfo(e.receiverId),
                r = e.commentId
                  ? { commentId: e.commentId }
                  : null !== n && void 0 !== n && n.instagramMessengerId
                  ? { userId: n.instagramMessengerId }
                  : void 0;
              if (!r)
                return void Xl.warn(
                  "Skipping message send: receiver instagramMessengerId is not set"
                );
              const s = t({
                  args: e.message.args,
                  payload: {
                    timestamp: this.opts.dateNow(),
                    ...e.message.payload,
                  },
                  api: this.getChatbotRendererAPI(e.receiverId, e.senderId),
                }),
                i = await this.opts.instagramClient.postMessages({
                  receiver: r,
                  body: s,
                });
              if (i.ok) {
                const t = {
                  user_id: e.receiverId,
                  event_type: _c,
                  event_properties: {
                    platform: "instagram",
                    template: e.message.name,
                    ...e.message.payload,
                  },
                  user_properties: e.message.analyticsUserProperties,
                };
                await Promise.all([
                  this.opts.sendAnalyticsEvents([t]),
                  await this.db.chatbot
                    .setLastReceivedMessagePayload(e.receiverId, {
                      timestamp: this.opts.dateNow(),
                      ...e.message.payload,
                    })
                    .catch((e) => {
                      var t;
                      return null === (t = this.opts.errorReporter) ||
                        void 0 === t
                        ? void 0
                        : t.captureException(e);
                    }),
                ]);
              } else {
                var o;
                const t = {
                    user_id: e.receiverId,
                    event_type: Ec,
                    event_properties: {
                      platform: "instagram",
                      template: e.message.name,
                      ...e.message.payload,
                      ...i,
                    },
                    user_properties: e.message.analyticsUserProperties,
                  },
                  r = new nl(
                    "Instagram chatbot message send failed: ".concat(
                      i.body || "request error"
                    ),
                    "server_error",
                    "chatbot_send_error",
                    "error",
                    {
                      receiverChatbotMetainfo: n,
                      receiverId: e.receiverId,
                      templateArgs: e.message.args,
                      templateName: e.message.name,
                      ...i,
                    }
                  );
                await Promise.all([
                  this.opts.sendAnalyticsEvents([t]),
                  null === (o = this.opts.errorReporter) || void 0 === o
                    ? void 0
                    : o.captureException(r),
                ]);
              }
            }),
            (this.sendMessengerChatbotMessage = async (e) => {
              let { message: t, receiverId: n, senderId: r } = e;
              const s = t.renderers.facebook;
              if (!s)
                throw Error(
                  "No facebook renderer in message template ".concat(t.name)
                );
              const i = await this.db.chatbot.fetchMetainfo(n);
              if (null === i || void 0 === i || !i.messengerId)
                return void Xl.warn(
                  "Skipping message send: receiver messengerId is not set"
                );
              const o = s({
                  args: t.args,
                  payload: { timestamp: this.opts.dateNow(), ...t.payload },
                  api: this.getChatbotRendererAPI(n, r),
                }),
                a = await this.opts
                  .postFBMessage(i.messengerId, o)
                  .then((e) =>
                    e.statusCode < 200 || e.statusCode >= 300
                      ? { ok: !1, error: e.body }
                      : { ok: !0 }
                  )
                  .catch((e) => ({ ok: !1, error: e }));
              if (a.ok) {
                const e = {
                  user_id: n,
                  event_type: _c,
                  event_properties: {
                    platform: "messenger",
                    template: t.name,
                    ...t.payload,
                  },
                  user_properties: t.analyticsUserProperties,
                };
                await Promise.all([
                  this.opts.sendAnalyticsEvents([e]),
                  await this.db.chatbot
                    .setLastReceivedMessagePayload(n, {
                      timestamp: this.opts.dateNow(),
                      ...t.payload,
                    })
                    .catch((e) => {
                      var t;
                      return null === (t = this.opts.errorReporter) ||
                        void 0 === t
                        ? void 0
                        : t.captureException(e);
                    }),
                ]);
              } else {
                var c;
                const e = {
                    user_id: n,
                    event_type: Ec,
                    event_properties: {
                      platform: "messenger",
                      template: t.name,
                      ...t.payload,
                      ...a,
                    },
                    user_properties: t.analyticsUserProperties,
                  },
                  r = new nl(
                    "Messenger chatbot message send failed: ".concat(
                      a.error || "request error"
                    ),
                    "server_error",
                    "chatbot_send_error",
                    "error",
                    {
                      receiverChatbotMetainfo: i,
                      receiverId: n,
                      templateArgs: t.args,
                      templateName: t.name,
                      ...a,
                    }
                  );
                await Promise.all([
                  this.opts.sendAnalyticsEvents([e]),
                  null === (c = this.opts.errorReporter) || void 0 === c
                    ? void 0
                    : c.captureException(r),
                ]);
              }
            }),
            (this.sendTelegramChatbotMessage = async (e) => {
              if (!this.opts.telegramClient)
                throw Error(
                  "Telegram client not configured. Make sure to set the TELEGRAM_BOT_TOKEN environment variable."
                );
              const t = e.message.renderers.telegram;
              if (!t)
                throw Error(
                  "No telegram renderer in message template ".concat(
                    e.message.name
                  )
                );
              const n = await this.db.chatbot.fetchMetainfo(e.receiverId),
                r = t({
                  args: e.message.args,
                  payload: {
                    timestamp: this.opts.dateNow(),
                    ...e.message.payload,
                  },
                  api: this.getChatbotRendererAPI(e.receiverId, e.senderId),
                });
              try {
                await this.opts.telegramClient.sendMessage({
                  chatId: e.chatId,
                  message: r,
                  replyToMessageId: e.replyToMessageId,
                });
                const t = {
                  user_id: e.receiverId,
                  event_type: _c,
                  event_properties: {
                    platform: "telegram",
                    template: e.message.name,
                    ...e.message.payload,
                  },
                  user_properties: e.message.analyticsUserProperties,
                };
                await Promise.all([
                  this.opts.sendAnalyticsEvents([t]),
                  await this.db.chatbot
                    .setLastReceivedMessagePayload(e.receiverId, {
                      timestamp: this.opts.dateNow(),
                      ...e.message.payload,
                    })
                    .catch((e) => {
                      var t;
                      return null === (t = this.opts.errorReporter) ||
                        void 0 === t
                        ? void 0
                        : t.captureException(e);
                    }),
                ]);
              } catch (i) {
                var s;
                const t = {
                    user_id: e.receiverId,
                    event_type: Ec,
                    event_properties: {
                      error: i.message,
                      platform: "telegram",
                      template: e.message.name,
                      ...e.message.payload,
                    },
                    user_properties: e.message.analyticsUserProperties,
                  },
                  r = new nl(
                    "Telegram chatbot message send failed: ".concat(i.message),
                    "server_error",
                    "chatbot_send_error",
                    "error",
                    {
                      receiverChatbotMetainfo: n,
                      receiverId: e.receiverId,
                      templateArgs: e.message.args,
                      templateName: e.message.name,
                      reason: i,
                    }
                  );
                await Promise.all([
                  this.opts.sendAnalyticsEvents([t]),
                  null === (s = this.opts.errorReporter) || void 0 === s
                    ? void 0
                    : s.captureException(r),
                ]);
              }
            }),
            (this.db = e.db);
        }
        async sendRawChatbotMessage(e, t) {
          if ("fb" !== this.opts.platform)
            throw Error("Only supported by the Facebook platform");
          return this.opts.postFBMessage(e, t);
        }
        async sendChatbotMessage(e) {
          if (!["fb", "line", "zoom", "web"].includes(this.opts.platform))
            throw new nl(
              "Chatbot messages are not supported on platform " +
                this.opts.platform,
              "server_error",
              "invalid_platform",
              "fatal"
            );
          const { forceChannel: t, receiverId: n, senderId: r, message: s } = e;
          if (!n)
            throw new nl(
              "Receiver of chatbot message invalid: " + n,
              "server_error",
              "chatbot_missing_receiver",
              "fatal"
            );
          if (!r)
            throw new nl(
              "Sender of chatbot message invalid: " + r,
              "server_error",
              "chatbot_missing_sender",
              "fatal"
            );
          if (!this.opts.config.chatbot)
            throw new nl(
              "Chatbot not configured.",
              "server_error",
              "chatbot_missing_configuration",
              "fatal"
            );
          const i = await this.db.chatbot.fetchMetainfo(n);
          if (!i) {
            const e =
              "Receiver has not subscribed to the chatbot. See https://docs.dev.gc-internal.net/replicant/index.html#chatbot-integration.";
            return (
              Xl.info("Skipping message send:", e),
              { ok: !1, reason: e, channels: {} }
            );
          }
          if (!i.messengerId)
            switch (this.opts.platform) {
              case "line":
                i.messengerId = n;
                break;
              case "zoom":
                i.messengerId = i.email;
            }
          let o = !!i.appleDeviceToken;
          if (i.appleDeviceToken)
            if (i.appleDeviceTokenUpdatedAt)
              Nf(i.appleDeviceTokenUpdatedAt, this.opts.dateNow()) &&
                (Xl.info(
                  "Chatbot - Apple device token is considered expired for: ".concat(
                    n
                  )
                ),
                (o = !1));
            else {
              const e = this.opts.dateNow();
              Xl.info(
                "Chatbot - Apple device token update time being set for: "
                  .concat(n, " to ")
                  .concat(e)
              ),
                await this.db.chatbot.setAppleDeviceToken(
                  n,
                  i.appleDeviceToken,
                  e
                );
            }
          let a = !!i.androidDeviceToken;
          if (i.androidDeviceToken)
            if (i.androidDeviceTokenUpdatedAt)
              Rf(i.androidDeviceTokenUpdatedAt, this.opts.dateNow()) &&
                (Xl.info(
                  "Chatbot - Android device token is considered expired for: ".concat(
                    n
                  )
                ),
                (a = !1));
            else {
              const e = this.opts.dateNow();
              Xl.info(
                "Chatbot - Android device token update time being set for: "
                  .concat(n, " to ")
                  .concat(e)
              ),
                await this.db.chatbot.setAndroidDeviceToken(
                  n,
                  i.androidDeviceToken,
                  e
                );
            }
          const c =
              (null === i || void 0 === i ? void 0 : i.lastSessionId) ||
              "sessionid-" + yc(),
            l = {
              payload: { timestamp: this.opts.dateNow(), ...s.payload },
              message: s,
              receiverChatbotMetainfo: i,
              receiverId: n,
              senderId: r,
              sessionId: c,
            },
            u = {},
            d = [];
          if (
            (!o ||
              (t && "ios" !== t && "nativepush" !== t) ||
              (d[0] = this.sendActivePushNotification(l)),
            !a ||
              (t && "android" !== t && "nativepush" !== t) ||
              (d[1] = this.sendAndroidPushNotification(l)),
            d.length > 0)
          ) {
            const e = await Promise.all(d);
            if (e[0]) {
              const t = e[0];
              t.ok ? (u.ios = "ok") : (u.ios = t.reason);
            }
            if (e[1]) {
              const t = e[1];
              t.ok ? (u.android = "ok") : (u.android = t.reason);
            }
            if ("ok" === u.ios || "ok" === u.android)
              return { ok: !0, channels: u };
          }
          if (i.webPushSubscription && (!t || "webpush" === t)) {
            const e = await this.sendWebPushNotification(l);
            if (((u.webpush = e.ok ? "ok" : e.reason), e.ok))
              return { ok: !0, channels: u };
          }
          if (i.smsSubscribed && (!t || "sms" === t)) {
            const e = await this.sendSmsNotification(l);
            if (((u.sms = e.ok ? "ok" : e.reason), e.ok))
              return { ok: !0, channels: u };
          }
          if (i.messengerId && (!t || "chatbot" === t)) {
            const e = await this.sendPlatformChatbotMessage(l);
            if (e.ok) return (u.chatbot = "ok"), { ok: !0, channels: u };
            u.chatbot = e.reason;
          }
          const h =
            Object.values(u).length > 0
              ? "All delivery channels failed"
              : "Skipping message, no delivery channel available for receiver";
          return (
            Xl.warn("Chatbot message send failed:", h, u, l),
            { ok: !1, reason: h, channels: u }
          );
        }
        async sendLineChatbotMessage(e) {
          if (!["line"].includes(this.opts.platform))
            throw new nl(
              "LINE messages are not supported on platform " +
                this.opts.platform,
              "server_error",
              "invalid_platform",
              "fatal"
            );
          const { receiverId: t, senderId: n, message: r, type: s } = e;
          if (!t)
            throw new nl(
              "Receiver of chatbot message invalid: " + t,
              "server_error",
              "chatbot_missing_receiver",
              "fatal"
            );
          if (!n)
            throw new nl(
              "Sender of chatbot message invalid: " + n,
              "server_error",
              "chatbot_missing_sender",
              "fatal"
            );
          if (!this.opts.config.chatbot)
            throw new nl(
              "Chatbot not configured.",
              "server_error",
              "chatbot_missing_configuration",
              "fatal"
            );
          const i = await this.db.chatbot.fetchMetainfo(t);
          if (!i) {
            const e =
              "Receiver has not subscribed to the chatbot. See https://docs.dev.gc-internal.net/replicant/index.html#chatbot-integration.";
            return Xl.info("Skipping message send:", e), { ok: !1, reason: e };
          }
          i.messengerId || (i.messengerId = t);
          const o =
              (null === i || void 0 === i ? void 0 : i.lastSessionId) ||
              "sessionid-" + yc(),
            a =
              "push" === s
                ? {
                    type: s,
                    receiverChatbotMetainfo: i,
                    receiverId: t,
                    senderId: n,
                    message: r,
                    payload: { timestamp: this.opts.dateNow(), ...r.payload },
                    sessionId: o,
                    sendMessageToLine: e.sendMessageToLine,
                  }
                : "reply" === s
                ? {
                    type: s,
                    replyToken: e.replyToken,
                    receiverChatbotMetainfo: i,
                    receiverId: t,
                    senderId: n,
                    message: r,
                    payload: { timestamp: this.opts.dateNow(), ...r.payload },
                    sessionId: o,
                    sendMessageToLine: e.sendMessageToLine,
                  }
                : wc(s);
          if (i.messengerId) {
            if ((await this.sendLinePlatformChatbotMessage(a)).ok)
              return { ok: !0 };
          }
          const c =
            "Skipping message, no delivery channel available for receiver";
          return (
            Xl.warn("Chatbot message send failed:", c, a), { ok: !1, reason: c }
          );
        }
        async sendWebPushNotification(e) {
          const t = e.receiverChatbotMetainfo.webPushSubscription;
          if (!t) return { ok: !1, reason: "Web Push not subscribed" };
          const n = e.message.renderers.webpush;
          if (!n) return { ok: !1, reason: "Web Push renderer not found" };
          const r = n({
            args: e.message.args,
            payload: e.payload,
            api: this.getChatbotRendererAPI(e.receiverId, e.senderId),
          });
          try {
            await this.opts.webPushClient.sendNotification(t, r);
          } catch (o) {
            const t = {
              user_id: e.receiverId,
              event_type: "WebPushNotificationFailure",
              event_properties: {
                template: e.message.name,
                error: o,
                ...e.payload,
              },
              insert_id: Nc(e.receiverId, e.sessionId),
            };
            var s;
            if ((await this.opts.sendAnalyticsEvents([t]), o instanceof Error))
              await (null === (s = this.opts.errorReporter) || void 0 === s
                ? void 0
                : s.captureException(
                    o,
                    { user: { id: e.senderId } },
                    { data: r, receiverId: e.receiverId }
                  ));
            return { ok: !1, reason: "".concat(o) };
          }
          const i = {
            user_id: e.receiverId,
            event_type: "WebPushNotificationSuccess",
            event_properties: { template: e.message.name, ...e.payload },
            user_properties: e.message.analyticsUserProperties,
            insert_id: Nc(e.receiverId, e.sessionId),
          };
          return await this.opts.sendAnalyticsEvents([i]), { ok: !0 };
        }
        async sendSmsNotification(e) {
          if (!e.receiverChatbotMetainfo.smsSubscribed)
            return { ok: !1, reason: "SMS not subscribed" };
          const t = await this.db.accountLink.getPhoneNumber(e.receiverId),
            n = e.message.renderers.sms;
          if (!t)
            throw new Error(
              "Receiver is subscribed to SMS but no valid phone number found"
            );
          return n
            ? (await this.opts.twilioClient.sendSms({
                receiver: t,
                body: n({
                  args: e.message.args,
                  payload: e.payload,
                  api: this.getChatbotRendererAPI(e.receiverId, e.senderId),
                }),
              }),
              { ok: !0 })
            : { ok: !1, reason: "SMS renderer not found" };
        }
        async sendActivePushNotification(e) {
          const t = e.message.renderers.ios;
          if (!t) return { ok: !1, reason: "iOS renderer not found" };
          const {
              receiverChatbotMetainfo: n,
              receiverId: r,
              senderId: s,
              message: i,
              payload: o,
              sessionId: a,
            } = e,
            c = n.appleDeviceToken,
            l = t({
              args: i.args,
              payload: o,
              api: this.getChatbotRendererAPI(r, s),
            }),
            u = await this.opts.sendIOSPushNotification({
              receiverId: r,
              rawPayload: l,
              userSessionId: a,
              appleDeviceToken: c,
              analyticsEventProperties: { ...o, template: i.name },
              analyticsUserProperties: i.analyticsUserProperties,
            });
          return {
            ok: u.success,
            reason: u.reason || "Sending iOS push notification failed",
          };
        }
        async sendAndroidPushNotification(e) {
          const t = e.message.renderers.android;
          if (!t) return { ok: !1, reason: "Android renderer not found" };
          const {
              receiverChatbotMetainfo: n,
              receiverId: r,
              senderId: s,
              message: i,
              payload: o,
              sessionId: a,
            } = e,
            c = n.androidDeviceToken,
            { notification: l, payload: u } = t({
              args: i.args,
              payload: o,
              api: this.getChatbotRendererAPI(r, s),
            }),
            d = await this.opts.sendAndroidPushNotification({
              receiverId: r,
              androidDeviceToken: c,
              notification: l,
              payload: u,
              userSessionId: a,
              analyticsEventProperties: { ...o, template: i.name },
              analyticsUserProperties: i.analyticsUserProperties,
            });
          return {
            ok: d.success,
            reason: d.reason || "Sending Android push notification failed",
          };
        }
        async sendPlatformChatbotMessage(e) {
          var t, n;
          let r, s;
          switch (this.opts.platform) {
            case "fb":
              (r = this.opts.postFBMessage), (s = "facebook");
              break;
            case "line":
              (r = this.opts.postLineMessage), (s = "line");
              break;
            case "zoom":
              (r = this.opts.postZoomMessage), (s = "zoom");
              break;
            default:
              return {
                ok: !1,
                reason: "Platform ".concat(
                  this.opts.platform,
                  " does not support a platform chatbot"
                ),
              };
          }
          const i = e.message.renderers[s];
          if (!i)
            return {
              ok: !1,
              reason: "Renderer for platform ".concat(s, " not found"),
            };
          const {
            receiverChatbotMetainfo: o,
            senderId: a,
            receiverId: c,
            message: l,
            payload: u,
            sessionId: d,
          } = e;
          if (!o.messengerId) return { ok: !1, reason: "No messenger ID set" };
          if (!o.subscribed)
            return { ok: !1, reason: "User is not subscribed to chatbot" };
          const h = this.opts.dateNow();
          if (Rg(this.opts.platform)) {
            if (
              (o.messagesSinceLastSession || 0) >=
              this.opts.config.chatbot.opts.maxMessagesPerSession
            )
              return { ok: !1, reason: "Message quota exceeded" };
            const e = o.timeLastSessionEnded;
            if (
              void 0 !== e &&
              e <
                h -
                  Sc({
                    days: this.opts.config.chatbot.opts.maxDaysSinceLastSession,
                  })
            )
              return { ok: !1, reason: "Last session date is too old" };
          }
          const p = [],
            f = await (null ===
              (t = (n = this.opts.config).encodePlatformMessagePayload) ||
            void 0 === t
              ? void 0
              : t.call(
                  n,
                  u,
                  this.opts.createPayloadEncoderAPI({
                    userId: a,
                    receiverId: c,
                    sessionId: d,
                    delayedActions: p,
                  })
                ));
          await this.opts.resolveDelayedActions(p);
          const m = i({
              args: l.args,
              payload: null !== f && void 0 !== f ? f : u,
              api: this.getChatbotRendererAPI(c, a),
            }),
            g = await r(o.messengerId, m).catch((e) => ({ error: e }));
          if ("error" in g || g.statusCode < 200 || g.statusCode >= 300) {
            let e;
            if ("body" in g)
              try {
                e = JSON.parse(g.body);
              } catch {}
            const t = {
              user_id: c,
              event_type: Ec,
              event_properties: {
                requestMs: "requestMs" in g ? g.requestMs : void 0,
                requestTries: "requestTries" in g ? g.requestTries : void 0,
                template: l.name,
                ...u,
                ...("error" in g
                  ? { error: g.error.message || g.error }
                  : {
                      response: {
                        body: e || g.body,
                        status_code: g.statusCode,
                      },
                    }),
              },
              insert_id: Nc(c, d),
            };
            return (
              "fb" === this.opts.platform &&
                (t.event_properties.messagesSinceLastSession =
                  o.messagesSinceLastSession || 0),
              await Promise.all([
                this.opts.sendAnalyticsEvents([t]),
                this.reportPlatformAPIError({
                  analyticsPayload: m,
                  error: "error" in g ? g.error : e || g.body,
                  receiverChatbotMetainfo: o,
                  receiverId: c,
                  templateName: l.name,
                }),
              ]),
              {
                ok: !1,
                reason:
                  "error" in g
                    ? g.error.message || g.error
                    : g.body || g.statusCode + "",
              }
            );
          }
          const v = {
            user_id: c,
            event_type: _c,
            event_properties: {
              requestMs: g.requestMs,
              requestTries: g.requestTries,
              template: l.name,
              ...u,
            },
            user_properties: l.analyticsUserProperties,
            insert_id: Nc(c, d),
          };
          return (
            "fb" === this.opts.platform &&
              (v.event_properties.messagesSinceLastSession =
                (o.messagesSinceLastSession || 0) + 1),
            await Promise.all([
              this.opts.sendAnalyticsEvents([v]),
              this.db.chatbot
                .setLastReceivedMessagePayload(c, u)
                .then(async () => {
                  "fb" === this.opts.platform &&
                    (await this.db.chatbot.markMessageSent(c, h));
                })
                .catch((e) => {
                  var t;
                  return null === (t = this.opts.errorReporter) || void 0 === t
                    ? void 0
                    : t.captureException(e);
                }),
            ]),
            { ok: !0 }
          );
        }
        async sendLinePlatformChatbotMessage(e) {
          var t, n;
          if ("line" !== this.opts.platform)
            throw new nl(
              "Chatbot message batching is not supported on platform " +
                this.opts.platform,
              "server_error",
              "invalid_platform",
              "fatal"
            );
          const {
            receiverChatbotMetainfo: r,
            receiverId: s,
            senderId: i,
            sessionId: o,
            message: a,
            payload: c,
            type: l,
          } = e;
          if (!a.renderers.line)
            return {
              ok: !1,
              reason: "Renderer for platform ".concat(
                this.opts.platform,
                " not found"
              ),
            };
          if (!r.messengerId) return { ok: !1, reason: "No messenger ID set" };
          if (!r.subscribed)
            return { ok: !1, reason: "User is not subscribed to chatbot" };
          const u = [],
            d = this.opts.createPayloadEncoderAPI({
              userId: i,
              receiverId: s,
              sessionId: o,
              delayedActions: u,
            }),
            h = await (null ===
              (t = (n = this.opts.config).encodePlatformMessagePayload) ||
            void 0 === t
              ? void 0
              : t.call(n, c, d));
          await this.opts.resolveDelayedActions(u);
          const p = a.renderers.line({
              args: a.args,
              payload: null !== h && void 0 !== h ? h : c,
              api: this.getChatbotRendererAPI(s, i),
            }),
            f =
              "push" === l
                ? e.sendMessageToLine({
                    type: "push",
                    userId: e.receiverId,
                    message: p,
                  })
                : "reply" === l
                ? e.sendMessageToLine({
                    type: "reply",
                    replyToken: e.replyToken,
                    message: p,
                  })
                : wc(l),
            m = await f.catch((e) => ({ error: e }));
          if ("error" in m || m.statusCode < 200 || m.statusCode >= 300) {
            let e;
            if ("body" in m)
              try {
                e = JSON.parse(m.body);
              } catch {}
            const t = {
              user_id: s,
              event_type: Ec,
              event_properties: {
                requestMs: "requestMs" in m ? m.requestMs : void 0,
                requestTries: "requestTries" in m ? m.requestTries : void 0,
                template: a.name,
                ...c,
                ...("error" in m
                  ? { error: m.error.message || m.error }
                  : {
                      response: {
                        body: e || m.body,
                        status_code: m.statusCode,
                      },
                    }),
              },
              insert_id: Nc(s, o),
            };
            return (
              await Promise.all([
                this.opts.sendAnalyticsEvents([t]),
                this.reportPlatformAPIError({
                  analyticsPayload: c,
                  error: "error" in m ? m.error : e || m.body,
                  receiverChatbotMetainfo: r,
                  receiverId: s,
                  templateName: a.name,
                }),
              ]),
              {
                ok: !1,
                reason:
                  "error" in m
                    ? m.error.message || m.error
                    : m.body || m.statusCode + "",
              }
            );
          }
          const g = {
            user_id: s,
            event_type: _c,
            event_properties: {
              requestMs: m.requestMs,
              requestTries: m.requestTries,
              template: a.name,
              ...c,
            },
            user_properties: undefined,
            insert_id: Nc(s, o),
          };
          return (
            await Promise.all([
              this.opts.sendAnalyticsEvents([g]),
              this.db.chatbot.setLastReceivedMessagePayload(s, c).catch((e) => {
                var t;
                return null === (t = this.opts.errorReporter) || void 0 === t
                  ? void 0
                  : t.captureException(e);
              }),
            ]),
            { ok: !0 }
          );
        }
        async reportPlatformAPIError(e) {
          var t;
          if (!this.opts.errorReporter) return;
          const {
              analyticsPayload: n,
              receiverChatbotMetainfo: r,
              receiverId: s,
              templateName: i,
            } = e,
            o = r.timeLastSessionEnded,
            a = o ? Math.floor((this.opts.dateNow() - o) / 1e3) : 0;
          let c = e.error;
          if ("fb" === this.opts.platform) {
            const e = "object" === typeof c && "error" in c ? c.error : void 0;
            if (e) {
              c = e;
              const t = Number(e.code),
                n = Number(e.error_subcode);
              if (void 0 === e.code || 1 === t || -1 === t) return;
              if (
                !{
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.LOG_VERBOSE_CHATBOT_ERRORS &&
                ((10 === t && 2018108 === n) ||
                  (10 === t && 2018278 === n) ||
                  (100 === t && 2018144 === n) ||
                  (200 === t && 1545041 === n) ||
                  (551 === t && 1545041 === n) ||
                  (613 === t && 2018144 === n))
              )
                return;
            }
          }
          const l =
            "string" === typeof c
              ? c
              : null === (t = c) || void 0 === t
              ? void 0
              : t.message;
          await this.opts.errorReporter.captureException(
            new nl(
              "Platform chatbot message send failed: " +
                (l || "unknown platform error"),
              "server_error",
              "chatbot_send_error",
              "error",
              {
                analyticsPayload: JSON.stringify(n),
                secondsSinceLastSession: a,
                receiverId: s,
                receiverChatbotMetainfo: r,
                templateName: i,
                ...("object" === typeof c ? c : void 0),
              }
            )
          );
        }
        getChatbotRendererAPI(e, t) {
          const n = this.opts.config.chatbot;
          return {
            getAssetPath: (e) => {
              if (!n || !n.assets)
                throw new nl(
                  "Chatbot assets not configured.",
                  "server_error",
                  "chatbot_missing_configuration",
                  "fatal"
                );
              if (!n.assets[e])
                throw new nl(
                  "Asset " + e.toString() + " not found.",
                  "server_error",
                  "chatbot_missing_asset",
                  "fatal"
                );
              if (!this.opts.chatbotAssetUrls[e])
                throw new nl(
                  "No entry for " + e.toString() + " in chatbotAssetUrls",
                  "server_error",
                  "chatbot_missing_asset_url",
                  "fatal"
                );
              return this.opts.chatbotAssetUrls[e];
            },
            getSenderID: () => t,
            getReceiverID: () => e,
            getUserAssetUrl: (e) => this.opts.userAssetsBaseUrl + e,
          };
        }
      }
      function Rg(e) {
        return "fb" === e;
      }
      function Dg(e, t) {
        var n;
        const r =
          null !== (n = e.metainfo.abTestAssignments) && void 0 !== n ? n : {};
        e.metainfo.abTestAssignments = {};
        for (const i in t.newAssignments) {
          const n = t.newAssignments[i],
            s = r[i];
          if (
            !n.newUsersOnly ||
            t.isNewUser ||
            (null !== s && void 0 !== s && s.newUsersOnly)
          )
            switch (n.type) {
              case "automatic":
                s && "automatic" !== s.type
                  ? (e.metainfo.abTestAssignments[i] = s)
                  : n.isByUserList
                  ? (e.metainfo.abTestAssignments[i] = n)
                  : (e.metainfo.abTestAssignments[i] =
                      null !== s && void 0 !== s ? s : n);
                break;
              case "manual-active":
              case "manual-inactive":
                "automatic" ===
                  (null === s || void 0 === s ? void 0 : s.type) &&
                  (e.metainfo.abTestAssignments[i] = s);
            }
        }
        for (const i in r) {
          var s;
          if (e.metainfo.abTestAssignments[i]) continue;
          const n = r[i],
            o = null === (s = t.newAssignments) || void 0 === s ? void 0 : s[i];
          "stopped" !== (null === o || void 0 === o ? void 0 : o.type)
            ? "automatic" !== n.type &&
              void 0 !== o &&
              (e.metainfo.abTestAssignments[i] = {
                ...n,
                type: "manual-inactive",
              })
            : (e.metainfo.abTestAssignments[i] = n);
        }
      }
      class Mg {
        constructor(e) {
          (this.opts = e), (this.config = e.config), (this.db = e.db);
        }
        async createOrLogin(e) {
          const {
            clientAppName: t,
            entry: n,
            getAbTestAssignments: r,
            id: s,
            sessionId: i,
            sessionName: o,
          } = e;
          return n
            ? this.login({
                id: s,
                getAbTestAssignments: r,
                sessionId: i,
                sessionName: o,
                entry: n,
              })
            : this.createUser({
                clientAppName: t,
                getAbTestAssignments: r,
                id: s,
                sessionId: i,
                sessionName: o,
              });
        }
        async login(e) {
          var t;
          const {
              getAbTestAssignments: n,
              id: r,
              sessionId: s,
              sessionName: i,
              entry: o,
            } = e,
            a = this.config.migrator.getLatestVersion();
          if (o.version > a)
            throw new nl(
              "Unknown schema version: " + o.version + ", latest is: " + a,
              $c.version_error
            );
          let c;
          try {
            c = Bm(this.config, o);
          } catch (m) {
            if (this.opts.isInitialDevelopment())
              return (
                Xl.info(
                  "Validation error on state: " +
                    m +
                    "\nSince we are running in initial development mode, nuke and re-create the user."
                ),
                await this.db.delete(r),
                this.createUser({ id: r, sessionId: s })
              );
            throw new nl(m, "replication_error", "user_login_error");
          }
          const l = c.entry,
            u = await (null === n || void 0 === n
              ? void 0
              : n({ isNewUser: !1, userId: r, entry: l }));
          u &&
            Dg(l, { newAssignments: u, isNewUser: !l.metainfo.lastSessionId });
          const d = this.opts.dateNow();
          l.lastLoginAt = d;
          const h = c.snapshot();
          h.entry.rev++,
            (h.entry.metainfo.lastSessionId = s),
            (h.entry.metainfo.lastSessionName = i);
          const p = ng({ entry: h.entry, now: d });
          if (!$l(l)) {
            const e = Object.values(l.userSharedStates).flatMap((e) =>
              Object.values(e)
            );
            await this.db.sharedStates.migrateLegacyUserSharedStates(e);
          }
          await this.db.writeEntryOrEntryDiff({
            diff: h.diff,
            entry: h.entry,
            oldEntryDiffs: [],
            recoverySnapshotUpdate: p,
            userId: r,
          }),
            await this.opts.writeChangeset({
              id: r,
              entry: h.entry,
              replication: { queue: [], results: [] },
              messages: [],
              diff: h.diff,
              snapshotUpdate: p,
            });
          const f = this.opts.migrateUserSharedStates(l.userSharedStates);
          return (
            f && (await f()),
            Rg(this.opts.platform) &&
              null !== (t = l.chatbotMetainfo) &&
              void 0 !== t &&
              t.messengerId &&
              (l.chatbotMetainfo = await this.db.chatbot.resetMessagingSession(
                r,
                d
              )),
            (l.rev = h.entry.rev),
            (l.mainItemRev = h.entry.mainItemRev),
            (l.metainfo = h.entry.metainfo),
            l
          );
        }
        async createUser(e) {
          const {
              clientAppName: t,
              getAbTestAssignments: n,
              id: r,
              sessionId: s,
              sessionName: i,
            } = e,
            o = this.config.stateSchema.getDefault(),
            a = this.opts.dateNow(),
            c = {
              state: o,
              version: this.config.migrator.getLatestVersion(),
              rev: 0,
              mainItemRev: 0,
              metainfo: {
                clientAppName: t,
                lastSessionName: i,
                random: { n: 0 },
              },
              metainfoMVCC: {},
              lastUpdated: a,
              createdAt: a,
              userSharedStates: {},
            };
          s && (c.lastLoginAt = a);
          const l = await (null === n || void 0 === n
            ? void 0
            : n({ isNewUser: !0, userId: r, entry: c }));
          return (
            l &&
              (Dg(c, { newAssignments: l, isNewUser: !0 }),
              (c.metainfo.lastSessionId = s)),
            await this.db.write(r, c, { noOverwrite: !0 }),
            c
          );
        }
      }
      const jg = Sc({ days: 1 });
      class Lg {
        constructor(e) {
          (this.opts = e), (this.cache = null);
        }
        async getECPM(e) {
          var t, n;
          if (!this.cache || this.cache.timestamp + jg < this.opts.dateNow())
            try {
              const e = await this.opts.db.ecpm.get();
              e &&
                (!this.cache || e.timestamp > this.cache.timestamp) &&
                (this.cache = e);
            } catch {}
          return null !==
            (t =
              null === (n = this.cache) ||
              void 0 === n ||
              null === (n = n.values) ||
              void 0 === n
                ? void 0
                : n[e]) && void 0 !== t
            ? t
            : {};
        }
      }
      const Ug = ["USD", "JPY"],
        Fg = _a.object({ rates: _a.map(_a.number()) });
      class Bg {
        constructor(e) {
          (this.opts = e), (this.cache = { timestamp: 0, rates: {} });
        }
        async getExchangeRates() {
          if (!this.getAccessKey()) return this.cache.rates;
          if (
            (this.opts.devOpts.disableExchangeRatesLocalCache &&
              (this.cache = { timestamp: 0, rates: {} }),
            this.isCacheOutdated())
          )
            try {
              await this.updateCacheFromDB();
              const e = Math.floor(Math.random() * Sc({ minutes: 10 }));
              this.isCacheOutdated(e) && (await this.updateCacheFromAPI());
            } catch (a_) {
              var e;
              await (null === (e = this.opts.devOpts.errorReporter) ||
              void 0 === e
                ? void 0
                : e.captureException(a_));
            }
          return this.cache.rates;
        }
        isCacheOutdated() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
          return (
            this.cache.timestamp + e + Sc({ days: 1 }) <
            this.opts.devOpts.dateNow()
          );
        }
        async updateCacheFromDB() {
          this.cache = await this.opts.db.exchangeRates.get();
        }
        async updateCacheFromAPI() {
          (this.cache.timestamp += Sc({ minutes: 10 })),
            await this.opts.db.exchangeRates.setTimestamp(this.cache.timestamp);
          const e = {},
            t = Ug.map(async (t) => {
              const n = await (function (e, t) {
                  let n;
                  const r = new Promise((e, r) => {
                    n = setTimeout(() => r(new Error("Action timed out")), t);
                  });
                  return Promise.race([e, r]).then(
                    (e) => (clearTimeout(n), e),
                    (e) => (clearTimeout(n), Promise.reject(e))
                  );
                })(
                  this.opts.fetcher.fetch({
                    method: "GET",
                    url: "http://api.exchangeratesapi.io/v1/latest?access_key="
                      .concat(this.getAccessKey(), "&base=")
                      .concat(t),
                    headers: {},
                  }),
                  Sc({ seconds: 10 })
                ),
                r = JSON.parse(n.body);
              !(function (e) {
                Fg.tryValidate(e, { ignoreUnexpectedFields: !0 });
              })(r),
                (e[t] = r.rates);
            });
          await Promise.all(t),
            (this.cache = { timestamp: this.opts.devOpts.dateNow(), rates: e }),
            await this.opts.db.exchangeRates.set(this.cache);
        }
        getAccessKey() {
          try {
            return (
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.EXCHANGE_RATES_API_ACCESS_KEY || ""
            );
          } catch (a_) {
            return "";
          }
        }
      }
      class Vg {
        constructor(e) {
          (this.opts = e), (this.db = e.db);
        }
        async fetchStates(e, t) {
          if (0 === (e = Array.from(new Set(e.filter((e) => !!e)))).length)
            return { states: {} };
          if (this.opts.metrics) {
            const n = e.filter((e) => t.consistentFetchIds.includes(e)).length;
            n &&
              this.opts.metrics.pushCustomMetric(
                "fetchStates.consistentReadsCount",
                n
              );
            const r = e.length - n;
            r &&
              this.opts.metrics.pushCustomMetric(
                "fetchStates.inconsistentReadsCount",
                r
              );
          }
          const n = {},
            r = await Promise.all(
              e.map((e) =>
                this.db
                  .fetch(e, {
                    consistentRead: t.consistentFetchIds.includes(e),
                  })
                  .catch(async (t) => {
                    const n = new nl(
                      "Fetching state error for ".concat(e, ": ").concat(t),
                      "server_error",
                      "db_error"
                    );
                    return (
                      (n.stack = t.stack),
                      await this.opts.errorReporter.captureException(n),
                      { error: t }
                    );
                  })
              )
            );
          for (let l = 0; l < e.length; l++) {
            var s, i;
            const u = e[l],
              d = r[l];
            if ("error" in d) continue;
            let h,
              p,
              f = [];
            if (d.entry) (h = d.entry), (f = d.entryDiffs), (p = d.messages);
            else {
              if (null !== t && void 0 !== t && t.disableDefaultEntryCreation)
                continue;
              try {
                (h = await this.opts.createUser(u)), (p = []);
              } catch (a_) {
                await this.opts.errorReporter.captureException(a_);
                continue;
              }
            }
            if (p.length >= this.opts.reduceStaleStatesMinMessages) {
              Xl.warn(
                "Friend " +
                  u +
                  " has more than " +
                  this.opts.reduceStaleStatesMinMessages +
                  " messages"
              );
              const e = this.opts.dateNow(),
                t = this.opts.reduceStateMaxMessageThreshold < p.length,
                n = {
                  friendId: u,
                  diffJSONLength: void 0,
                  reducedMessagesCount: void 0,
                  reducedMessagesJSONLength: void 0,
                };
              if (
                h.lastUpdated <
                  e - this.opts.reduceStaleStatesMinTimeSinceLastUpdate ||
                t
              )
                try {
                  const {
                    virtual: e,
                    reducedMessages: r,
                    unreducedMessages: s,
                  } = this.opts.migrateAndApplyMessages(u, h, p);
                  (h = e.entry),
                    t &&
                      (await this.opts.errorReporter.captureException(
                        new nl(
                          "User received a high number of messages, forcing message reduction",
                          "server_error",
                          "exceeded_message_reduction_threshold",
                          "warning"
                        ),
                        void 0,
                        n
                      )),
                    (p = []),
                    h.rev++;
                  const i = ng({ entry: h, now: this.opts.dateNow() });
                  Ll(this.opts.dateNow(), h.metainfo, r);
                  const o = e.snapshot();
                  if (
                    ((h = o.entry),
                    (n.reducedMessagesCount = r.length),
                    (n.reducedMessagesJSONLength = JSON.stringify(r).length),
                    (n.diffJSONLength = JSON.stringify(o.diff).length),
                    !$l(h))
                  ) {
                    const e = Object.values(h.userSharedStates).flatMap((e) =>
                      Object.values(e)
                    );
                    await this.db.sharedStates.migrateLegacyUserSharedStates(e);
                  }
                  await this.db.writeEntryOrEntryDiff({
                    diff: o.diff,
                    entry: h,
                    oldEntryDiffs: f,
                    recoverySnapshotUpdate: i,
                    userId: u,
                  }),
                    await Promise.all([
                      this.opts.writeChangeset({
                        id: u,
                        entry: h,
                        replication: { queue: [], results: [] },
                        messages: r,
                        diff: o.diff,
                        snapshotUpdate: i,
                      }),
                      this.db.deleteMessages(
                        u,
                        r.concat(Ml(this.opts.dateNow(), s))
                      ),
                    ]),
                    Xl.info(
                      "fetchStates: Reduced " +
                        r.length +
                        " messages for stale state " +
                        u
                    );
                } catch (a_) {
                  a_ instanceof Zl ||
                    ("string" ===
                      typeof (null === a_ || void 0 === a_
                        ? void 0
                        : a_.message) &&
                      (a_.message =
                        "Friend state reduction failed: " + a_.message),
                    await this.opts.errorReporter.captureException(
                      a_,
                      void 0,
                      n
                    ));
                }
            }
            const m =
                !(
                  null === (s = h.chatbotMetainfo) ||
                  void 0 === s ||
                  !s.appleDeviceTokenUpdatedAt
                ) &&
                Nf(
                  h.chatbotMetainfo.appleDeviceTokenUpdatedAt,
                  this.opts.dateNow()
                ),
              g =
                !(
                  null === (i = h.chatbotMetainfo) ||
                  void 0 === i ||
                  !i.androidDeviceTokenUpdatedAt
                ) &&
                Rf(
                  h.chatbotMetainfo.androidDeviceTokenUpdatedAt,
                  this.opts.dateNow()
                ),
              v = qg(h, p);
            if (
              !t.friendRevs ||
              !(u in t.friendRevs) ||
              t.friendRevs[u] !== v
            ) {
              var o, a, c;
              const { virtual: e, inapplicableMessages: t } =
                this.opts.migrateAndApplyMessages(u, h, p);
              t.length > 0 && (await this.db.deleteMessages(u, t)),
                (h = e.entry),
                El(h.state, Tl(u, h), this.opts.config),
                (n[u] = {
                  state: h.state,
                  lastUpdated: h.lastUpdated,
                  createdAt: h.createdAt,
                  friendRev: v,
                  apnEnabled:
                    !(
                      null === (o = h.chatbotMetainfo) ||
                      void 0 === o ||
                      !o.appleDeviceToken
                    ) && !m,
                  fcmEnabled:
                    !(
                      null === (a = h.chatbotMetainfo) ||
                      void 0 === a ||
                      !a.androidDeviceToken
                    ) && !g,
                  chatbot: {
                    subscribed: !(
                      null === (c = h.chatbotMetainfo) ||
                      void 0 === c ||
                      !c.subscribed
                    ),
                  },
                  metainfo: { abTestAssignments: h.metainfo.abTestAssignments },
                  userSharedStates: h.userSharedStates,
                });
            }
          }
          return t.disablePagination
            ? { states: n }
            : (function (e) {
                const { allStates: t, gzipToBase64: n, maxSize: r } = e;
                if (n(JSON.stringify(t)).length < r) return { states: t };
                {
                  const e = Object.keys(t);
                  let s = 1,
                    i = e.length,
                    o = Math.floor((s + i) / 2),
                    a = e
                      .slice(0, o)
                      .reduce((e, n) => ({ ...e, [n]: t[n] }), {});
                  for (; o !== s && o !== i; ) {
                    n(JSON.stringify(a)).length > r
                      ? ((i = o), (o = Math.floor((s + o) / 2)))
                      : ((s = o), (o = Math.floor((o + i) / 2))),
                      (a = e
                        .slice(0, o)
                        .reduce((e, n) => ({ ...e, [n]: t[n] }), {}));
                  }
                  return { states: a, unprocessedIds: e.slice(o) };
                }
              })({
                allStates: n,
                gzipToBase64: this.opts.gzipToBase64,
                maxSize: 95e4,
              });
        }
      }
      function qg(e, t) {
        return 1e4 * e.rev + t.length;
      }
      class Hg {
        constructor(e) {
          this.opts = e;
        }
        async getBatch(e) {
          const t = await Promise.all(
              e.map((e) => this.opts.db.internalKvStore.fetch(e))
            ),
            n = {};
          return (
            e.forEach((e, r) => {
              const s = t[r];
              null !== s && void 0 !== s && (n[e] = s);
            }),
            n
          );
        }
        async get(e) {
          return (await this.getBatch([e]))[e] || null;
        }
        async sendBatch(e) {
          for (const t in e)
            if (!e[t] || "string" !== typeof e[t])
              throw new nl(
                "Invalid value for key: '".concat(t, "'."),
                "replication_error",
                "key_value_storage_error"
              );
          await Promise.all(
            Object.entries(e).map((e) => {
              let [t, n] = e;
              return this.opts.db.internalKvStore.write(t, n);
            })
          );
        }
        async send(e, t) {
          await this.sendBatch({ [e]: t });
        }
      }
      class Wg {
        constructor(e) {
          (this.opts = e),
            (this.sendIOSPushNotification = async (e) => {
              const {
                receiverId: t,
                appleDeviceToken: n,
                rawPayload: r,
                analyticsEventProperties: s,
                analyticsUserProperties: i,
                userSessionId: o,
              } = e;
              let a, c;
              try {
                const e = await this.opts.postActivePushNotification(n, r);
                (a = e.success),
                  a
                    ? await this.db.chatbot.updateTimeLastTargetedByChannelMessage(
                        t,
                        "ios",
                        this.opts.dateNow()
                      )
                    : (c = e.reason);
              } catch (a_) {
                (a = !1),
                  (c = a_.message),
                  this.opts.errorReporter &&
                    (await this.opts.errorReporter.captureException(
                      new nl(
                        c || "Sending active push iOS notification failed",
                        $c.server_error,
                        tl.push_notification_error,
                        "error"
                      )
                    ));
              }
              const l = [];
              if (a) {
                const e = {
                  user_id: t,
                  event_type: Ac,
                  event_properties: { ...s, platform: "IOS_APP" },
                  user_properties: i,
                  insert_id: Nc(t, o),
                };
                l.push(e);
              } else {
                const e = {
                  user_id: t,
                  event_type: Tc,
                  event_properties: { ...s, reason: c, platform: "IOS_APP" },
                  insert_id: Nc(t, o),
                };
                l.push(e),
                  ("Unregistered" !== c && "DeviceTokenNotForTopic" !== c) ||
                    (await this.db.chatbot.setAppleDeviceToken(t, "", 0));
              }
              return (
                await this.opts.sendAnalyticsEvents(l),
                { success: a, reason: c }
              );
            }),
            (this.db = e.db);
        }
      }
      class Kg {
        constructor(e) {
          this.opts = e;
        }
        async getBatch(e) {
          const t = await Promise.all(
              e.map((e) => this.opts.db.kvStore.fetch(e, this.opts.dateNow()))
            ),
            n = {};
          return (
            e.forEach((e, r) => {
              const s = t[r];
              null !== s && void 0 !== s && (n[e] = s);
            }),
            n
          );
        }
        async get(e) {
          return (await this.getBatch([e]))[e] || null;
        }
        async sendBatch(e, t) {
          for (const r in e)
            if (!e[r] || "string" !== typeof e[r])
              throw new nl(
                "Invalid value for key: '".concat(r, "'."),
                "replication_error",
                "key_value_storage_error"
              );
          const n = this.opts.dateNow();
          await Promise.all(
            Object.entries(e).map((e) => {
              let [r, s] = e;
              return this.opts.db.kvStore.write(r, s, n, {
                expiresInMs:
                  null === t || void 0 === t ? void 0 : t.expiresInMs,
              });
            })
          );
        }
        async send(e, t, n) {
          await this.sendBatch({ [e]: t }, n);
        }
      }
      const zg = {
        randomUUID:
          "undefined" !== typeof crypto &&
          crypto.randomUUID &&
          crypto.randomUUID.bind(crypto),
      };
      let Gg;
      const Jg = new Uint8Array(16);
      function Qg() {
        if (
          !Gg &&
          ((Gg =
            "undefined" !== typeof crypto &&
            crypto.getRandomValues &&
            crypto.getRandomValues.bind(crypto)),
          !Gg)
        )
          throw new Error(
            "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
          );
        return Gg(Jg);
      }
      const Yg = [];
      for (let n = 0; n < 256; ++n) Yg.push((n + 256).toString(16).slice(1));
      function Xg(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        return (
          Yg[e[t + 0]] +
          Yg[e[t + 1]] +
          Yg[e[t + 2]] +
          Yg[e[t + 3]] +
          "-" +
          Yg[e[t + 4]] +
          Yg[e[t + 5]] +
          "-" +
          Yg[e[t + 6]] +
          Yg[e[t + 7]] +
          "-" +
          Yg[e[t + 8]] +
          Yg[e[t + 9]] +
          "-" +
          Yg[e[t + 10]] +
          Yg[e[t + 11]] +
          Yg[e[t + 12]] +
          Yg[e[t + 13]] +
          Yg[e[t + 14]] +
          Yg[e[t + 15]]
        );
      }
      const Zg = function (e, t, n) {
        if (zg.randomUUID && !t && !e) return zg.randomUUID();
        const r = (e = e || {}).random || (e.rng || Qg)();
        if (((r[6] = (15 & r[6]) | 64), (r[8] = (63 & r[8]) | 128), t)) {
          n = n || 0;
          for (let e = 0; e < 16; ++e) t[n + e] = r[e];
          return t;
        }
        return Xg(r);
      };
      class $g {
        constructor(e) {
          this.opts = e;
        }
        async createLoginToken(e) {
          let { expiresInMs: t, userId: n } = e;
          const r = Zg();
          return (
            await this.opts.db.loginTokens.writeLoginToken({
              expiresAtMs: this.opts.dateNow() + t,
              token: r,
              userId: n,
            }),
            r
          );
        }
        createWebPlayerToken(e) {
          return this.opts.createWebPlayerToken(e);
        }
        async consumeLoginToken(e) {
          let { token: t, userId: n } = e;
          const r = await this.opts.db.loginTokens.fetchLoginToken({
            token: t,
            userId: n,
          });
          if (!r) return !1;
          return (
            !(r.expiresAtMs <= this.opts.dateNow()) &&
            (await this.opts.db.loginTokens.deleteLoginToken({
              token: t,
              userId: n,
            }),
            !0)
          );
        }
      }
      function ev(e, t, n, r) {
        return e.createSHA256Hash(
          "".concat(t, ":").concat(r, ":").concat(n),
          "hex"
        );
      }
      const tv = (e, t) => "Your one-time password is " + e;
      class nv {
        constructor(e) {
          this.opts = e;
        }
        async initiateOtp(e) {
          const t = Zg();
          let n = "userId" in e ? { user_id: e.userId } : { device_id: Zg() },
            r = null;
          try {
            var s;
            if ("sms" !== e.type)
              throw Error("OTP type ".concat(e.type, " is not implemented"));
            if (
              !{
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.APP_SECRET
            )
              throw Error("APP_SECRET env var must be configured to use OTP");
            if (
              "true" !==
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.WEB_PLAYABLE
            )
              throw Error("Web playable mode must be enabled to use OTP");
            if (
              e.templateId &&
              (null === (s = this.opts.config.otp) ||
                void 0 === s ||
                null === (s = s.smsTemplates) ||
                void 0 === s ||
                !s[e.templateId])
            )
              throw Error("Invalid OTP SMS template ID: " + e.templateId);
            if (
              ((r = await this.opts.twilio.sanitizePhoneNumber(e.receiver)),
              null === r)
            )
              throw Wm.withCode(
                "Invalid phone number",
                "server_error",
                "invalid_phone_number"
              );
            let i = r.sanitizedPhoneNumber;
            if ("login" === e.intent) {
              let t = await this.opts.db.accountLink.getUserId({
                clientAppName: e.clientAppName,
                phoneNumber: r.sanitizedPhoneNumber,
              });
              if (
                (t ||
                  ((t = await this.opts.db.accountLink.getUserId({
                    clientAppName: e.clientAppName,
                    phoneNumber: e.receiver,
                  })),
                  (i = e.receiver)),
                !t)
              )
                throw Wm.withCode(
                  "OTP receiver not found",
                  "authorization_error",
                  "invalid_otp_receiver"
                );
              n = { user_id: t };
            }
            const o = (function (e) {
                return new Array(e)
                  .fill(0)
                  .map(() => Math.floor(10 * Math.random()))
                  .join("");
              })(6),
              a = ev(
                this.opts.crypto,
                t,
                o,
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.APP_SECRET
              );
            await this.opts.db.otp.createVerification(
              {
                clientAppName: "login" === e.intent ? e.clientAppName : void 0,
                codeHash: a,
                consentText: "addReceiver" === e.intent ? e.consentText : "",
                id: t,
                intent: e.intent,
                receiver: i,
                type: e.type,
              },
              this.opts.dateNow()
            );
            const c = (
              e.templateId
                ? this.opts.config.otp.smsTemplates[e.templateId]
                : tv
            )(o, e.additionalTemplateData);
            await this.opts.twilio.sendSms({
              body: c,
              receiver: r.sanitizedPhoneNumber,
            });
          } catch (i) {
            throw (
              (await this.opts.sendAnalyticsEvents([
                {
                  ...n,
                  event_type: "OTPRequestFailure",
                  event_properties: {
                    errorMessage: i.message,
                    intent: e.intent,
                    type: e.type,
                  },
                },
              ]),
              i)
            );
          }
          return (
            await this.opts.sendAnalyticsEvents([
              {
                ...n,
                event_type: "OTPRequestSuccess",
                event_properties: { intent: e.intent, type: e.type },
              },
            ]),
            {
              localePhoneNumber: r.localePhoneNumber,
              phoneNumber: r.sanitizedPhoneNumber,
              verificationId: t,
            }
          );
        }
        async verifyAndLinkUserId(e) {
          const t = "addReceiver";
          try {
            const n = await this.verifyOtp({
              code: e.code,
              verificationId: e.verificationId,
              intent: t,
            });
            if (!n)
              return (
                await this.opts.sendAnalyticsEvents([
                  {
                    user_id: e.userId,
                    event_type: Oc,
                    event_properties: {
                      intent: t,
                      errorMessage: "invalid_otp_code",
                    },
                  },
                ]),
                !1
              );
            if ("sms" !== n.type) throw wc(n.type);
            return (
              await this.opts.db.accountLink.linkUserId({
                clientAppName: e.entry.metainfo.clientAppName,
                consentText: n.consentText,
                now: this.opts.dateNow(),
                phoneNumber: n.receiver,
                userId: e.userId,
              }),
              (e.entry.metainfo.hasPhoneNumber = !0),
              await this.opts.sendAnalyticsEvents([
                {
                  user_id: e.userId,
                  event_type: kc,
                  event_properties: { intent: t, type: n.type },
                },
              ]),
              !0
            );
          } catch (n) {
            throw (
              (await this.opts.sendAnalyticsEvents([
                {
                  user_id: e.userId,
                  event_type: Oc,
                  event_properties: { intent: t, errorMessage: n.message },
                },
              ]),
              n)
            );
          }
        }
        async verifyOtpAndGetLinkedUserId(e) {
          try {
            const t = await this.verifyOtp({
              code: e.code,
              verificationId: e.verificationId,
              intent: "login",
            });
            if (!t)
              throw Wm.withCode(
                "OTP verification failed",
                "authorization_error",
                "invalid_otp_code"
              );
            let n = null;
            if ("sms" !== t.type) throw wc(t.type);
            if (
              ((n = await this.opts.db.accountLink.getUserId({
                clientAppName: t.clientAppName,
                phoneNumber: t.receiver,
              })),
              !n)
            )
              throw Error("No linked user found for verified OTP receiver");
            return (
              await this.opts.sendAnalyticsEvents([
                {
                  user_id: n,
                  event_type: kc,
                  event_properties: { intent: "login", type: t.type },
                },
              ]),
              n
            );
          } catch (t) {
            throw (
              (await this.opts.sendAnalyticsEvents([
                {
                  device_id: Zg(),
                  event_type: Oc,
                  event_properties: {
                    errorMessage: t.message,
                    intent: "login",
                  },
                },
              ]),
              t)
            );
          }
        }
        async verifyOtp(e) {
          const t = await this.opts.db.otp.getVerification(
            { id: e.verificationId, intent: e.intent },
            this.opts.dateNow()
          );
          return t &&
            (function (e, t, n, r, s) {
              return e.timingSafeEqual(ev(e, t, n, r), s);
            })(
              this.opts.crypto,
              e.verificationId,
              e.code,
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.APP_SECRET,
              t.codeHash
            )
            ? t
            : null;
        }
      }
      const rv = "__serialized__",
        sv = "__error__";
      function iv(e) {
        return e instanceof Error
          ? { ...e, name: e.name, message: e.message, stack: e.stack, [rv]: sv }
          : e;
      }
      function ov(e) {
        if ("object" === typeof e && null !== e && e[rv] === sv) {
          const t =
            "ReplicantError" === e.name ? new nl(e.message, e.code) : Error();
          for (const n of Object.keys(e)) n !== rv && (t[n] = e[n]);
          return t;
        }
        return e;
      }
      function av(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
        return (t = Math.max(t, -1)), n(e, 0);
        function n(e, t) {
          switch (typeof e) {
            case "object":
              return null === e
                ? "null"
                : Array.isArray(e)
                ? (function (e, t) {
                    const s = [];
                    for (const r of e) s.push(n(r, t + 1));
                    return r(s, "[", "]", t);
                  })(e, t)
                : e.constructor && "Object" !== e.constructor.name
                ? "RegExp" === e.constructor.name
                  ? e.toString()
                  : e.constructor.name
                  ? "[object " + e.constructor.name + "]"
                  : "[anonymous object]"
                : (function (e, t) {
                    const s = [];
                    for (const r in e)
                      e.hasOwnProperty(r) &&
                        s.push(JSON.stringify(r) + ": " + n(e[r], t + 1));
                    return r(s, "{", "}", t);
                  })(e, t);
            case "undefined":
              return "undefined";
            case "number":
              if (Number.isNaN(e)) return "NaN";
              switch (e) {
                case 1 / 0:
                  return "Infinity";
                case -1 / 0:
                  return "-Infinity";
                default:
                  return JSON.stringify(e);
              }
            case "bigint":
              return e.toString() + "n";
            case "function":
              return e.name
                ? "[function " + e.name + "]"
                : "[anonymous function]";
            case "symbol":
              return e.toString();
            default:
              return JSON.stringify(e);
          }
        }
        function r(e, n, r, s) {
          return 0 === e.length
            ? n + r
            : -1 === t
            ? [n, e.join(", "), r].join(" ")
            : [
                n,
                e.map((e) => " ".repeat(t * (s + 1)) + e).join(",\n"),
                " ".repeat(t * s) + r,
              ].join("\n");
        }
      }
      function cv(e) {
        const t = { ...e },
          n = { ...t, hasUsedAsyncAPIs: !1 },
          r = [];
        return (
          (function e(t, s) {
            for (const i in t)
              "function" === typeof t[i]
                ? (t[i] = function () {
                    let e;
                    try {
                      for (
                        var t = arguments.length, o = new Array(t), a = 0;
                        a < t;
                        a++
                      )
                        o[a] = arguments[a];
                      e = s[i].apply(null, o);
                    } catch (c) {
                      throw (
                        (r.push({
                          value: Ho(iv(c)),
                          async: !1,
                          resolved: !0,
                          failed: !0,
                        }),
                        c)
                      );
                    }
                    if (bc(e)) {
                      const t = r.length;
                      r.push({ value: "", async: !0, resolved: !1 }),
                        e
                          .then((e) => {
                            (r[t].value = Ho(e)), (r[t].resolved = !0);
                          })
                          .catch((e) => {
                            (r[t].value = Ho(iv(e))),
                              (r[t].resolved = !0),
                              (r[t].failed = !0);
                          }),
                        (n.hasUsedAsyncAPIs = !0);
                    } else r.push({ value: Ho(e), async: !1, resolved: !0 });
                    return e;
                  })
                : "object" === typeof t[i] &&
                  ((t[i] = { ...t[i] }), e(t[i], s[i]));
          })(n, t),
          { api: n, results: r }
        );
      }
      class lv {
        constructor(e) {
          (this.opts = e),
            (this.createActionAPI = (e) => {
              const t = this.opts.createActionAPI(e);
              if (!this.opts.config.sendActionAnalyticsWithClient || e.isLogin)
                return t;
              const n = (t) => t.userId && t.userId !== e.userId;
              return {
                ...t,
                sendAnalyticsEvents: (e) => t.sendAnalyticsEvents(e.filter(n)),
              };
            }),
            (this.db = e.db);
        }
        async handleReplicateRequest(e) {
          var t;
          Xl.debug("REPLICANT: replicate ", e);
          const { id: n, queue: r, rev: s, stateContext: i } = e,
            o = r.every((e) => e.fn === Kc);
          let a;
          if (o) {
            a = this.rescheduleOnSessionEndEvent(n);
            if (
              0 ===
              (await this.db.fetchMessages(n, { consistentRead: !0 })).length
            )
              return (
                await a, { lastUpdated: 0, messages: [], results: [], rev: s }
              );
          }
          const {
            entry: c,
            entryDiffs: l,
            messages: u,
          } = await this.db
            .fetch(n, { consistentRead: !1 })
            .then((e) =>
              e.entry && s > e.entry.rev
                ? this.db.fetch(n, { consistentRead: !0 })
                : e
            );
          if (!c) throw new Error("Entry not found for id: " + n);
          if (
            ((i.id = n),
            (i.userData = c),
            (i.messages = u),
            c.version > this.opts.config.migrator.getLatestVersion())
          )
            throw new nl(
              "Version "
                .concat(this.opts.config.version, " is too low. Expected ")
                .concat(c.metainfo.appVersion, "!"),
              $c.version_error
            );
          const d = () => {
            if (c.metainfo.lastSessionId !== e.sessionId) {
              const t = {
                clientSessionName: e.sessionName,
                lastSessionName: c.metainfo.lastSessionName,
              };
              throw new nl(
                "Session desync: see more in https://docs.dev.gc-internal.net/replicant/faq/#how-to-fix-session-desync-errors.",
                $c.session_desync_error,
                void 0,
                "fatal",
                {
                  clientRev: s,
                  clientSessionId: e.sessionId,
                  serverRev: c.rev,
                  serverLastSessionId: c.metainfo.lastSessionId,
                },
                t
              );
            }
          };
          if (c.rev !== s) {
            if ((d(), c.rev === s + 1)) {
              var h;
              const t =
                null !== (h = await this.opts.db.fetchChangeset(n, c.rev)) &&
                void 0 !== h
                  ? h
                  : await this.opts.db.fetchChangeset(n, c.rev, {
                      consistentRead: !0,
                    });
              if (!t || Array.isArray(t.replication))
                throw new Error(
                  "Could not fetch changeset for id: " + n + ", rev: " + s
                );
              if (
                c.metainfo.lastClientRequestId &&
                c.metainfo.lastClientRequestId !== e.clientRequestId
              ) {
                const e = r.filter((e) => e.fn !== Kc);
                if (!Wo(t.replication.queue, e))
                  throw (
                    (d(),
                    new nl(
                      "Client revision number does not match the latest revision known to server. This may be caused by a race condition.",
                      $c.replication_error,
                      tl.retry_queue_mismatch,
                      "error",
                      {
                        clientRev: s,
                        clientQueue: e,
                        serverRev: c.rev,
                        serverQueue: t.replication.queue,
                      }
                    ))
                  );
              }
              const i = r.some((e) => e.async);
              return {
                messages: i ? t.messages : [],
                results: t.replication.results,
                rev: c.rev,
                lastUpdated: c.lastUpdated,
              };
            }
            throw new nl(
              "Client revision number does not match the latest revision known to server. This may be caused by a race condition.",
              $c.replication_error,
              tl.rev_id_mismatch,
              "error",
              { clientRev: s, serverRev: c.rev }
            );
          }
          if (c.version !== this.opts.config.migrator.getLatestVersion())
            throw new Error("Invalid user document version: " + c.version);
          a =
            null !== (t = a) && void 0 !== t
              ? t
              : this.rescheduleOnSessionEndEvent(n);
          const p = await this.replicate({
            abTestsDynamicConfig: e.abTestsDynamicConfig,
            clientRandomSeed: e.clientRandomSeed,
            clientRequestId: e.clientRequestId,
            consistentFetchIds: e.consistentFetchIds,
            entry: c,
            entryDiffs: l,
            id: n,
            messages: u,
            queue: r,
            pushDocToIndex: e.pushDocToIndex,
            requestedProfileIds: e.requestedProfileIds,
            sessionId: e.sessionId,
            sessionName: e.sessionName,
          });
          return (
            await a,
            {
              lastUpdated: p.lastUpdated,
              messages: p.messages,
              results: p.results,
              rev: p.entry.rev,
              metainfoDelta: p.metainfoDelta,
              newLastUpdated: p.newLastUpdated,
              requestedProfiles: p.requestedProfiles,
            }
          );
        }
        async replicate(e) {
          var t, n, r;
          const {
            clientRandomSeed: s,
            consistentFetchIds: i,
            entry: o,
            entryDiffs: a,
            requestedProfileIds: c,
            id: l,
            messages: u,
            queue: d,
          } = e;
          let h;
          try {
            h = Bm(this.opts.config, o);
          } catch (a_) {
            throw new nl(
              "Replication error: Invalid state: ".concat(
                JSON.stringify(o.state),
                "."
              ),
              "replication_error",
              "invalid_state"
            );
          }
          const p = [],
            f = [],
            m = h.entry,
            g = m.lastUpdated,
            v = Ho(m.metainfoMVCC.paymentSubscription),
            y =
              null === (t = m.metainfo.purchaseHistory) || void 0 === t
                ? void 0
                : t.length,
            b = m.metainfo.hasPhoneNumber,
            w = m.lastInvokeTime,
            S =
              e.pushDocToIndex &&
              JSON.stringify(Yf(l, m, this.opts.config, () => g)),
            _ = [],
            E = [];
          Al(m.state, Tl(l, m), this.opts.config),
            d.forEach((e) => {
              e.fn === zc && _a.array(_a.string()).tryValidate(e.args);
            });
          const A = Zm();
          e.clientRequestId &&
            (h.entry.metainfo.lastClientRequestId = e.clientRequestId);
          for (const F of d) {
            if (F.fn === Kc) continue;
            const t = F.fn === zc,
              n = Ko(this.opts.config.actions, F.fn);
            if (t) {
              if (n)
                throw new nl(
                  "System actions should not be configurable.",
                  "replication_error",
                  "invalid_action"
                );
            } else if (
              !n ||
              ("async" === n.type && !F.async) ||
              ("sync" === n.type && F.async)
            )
              throw new nl(
                "Action " + F.fn + " not found or async flag not correct!",
                "replication_error",
                "invalid_action"
              );
            if (F.args) {
              const e = JSON.stringify(F.args).length;
              if (e > Gc) {
                const t = rl({ actionName: F.fn, argsSize: e });
                await this.opts.errorReporter.captureException(t, {
                  user: { id: l },
                });
              }
            }
            const r = this.opts.dateNow(),
              s = F.meta ? F.meta.now : r,
              o = {
                abTestsDynamicConfig: e.abTestsDynamicConfig,
                userId: l,
                entry: m,
                consistentFetchIds: i,
                delayedActions: E,
                invokeTime: s,
                sessionId: e.sessionId,
                fetcher: this.opts.fetcher,
              };
            if (!m.metainfo.clockOffset && r < m.lastUpdated - Qc) {
              const e =
                "Current server time could not be validated: ".concat(r, ": ") +
                "offset to lastUpdated: ".concat(r - m.lastUpdated);
              throw new nl(e, "replication_error", "client_time_invalid");
            }
            if (F.meta) {
              const e = m.lastInvokeTime || 0;
              if (!m.metainfo.clockOffset && (s < e || s > r + Qc)) {
                if (s > r + Yc) {
                  const t =
                    "Very large offset to now: ".concat(s - r, ". ") +
                    "Offset to lastInvokeTime: ".concat(s - e, " ");
                  throw new nl(
                    t,
                    "replication_error",
                    "client_time_offset_too_large"
                  );
                }
                {
                  const t =
                    "Client supplied time could not be validated: ".concat(
                      s,
                      ": "
                    ) +
                    "offset to lastInvokeTime: ".concat(s - e, " ") +
                    "and offset to now: ".concat(s - r, ".");
                  throw new nl(t, "replication_error", "client_time_invalid");
                }
              }
              m.lastInvokeTime = s;
            }
            const a = { type: "action", name: F.fn, userId: l };
            if (F.async) {
              const e = cv(
                this.createActionAPI({
                  ...o,
                  async: !0,
                  isLogin: !0 === F.isLogin,
                })
              );
              A && Xm(e.api, a), (e.api.hasUsedAsyncAPIs = !1);
              const t = (A ? Qm(n.fn, a) : n.fn)(m.state, F.args, e.api);
              if (e.api.hasUsedAsyncAPIs && !bc(t))
                throw new nl(
                  "Async action `" +
                    F.fn +
                    "` uses asynchronous APIs, but does not return a promise.",
                  "replication_error",
                  "invalid_action"
                );
              if (
                (await t,
                e.api.hasUsedAsyncAPIs &&
                  e.results.some((e) => e.async && !e.resolved))
              )
                throw new nl(
                  "Async action `" +
                    F.fn +
                    "` has unresolved async api results",
                  "replication_error",
                  "invalid_action"
                );
              _.push(
                e.results.map((e) => {
                  let { value: t, async: n, failed: r } = e;
                  return { value: t, async: n, failed: r };
                })
              );
            } else {
              const e = this.createActionAPI({
                ...o,
                async: !1,
                isLogin: !0 === F.isLogin,
              });
              if (t) {
                const e = F.args.map((e) => {
                    const t = u.find((t) => e === t.id);
                    if (!t)
                      throw new nl(
                        "Cannot apply a non-existent message",
                        "replication_error",
                        "missing_messages",
                        "error",
                        { messageId: e }
                      );
                    return t;
                  }),
                  t = this.opts.applyMessagesToState(l, m, e, { isSampled: A });
                p.push(...t.reducedMessages), f.push(...t.unreducedMessages);
              } else {
                (A ? Qm(n.fn, a) : n.fn)(m.state, F.args, e);
              }
            }
          }
          if (void 0 !== s && m.metainfo.random.n !== s)
            throw new nl(
              "Client's random seed doesn't match server's random seed after executing actions. " +
                "client: "
                  .concat(s, ", server: ")
                  .concat(m.metainfo.random.n, "\n") +
                "See https://docs.dev.gc-internal.net/replicant/faq/index.html#how-to-fix-random-seed-errors for more.",
              "replication_error",
              "random_seed_invalid"
            );
          try {
            this.opts.config.stateSchema.tryValidate(m.state);
          } catch (U) {
            throw new nl(
              "Applying actions "
                .concat(JSON.stringify(d.map((e) => e.fn)), " yields error: ")
                .concat(U.message),
              "replication_error",
              "invalid_action"
            );
          }
          const T = this.opts.getApplicableMessages(u).filter((e) => {
              const t = p.find((t) => {
                let { id: n } = t;
                return n === e.id;
              });
              return !jl(h.entry.metainfo, e) && !t;
            }),
            P = d.some((e) => e.async);
          if (P) {
            const e = this.opts.applyMessagesToState(l, m, T, { isSampled: A });
            p.push(...e.reducedMessages), f.push(...e.unreducedMessages);
          }
          const I = d
              .map((e) => e.fn)
              .filter(
                (e) =>
                  !(function (e) {
                    return e === zc || e === Kc;
                  })(e)
              ),
            C =
              A && 1 === I.length
                ? { type: "action", name: I[0], userId: l }
                : void 0,
            k = {
              entryPromises: { [l]: Promise.resolve(m) },
              performanceTracking: { context: C },
            };
          let O;
          if (
            (await this.opts.apiAccess.resolveDelayedActions(E, k),
            c && c.length > 0)
          ) {
            O = (
              await this.opts.apiAccess.fetchStates(c, {
                consistentFetchIds: i,
              })
            ).states;
          }
          const x = d.filter((e) => e.fn !== Kc),
            N = Ml(this.opts.dateNow(), f);
          if (x.length > 0 || p.length > 0) {
            m.rev++,
              (m.lastUpdated = this.opts.dateNow()),
              (m.metainfo.appVersion = this.opts.config.version),
              (m.metainfo.lastSessionName = e.sessionName),
              (m.metainfo.lastSessionId = e.sessionId),
              Ll(this.opts.dateNow(), m.metainfo, p);
            const t = ng({ entry: m, now: m.lastUpdated }),
              n = h.snapshot(),
              { itemByteSize: r } = await this.db.writeEntryOrEntryDiff({
                diff: n.diff,
                entry: n.entry,
                lastInvokeTime:
                  m.lastInvokeTime === w ? void 0 : m.lastInvokeTime,
                oldEntryDiffs: a,
                recoverySnapshotUpdate: t,
                userId: l,
              });
            r > 3e5 &&
              (await this.opts.errorReporter.captureException(
                new nl(
                  "User entry or entry diff size above 300KB. Reduce state size to avoid hitting the 400KB hard limit!",
                  "server_error",
                  "state_too_large",
                  "fatal"
                ),
                { user: { id: l } },
                { itemByteSize: r }
              )),
              (p.length > 0 || N.length > 0) &&
                (await this.db.deleteMessages(l, p.concat(N)));
            const s = this.opts
              .writeChangeset({
                id: l,
                date: new Date(n.entry.lastUpdated),
                entry: n.entry,
                replication: { queue: x, results: _ },
                messages: p,
                diff: n.diff,
                snapshotUpdate: t,
              })
              .catch(async (e) => {
                await this.opts.errorReporter.captureException(
                  e,
                  { user: { id: l } },
                  {
                    diffJSONLength: JSON.stringify(n.diff).length,
                    messagesJSONLength: JSON.stringify(p).length,
                  }
                );
              });
            if (e.pushDocToIndex) {
              const t = Yf(l, m, this.opts.config, this.opts.dateNow);
              JSON.stringify(t) !== S && (await e.pushDocToIndex(l, t));
            }
            await s;
          } else N.length > 0 && (await this.db.deleteMessages(l, N));
          const R = m.metainfo.hasPhoneNumber,
            D = R !== b ? R : void 0,
            M = m.metainfoMVCC.paymentSubscription,
            j = v !== M ? M : void 0,
            L =
              y !==
              (null === (n = m.metainfo.purchaseHistory) || void 0 === n
                ? void 0
                : n.length)
                ? null === (r = m.metainfo.purchaseHistory) || void 0 === r
                  ? void 0
                  : r.slice(y)
                : void 0;
          return {
            entry: m,
            results: _,
            messages: P ? p : T.filter((e) => !p.includes(e)),
            metainfoDelta: {
              hasPhoneNumber: D,
              paymentSubscriptionStatus: j,
              purchaseHistory: L,
            },
            requestedProfiles: O,
            lastUpdated: g,
            newLastUpdated: m.lastUpdated > g ? m.lastUpdated : void 0,
          };
        }
        async rescheduleOnSessionEndEvent(e) {
          var t;
          const n = Sc({ minutes: 1 });
          if (
            !(
              null === (t = this.opts.config.eventHandlers) ||
              void 0 === t ||
              !t.onSessionEnd
            )
          )
            try {
              const t = await this.db.metainfoMVCC.fetchMetainfoMVCC(e);
              await this.opts.apiAccess.systemScheduledActions.schedule.onSessionEnd(
                {
                  args: {},
                  delayInMS: n,
                  notificationId: "onSessionEnd",
                  userData: { metainfoMVCC: t },
                  userId: e,
                }
              );
            } catch (r) {
              await this.opts.errorReporter.captureException(r, {
                user: { id: e },
              });
            }
        }
      }
      async function uv(e, t, n, r, s) {
        const i = Math.max(t.lastMessageReceivedAt || 0, t.lastUpdated),
          o = Yf(e, t, n, () => i);
        await s();
        const a = Yf(e, t, n, r);
        if (!Wo(o, a)) return a;
      }
      class dv {
        constructor(e) {
          var t;
          (this.opts = e),
            (this.executeScheduledActions = async (e) => {
              Xl.info(
                "Executing a batch of ".concat(e.length, " scheduled actions")
              );
              const t = ll(e.map((e) => e.userId)),
                n = await Promise.all(
                  t.map(async (e) => {
                    try {
                      const t = await this.opts.getReadOnlyEntry(e);
                      return t ? t.entry : null;
                    } catch (n) {
                      var t;
                      const e = new nl(
                        "Scheduled actions error: " + n,
                        "server_error",
                        "db_error"
                      );
                      return (
                        (e.stack = n.stack),
                        await (null === (t = this.opts.errorReporter) ||
                        void 0 === t
                          ? void 0
                          : t.captureException(e)),
                        null
                      );
                    }
                  })
                ),
                r = Object.fromEntries(
                  n.filter((e) => null !== e).map((e) => [e.state.id, e])
                ),
                s = { entryPromises: Go(r, (e, t) => Promise.resolve(t)) },
                i = [],
                o = async (e, t) => {
                  const [n, r] = hl(
                    e,
                    (e) =>
                      "postMessage" ===
                        (null === e || void 0 === e ? void 0 : e.type) ||
                      "sendAnalyticsEvents" ===
                        (null === e || void 0 === e ? void 0 : e.type)
                  );
                  i.push(...n),
                    await this.opts.resolveDelayedActions(r, {
                      ...s,
                      performanceTracking: { context: t },
                    });
                },
                a = { successful: [], failed: [] },
                c = {};
              return (
                await Promise.all(
                  e.map(async (e) => {
                    try {
                      if (
                        (function (e) {
                          return !!e.isSystemAction && e.userId === pg;
                        })(e)
                      )
                        return await this.executeGlobalSystemScheduledAction(e);
                      const t = r[e.userId];
                      if (!t)
                        throw new nl(
                          "Scheduled actions error: no user found",
                          "server_error",
                          "scheduled_actions_error",
                          "error",
                          e
                        );
                      const n = await uv(
                        e.userId,
                        t,
                        this.opts.config,
                        this.opts.dateNow,
                        () =>
                          this.executeScheduledAction({
                            action: e,
                            entry: t,
                            resolveDelayedActions: o,
                          })
                      );
                      n && (c[e.userId] = n), a.successful.push(e.id);
                    } catch (a_) {
                      var t;
                      await (null === (t = this.opts.errorReporter) ||
                      void 0 === t
                        ? void 0
                        : t.captureException(
                            a_,
                            { user: { id: e.userId } },
                            e
                          )),
                        a.failed.push(e.id);
                    }
                  })
                ),
                await Promise.all([
                  this.opts.resolveDelayedActions(i, s).catch((e) => {
                    var t;
                    return null === (t = this.opts.errorReporter) ||
                      void 0 === t
                      ? void 0
                      : t.captureException(e, void 0, { delayedActions: i });
                  }),
                  this.opts.pushDocsToIndex(c),
                ]),
                a
              );
            }),
            (this.scheduledActions =
              null !== (t = this.opts.config.scheduledActions) && void 0 !== t
                ? t
                : {}),
            (this.systemScheduledActions = yg({
              config: this.opts.config,
              db: this.opts.db,
            }));
        }
        async enqueueScheduledActionsForTimeslot(e) {
          let t,
            n =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 200;
          if (this.opts.queue)
            do {
              const r = await this.opts.db.scheduledActions.fetchAllForTimeslot(
                e,
                n,
                t
              );
              t = r.continuationTokens;
              const s = Object.keys(r.actions);
              Xl.info(
                "Running scheduled actions for timeslot ".concat(e, " (") +
                  new Date(1e3 * e * 60).toISOString() +
                  "): ".concat(s.length, " actions")
              );
              const i = await this.opts.queue.enqueueScheduledActions(
                s.map((t) => hv(t, e, r.actions[t]))
              );
              await this.opts.db.scheduledActions.deleteBatch(
                i.successful.map((t) => ({ timeslotId: e, actionId: pv(t) }))
              );
            } while (t);
        }
        async executeScheduledAction(e) {
          const { action: t, entry: n, resolveDelayedActions: r } = e,
            { actionName: s, actionArgs: i, userId: o } = t,
            a = t.isSystemAction
              ? this.systemScheduledActions[s]
              : this.scheduledActions[s];
          if (!a) return void Xl.warn("Unknown scheduled action: " + s);
          const c = a.schema.validate(i);
          if (c)
            return void Xl.warn(
              "Error validating args for action `" + s + "`: " + c
            );
          const l = [],
            u = await this.opts.createEventHandlerApi({
              consistentFetchIds: [],
              delayedActions: l,
              entry: n,
              userId: o,
              scheduledActionId: t.id,
            }),
            d = Zm(),
            h = { type: "scheduledAction", name: t.actionName, userId: o };
          d && Xm(u, h);
          await Dm({
            db: this.opts.db,
            entry: n,
            event: { type: "scheduledAction", scheduledActionName: s },
            eventHandler: async () => {
              const e = d ? Qm(a.action, h) : a.action;
              await e(n.state, i, u), await r(l, d ? h : void 0);
            },
            now: this.opts.dateNow(),
            userId: o,
          });
        }
        async executeGlobalSystemScheduledAction(e) {
          const { actionName: t, actionArgs: n } = e,
            r = this.systemScheduledActions[t].schema.validate(n);
          if (
            (r && Xl.warn("Error validating args for action `" + t + "`: " + r),
            e.actionName !== gg)
          )
            throw Error(
              "Invalid global system scheduled action name ".concat(
                e.actionName
              )
            );
          {
            this.systemScheduledActions.lineChatbotBroadcast.schema;
            const { broadcastId: t, broadcastOpts: r } = n,
              o = this.opts.dateNow();
            try {
              const e =
                await this.opts.narrowcastAPIClient.sendNarrowcastMessage(t, r);
              await this.opts.db.lineChatbotBroadcasts.addBroadcast({
                broadcastId: t,
                broadcastOpts: r,
                createdAt: o,
                requestId: e,
              });
            } catch (i) {
              var s;
              await this.opts.db.lineChatbotBroadcasts.addBroadcast({
                broadcastId: t,
                broadcastOpts: r,
                createdAt: o,
                error: i.message,
              }),
                await (null === (s = this.opts.errorReporter) || void 0 === s
                  ? void 0
                  : s.captureException(i, { user: { id: e.userId } }, e));
            }
          }
        }
      }
      const hv = (e, t, n) => ({
          actionArgs: n.actionArgs,
          actionName: n.actionName,
          id: e + "-" + t,
          isSystemAction: n.isSystemAction,
          userId: n.userId,
        }),
        pv = (e) => e.split("-")[0];
      class fv {
        constructor(e) {
          this.opts = e;
        }
        async resolveAllSharedStatesUpdates(e) {
          const t = {};
          for (let s = 0; s < e.length; s++) {
            const n = e[s],
              { stateId: r } = n,
              i = e.slice(s + 1).filter((e) => e.stateId === r);
            if (
              ("deleteUserSharedState" !== n.type &&
                "setUserSharedState" !== n.type) ||
              !i.find(
                (e) =>
                  "deleteUserSharedState" === e.type ||
                  "setUserSharedState" === e.type
              )
            ) {
              if ("setUserSharedState" === n.type) {
                const t = e.find(
                  (e) => e.stateId === r && "setUserSharedState" === e.type
                );
                n.userState.rev = t.userState.rev;
                if (
                  !(
                    !t.previousStateValue ||
                    JSON.stringify(n.userState.state) !== t.previousStateValue
                  )
                )
                  continue;
              }
              t[r] || (t[r] = []), t[r].push(n);
            }
          }
          const n = [],
            r = {};
          for (const s in t) {
            const e = t[s],
              i = e[0].stateName;
            n.push(
              this.resolveSharedStateUpdates({
                stateId: s,
                stateName: i,
                updates: e,
              }).then((e) => {
                e && (r[i] || (r[i] = {}), (r[i][s] = e));
              })
            );
          }
          return await Promise.all(n), r;
        }
        async fetchSharedState(e) {
          var t;
          const { consistentRead: n, stateId: r, stateName: s } = e,
            i = this.tryGetStateConfig(s),
            o = await this.opts.db.sharedStates.fetchSharedState({
              stateId: r,
              stateName: s,
              consistentRead: n,
            });
          let a = o.sharedState;
          if (
            i.schema.global &&
            !(null !== (t = a) && void 0 !== t && t.globalSharedState) &&
            !n
          ) {
            const e = await this.opts.db.sharedStates.fetchGlobalSharedState({
              stateId: r,
              stateName: s,
              consistentRead: !0,
            });
            var c, l, u, d;
            if (e && e.stateName === s)
              a = {
                globalSharedState: e,
                sharedStateMessages:
                  null !==
                    (c =
                      null === (l = a) || void 0 === l
                        ? void 0
                        : l.sharedStateMessages) && void 0 !== c
                    ? c
                    : [],
                userSharedStates:
                  null !==
                    (u =
                      null === (d = a) || void 0 === d
                        ? void 0
                        : d.userSharedStates) && void 0 !== u
                    ? u
                    : {},
              };
          }
          if (
            !a ||
            (a.globalSharedState && a.globalSharedState.stateName !== s)
          )
            return;
          if (o.consumedCapacity > 150) {
            const e = new nl(
              "Shared state size in storage exceeds the suggested limit. To avoid performance issues, either reduce the number of user states or remove unused state properties.",
              "server_error",
              "shared_state_too_large",
              "warning",
              {
                consumedCapacity: o.consumedCapacity,
                messageCount: a.sharedStateMessages.length,
                stateId: r,
                stateName: s,
                userCount: Object.keys(a.userSharedStates).length,
              }
            );
            await this.opts.errorReporter.captureException(e);
          }
          const h = i.schema.user,
            p = h
              ? Go(
                  a.userSharedStates,
                  (e, t) => (this.migrateAndFillDefaults(h, t), t.state)
                )
              : {};
          if (!i.schema.global)
            return { global: void 0, users: p, lastMessageAt: 0 };
          const f = a.globalSharedState;
          if (!f) return;
          this.migrateAndFillDefaults(i.schema.global, f);
          const m = a.sharedStateMessages.filter((t) => {
            var n;
            return !(
              null !== (n = e.excludeMessageIds) && void 0 !== n ? n : []
            ).includes(t.id);
          });
          let g = f.updatedAt;
          if (m.length) {
            const { reducedMessages: t, unreducedMessages: n } =
              this.applyMessages({
                globalItem: f,
                messages: m,
                stateName: s,
                users: p,
              });
            t.length > 0 && (g = Math.max(...t.map((e) => e.timestamp)));
            if (e.reduceMessages && t.length + n.length >= 100) {
              const e = Ml(this.opts.dateNow(), n);
              if (t.length > 0) {
                Ll(this.opts.dateNow(), f, t),
                  f.rev++,
                  (f.updatedAt = this.opts.dateNow());
                try {
                  await this.opts.db.sharedStates.writeGlobalSharedState(f);
                } catch (a_) {
                  if (!(a_ instanceof Zl)) throw a_;
                }
              }
              await this.opts.db.sharedStates.deleteSharedStateMessages(
                [...t, ...e].map((e) => ({
                  messageId: e.id,
                  stateId: r,
                  stateName: s,
                }))
              );
            }
          }
          return { global: f.state, users: p, lastMessageAt: g };
        }
        async fetchOrCreateSharedState(e) {
          const { stateId: t, stateName: n } = e;
          try {
            const e = this.opts.dateNow(),
              r = await this.writeGlobalSharedState({
                now: e,
                stateId: t,
                stateName: n,
              }),
              s = { global: r.state, lastMessageAt: r.createdAt, users: {} },
              i = this.getIndexDoc({
                now: e,
                sharedState: s,
                stateId: t,
                stateName: n,
              });
            return (
              i &&
                (await this.opts.pushSharedStateDocToIndex({
                  indexDoc: i,
                  stateId: t,
                  stateName: n,
                })),
              s
            );
          } catch (r) {
            if (r instanceof nl && "shared_state_duplicate_id" === r.subCode) {
              const e = await this.fetchSharedState({
                stateId: t,
                stateName: n,
                consistentRead: !0,
              });
              if (!e)
                throw Error(
                  "Shared state ".concat(n, " with ID ").concat(t, " not found")
                );
              return e;
            }
            throw r;
          }
        }
        setUserState(e) {
          var t, n, r, s;
          const i = this.tryGetStateConfig(e.stateName).schema.user;
          if (!i)
            throw new Error(
              "Cannot set user shared state "
                .concat(e.stateName, " for ")
                .concat(e.stateId, ": No user schema.")
            );
          i.schema.tryValidate(e.state);
          const o = e.entry.userSharedStates,
            a = {
              state: e.state,
              userId: e.userId,
              stateId: e.stateId,
              stateName: e.stateName,
              rev:
                null !==
                  (t =
                    null === (n = o[e.stateName]) ||
                    void 0 === n ||
                    null === (n = n[e.stateId]) ||
                    void 0 === n
                      ? void 0
                      : n.rev) && void 0 !== t
                  ? t
                  : 0,
              version:
                null !==
                  (r =
                    null === (s = i.migrator) || void 0 === s
                      ? void 0
                      : s.getLatestVersion()) && void 0 !== r
                  ? r
                  : 1,
            };
          return (
            this.migrateAndFillDefaults(i, a),
            ++a.rev,
            (o[e.stateName] = { ...o[e.stateName], [e.stateId]: a }),
            a
          );
        }
        migrateUserSharedStates(e) {
          if (!e) return;
          const t = this.opts.config.sharedStates,
            n = {};
          for (const i in e) {
            var r;
            const s =
              null === t || void 0 === t || null === (r = t[i]) || void 0 === r
                ? void 0
                : r.schema.user;
            if (!s) continue;
            const o = e[i];
            for (const e in o) {
              const t = o[e];
              if (!t) continue;
              const r = t.version;
              this.migrateAndFillDefaults(s, t),
                r !== t.version && (n[e] = { rev: t.rev });
            }
          }
          const s = Object.values(e)
            .flatMap((e) => Object.values(e))
            .filter((e) => {
              var t;
              return (
                (null === (t = n[e.stateId]) || void 0 === t
                  ? void 0
                  : t.rev) === e.rev
              );
            });
          if (s.length) {
            return async () => {
              await Promise.all(
                s.map(async (e) => {
                  ++e.rev,
                    await Promise.all([
                      this.opts.db.sharedStates.writeUserSharedState(e),
                      this.opts.db.sharedStates
                        .writeUserSharedState(e, { useLegacyKey: !0 })
                        .catch(() => {}),
                    ]);
                })
              );
            };
          }
        }
        async resolveSharedStateUpdates(e) {
          const { stateId: t, stateName: n, updates: r } = e,
            s = this.tryGetStateConfig(n),
            i = this.opts.dateNow(),
            o = s.schema.global,
            a = [],
            c = r.some((e) => "createSharedState" === e.type),
            l =
              ql(s) ||
              r.some((e) => {
                const t =
                  "setUserSharedState" === e.type && 1 === e.userState.rev;
                return "postSharedStateMessage" === e.type || t;
              });
          let u;
          if (c) {
            if (
              ((u = {
                global:
                  null === o || void 0 === o ? void 0 : o.schema.getDefault(),
                lastMessageAt: i,
                users: {},
              }),
              o)
            ) {
              const e = this.writeGlobalSharedState({
                now: i,
                state: u.global,
                stateId: t,
                stateName: n,
              });
              a.push(e);
            }
          } else if (l) {
            const e = [];
            for (const t of r)
              "postSharedStateMessage" === t.type &&
                t.flushed &&
                e.push(t.message.id);
            const s = r.some((e) => "postSharedStateMessage" === e.type);
            u = await this.fetchSharedState({
              excludeMessageIds: e,
              stateName: n,
              stateId: t,
              reduceMessages: s,
            });
          }
          const d = u
              ? this.getIndexDoc({
                  now: u.lastMessageAt,
                  sharedState: u,
                  stateId: t,
                  stateName: n,
                })
              : void 0,
            h = [];
          for (const g of r)
            switch (g.type) {
              case "createSharedState":
                break;
              case "deleteUserSharedState": {
                var p;
                const e = Promise.all([
                  this.opts.db.sharedStates.deleteUserSharedState({
                    stateId: t,
                    stateName: n,
                    userId: g.userId,
                  }),
                  this.opts.db.sharedStates
                    .deleteUserSharedState({
                      stateId: t,
                      stateName: n,
                      useLegacyKey: !0,
                      userId: g.userId,
                    })
                    .catch(() => {}),
                ]);
                a.push(e),
                  null === (p = u) || void 0 === p || delete p.users[g.userId];
                break;
              }
              case "postSharedStateMessage": {
                var f;
                if (!o)
                  throw new Error(
                    "Trying to post messages to a shared state without a global schema, name: " +
                      n
                  );
                if (null === (f = u) || void 0 === f || !f.global)
                  throw new Error(
                    "Trying to post messages to a global shared state that does not exist: ".concat(
                      JSON.stringify(g)
                    )
                  );
                const e = {
                  args: g.message.args,
                  id: g.message.id,
                  name: g.message.name,
                  sender: g.message.sender,
                  stateId: t,
                  stateName: n,
                  timestamp: this.opts.dateNow() + g.message.senderClockOffset,
                };
                g.flushed ||
                  (await Dl([e], this.opts.errorReporter, {
                    sharedStateName: n,
                    sharedStateId: t,
                  }),
                  h.push(e)),
                  this.applyMessages({
                    globalItem: { state: u.global, stateId: t },
                    isSampled: Zm(),
                    messages: [e],
                    stateName: n,
                    users: u.users,
                  });
                break;
              }
              case "setUserSharedState": {
                var m;
                const e = 1 === g.userState.rev;
                if (o && (null === (m = u) || void 0 === m || !m.global) && e)
                  throw new Error(
                    "Cannot set user shared state for "
                      .concat(n, " id=")
                      .concat(t, ": global state does not exist.")
                  );
                const r = Promise.all([
                  this.opts.db.sharedStates.writeUserSharedState(g.userState),
                  this.opts.db.sharedStates
                    .writeUserSharedState(g.userState, { useLegacyKey: !0 })
                    .catch(() => {}),
                ]);
                a.push(r),
                  u && (u.users[g.userState.userId] = g.userState.state);
                break;
              }
              default:
                wc(g);
            }
          if (
            (h.length > 0 &&
              a.push(this.opts.db.sharedStates.writeSharedStateMessages(h)),
            await Promise.all(a),
            d && u)
          ) {
            const e = this.getIndexDoc({
              now: this.opts.dateNow(),
              sharedState: u,
              stateId: t,
              stateName: n,
            });
            if (c || JSON.stringify(d) !== JSON.stringify(e)) return e;
          }
        }
        getIndexDoc(e) {
          const { now: t, sharedState: n, stateId: r, stateName: s } = e,
            i = this.tryGetStateConfig(s);
          if (ql(i))
            return (function (e, t, n, r) {
              const s = () => {
                throw Error(
                  "This method is not supported by shared state computed properties"
                );
              };
              return Qf({
                api: {
                  date: { now: r },
                  chatbot: {
                    getAppleDeviceTokenUpdatedAt: s,
                    getAndroidDeviceTokenUpdatedAt: s,
                  },
                  getClockOffset: s,
                  purchases: { getPurchaseHistory: s },
                },
                computedProperties: Xf(n),
                docId: e,
                state: t,
              });
            })(r, n, i.computedProperties, () => t);
        }
        async writeGlobalSharedState(e) {
          var t, n;
          const { now: r, stateId: s, stateName: i, state: o } = e,
            a = this.tryGetStateConfig(i).schema.global;
          if (!a)
            throw Error(
              "Cannot write global shared state: no global schema in ".concat(i)
            );
          const c = {
            state: null !== o && void 0 !== o ? o : a.schema.getDefault(),
            stateId: s,
            stateName: i,
            createdAt: r,
            updatedAt: r,
            rev: 0,
            version:
              null !==
                (t =
                  null === (n = a.migrator) || void 0 === n
                    ? void 0
                    : n.getLatestVersion()) && void 0 !== t
                ? t
                : 1,
          };
          try {
            await this.opts.db.sharedStates.writeGlobalSharedState(c);
          } catch (l) {
            if (l instanceof Zl)
              throw new nl(
                "Cannot create shared state "
                  .concat(i, ": duplicate state ID ")
                  .concat(s),
                "server_error",
                "shared_state_duplicate_id"
              );
            throw l;
          }
          return c;
        }
        tryGetStateConfig(e) {
          var t;
          const n =
            null === (t = this.opts.config.sharedStates) || void 0 === t
              ? void 0
              : t[e];
          if (!n) throw Error("Invalid shared state name ".concat(e));
          return n;
        }
        migrateAndFillDefaults(e, t) {
          if (e.migrator) {
            0 === t.version && (t.version = 1);
            try {
              !(function (e, t, n) {
                const r = e.migrator.getLatestVersion();
                if (t.version < r) {
                  for (let n = t.version; n < r; n++)
                    e.migrator.applyMigration(t.state, n);
                  t.version = r;
                }
                const s = [],
                  i = e.stateSchema.tryValidateAndFillDefaults(t.state, n);
                null !== i &&
                  (s.push(...(xm(t.state, i) || [])), (t.state = i));
              })({ migrator: e.migrator, stateSchema: e.schema }, t);
            } catch (a_) {
              if (!this.isInitialDevelopment(e.migrator)) throw a_;
              (t.state = e.schema.getDefault()),
                "updatedAt" in t && (t.updatedAt = this.opts.dateNow());
            }
          }
        }
        isInitialDevelopment(e) {
          return this.opts.isInitialDevelopment() && 1 === e.getLatestVersion();
        }
        applyMessages(e) {
          var t, n;
          const { globalItem: r, messages: s, stateName: i, users: o } = e,
            a = [],
            c = [],
            l = (e, t) => {
              Xl.warn(e);
              if (!(this.opts.dateNow() - t.timestamp > Sc({ hours: 23 })))
                return;
              const n = new Error(e);
              (n.stateContext = {
                message: t,
                sharedState: { global: r.state, users: o },
              }),
                this.opts.errorReporter.captureException(n);
            },
            u =
              null === (t = this.opts.config.sharedStates) || void 0 === t
                ? void 0
                : t[i],
            d =
              null !== (n = null === u || void 0 === u ? void 0 : u.messages) &&
              void 0 !== n
                ? n
                : {},
            h = Ul(d, s, {
              onUnknownMessage: (e) => {
                c.push(e), l("Unknown message: " + e.name, e);
              },
              onInvalidArgs: (e, t) => {
                c.push(e);
                const n =
                  "Error validating args for message `" + e.name + "`: " + t;
                l(n, e);
              },
            }).filter((e) => !jl(r, e));
          if (h.length > 0) {
            const t = JSON.stringify(r.state);
            for (const s of h)
              try {
                const t = {
                    type: "sharedStateMessage",
                    name: s.name,
                    userId: r.stateId,
                  },
                  n = d[s.name].reducer;
                (e.isSampled ? Qm(n, t) : n)(
                  { global: r.state, users: o },
                  s.args,
                  { senderId: s.sender, timestamp: s.timestamp }
                ),
                  a.push(s);
              } catch (a_) {
                var p;
                const t = new nl(
                    "Error applying message "
                      .concat(s.name, " to shared state ")
                      .concat(i, ": ")
                      .concat(a_),
                    "replication_error",
                    "message_errored",
                    "fatal",
                    {
                      args: JSON.stringify(s.args),
                      receiver: r.stateId,
                      sender: s.sender,
                      timestamp: s.timestamp,
                    }
                  ),
                  [, ...n] = a_.stack.split("\n"),
                  o =
                    null === (p = t.stack) || void 0 === p
                      ? void 0
                      : p.split("\n")[0];
                (t.stack = [o, ...n].join("\n")),
                  this.opts.errorReporter.captureException(t),
                  c.push(s);
              }
            const n = u.schema.global.schema.validate(r.state);
            if (n) {
              const e =
                "Replication error: Applying messages ".concat(
                  JSON.stringify(s),
                  " "
                ) +
                "to shared state ".concat(i, " ") +
                "failed with: ".concat(n, ". ") +
                "Original shared state: ".concat(t, ". ") +
                "Invalid state after messages: ".concat(
                  JSON.stringify(r.state)
                );
              throw new nl(e, "replication_error", "invalid_message");
            }
          }
          return { reducedMessages: a, unreducedMessages: c };
        }
      }
      class mv {
        constructor(e) {
          this.db = e;
        }
        async updatePlayer(e) {
          var t;
          const { playerId: n, meta: r, nonPlayerFriendIds: s } = e,
            i = await this.db.socialGraph.getPlayer(n),
            o = [],
            a =
              null !==
                (t =
                  null === i || void 0 === i ? void 0 : i.nonPlayerFriendIds) &&
              void 0 !== t
                ? t
                : [];
          for (const c of [...a, ...s])
            a.includes(c)
              ? s.includes(c) ||
                o.push(this.db.socialGraph.removePlayerFriend(c, n))
              : o.push(this.db.socialGraph.addPlayerFriend(c, n));
          await Promise.all(o),
            (i && Wo(i.meta, r) && Wo(i.nonPlayerFriendIds, s)) ||
              (await this.db.socialGraph.createOrUpdatePlayer({
                id: n,
                nonPlayerFriendIds: s,
                meta: r,
              }));
        }
        async trackInteractions(e) {
          const { senderId: t, interactions: n } = e,
            r = {};
          for (const s of n)
            s.receiverId in r || (r[s.receiverId] = []),
              r[s.receiverId].push(s);
          await Promise.all(
            Object.entries(r).map((e) => {
              let [n, r] = e;
              return this.db.socialGraph.createInteractions(
                n,
                r.map((e) => {
                  let { meta: n, timestamp: r, type: s } = e;
                  return { meta: n, senderId: t, timestamp: r, type: s };
                })
              );
            })
          );
        }
        async getNonPlayers(e) {
          const t = await this.db.socialGraph.getNonPlayers(e),
            n = [...new Set(t.flatMap((e) => e.playerFriendIds))],
            r = await this.db.socialGraph.getPlayers(n);
          return t.map((e) => {
            let { id: t, interactions: n, playerFriendIds: s } = e;
            return {
              id: t,
              interactions: n,
              playerFriends: s
                .filter((e) => e in r)
                .map((e) => ({ id: e, meta: r[e].meta })),
            };
          });
        }
      }
      class gv {
        constructor(e) {
          this.opts = e;
        }
        async encryptUserId(e) {
          const t = await this.getEncryptionKey(),
            n = (function (e) {
              return new Uint8Array(Array.from(e).map((e) => e.charCodeAt(0)));
            })(this.opts.crypto.createSHA256Hash(e, "hex")).slice(0, 12);
          return this.opts.crypto.aesEncrypt(t, e, n);
        }
        async decryptUserId(e) {
          const t = await this.getEncryptionKey();
          return this.opts.crypto.aesDecrypt(t, e, 12);
        }
        getEncryptionKey() {
          if (!this.encryptionKeyPromise) {
            if (
              !{
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.USER_ID_ENCRYPTION_KEY
            )
              throw Error(
                "USER_ID_ENCRYPTION_KEY environment variable is required for user ID encryption"
              );
            this.encryptionKeyPromise = this.opts.crypto.importAesKey(
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.USER_ID_ENCRYPTION_KEY
            );
          }
          return this.encryptionKeyPromise;
        }
      }
      const vv = _a
          .object({
            field: _a.tuple(["comments"]),
            value: _a
              .object({
                from: _a
                  .object({ id: _a.string(), username: _a.string() })
                  .additionalProperties(),
                id: _a.string(),
                media: _a
                  .object({ id: _a.string(), media_product_type: _a.string() })
                  .additionalProperties(),
                text: _a.string(),
              })
              .additionalProperties(),
          })
          .additionalProperties(),
        yv = { sender: _a.object({ id: _a.string() }).additionalProperties() },
        bv = _a
          .object({
            ...yv,
            message: _a
              .object({ mid: _a.string(), text: _a.string().optional() })
              .additionalProperties(),
          })
          .additionalProperties(),
        wv = _a
          .object({
            ...yv,
            reaction: _a
              .object({ mid: _a.string(), reaction: _a.string().optional() })
              .additionalProperties()
              .optional(),
          })
          .additionalProperties(),
        Sv = _a
          .object({
            ...yv,
            postback: _a
              .object({
                mid: _a.string(),
                referral: _a
                  .object({ ref: _a.string().optional() })
                  .additionalProperties()
                  .optional(),
              })
              .additionalProperties(),
          })
          .additionalProperties(),
        _v = _a
          .object({
            ...yv,
            referral: _a
              .object({ ref: _a.string().optional() })
              .additionalProperties(),
          })
          .additionalProperties(),
        Ev = _a.union([bv, wv, Sv, _v]),
        Av = _a
          .object({
            object: _a.tuple(["instagram"]),
            entry: _a.array(
              _a
                .object({
                  changes: _a.array(_a.unknown()).optional(),
                  messaging: _a.array(_a.unknown()).optional(),
                })
                .additionalProperties()
            ),
          })
          .additionalProperties();
      class Tv {
        constructor(e) {
          this.opts = e;
        }
        async handleWebhook(e) {
          if (!Av.isValid(e)) {
            const t = Error("Unexpected Instagram webhook request body");
            throw ((t.requestBody = e), t);
          }
          const t = [
            ...e.entry
              .flatMap((e) => {
                var t;
                return null !== (t = e.changes) && void 0 !== t ? t : [];
              })
              .filter((e) => vv.isValid(e))
              .map((e) => ({ ...e, platform: "instagram" })),
            ...e.entry
              .flatMap((e) => {
                var t;
                return null !== (t = e.messaging) && void 0 !== t ? t : [];
              })
              .filter((e) => Ev.isValid(e))
              .map((e) => ({ ...e, platform: "instagram" })),
          ];
          if (0 === t.length) return;
          const n = t.map((e) =>
            (function (e) {
              return { user_id: Pv(e), event_type: Cc, event_properties: e };
            })(e)
          );
          await Promise.all([
            this.opts.sendAnalyticsEvents(n),
            this.handleEvents(t),
          ]);
        }
        async handleEvents(e) {
          var t;
          const n =
            null === (t = this.opts.config.chatbot) ||
            void 0 === t ||
            null === (t = t.events) ||
            void 0 === t
              ? void 0
              : t.onWebhook;
          if (!n) return;
          const r = dl(e, Pv),
            s = {},
            i = Object.entries(r).map(async (e) => {
              let [t, r] = e;
              try {
                var i;
                const { entry: e } = await this.opts.getReadOnlyEntry(t, {
                  assignABTests: this.opts.config.assignAbTestsOnWebhook,
                  createIfNotFound: !0,
                });
                (null !== (i = e.chatbotMetainfo) &&
                  void 0 !== i &&
                  i.instagramMessengerId) ||
                  (await this.opts.db.chatbot.setInstagramMessengerId({
                    userId: t,
                    instagramMessengerId: t,
                  }));
                const o = [],
                  a = await this.opts.createEventHandlerApi({
                    consistentFetchIds: [],
                    delayedActions: o,
                    entry: e,
                    userId: t,
                  }),
                  c = async () => {
                    for (const t of r) await n(e.state, t, a);
                    await this.opts.resolveDelayedActions(o);
                  },
                  l = await uv(t, e, this.opts.config, this.opts.dateNow, () =>
                    Dm({
                      db: this.opts.db,
                      entry: e,
                      event: { type: "onWebhook" },
                      eventHandler: c,
                      now: this.opts.dateNow(),
                      userId: t,
                    })
                  );
                l && (s[t] = l);
              } catch (o) {
                const e = new nl(
                  "IG webhook event handler failed: " + o.message,
                  "server_error"
                );
                (e.extras = { events: r, reason: o }),
                  (e.stack = o.stack),
                  await this.opts.errorReporter.captureException(e);
              }
            });
          await Promise.all(i), await this.opts.pushDocsToIndex(s);
        }
      }
      function Pv(e) {
        return (function (e) {
          return "comments" === e.field;
        })(e)
          ? e.value.from.id
          : e.sender.id;
      }
      class Iv {
        constructor(e) {
          this.opts = e;
        }
        async handleEvents(e) {
          const t = [],
            n = (function (e) {
              const t = {};
              return (
                e
                  .filter(
                    (t) =>
                      !["follow", "unfollow"].includes(t.type) ||
                      !e.some((e) => {
                        let { source: n, timestamp: r, type: s } = e;
                        return (
                          ["follow", "unfollow"].includes(s) &&
                          n.userId === t.source.userId &&
                          r > t.timestamp
                        );
                      })
                  )
                  .forEach((e) => {
                    t[e.source.userId] || (t[e.source.userId] = []),
                      t[e.source.userId].push(e);
                  }),
                t
              );
            })(e.filter((e) => !e.deliveryContext.isRedelivery)),
            r = {},
            s = Object.entries(n).map(async (e) => {
              var n, s;
              let i,
                o,
                [a, c] = e;
              const { enabledWebhookEvents: l, onWebhook: u } =
                  null !==
                    (n =
                      null === (s = this.opts.config.chatbot) || void 0 === s
                        ? void 0
                        : s.events) && void 0 !== n
                    ? n
                    : {},
                d =
                  u &&
                  c.some((e) =>
                    null === l || void 0 === l ? void 0 : l.includes(e.type)
                  ),
                h = [];
              var p;
              d &&
                ((i =
                  null ===
                    (p = await this.opts.getReadOnlyEntry(a, {
                      assignABTests: this.opts.config.assignAbTestsOnWebhook,
                      createIfNotFound: !0,
                    })) || void 0 === p
                    ? void 0
                    : p.entry),
                (o = await this.opts.createEventHandlerApi({
                  consistentFetchIds: [],
                  delayedActions: h,
                  entry: i,
                  userId: a,
                })));
              const f = async () => {
                for (const e of c) await this.handleEvent(e, t, i, o);
                await this.opts.resolveDelayedActions(h);
              };
              try {
                if (i) {
                  const e = await uv(
                    a,
                    i,
                    this.opts.config,
                    this.opts.dateNow,
                    () =>
                      Dm({
                        db: this.opts.db,
                        entry: i,
                        event: { type: "onWebhook" },
                        eventHandler: f,
                        now: this.opts.dateNow(),
                        userId: a,
                      })
                  );
                  e && (r[a] = e);
                } else await f();
              } catch (m) {
                const e = new nl(
                  "LINE webhook event handler failed: " + m.message,
                  "server_error"
                );
                (e.extras = { events: c, reason: m }),
                  (e.stack = m.stack),
                  await this.opts.errorReporter.captureException(e);
              }
            });
          await Promise.all(s),
            await Promise.all([
              t.length > 0 ? this.opts.sendAnalyticsEvents(t) : void 0,
              this.opts.pushDocsToIndex(r),
            ]);
        }
        async handleEvent(e, t, n, r) {
          var s, i, o;
          if ("follow" === e.type)
            t.push(
              (function (e) {
                var t;
                return {
                  user_id: e.source.userId,
                  event_type: Pc,
                  event_properties: {
                    isUnblocked:
                      null === (t = e.follow) || void 0 === t
                        ? void 0
                        : t.isUnblocked,
                    timestampFromLine: e.timestamp,
                  },
                };
              })(e)
            ),
              await this.opts.db.chatbot.markSubscribed(
                e.source.userId,
                !0,
                this.opts.dateNow()
              );
          else if ("unfollow" === e.type) {
            const r = n
              ? n.chatbotMetainfo
              : await this.opts.db.chatbot.fetchMetainfo(e.source.userId);
            t.push(
              (function (e, t) {
                const n = {
                  user_id: e.source.userId,
                  event_type: Ic,
                  event_properties: { timestampFromLine: e.timestamp },
                };
                if (t) {
                  const r = e.timestamp - t.timestamp;
                  n.event_properties = {
                    ...n.event_properties,
                    latestChatbotReceivedMessagePayload: t,
                    latestChatbotTimeSinceLastReceivedMessage: r,
                  };
                }
                return n;
              })(
                e,
                null === r || void 0 === r
                  ? void 0
                  : r.lastReceivedMessagePayload
              )
            ),
              await this.opts.db.chatbot.markSubscribed(
                e.source.userId,
                !1,
                this.opts.dateNow()
              );
          }
          const { enabledWebhookEvents: a, onWebhook: c } =
            null !==
              (s =
                null === (i = this.opts.config.chatbot) || void 0 === i
                  ? void 0
                  : i.events) && void 0 !== s
              ? s
              : {};
          if (c && (null === a || void 0 === a ? void 0 : a.includes(e.type))) {
            if (!n || !r) throw Error("entry or eventHandlerApi is undefined");
            t.push(
              (function (e) {
                return {
                  user_id: e.source.userId,
                  event_type: Cc,
                  event_properties: { ...e, timestampFromLine: e.timestamp },
                };
              })(e)
            ),
              "message" !== e.type ||
                (null !== (o = n.chatbotMetainfo) &&
                  void 0 !== o &&
                  o.subscribed) ||
                (n.chatbotMetainfo = await this.opts.db.chatbot.markSubscribed(
                  n.state.id,
                  !0,
                  this.opts.dateNow()
                )),
              await c(n.state, e, r);
          }
        }
      }
      const Cv = _a
          .object({
            field: _a.tuple(["feed"]),
            value: _a
              .object({
                from: _a.object({ id: _a.string() }).additionalProperties(),
              })
              .additionalProperties(),
          })
          .additionalProperties(),
        kv = {
          sender: _a.object({ id: _a.string() }).additionalProperties(),
          recipient: _a.object({ id: _a.string() }).additionalProperties(),
          timestamp: _a.int(),
        },
        Ov = _a
          .object({
            sender: kv.sender,
            recipient: kv.recipient,
            delivery: _a
              .object({ mids: _a.array(_a.string()), watermark: _a.int() })
              .additionalProperties(),
          })
          .additionalProperties(),
        xv = _a
          .object({
            ...kv,
            message: _a
              .object({ mid: _a.string(), text: _a.string().optional() })
              .additionalProperties(),
          })
          .additionalProperties(),
        Nv = _a
          .object({
            ...kv,
            postback: _a
              .object({
                mid: _a.string(),
                referral: _a
                  .object({ ref: _a.string().optional() })
                  .additionalProperties()
                  .optional(),
              })
              .additionalProperties(),
          })
          .additionalProperties(),
        Rv = _a
          .object({
            ...kv,
            read: _a.object({ watermark: _a.int() }).additionalProperties(),
          })
          .additionalProperties(),
        Dv = _a
          .object({
            ...kv,
            referral: _a
              .object({ ref: _a.string().optional() })
              .additionalProperties(),
          })
          .additionalProperties(),
        Mv = _a.union([Ov, xv, Nv, Rv, Dv]),
        jv = _a
          .object({
            object: _a.tuple(["page"]),
            entry: _a.array(
              _a
                .object({
                  changes: _a.array(_a.unknown()).optional(),
                  messaging: _a.array(_a.unknown()).optional(),
                })
                .additionalProperties()
            ),
          })
          .additionalProperties();
      class Lv {
        constructor(e) {
          this.opts = e;
        }
        async handleWebhook(e) {
          if (!jv.isValid(e)) {
            const t = Error("Unexpected Messenger webhook request body");
            throw ((t.requestBody = e), t);
          }
          const t = [
            ...e.entry
              .flatMap((e) => {
                var t;
                return null !== (t = e.changes) && void 0 !== t ? t : [];
              })
              .filter((e) => Cv.isValid(e))
              .map((e) => ({ ...e, platform: "messenger" })),
            ...e.entry
              .flatMap((e) => {
                var t;
                return null !== (t = e.messaging) && void 0 !== t ? t : [];
              })
              .filter((e) => Mv.isValid(e))
              .map((e) => ({ ...e, platform: "messenger" })),
          ];
          if (0 === t.length) return;
          const n = t.map((e) =>
            (function (e) {
              return { user_id: Uv(e), event_type: Cc, event_properties: e };
            })(e)
          );
          await Promise.all([
            this.opts.sendAnalyticsEvents(n),
            this.handleEvents(t),
          ]);
        }
        async handleEvents(e) {
          var t;
          const n =
            null === (t = this.opts.config.chatbot) ||
            void 0 === t ||
            null === (t = t.events) ||
            void 0 === t
              ? void 0
              : t.onWebhook;
          if (!n) return;
          const r = {},
            s = dl(e, Uv),
            i = Object.entries(s).map(async (e) => {
              let [t, s] = e;
              try {
                var i;
                const { entry: e } = await this.opts.getReadOnlyEntry(t, {
                  assignABTests: this.opts.config.assignAbTestsOnWebhook,
                  createIfNotFound: !0,
                });
                (null !== (i = e.chatbotMetainfo) &&
                  void 0 !== i &&
                  i.messengerId) ||
                  (await this.opts.db.chatbot.setMessengerId(t, t));
                const o = [],
                  a = await this.opts.createEventHandlerApi({
                    consistentFetchIds: [],
                    delayedActions: o,
                    entry: e,
                    userId: t,
                  }),
                  c = async () => {
                    for (const t of s) await n(e.state, t, a);
                    await this.opts.resolveDelayedActions(o);
                  },
                  l = await uv(t, e, this.opts.config, this.opts.dateNow, () =>
                    Dm({
                      db: this.opts.db,
                      entry: e,
                      event: { type: "onWebhook" },
                      eventHandler: c,
                      now: this.opts.dateNow(),
                      userId: t,
                    })
                  );
                l && (r[t] = l);
              } catch (o) {
                const e = new nl(
                  "Messenger webhook event handler failed: " + o.message,
                  "server_error"
                );
                (e.extras = { events: s, reason: o }),
                  (e.stack = o.stack),
                  await this.opts.errorReporter.captureException(e);
              }
            });
          await Promise.all(i), await this.opts.pushDocsToIndex(r);
        }
      }
      function Uv(e) {
        return (function (e) {
          return "feed" === e.field;
        })(e)
          ? e.value.from.id
          : e.sender.id;
      }
      const Fv = _a.object({ id: _a.int() }).additionalProperties(),
        Bv = _a
          .object({
            id: _a.int(),
            is_bot: _a.boolean(),
            first_name: _a.string(),
            last_name: _a.string().optional(),
            language_code: _a.string().optional(),
            username: _a.string().optional(),
          })
          .additionalProperties(),
        Vv = _a
          .object({
            chat: Fv,
            message_id: _a.int(),
            from: Bv.optional(),
            date: _a.int(),
            text: _a.string().optional(),
          })
          .additionalProperties(),
        qv = _a
          .object({ update_id: _a.int(), message: Vv.optional() })
          .additionalProperties();
      function Hv(e, t) {
        return { user_id: e, event_type: Cc, event_properties: t };
      }
      class Wv {
        constructor(e) {
          this.opts = e;
        }
        async handleEvent(e) {
          var t, n;
          if ("app_deauthorized" !== e.event)
            throw Error("Invalid Zoom webhook event: " + JSON.stringify(e));
          const r =
            null === (t = this.opts.config.chatbot) ||
            void 0 === t ||
            null === (t = t.events) ||
            void 0 === t
              ? void 0
              : t.onWebhook;
          if (!r) return;
          const s = e.payload.user_id,
            i =
              null === (n = await this.opts.getReadOnlyEntry(s)) || void 0 === n
                ? void 0
                : n.entry;
          if (!i) {
            const e = Error(
              "Zoom webhook failed: Replicant user does not exist"
            );
            throw ((e.userId = s), e);
          }
          await this.opts.sendAnalyticsEvents([Kv(e)]);
          const o = [],
            a = await this.opts.createEventHandlerApi({
              consistentFetchIds: [],
              delayedActions: o,
              entry: i,
              userId: s,
            }),
            c = async () => {
              await r(i.state, e, a), await this.opts.resolveDelayedActions(o);
            },
            l = await uv(s, i, this.opts.config, this.opts.dateNow, () =>
              Dm({
                db: this.opts.db,
                entry: i,
                event: { type: "onWebhook" },
                eventHandler: c,
                now: this.opts.dateNow(),
                userId: s,
              })
            );
          l && (await this.opts.pushDocsToIndex({ [s]: l }));
        }
      }
      function Kv(e) {
        return {
          user_id: e.payload.user_id,
          event_type: Cc,
          event_properties: { webhookEventType: e.event },
        };
      }
      class zv {
        constructor(e, t) {
          var n,
            r,
            s,
            i,
            o,
            a,
            c,
            l,
            u = this;
          (this.config = e),
            (this.opts = t),
            (this.handleAfterContextSwitchHook = this.handler(async (e) => {
              if ("fb" !== this.platform) return;
              const t = await this.db.metainfoMVCC.addCancelledOnGameEndEventId(
                e.id,
                e.contextSwitchEventId
              );
              await this.systemScheduledActions.unschedule({
                notificationId: xg,
                userData: { metainfoMVCC: t },
                userId: e.id,
              });
            })),
            (this.handleCreateOrLogin = this.handler(async (e) => {
              var t;
              const {
                  id: n,
                  onLoginActionArgs: r,
                  sessionId: s,
                  sessionName: i,
                  ip: o,
                  prefetchKeys: a,
                  prefetchInternalKeys: c,
                  skipOnLoginAction: l,
                } = e,
                u = this.abTests.getDynamicConfig().then((e) => e.abTests),
                d =
                  null !== a && void 0 !== a && a.length
                    ? this.kvStore.getBatch(a).catch(async (e) => {
                        await this.errorReporter.captureException(e);
                      })
                    : Promise.resolve(),
                h =
                  null !== c && void 0 !== c && c.length
                    ? this.internalKvStore.getBatch(c).catch(async (e) => {
                        await this.errorReporter.captureException(e);
                      })
                    : Promise.resolve(),
                p = this.getExtraLoginData(o);
              Xl.debug("REPLICANT: createOrLogin", n);
              const {
                  entry: f,
                  entryDiffs: m,
                  messages: g,
                } = await this.db.fetch(n, { consistentRead: !1 }),
                v = null === f,
                y =
                  null !==
                    (t =
                      null === f || void 0 === f
                        ? void 0
                        : f.metainfo.abTestAssignments) && void 0 !== t
                    ? t
                    : {},
                b =
                  f && this.opts.stripe
                    ? Wf({
                        dateNow: this.devOpts.dateNow,
                        db: this.db,
                        metainfoMVCC: f.metainfoMVCC,
                        reportError: (e) => this.reportError(e),
                        stripe: this.opts.stripe,
                        userId: n,
                      })
                    : void 0;
              try {
                var w, S;
                let t = await this.createOrLoginHandler.createOrLogin({
                  clientAppName: e.clientAppName,
                  getAbTestAssignments: (e) => {
                    var t, n, r;
                    return this.abTests.getAssignments({
                      currentAssignments:
                        null !==
                          (t =
                            null === (n = e.entry) || void 0 === n
                              ? void 0
                              : n.metainfo.abTestAssignments) && void 0 !== t
                          ? t
                          : {},
                      isNewUser: e.isNewUser,
                      userId: e.userId,
                      userState:
                        null === (r = e.entry) || void 0 === r
                          ? void 0
                          : r.state,
                    });
                  },
                  id: n,
                  sessionId: s,
                  sessionName: i,
                  entry: f,
                });
                const o = [];
                if (
                  this.config.onLoginAction &&
                  !this.config.actions[this.config.onLoginAction]
                )
                  throw Error(
                    "Invalid onLoginAction: '".concat(
                      this.config.onLoginAction,
                      "' not found in config.actions"
                    )
                  );
                const a =
                  !l && this.config.onLoginAction
                    ? this.config.actions[this.config.onLoginAction]
                    : void 0;
                g.length > 0 &&
                  "async" !== (null === a || void 0 === a ? void 0 : a.type) &&
                  o.push({ async: !1, fn: zc, args: g.map((e) => e.id) }),
                  a &&
                    o.push({
                      async: "async" === a.type,
                      fn: this.config.onLoginAction,
                      args: r,
                      isLogin: !0,
                    });
                const c =
                  null !== (w = this.config.modules) && void 0 !== w ? w : [];
                for (const e of c)
                  if (e.config.onLoginAction) {
                    const t = ""
                        .concat(e.name, ".")
                        .concat(e.config.onLoginAction),
                      n = Ko(e.config.actions, t);
                    if (!n)
                      throw Error(
                        "Invalid onLoginAction in module '"
                          .concat(e.name, "': '")
                          .concat(
                            e.config.onLoginAction,
                            "' not found in config.actions."
                          )
                          .concat(e.name)
                      );
                    o.push({ async: "async" === n.type, fn: t, isLogin: !0 });
                  }
                const _ = {};
                for (const [e, n] of Object.entries(await u)) {
                  if (!n) continue;
                  const {
                    active: t,
                    rollOut: r,
                    newUsersRollOut: s,
                    stopAssignment: i,
                  } = n;
                  _[e] = {
                    active: t,
                    rollOut: v && void 0 !== s ? s : r,
                    stopAssignment: i,
                  };
                }
                if (o.length > 0) {
                  t = (
                    await this.replicateHandler.replicate({
                      abTestsDynamicConfig: _,
                      consistentFetchIds: [n],
                      entry: t,
                      entryDiffs: m,
                      id: n,
                      messages: g,
                      queue: o,
                      sessionId: s,
                      sessionName: i,
                    })
                  ).entry;
                }
                const E = this.opts.encodeToken({
                  playerId: n,
                  appName: jm(this.config),
                  dateNow: this.devOpts.dateNow,
                });
                if (this.supportsIndexing) {
                  const e = Yf(n, t, this.config, this.devOpts.dateNow);
                  await this.pushDocsToIndex({ [n]: e });
                }
                const [A, T, P, I] = await Promise.all([p, b, d, h]);
                T && (t.metainfoMVCC.paymentSubscription = T);
                const C = this.devOpts.userAssetsBaseUrl,
                  k = this.devOpts.chatbotAssetUrls,
                  O = bl({
                    oldAssignments: y,
                    newAssignments:
                      null !== (S = t.metainfo.abTestAssignments) &&
                      void 0 !== S
                        ? S
                        : {},
                  });
                return {
                  ...t,
                  abTestsDynamicConfig: _,
                  prefetchedKeys: P || void 0,
                  prefetchedInternalKeys: I || void 0,
                  token: E,
                  userAssetsBaseUrl: C,
                  chatbotAssetUrls: k,
                  extraData: A,
                  abTestChangeEvents: O,
                };
              } catch (a_) {
                throw (
                  ((a_.stateContext = { id: n, entry: f, messages: g }), a_)
                );
              }
            })),
            (this.handleGetToken = this.handler(async (e) => {
              try {
                return {
                  token: this.opts.encodeToken({
                    playerId: e,
                    appName: jm(this.config),
                    dateNow: this.devOpts.dateNow,
                  }),
                };
              } catch (a_) {
                throw ((a_.stateContext = { id: e }), a_);
              }
            })),
            (this.handleReplicate = this.handler(async (e) => {
              const t = {};
              try {
                return await this.replicateHandler.handleReplicateRequest({
                  ...e,
                  pushDocToIndex: (e, t) => this.pushDocsToIndex({ [e]: t }),
                  stateContext: t,
                });
              } catch (a_) {
                throw (
                  ((a_.stateContext = t),
                  (a_.code = a_.code || $c.replication_error),
                  a_)
                );
              }
            })),
            (this.handleFetchStates = this.handler((e, t, n) =>
              this.fetchStatesHandler.fetchStates(e, {
                friendRevs: t,
                consistentFetchIds: n,
              })
            )),
            (this.handleInferGenderFromName = this.handler(async (e) => {
              try {
                return await this.devOpts.inferGenderFromName(e);
              } catch (t) {
                const e = new nl(
                  t.message,
                  "server_error",
                  "gender_inference_error"
                );
                throw ((e.stack = t.stack), e);
              }
            })),
            (this.handleOtpInitiate = this.handler(async (e) =>
              this.otp.initiateOtp(e)
            )),
            (this.handleSocialGraphUpdateSelf = this.handler(async (e) => {
              await this.socialGraph.updatePlayer(e);
            })),
            (this.handleSocialGraphTrackInteractions = this.handler(
              async (e) => {
                await this.socialGraph.trackInteractions(e);
              }
            )),
            (this.handleUserAssetUpload = this.handler(async (e) => ({
              assetUrl: await this.assetUploader.uploadDataURLAsset(e),
            }))),
            (this.handleWriteKvPairs = this.handler(
              async (e, t) => (await this.kvStore.sendBatch(e, t), !0)
            )),
            (this.handleFetchKvPairs = this.handler(async (e) =>
              this.kvStore.getBatch(e)
            )),
            (this.handleFetchInternalKvPairs = this.handler(async (e) =>
              this.internalKvStore.getBatch(e)
            )),
            (this.handleNukeUser = this.handler(async (e) => {
              e.sources ||
                (e.sources = {
                  amplitude: !1,
                  sentry: !1,
                  replicant: !0,
                  indexDB: !0,
                });
              const t = [],
                n = [],
                r = [];
              e.sources.amplitude,
                e.sources.sentry,
                e.sources.indexDB &&
                  this.supportsIndexing &&
                  (this.opts.indexDB
                    ? (r.push("indexDB"),
                      t.push(this.opts.indexDB.delete(e.userId)))
                    : n.push("indexDB undefined")),
                e.sources.replicant &&
                  (r.push("replicant"), t.push(this.db.delete(e.userId)));
              if (
                ((await Promise.allSettled(t)).forEach((e, t) => {
                  "rejected" === e.status && n.push(r[t] + " - " + e.reason);
                }),
                n.length > 0)
              )
                throw new Error(n.join("; "));
            })),
            (this.handleNukeDB = this.handler(async () => {
              var e;
              (await this.db.nukeDB(), this.supportsIndexing) &&
                (await (null === (e = this.opts.indexDB) || void 0 === e
                  ? void 0
                  : e.recreateIndex()));
              this.opts.sharedStateIndexDBs &&
                (await Promise.all(
                  Object.values(this.opts.sharedStateIndexDBs).map((e) =>
                    e.recreateIndex()
                  )
                ));
            })),
            (this.handleSetTestUsers = this.handler(async (e, t) => {
              const n = await Promise.all(
                Object.entries(t).map(async (t) => {
                  let [n, r] = t;
                  const s = e + "_" + n;
                  let i = Qo(this.config.stateSchema.getDefault(), r);
                  try {
                    i = this.stateSchema.tryDecode(i);
                  } catch (a_) {
                    throw ((a_.stateContext = { id: s }), a_);
                  }
                  const { entry: o, messages: a } = await this.db.fetch(s);
                  try {
                    const e = {
                      ...(await this.createOrLoginHandler.createOrLogin({
                        id: s,
                        entry: o,
                      })),
                      state: i,
                    };
                    if (
                      (await this.db.write(s, e),
                      a.length > 0 && (await this.db.deleteMessages(s, a)),
                      this.supportsIndexing)
                    ) {
                      const t = Yf(s, e, this.config, this.devOpts.dateNow);
                      await this.pushDocsToIndex({ [s]: t });
                    }
                  } catch (a_) {
                    throw (
                      ((a_.stateContext = { id: s, entry: o, messages: a }), a_)
                    );
                  }
                  return { [n]: s };
                })
              );
              return { testUsersMap: Object.assign({}, ...n) };
            })),
            (this.handleAdminAction = this.handler(async (e, t) =>
              this.adminHandler.handleAdminAction({ action: e, args: t })
            )),
            (this.handleIOSBridgeFetch = this.handler(async (e, t) => {
              const n = "ios_" + e + "_" + t,
                r = await this.db.kvStore.fetch(n, this.devOpts.dateNow());
              return r && (await this.db.kvStore.delete(n)), r;
            })),
            (this.handleIOSBridgePut = this.handler(async (e, t, n, r) => {
              const s = "ios_" + e + "_" + t;
              if (n.length >= 1e5)
                throw new nl(
                  "iOS bridge payload too large",
                  "server_error",
                  "payload_too_large"
                );
              await this.db.kvStore.write(s, n, r);
            })),
            (this.handleIOSPostAPN = this.handler(async (e) => {
              let {
                receiverId: t,
                notification: n,
                payload: r,
                imageUrl: s,
                analyticsUserProps: i,
              } = e;
              const o = await this.db.chatbot.fetchMetainfo(t);
              return this.doIOSPostAPN({
                receiverId: t,
                receiverChatbotMetainfo: null !== o && void 0 !== o ? o : {},
                notification: n,
                payload: r,
                imageUrl: s,
                analyticsUserProps: i,
              });
            })),
            (this.handleAndroidPushNotification = this.handler(async (e) => {
              let {
                receiverId: t,
                notification: n,
                payload: r,
                imageUrl: s,
                analyticsUserProps: i,
              } = e;
              const o = await this.db.chatbot.fetchMetainfo(t);
              return this.doAndroidPushNotification({
                receiverId: t,
                receiverChatbotMetainfo: null !== o && void 0 !== o ? o : {},
                notification: n,
                payload: r,
                imageUrl: s,
                analyticsUserProps: i,
              });
            })),
            (this.handlePushNotification = this.handler(async (e) => {
              let {
                receiverId: t,
                notificationPlatformProps: n,
                payload: r,
                imageUrl: s,
                analyticsUserProps: i,
              } = e;
              const o = await this.db.chatbot.fetchMetainfo(t),
                a = await Promise.all([
                  this.doIOSPostAPN({
                    receiverId: t,
                    receiverChatbotMetainfo:
                      null !== o && void 0 !== o ? o : {},
                    notification: n.ios,
                    payload: r,
                    imageUrl: s,
                    analyticsUserProps: i,
                  }),
                  this.doAndroidPushNotification({
                    receiverId: t,
                    receiverChatbotMetainfo:
                      null !== o && void 0 !== o ? o : {},
                    notification: n.android,
                    payload: r,
                    imageUrl: s,
                    analyticsUserProps: i,
                  }),
                ]);
              return { ios: a[0], android: a[1] };
            })),
            (this.changesetsFlushedPromise = Promise.resolve()),
            (this.handleFBWebhook = async (e) => {
              var t;
              await (null === (t = this.fbWebhookHandler) || void 0 === t
                ? void 0
                : t.call(this, e));
            }),
            (this.handleInstagramWebhook = async (e) => {
              await this.instagramWebhookHandler.handleWebhook(e);
            }),
            (this.handleMessengerWebhook = async (e) => {
              await this.messengerWebhookHandler.handleWebhook(e);
            }),
            (this.handleAtoneWebhook = async (e) => {
              if (!this.atoneWebhookHandler)
                throw Error(
                  "Atone webhook handler is not configured. Make sure to define the ATONE_* environment variables."
                );
              await this.atoneWebhookHandler.handleEvent(e);
            }),
            (this.handleKomojuWebhook = async (e) => {
              if (!this.komojuWebhookHandler)
                throw Error(
                  "Komoju webhook handler is not configured. Make sure to define the KOMOJU_* environment variables."
                );
              await this.komojuWebhookHandler.handleEvent(e);
            }),
            (this.handleXsollaWebhook = async (e) => {
              if (!this.xsollaWebhookHandler)
                throw Error(
                  "Xsolla webhook handler is not configured. Make sure to define the XSOLLA_* environment variables."
                );
              await this.xsollaWebhookHandler.handleEvent(e);
            }),
            (this.handleLineWebhook = async (e) => {
              var t;
              await (null === (t = this.lineWebhookHandler) || void 0 === t
                ? void 0
                : t.handleEvents(e));
            }),
            (this.handleStripeWebhook = async (e) => {
              var t;
              await (null === (t = this.stripeWebhookHandler) || void 0 === t
                ? void 0
                : t.call(this, e));
            }),
            (this.handleTelegramWebhook = async (e) => {
              await this.telegramWebhookHandler.handleEvent(e);
            }),
            (this.handleZoomWebhook = async (e) => {
              var t;
              await (null === (t = this.zoomWebhookHandler) || void 0 === t
                ? void 0
                : t.handleEvent(e));
            }),
            (this.postMessages = async (e) => {
              var t;
              const n = e.receiverId,
                r = e.messages.map((e) => e.id),
                { entryPromises: s } =
                  null !== (t = e.context) && void 0 !== t
                    ? t
                    : { entryPromises: {} };
              s[n] ||
                (s[n] = this.getReadOnlyEntry(n, {
                  skipMessageIds: r,
                  skipWrites: !0,
                }).then((e) => {
                  var t;
                  return null !==
                    (t = null === e || void 0 === e ? void 0 : e.entry) &&
                    void 0 !== t
                    ? t
                    : null;
                }));
              const i = await s[n];
              if (!i) {
                if (!1 === this.config.throwOnMessageReceiverNotFound)
                  return {};
                throw new Error(
                  "Trying to post a message to a user that does not exist. id: " +
                    n +
                    ", messages: " +
                    JSON.stringify(e.messages)
                );
              }
              const o = Bm(this.config, i);
              await Dl(e.messages, this.errorReporter, {
                receiverId: e.receiverId,
              });
              const a = e.messages.map((e) => ({
                  id: e.id,
                  name: e.name,
                  args: e.args,
                  sender: e.sender,
                  timestamp: this.devOpts.dateNow() + e.senderClockOffset,
                })),
                c = a.filter((t, n) => !e.messages[n].skipDbWrite);
              c.length > 0 && (await this.db.writeMessages(n, c));
              const l = e.messages.every((e) => e.skipIndexing);
              if (this.supportsIndexing && !l) {
                const e = await uv(
                  n,
                  o.entry,
                  this.config,
                  this.devOpts.dateNow,
                  () => this.migrateAndApplyMessages(n, o, a)
                );
                if (e) return { [n]: e };
              }
              return {};
            }),
            (this.resolveDelayedActions = async (e, t) => {
              var n;
              if (0 === e.length) return;
              const r = [],
                s = [],
                i = [],
                o = [],
                a = [],
                c =
                  null === t ||
                  void 0 === t ||
                  null === (n = t.performanceTracking) ||
                  void 0 === n
                    ? void 0
                    : n.context;
              for (const f of e)
                if ("action" === f.type) {
                  const e = c ? Qm(f.action, c, f.apiMethodName) : f.action;
                  r.push(e());
                } else if (
                  "createSharedState" === f.type ||
                  "deleteUserSharedState" === f.type ||
                  "postSharedStateMessage" === f.type ||
                  "setUserSharedState" === f.type
                )
                  a.push(f);
                else if ("sendAnalyticsEvents" === f.type) i.push(...f.events);
                else if ("postMessage" === f.type) {
                  const e = s.find(
                    (e) => e.type === f.type && e.receiverId === f.receiverId
                  );
                  e ? e.messages.push(...f.messages) : s.push(f);
                } else
                  "scheduleAction" === f.type || "unscheduleAction" === f.type
                    ? o.push(f)
                    : wc(f);
              const l = {
                postMessages: this.postMessages.bind(this),
                resolveActionScheduleUpdates: Uf,
                resolveSharedStatesUpdates:
                  this.sharedStates.resolveAllSharedStatesUpdates.bind(
                    this.sharedStates
                  ),
                sendAnalyticsEvents: this.sendAnalyticsEvents.bind(this),
              };
              function u(e, t) {
                l[e] = Qm(l[e], c, t);
              }
              c &&
                (u("postMessages", "api.postMessage.*"),
                u("resolveActionScheduleUpdates", "api.scheduledActions.*"),
                u("resolveSharedStatesUpdates", "api.sharedStates.*"),
                u("sendAnalyticsEvents", "api.sendAnalyticsEvents")),
                i.length > 0 && r.push(l.sendAnalyticsEvents(i, t)),
                o.length > 0 &&
                  r.push(
                    l.resolveActionScheduleUpdates({
                      db: this.db,
                      errorReporter: this.errorReporter,
                      now: this.devOpts.dateNow(),
                      scheduleUpdates: o,
                    })
                  ),
                a.length > 0 &&
                  r.push(
                    l.resolveSharedStatesUpdates(a).then(async (e) => {
                      const t = [];
                      for (const n in e)
                        for (const r in e[n]) {
                          const s = e[n][r];
                          t.push(
                            this.pushSharedStateDocToIndex({
                              stateName: n,
                              stateId: r,
                              indexDoc: s,
                            })
                          );
                        }
                      await Promise.all(t);
                    })
                  ),
                this.lineMessageClient &&
                  r.push(this.lineMessageClient.flush());
              const d = Promise.all(
                s.map(async (e) => {
                  if ("postMessage" === e.type)
                    return l.postMessages({
                      receiverId: e.receiverId,
                      messages: e.messages,
                      context: t,
                    });
                  throw Error(
                    "batchedMessageActions should not contain other than postMessage actions"
                  );
                })
              ).then((e) => this.pushDocsToIndex(Object.assign({}, ...e)));
              r.push(d);
              const h = [];
              let p = !1;
              if (
                (await Promise.all(
                  r.map((e) =>
                    e.catch((e) => {
                      h.push(e), (p = p || "fatal" === e.severity);
                    })
                  )
                ),
                h.length > 0)
              ) {
                const e = h.map((e) =>
                  e instanceof nl
                    ? { code: e.code, subCode: e.subCode }
                    : { code: $c.unknown_error }
                );
                throw new nl(
                  "Error resolving delayed actions: " +
                    h.map((e) => e.message).join("; "),
                  "replication_error",
                  "delayed_actions_error",
                  p ? "fatal" : "error",
                  { errors: h },
                  { errors: e }
                );
              }
            }),
            (this.searchPlayers = async (e) => {
              if (this.opts.indexDB) {
                return this.opts.indexDB.query(e);
              }
              {
                const t = new Error(
                  "IndexDB is undefined: searchPlayers will return empty result set. Make sure to configure Elasticsearch."
                );
                return (
                  await this.errorReporter.captureException(t, void 0, {
                    query: e,
                  }),
                  { results: [] }
                );
              }
            }),
            (this.countPlayers = async (e) => {
              if (this.opts.indexDB) return this.opts.indexDB.count(e);
              {
                const t = new Error(
                  "IndexDB is undefined: countPlayers will return 0. Make sure to configure Elasticsearch."
                );
                return (
                  await this.errorReporter.captureException(t, void 0, {
                    query: e,
                  }),
                  0
                );
              }
            }),
            (this.searchSharedStates = async (e, t) => {
              var n, r;
              const s =
                null === (n = this.config.sharedStates) || void 0 === n
                  ? void 0
                  : n[e];
              if (!s)
                throw Error(
                  "Shared state with name ".concat(
                    e,
                    " is not found in configuration"
                  )
                );
              if (!ql(s))
                throw Error(
                  "Shared state with name ".concat(
                    e,
                    " does not have any searchable computed properties"
                  )
                );
              const i =
                null === (r = this.opts.sharedStateIndexDBs) || void 0 === r
                  ? void 0
                  : r[e];
              if (!i) {
                const e = new Error(
                  "IndexDB is undefined: searchSharedStates will return an empty result set. Make sure to configure Elasticsearch."
                );
                return (
                  await this.errorReporter.captureException(e, void 0, {
                    query: t,
                  }),
                  { results: [] }
                );
              }
              return i.query(t);
            }),
            (this.countSharedStates = async (e, t) => {
              var n, r;
              const s =
                null === (n = this.config.sharedStates) || void 0 === n
                  ? void 0
                  : n[e];
              if (!s)
                throw Error(
                  "Shared state with name ".concat(
                    e,
                    " is not found in configuration"
                  )
                );
              if (!ql(s))
                throw Error(
                  "Shared state with name ".concat(
                    e,
                    " does not have any searchable computed properties"
                  )
                );
              const i =
                null === (r = this.opts.sharedStateIndexDBs) || void 0 === r
                  ? void 0
                  : r[e];
              if (!i) {
                const e = new Error(
                  "IndexDB is undefined: countSharedStates will return an empty result set. Make sure to configure Elasticsearch."
                );
                return (
                  await this.errorReporter.captureException(e, void 0, {
                    query: t,
                  }),
                  0
                );
              }
              return i.count(t);
            }),
            (this.getReadOnlyEntry = async (e, t) => {
              var n;
              const r = await this.db.fetch(e, {
                consistentRead:
                  (null === t || void 0 === t ? void 0 : t.consistentRead) ||
                  !1,
                skipWrites: null === t || void 0 === t ? void 0 : t.skipWrites,
              });
              let { entry: s, messages: i } = r;
              null !== t &&
                void 0 !== t &&
                t.skipMessageIds &&
                t.skipMessageIds.length > 0 &&
                (i = i.filter((e) => !t.skipMessageIds.includes(e.id)));
              let o = [];
              if (s) {
                if (null !== t && void 0 !== t && t.assignABTests) {
                  var a;
                  const t =
                      null !== (a = s.metainfo.abTestAssignments) &&
                      void 0 !== a
                        ? a
                        : {},
                    n = await this.abTests.getAssignments({
                      userId: e,
                      isNewUser: !1,
                      currentAssignments: t,
                      userState: s.state,
                    });
                  o = Rm(s.metainfo, () =>
                    Dg(s, { newAssignments: n, isNewUser: !1 })
                  );
                }
              } else {
                if (null === t || void 0 === t || !t.createIfNotFound)
                  return null;
                (s = await this.createOrLoginHandler.createOrLogin({
                  id: e,
                  entry: null,
                  getAbTestAssignments:
                    null !== t && void 0 !== t && t.assignABTests
                      ? (e) => {
                          var t, n, r;
                          return this.abTests.getAssignments({
                            currentAssignments:
                              null !==
                                (t =
                                  null === (n = e.entry) || void 0 === n
                                    ? void 0
                                    : n.metainfo.abTestAssignments) &&
                              void 0 !== t
                                ? t
                                : {},
                            isNewUser: e.isNewUser,
                            userId: e.userId,
                            userState:
                              null === (r = e.entry) || void 0 === r
                                ? void 0
                                : r.state,
                          });
                        }
                      : void 0,
                })),
                  (i = []);
              }
              const {
                virtual: c,
                reducedMessages: l,
                inapplicableMessages: u,
              } = this.migrateAndApplyMessages(e, s, i);
              if (o.length > 0) {
                if (((s.rev += 1), l.length > 0)) {
                  const e = Rm(s.metainfo, () =>
                    Ll(this.devOpts.dateNow(), s.metainfo, l)
                  );
                  o.push(...e);
                }
                try {
                  await this.db.writeEntryOrEntryDiff({
                    diff: { metainfo: o },
                    entry: s,
                    oldEntryDiffs: r.entryDiffs,
                    recoverySnapshotUpdate: {
                      expirationsMs: {},
                      shouldWriteNewSnapshot: !1,
                    },
                    userId: e,
                  });
                } catch (d) {
                  if (!(d instanceof Zl)) throw d;
                }
                l.length > 0 && (await this.db.deleteMessages(e, l));
              } else
                u.length > 0 &&
                  (null === t || void 0 === t || !t.skipWrites) &&
                  (await this.db.deleteMessages(e, u));
              return (
                El(c.entry.state, Tl(e, c.entry), this.config),
                {
                  consumedCapacity: r.consumedCapacity,
                  entry: {
                    ...c.entry,
                    lastAppliedMessageId:
                      null === (n = l.at(-1)) || void 0 === n ? void 0 : n.id,
                  },
                }
              );
            }),
            (this.pushDocsToIndex = async (e) => {
              if (!this.supportsIndexing) return;
              const t = {};
              for (const n in e) {
                if (
                  this.config.indexAnonymousWebPlayers ||
                  !n.startsWith("web_")
                ) {
                  const r = e[n];
                  t[n] = r;
                  const s = JSON.stringify(r).length;
                  s > 2e5 &&
                    (await this.reportError(sl({ docSize: s, userId: n })));
                }
              }
              if (0 !== Object.keys(t).length)
                try {
                  this.opts.indexingQueue
                    ? await this.opts.indexingQueue.enqueueIndexDocuments(t)
                    : await this.opts.indexDB.batchPushDocuments(t);
                } catch (a_) {
                  await this.reportError(a_);
                }
            }),
            (this.pushSharedStateDocToIndex = async (e) => {
              var t, n;
              const { indexDoc: r, stateId: s, stateName: i } = e;
              if (
                !(null === (t = this.config.sharedStates) || void 0 === t
                  ? void 0
                  : t[i])
              )
                throw Error(
                  "Cannot index invalid shared state with name: " + i
                );
              const o =
                null === (n = this.opts.sharedStateIndexDBs) || void 0 === n
                  ? void 0
                  : n[i];
              if (!o) return;
              const a = JSON.stringify(r).length;
              a > 2e5 &&
                (await this.reportError(sl({ docSize: a, sharedStateId: s })));
              try {
                this.opts.indexingQueue
                  ? await this.opts.indexingQueue.enqueueSharedStateIndexDocument(
                      i,
                      s,
                      r
                    )
                  : await o.batchPushDocuments({ [s]: r });
              } catch (a_) {
                await this.reportError(a_);
              }
            }),
            (this.migrateAndApplyMessages = (e, t, n, r) => {
              try {
                const s = t instanceof Vm ? t : Bm(this.config, t);
                this.sharedStates.migrateUserSharedStates(
                  s.entry.userSharedStates
                );
                const {
                  reducedMessages: i,
                  unreducedMessages: o,
                  inapplicableMessages: a,
                } = this.applyMessagesToState(e, s.entry, n, {
                  isSampled: null === r || void 0 === r ? void 0 : r.isSampled,
                });
                return {
                  virtual: s,
                  reducedMessages: i,
                  unreducedMessages: o,
                  inapplicableMessages: a,
                };
              } catch (a_) {
                if (this.isInitialDevelopment()) {
                  return {
                    virtual:
                      t instanceof Vm
                        ? t
                        : Bm(this.config, {
                            ...t,
                            state: this.stateSchema.getDefault(),
                            lastUpdated: Date.now(),
                          }),
                    reducedMessages: [],
                    unreducedMessages: [],
                    inapplicableMessages: [],
                  };
                }
                throw a_;
              }
            }),
            (this.writeChangeset = async (e) => {
              var t;
              await this.db.writeChangeset({
                ...e,
                date: null !== (t = e.date) && void 0 !== t ? t : new Date(),
                appVersion: this.config.version,
                snapshotUpdate: e.snapshotUpdate,
              });
            }),
            (this.applyMessagesToState = (e, t, n, r) => {
              const s = [],
                i = [],
                o = [],
                a = (n, r, s) => {
                  if (
                    !(this.devOpts.dateNow() - s.timestamp > Sc({ hours: 23 }))
                  )
                    return;
                  const i = { message: s, receiver: e, state: t.state },
                    o = new nl(n, "server_error", r, "warning", i);
                  this.errorReporter.captureException(o);
                },
                c = Ul(this.messages, n, {
                  onUnknownMessage: (e) => {
                    i.push(e);
                    const t = "name" in e ? e.name : e.event.type;
                    a(
                      "Unknown message: ".concat(
                        t,
                        ". This can happen when a user on an old client version tries to read the state of a user on a newer client version."
                      ),
                      "unknown_message",
                      e
                    );
                  },
                  onInvalidArgs: (e, t) => {
                    i.push(e);
                    const n = "name" in e ? e.name : e.event.type;
                    a(
                      "Error validating args for message '"
                        .concat(n, "': ")
                        .concat(
                          t,
                          ". This can happen when a user on an old client version tries to read the state of a user on a newer client version."
                        ),
                      "invalid_message_args",
                      e
                    );
                  },
                }).filter((e) => !jl(t.metainfo, e));
              if (c.length > 0) {
                Al(t.state, Tl(e, t), this.config);
                const n = () => this.stateSchema.tryValidate(t.state);
                for (const a of c)
                  try {
                    if (Fl(a)) Mm(t, a, n);
                    else {
                      const { reducer: s } = Ko(this.messages, a.name),
                        i = { type: "message", name: a.name, userId: e },
                        o =
                          null !== r && void 0 !== r && r.isSampled
                            ? Qm(s, i)
                            : s;
                      Nm(t.state, () => {
                        o(t.state, a.args, {
                          senderId: a.sender,
                          timestamp: a.timestamp,
                        }),
                          n();
                      });
                    }
                    s.push(a);
                  } catch (a_) {
                    var l;
                    const r = Fl(a) ? a.event.type : a.name,
                      c =
                        a_ instanceof _a.ValidationError
                          ? new nl(
                              "Applying message ".concat(
                                r,
                                " resulted in invalid state"
                              ),
                              "replication_error",
                              "invalid_state_after_message",
                              "warning",
                              { ...a, cause: a_.message }
                            )
                          : new nl(
                              "Error applying message "
                                .concat(r, ": ")
                                .concat(a_),
                              "replication_error",
                              "message_errored",
                              "warning",
                              { ...a, receiver: e, receiverRev: t.rev }
                            ),
                      [, ...u] = a_.stack.split("\n"),
                      d =
                        null === (l = c.stack) || void 0 === l
                          ? void 0
                          : l.split("\n")[0];
                    (c.stack = [d, ...u].join("\n")),
                      this.errorReporter.captureException(c);
                    !(
                      Fl(a) &&
                      a_ instanceof nl &&
                      "inapplicable_diff" === a_.subCode
                    )
                      ? i.push(a)
                      : (s.push(a), o.push(a));
                  }
              }
              return {
                reducedMessages: s,
                unreducedMessages: i,
                inapplicableMessages: o,
              };
            }),
            (this.createActionAPI = (e) => {
              var t;
              const {
                  async: n,
                  consistentFetchIds: r,
                  delayedActions: s,
                  entry: i,
                  invokeTime: o,
                  sessionId: a,
                  userId: c,
                  fetcher: l,
                } = e,
                d = qf({
                  errorReporter: this.errorReporter,
                  userId: c,
                  userData: i,
                  db: this.db,
                  delayedActions: s,
                  scheduledActions:
                    null !== (t = this.config.scheduledActions) && void 0 !== t
                      ? t
                      : {},
                  invokeTime: o,
                });
              let h;
              h =
                "fb" === this.opts.platform ||
                "line" === this.opts.platform ||
                "zoom" === this.opts.platform ||
                "web" === this.opts.platform
                  ? jf
                  : Hf;
              const p = h({
                richMenuAPIClient: this.devOpts.richMenuAPIClient,
                userId: c,
                db: this.db,
                entry: i,
                errorReporter: this.errorReporter,
                sendChatbotMessage: function () {
                  return u.chatbot
                    .sendChatbotMessage(...arguments)
                    .then((e) => e.ok);
                },
                makeLineMessageReservation: this.lineMessageClient
                  ? () => this.lineMessageClient.reserve()
                  : () => {
                      throw new Error("Not available on non-LINE platforms");
                    },
                sendLineChatbotMessage: function () {
                  return u.chatbot
                    .sendLineChatbotMessage(...arguments)
                    .then((e) => e.ok);
                },
                sendInstagramChatbotMessage: function () {
                  return u.chatbot.sendInstagramChatbotMessage(...arguments);
                },
                sendMessengerChatbotMessage: function () {
                  return u.chatbot.sendMessengerChatbotMessage(...arguments);
                },
                sendTelegramChatbotMessage: function () {
                  return u.chatbot.sendTelegramChatbotMessage(...arguments);
                },
                delayedActions: s,
                invokeTime: o,
                platform: this.opts.platform,
                validateChatbotSubscription:
                  this.devOpts.validateChatbotSubscription,
                dateNow: this.devOpts.dateNow,
                fetcher: l,
                sendAnalyticsEvents: function () {
                  return u.sendAnalyticsEvents(...arguments);
                },
              });
              return this.opts.createActionAPI({
                abTestsDynamicConfig: e.abTestsDynamicConfig,
                apiAccess: this,
                async: n,
                chatbotApi: p,
                consistentFetchIds: r,
                db: this.db,
                delayedActions: s,
                encryptUserId: (e) => this.userIdEncryption.encryptUserId(e),
                entry: i,
                id: c,
                invokeTime: o,
                komojuClient: this.opts.komojuClient,
                telegramClient: this.opts.telegramClient,
                xsollaClient: this.opts.xsollaClient,
                messages: this.config.messages,
                platform: this.opts.platform,
                scheduledActionsApi: d,
                sendTemplatedEmail: this.devOpts.sendTemplatedEmail,
                sessionId: a,
                sharedStates: this.config.sharedStates,
                userAssetsBaseUrl: this.devOpts.userAssetsBaseUrl,
                fetcher: l,
              });
            }),
            (this.createEventHandlerApi = async (e) => {
              const { abTests: t } = await this.abTests.getDynamicConfig(),
                { getSessionID: n, ...r } = this.createActionAPI({
                  abTestsDynamicConfig: t,
                  async: !0,
                  consistentFetchIds: e.consistentFetchIds,
                  delayedActions: e.delayedActions,
                  entry: e.entry,
                  invokeTime: Date.now(),
                  sessionId: "",
                  userId: e.userId,
                  fetcher: this.opts.fetcher,
                  isLogin: !1,
                });
              return (
                delete r.purchases.validatePurchase,
                (r.math.random = Math.random),
                r
              );
            });
          const {
            options: d,
            platform: h,
            db: p,
            indexDB: f,
            assetUploader: m,
          } = t;
          (this.devOpts = {
            simulatedLatency: 0,
            dateNow: Date.now,
            lookupGeoIp: () => {},
            postFBMessage: () => Promise.resolve({ body: "", statusCode: 200 }),
            postLineMessage: () =>
              Promise.resolve({ body: "", statusCode: 200 }),
            postZoomMessage: () =>
              Promise.resolve({ body: "", statusCode: 200 }),
            postAnalytics: () => Promise.resolve(),
            postActivePushNotification: () => Promise.resolve({ success: !0 }),
            postFirebaseCloudMessage: () => Promise.resolve({ success: !0 }),
            postNativeBridgeSecret: () => Promise.resolve(),
            chatbotAssetUrls: {},
            userAssetsBaseUrl: "",
            reduceStaleStatesMinMessages: 50,
            reduceStaleStatesMinTimeSinceLastUpdate: Sc({ hours: 12 }),
            reduceStateMaxMessageThreshold: 200,
            disableExchangeRatesLocalCache: !1,
            abTestsCacheExpiresInMs: Sc({ minutes: 1 }),
            sendTemplatedEmail:
              null !==
                (n =
                  null === d || void 0 === d ? void 0 : d.sendTemplatedEmail) &&
              void 0 !== n
                ? n
                : async () => {
                    throw new Error("sendTemplatedEmail not defined");
                  },
            ...d,
            inferGenderFromName:
              null !==
                (r =
                  null === d || void 0 === d
                    ? void 0
                    : d.inferGenderFromName) && void 0 !== r
                ? r
                : async () => "unknown",
            validateChatbotSubscription:
              null !==
                (s =
                  null === d || void 0 === d
                    ? void 0
                    : d.validateChatbotSubscription) && void 0 !== s
                ? s
                : Mf,
          }),
            (this.db = p),
            (this.assetUploader = m),
            tm(e),
            (this.kvStore = new Kg({
              db: p,
              dateNow: () => this.devOpts.dateNow(),
            })),
            (this.internalKvStore = new Hg({ db: p })),
            (this.loginTokens = new $g({
              dateNow: this.devOpts.dateNow,
              db: p,
              createWebPlayerToken: (e) =>
                this.opts.generateWebPlayerAuthToken(e.userId),
            })),
            (this.sharedStates = new fv({
              config: e,
              db: p,
              dateNow: () => this.devOpts.dateNow(),
              errorReporter: this.errorReporter,
              isInitialDevelopment: () => this.isInitialDevelopment(),
              pushSharedStateDocToIndex: function () {
                return u.pushSharedStateDocToIndex(...arguments);
              },
            })),
            (this.messages =
              null !== (i = e.messages) && void 0 !== i ? i : {}),
            (this.migrator = e.migrator),
            (this.stateSchema = e.stateSchema),
            (this.supportsIndexing =
              !!this.opts.indexDB &&
              !!this.config.computedProperties &&
              Object.values(this.config.computedProperties).some(
                (e) => !!e._searchable
              )),
            (this.airtable = new Ig({
              airtable: t.airtable,
              dateNow: this.devOpts.dateNow,
              db: p,
              errorReporter: this.devOpts.errorReporter,
            })),
            (this.asyncGetters = new Og({
              aiClient: t.aiClient,
              apiAccess: this,
              atoneClient: this.opts.atoneClient,
              dateNow: this.devOpts.dateNow,
              db: p,
              komojuClient: this.opts.komojuClient,
              telegramClient: t.telegramClient,
              xsollaClient: this.opts.xsollaClient,
              stripe: t.stripe,
              validateChatbotSubscription:
                this.devOpts.validateChatbotSubscription,
              fetcher: t.fetcher,
              sendAnalyticsEvents: function () {
                return u.sendAnalyticsEvents(...arguments);
              },
              userAssetsBaseUrl: this.devOpts.userAssetsBaseUrl,
            })),
            (this.ecpm = new Lg({ db: p, dateNow: this.devOpts.dateNow })),
            (this.iosNotifications = new Wg({
              db: p,
              postActivePushNotification:
                this.devOpts.postActivePushNotification,
              sendAnalyticsEvents: function () {
                return u.sendAnalyticsEvents(...arguments);
              },
              errorReporter: this.devOpts.errorReporter,
              dateNow: this.devOpts.dateNow,
            })),
            (this.androidNotifications = new kg({
              db: p,
              postFirebaseCloudMessage: this.devOpts.postFirebaseCloudMessage,
              sendAnalyticsEvents: function () {
                return u.sendAnalyticsEvents(...arguments);
              },
              errorReporter: this.devOpts.errorReporter,
              dateNow: this.devOpts.dateNow,
            })),
            (this.analytics = new Cg({
              config: e,
              dateNow: this.devOpts.dateNow,
              errorReporter: this.errorReporter,
              getReadOnlyEntry: function () {
                return u.getReadOnlyEntry(...arguments);
              },
              postAnalytics: (e) => this.devOpts.postAnalytics(e),
            })),
            (this.oauth = new Km({
              platform: h,
              discordClient: this.opts.discordClient,
              lineOAuthClient: this.opts.lineOAuthClient,
            })),
            (this.systemScheduledActions = new bg({
              config: e,
              dateNow: this.devOpts.dateNow,
              db: p,
              errorReporter: this.errorReporter,
              resolveDelayedActions: function () {
                return u.resolveDelayedActions(...arguments);
              },
            })),
            (this.lineMessageClient = this.opts.lineMessageClient),
            (this.userIdEncryption = new gv({ crypto: this.opts.crypto }));
          const g = {
            chatbotAssetUrls: this.devOpts.chatbotAssetUrls,
            config: e,
            createPayloadEncoderAPI: function () {
              return u.createPayloadEncoderAPI(...arguments);
            },
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            errorReporter: this.errorReporter,
            instagramClient: this.opts.instagramClient,
            platform: h,
            postFBMessage: function () {
              return u.devOpts.postFBMessage(...arguments);
            },
            postLineMessage: function () {
              return u.devOpts.postLineMessage(...arguments);
            },
            postZoomMessage: function () {
              return u.devOpts.postZoomMessage(...arguments);
            },
            resolveDelayedActions: function () {
              return u.resolveDelayedActions(...arguments);
            },
            sendAnalyticsEvents: function () {
              return u.sendAnalyticsEvents(...arguments);
            },
            sendAndroidPushNotification: function () {
              return u.androidNotifications.sendAndroidPushNotification(
                ...arguments
              );
            },
            sendIOSPushNotification: function () {
              return u.iosNotifications.sendIOSPushNotification(...arguments);
            },
            telegramClient: t.telegramClient,
            twilioClient: t.twilio,
            userAssetsBaseUrl: this.devOpts.userAssetsBaseUrl,
            webPushClient: t.webPush,
          };
          var v;
          ((this.chatbot = new Ng(g)),
          (this.scheduledActions = new dv({
            config: e,
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            errorReporter: this.errorReporter,
            createEventHandlerApi: function () {
              return u.createEventHandlerApi(...arguments);
            },
            getReadOnlyEntry: function () {
              return u.getReadOnlyEntry(...arguments);
            },
            narrowcastAPIClient: this.opts.narrowcastAPIClient,
            resolveDelayedActions: function () {
              return u.resolveDelayedActions(...arguments);
            },
            pushDocsToIndex: function () {
              return u.pushDocsToIndex(...arguments);
            },
            queue: this.opts.scheduledActionsQueue,
          })),
          (this.createOrLoginHandler = new Mg({
            config: e,
            db: p,
            createActionAPI: this.createActionAPI,
            dateNow: () => this.devOpts.dateNow(),
            isInitialDevelopment: function () {
              return u.isInitialDevelopment(...arguments);
            },
            platform: this.opts.platform,
            resolveDelayedActions: function () {
              return u.resolveDelayedActions(...arguments);
            },
            writeChangeset: function () {
              return u.writeChangeset(...arguments);
            },
            migrateUserSharedStates: function () {
              return u.sharedStates.migrateUserSharedStates(...arguments);
            },
          })),
          (this.fetchStatesHandler = new Vg({
            config: e,
            db: p,
            dateNow: () => this.devOpts.dateNow(),
            migrateAndApplyMessages: function () {
              return u.migrateAndApplyMessages(...arguments);
            },
            writeChangeset: function () {
              return u.writeChangeset(...arguments);
            },
            reduceStaleStatesMinMessages:
              this.devOpts.reduceStaleStatesMinMessages,
            reduceStateMaxMessageThreshold:
              this.devOpts.reduceStateMaxMessageThreshold,
            reduceStaleStatesMinTimeSinceLastUpdate:
              this.devOpts.reduceStaleStatesMinTimeSinceLastUpdate,
            createUser: async (e) =>
              this.createOrLoginHandler.createOrLogin({ id: e, entry: null }),
            errorReporter: this.errorReporter,
            gzipToBase64: this.opts.gzipToBase64,
            metrics: this.devOpts.metrics,
          })),
          (this.replicateHandler = new lv({
            apiAccess: this,
            applyMessagesToState: function () {
              return u.applyMessagesToState(...arguments);
            },
            config: e,
            createActionAPI: this.createActionAPI,
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            errorReporter: this.errorReporter,
            getApplicableMessages: function () {
              for (
                var e = arguments.length, t = new Array(e), n = 0;
                n < e;
                n++
              )
                t[n] = arguments[n];
              return Ul(u.messages, ...t);
            },
            writeChangeset: function () {
              return u.writeChangeset(...arguments);
            },
            fetcher: this.opts.fetcher,
          })),
          (this.adminHandler = new Eg({
            apiAccess: this,
            chatbot: new Ng({ ...g, errorReporter: void 0 }),
            db: p,
            fetcher: this.opts.fetcher,
            indexDB: f,
            narrowcastAPIClient: this.opts.narrowcastAPIClient,
            dateNow: () => this.devOpts.dateNow(),
            postMessages: (e) =>
              this.postMessages(e).then(
                async (e) => (await this.pushDocsToIndex(e), e)
              ),
            deleteUserData: async function () {
              await u.handleNukeUser(...arguments);
            },
            taskRunnerClient: this.opts.taskRunnerClient,
          })),
          (this.fbWebhookHandler = (function (e) {
            const t = async (t) => {
                var n, r;
                const s = t.game_play;
                let i;
                if (s.payload)
                  try {
                    i = JSON.parse(s.payload);
                  } catch (a_) {
                    i = void 0;
                  }
                const o = {
                    playerId: s.player_id,
                    messengerId: t.sender.id,
                    contextType: s.context_type,
                    contextId: s.context_id,
                    payload: i,
                    score: s.score,
                  },
                  a = e.db.internalKvStore.fetch(Zc + o.messengerId),
                  c =
                    null === (n = await e.getReadOnlyEntry(o.playerId)) ||
                    void 0 === n
                      ? void 0
                      : n.entry;
                if (!c) {
                  var l;
                  const t = new nl(
                    "Chatbot webhook target user does not exist in Replicant. This can happen if the player subscribes to the platform chatbot before completing their first Replicant login.",
                    "server_error",
                    "chatbot_missing_player",
                    "warning"
                  );
                  return void (await (null === (l = e.errorReporter) ||
                  void 0 === l
                    ? void 0
                    : l.captureException(t, { user: { id: o.playerId } })));
                }
                (c.chatbotMetainfo &&
                  c.chatbotMetainfo.messengerId === o.messengerId) ||
                  (c.chatbotMetainfo = await e.db.chatbot.setMessengerId(
                    o.playerId,
                    o.messengerId
                  )),
                  (await a) ||
                    (await e.db.internalKvStore.write(
                      Zc + o.messengerId,
                      o.playerId
                    )),
                  (c.chatbotMetainfo =
                    await e.db.chatbot.markSubscribedAndResetMessagingSession(
                      o.playerId,
                      !0,
                      e.dateNow()
                    )),
                  await e.sendAnalyticsEvents([Df(o.playerId, !0)]);
                const u = e.config.chatbot,
                  d =
                    null === u ||
                    void 0 === u ||
                    null === (r = u.events) ||
                    void 0 === r
                      ? void 0
                      : r.onGameEnd;
                if (u && d) {
                  const t = o.payload,
                    n =
                      null !== t && void 0 !== t && t.sessionId
                        ? t.sessionId
                        : void 0,
                    r = !n || c.chatbotMetainfo.lastSessionId !== n;
                  if (
                    null ===
                    _a
                      .object({
                        eventId: _a.string().optional(),
                        eventType: _a.tuple(["CONTEXT_SWITCH"]),
                      })
                      .validate(o.payload, { ignoreUnexpectedFields: !0 })
                  ) {
                    var h;
                    const t = await e.db.metainfoMVCC.fetchMetainfoMVCC(
                        o.playerId,
                        { consistentRead: !0 }
                      ),
                      { eventId: n } = o.payload;
                    if (
                      n &&
                      (null === (h = t.cancelledOnGameEndEventIds) ||
                      void 0 === h
                        ? void 0
                        : h.includes(n))
                    )
                      return;
                    return void (await e.systemScheduledActions.schedule.onGameEnd(
                      {
                        args: {
                          eventData: {
                            messengerId: o.messengerId,
                            playerId: o.playerId,
                            contextId: o.contextId,
                            contextType: o.contextType,
                            payload: o.payload,
                            score: o.score,
                          },
                          isFirstInSession: r,
                        },
                        delayInMS: Sc({
                          minutes: u.opts.onGameEndTimeoutMinutes,
                        }),
                        notificationId: xg,
                        userData: c,
                        userId: o.playerId,
                      }
                    ));
                  }
                  await e.systemScheduledActions.unschedule({
                    notificationId: xg,
                    userData: c,
                    userId: o.playerId,
                  });
                  const s = [],
                    i = await e.createEventHandlerApi({
                      consistentFetchIds: [],
                      delayedActions: s,
                      entry: c,
                      userId: o.playerId,
                    }),
                    a = async () => {
                      await d(c.state, o, i, r),
                        await e.resolveDelayedActions(s);
                    },
                    l = await uv(o.playerId, c, e.config, e.dateNow, () =>
                      Dm({
                        db: e.db,
                        entry: c,
                        event: { type: "onGameEnd" },
                        eventHandler: a,
                        now: e.dateNow(),
                        userId: o.playerId,
                      })
                    );
                  l && (await e.pushDocsToIndex({ [o.playerId]: l })),
                    n &&
                      (c.chatbotMetainfo = await e.db.chatbot.setSessionId(
                        o.playerId,
                        n
                      ));
                }
              },
              n = async (t) => {
                var n;
                if (
                  null !== (n = e.config.chatbot) &&
                  void 0 !== n &&
                  null !== (n = n.events) &&
                  void 0 !== n &&
                  n.onWebhook
                )
                  return;
                const r = t.referral.ref,
                  s = t.sender.id;
                try {
                  const t = await e.messengerIdToPlayerId(s);
                  if (!t)
                    throw new nl(
                      "No player found for PSID: ".concat(s, " "),
                      "server_error",
                      "webhook_referral_player_not_found",
                      "fatal"
                    );
                  const n = await e.fetchNativeBridgeSecret(t);
                  if (
                    (await e.postNativeBridgeSecret({
                      bridgeSecret: n,
                      playerId: t,
                      referralCode: r,
                    }),
                    !{
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.REFERRAL_WEBHOOK_URL)
                  )
                    throw new nl(
                      "No referral webhook url configured. Expected process.env.REFERRAL_WEBHOOK_URL to be set",
                      "server_error",
                      "webhook_referral_url_not_set",
                      "fatal"
                    );
                  const o = {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.REFERRAL_WEBHOOK_URL,
                    a = {
                      messaging_type: "UPDATE",
                      message: {
                        attachment: {
                          type: "template",
                          payload: {
                            template_type: "generic",
                            image_aspect_ratio: "square",
                            elements: [
                              {
                                title: "Success",
                                subtitle: "Account successfully linked!",
                                default_action: { type: "web_url", url: o },
                                buttons: [
                                  { title: "Play", type: "web_url", url: o },
                                ],
                              },
                            ],
                          },
                        },
                      },
                    },
                    c = await e.chatbot.sendRawChatbotMessage(s, a);
                  if (200 !== c.statusCode) {
                    var i;
                    const n = c.body;
                    await (null === (i = e.errorReporter) || void 0 === i
                      ? void 0
                      : i.captureException(
                          new nl(
                            "Referral webhook callback failed to send chatbot message",
                            "server_error",
                            "chatbot_send_error",
                            "error",
                            {
                              receiverId: t,
                              template: JSON.stringify(a),
                              errorBody: n,
                            }
                          )
                        ));
                  }
                  Xl.debug(c.body);
                } catch (a_) {
                  var o;
                  await (null === (o = e.errorReporter) || void 0 === o
                    ? void 0
                    : o.captureException(a_));
                  const n = {
                    messaging_type: "UPDATE",
                    message: {
                      text: "An error occurred trying to link your accounts. Please make sure that you are subscribed to the chatbot in the game and try again. If the error persists, please contact us at thuglife@chobolabs.com",
                    },
                  };
                  Xl.debug("ERROR: " + a_.message);
                  const r = await e.chatbot.sendRawChatbotMessage(s, n);
                  Xl.debug(r.body);
                }
              },
              r = async (t) => {
                var n, r;
                if (
                  null !== (n = e.config.chatbot) &&
                  void 0 !== n &&
                  null !== (n = n.events) &&
                  void 0 !== n &&
                  n.onWebhook
                )
                  return;
                let s,
                  i,
                  o,
                  a,
                  c = "Play Now";
                Xl.debug(t.postback);
                const l =
                  null === (r = t.postback) || void 0 === r
                    ? void 0
                    : r.payload;
                if (l) {
                  const e = JSON.parse(l);
                  (a = e.url),
                    (s = e.title),
                    (i = e.subtitle),
                    (o = e.image_url),
                    (c = e.cta || c);
                }
                if (!s || !o || !a) {
                  const e = [];
                  throw (
                    (s || e.push("title"),
                    o || e.push("imageUrl"),
                    a || e.push("url"),
                    new nl(
                      "Missing required postback webhook payload params: ".concat(
                        e.map((e) => "'".concat(e, "'")).join(", ")
                      ),
                      "server_error",
                      "webhook_postback_missing_params",
                      "error"
                    ))
                  );
                }
                const u = t.sender.id;
                try {
                  const t = {
                      messaging_type: "UPDATE",
                      message: {
                        attachment: {
                          type: "template",
                          payload: {
                            template_type: "generic",
                            image_aspect_ratio: "square",
                            elements: [
                              {
                                title: s,
                                subtitle: i,
                                image_url: o,
                                default_action: { type: "web_url", url: a },
                                buttons: [
                                  { title: c, type: "web_url", url: a },
                                ],
                              },
                            ],
                          },
                        },
                      },
                    },
                    n = await e.chatbot.sendRawChatbotMessage(u, t);
                  if (200 !== n.statusCode) {
                    var d;
                    const r = n.body;
                    let s = null;
                    try {
                      s = await e.messengerIdToPlayerId(u);
                    } catch {}
                    await (null === (d = e.errorReporter) || void 0 === d
                      ? void 0
                      : d.captureException(
                          new nl(
                            "Postback webhook callback failed to send chatbot message",
                            "server_error",
                            "chatbot_send_error",
                            "error",
                            {
                              receiverId: s,
                              template: JSON.stringify(t),
                              errorBody: r,
                            }
                          )
                        ));
                  }
                  Xl.debug(n.body);
                } catch (a_) {
                  var h;
                  await (null === (h = e.errorReporter) || void 0 === h
                    ? void 0
                    : h.captureException(a_)),
                    Xl.debug("ERROR IN POSTBACK WEBHOOK: " + a_.message);
                }
              };
            return async (e) => {
              for (const s of e)
                "game_play" in s
                  ? await t(s)
                  : "referral" in s
                  ? (Xl.info(
                      "*FACEBOOK_WEBHOOK_DEBUG* Referral webhook triggered"
                    ),
                    await n(s))
                  : "postback" in s &&
                    (Xl.info(
                      "*FACEBOOK_WEBHOOK_DEBUG* Postback webhook triggered"
                    ),
                    await r(s));
            };
          })({
            chatbot: this.chatbot,
            config: e,
            createEventHandlerApi: function () {
              return u.createEventHandlerApi(...arguments);
            },
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            errorReporter: this.devOpts.errorReporter,
            fetchNativeBridgeSecret: function () {
              return u.fetchNativeBridgeSecret(...arguments);
            },
            getReadOnlyEntry: function () {
              return u.getReadOnlyEntry(...arguments);
            },
            messengerIdToPlayerId: function () {
              return u.messengerIdToPlayerId(...arguments);
            },
            postNativeBridgeSecret: function () {
              return u.devOpts.postNativeBridgeSecret(...arguments);
            },
            pushDocsToIndex: function () {
              return u.pushDocsToIndex(...arguments);
            },
            resolveDelayedActions: (e) => this.resolveDelayedActions(e),
            sendAnalyticsEvents: function () {
              return u.sendAnalyticsEvents(...arguments);
            },
            systemScheduledActions: this.systemScheduledActions,
          })),
          (this.lineWebhookHandler = new Iv({
            config: e,
            createEventHandlerApi: function () {
              return u.createEventHandlerApi(...arguments);
            },
            db: p,
            errorReporter: this.errorReporter,
            getReadOnlyEntry: function () {
              return u.getReadOnlyEntry(...arguments);
            },
            pushDocsToIndex: function () {
              return u.pushDocsToIndex(...arguments);
            },
            resolveDelayedActions: (e) => this.resolveDelayedActions(e),
            sendAnalyticsEvents: function () {
              return u.sendAnalyticsEvents(...arguments);
            },
            dateNow: () => this.devOpts.dateNow(),
          })),
          (this.zoomWebhookHandler = new Wv({
            config: e,
            createEventHandlerApi: function () {
              return u.createEventHandlerApi(...arguments);
            },
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            getReadOnlyEntry: function () {
              return u.getReadOnlyEntry(...arguments);
            },
            pushDocsToIndex: function () {
              return u.pushDocsToIndex(...arguments);
            },
            resolveDelayedActions: function () {
              return u.resolveDelayedActions(...arguments);
            },
            sendAnalyticsEvents: function () {
              return u.sendAnalyticsEvents(...arguments);
            },
          })),
          (this.instagramWebhookHandler = new Tv({
            config: e,
            createEventHandlerApi: function () {
              return u.createEventHandlerApi(...arguments);
            },
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            errorReporter: this.errorReporter,
            getReadOnlyEntry: function () {
              return u.getReadOnlyEntry(...arguments);
            },
            pushDocsToIndex: function () {
              return u.pushDocsToIndex(...arguments);
            },
            resolveDelayedActions: (e) => this.resolveDelayedActions(e),
            sendAnalyticsEvents: function () {
              return u.sendAnalyticsEvents(...arguments);
            },
          })),
          (this.messengerWebhookHandler = new Lv({
            config: e,
            createEventHandlerApi: function () {
              return u.createEventHandlerApi(...arguments);
            },
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            errorReporter: this.errorReporter,
            getReadOnlyEntry: function () {
              return u.getReadOnlyEntry(...arguments);
            },
            pushDocsToIndex: function () {
              return u.pushDocsToIndex(...arguments);
            },
            resolveDelayedActions: (e) => this.resolveDelayedActions(e),
            sendAnalyticsEvents: function () {
              return u.sendAnalyticsEvents(...arguments);
            },
          })),
          (this.otp = new nv({
            config: e,
            crypto: this.opts.crypto,
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            errorReporter: this.devOpts.errorReporter,
            sendAnalyticsEvents: function () {
              return u.sendAnalyticsEvents(...arguments);
            },
            twilio: t.twilio,
          })),
          null !== (o = t.options) &&
            void 0 !== o &&
            o.createAtoneWebhookHandler &&
            (this.atoneWebhookHandler = t.options.createAtoneWebhookHandler({
              sendAnalyticsEvents: function () {
                return u.sendAnalyticsEvents(...arguments);
              },
            })),
          null !== (a = t.options) &&
            void 0 !== a &&
            a.createKomojuWebhookHandler &&
            t.komojuClient &&
            (this.komojuWebhookHandler = t.options.createKomojuWebhookHandler({
              sendAnalyticsEvents: function () {
                return u.sendAnalyticsEvents(...arguments);
              },
            })),
          null !== (c = t.options) &&
            void 0 !== c &&
            c.createXsollaWebhookHandler &&
            t.xsollaClient &&
            (this.xsollaWebhookHandler = t.options.createXsollaWebhookHandler({
              sendAnalyticsEvents: function () {
                return u.sendAnalyticsEvents(...arguments);
              },
            })),
          null !== (l = t.options) &&
            void 0 !== l &&
            l.createStripeWebhookHandler) &&
            (this.stripeWebhookHandler =
              null === (v = t.options) || void 0 === v
                ? void 0
                : v.createStripeWebhookHandler({
                    db: p,
                    decryptUserId:
                      "line" === this.platform
                        ? (e) => this.userIdEncryption.decryptUserId(e)
                        : void 0,
                    sendAnalyticsEvents: function () {
                      return u.sendAnalyticsEvents(...arguments);
                    },
                    dateNow: () => this.devOpts.dateNow(),
                  }));
          (this.telegramWebhookHandler = (function (e) {
            return {
              async handleEvent(t) {
                var n, r;
                let { body: s, secretToken: i } = t;
                if (
                  !{
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.TELEGRAM_WEBHOOK_SECRET_TOKEN
                )
                  throw Error(
                    "TELEGRAM_WEBHOOK_SECRET_TOKEN must be configured before receiving Telegram webhooks"
                  );
                if (
                  i !==
                  {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.TELEGRAM_WEBHOOK_SECRET_TOKEN
                )
                  throw Error("Invalid Telegram webhook secret token");
                const o =
                  null === (n = e.config.chatbot) ||
                  void 0 === n ||
                  null === (n = n.events) ||
                  void 0 === n
                    ? void 0
                    : n.onWebhook;
                if (!o)
                  throw Error(
                    "onWebhook handler is not defined in chatbot configuration"
                  );
                if (!qv.isValid(s))
                  throw Error(
                    "Unexpected Telegram webhook request body: " +
                      JSON.stringify(s)
                  );
                const a =
                  null === (r = s.message) ||
                  void 0 === r ||
                  null === (r = r.from) ||
                  void 0 === r ||
                  null === (r = r.id) ||
                  void 0 === r
                    ? void 0
                    : r.toString();
                if (!a) return;
                const c = { ...s, platform: "telegram" },
                  l = e.sendAnalyticsEvents([Hv(a, c)]),
                  { entry: u } = await e.getReadOnlyEntry(a, {
                    assignABTests: e.config.assignAbTestsOnWebhook,
                    createIfNotFound: !0,
                  }),
                  d = [],
                  h = await e.createEventHandlerApi({
                    consistentFetchIds: [],
                    delayedActions: d,
                    entry: u,
                    userId: a,
                  });
                try {
                  const t = async () => {
                      await o(u.state, c, h), await e.resolveDelayedActions(d);
                    },
                    n = await uv(a, u, e.config, e.dateNow, () =>
                      Dm({
                        db: e.db,
                        entry: u,
                        event: { type: "onWebhook" },
                        eventHandler: t,
                        now: e.dateNow(),
                        userId: a,
                      })
                    );
                  n && (await e.pushDocsToIndex({ [a]: n }));
                } catch (p) {
                  const t = new nl(
                    "Telegram webhook event handler failed: " + p.message,
                    "server_error"
                  );
                  (t.extras = { event: s, reason: p }),
                    (t.stack = p.stack),
                    await e.errorReporter.captureException(t);
                }
                await l;
              },
            };
          })({
            config: e,
            createEventHandlerApi: function () {
              return u.createEventHandlerApi(...arguments);
            },
            dateNow: () => this.devOpts.dateNow(),
            db: p,
            errorReporter: this.errorReporter,
            getReadOnlyEntry: function () {
              return u.getReadOnlyEntry(...arguments);
            },
            pushDocsToIndex: function () {
              return u.pushDocsToIndex(...arguments);
            },
            resolveDelayedActions: (e) => this.resolveDelayedActions(e),
            sendAnalyticsEvents: function () {
              return u.sendAnalyticsEvents(...arguments);
            },
          })),
            (this.socialGraph = new mv(p)),
            (this.exchangeRateHandler = new Bg({
              db: p,
              config: e,
              devOpts: this.devOpts,
              fetcher: this.opts.fetcher,
            })),
            (this.abTests = new eg({
              db: p,
              config: e,
              devOpts: this.devOpts,
            }));
        }
        get changesetsFlushed() {
          return this.changesetsFlushedPromise;
        }
        get errorReporter() {
          var e;
          return null !== (e = this.devOpts.errorReporter) && void 0 !== e
            ? e
            : Kf;
        }
        get platform() {
          return this.opts.platform;
        }
        get version() {
          return this.config.version;
        }
        async handleCreateOrLoginWebPlayer(e) {
          let t = e.id;
          if (!t)
            if (e.otp) t = await this.otp.verifyOtpAndGetLinkedUserId(e.otp);
            else if (e.loginToken) {
              const { token: n, userId: r } = e.loginToken;
              if (
                !(await this.loginTokens.consumeLoginToken({
                  token: n,
                  userId: r,
                }))
              )
                throw Error("Invalid login token");
              t = r;
            } else t = this.opts.generateWebPlayerId();
          const { data: n, ...r } = await this.handleCreateOrLogin({
            ...e,
            id: t,
          });
          e.otp &&
            !n.metainfo.hasPhoneNumber &&
            (await this.errorReporter.captureException(
              Error(
                "User with verified phone number has no APIMetainfo.hasPhoneNumber"
              ),
              { user: { id: t, ipAddress: e.ip || "" } }
            ));
          const s = this.opts.generateWebPlayerAuthToken(t);
          return { ...r, data: { ...n, id: t, webPlayerAuthToken: s } };
        }
        handleOAuthGetAccessToken(e) {
          return this.oauth.fetchAccessToken(e);
        }
        async sendAnalyticsEvents(e, t) {
          await this.analytics.sendAnalyticsEvents(e, t);
        }
        async messengerIdToPlayerId(e) {
          return this.db.internalKvStore.fetch(Zc + e);
        }
        async reportError(e, t) {
          return this.errorReporter.captureException(e, void 0, t);
        }
        async fetchNativeBridgeSecret(e) {
          const t = (await this.db.chatbot.fetchMetainfos([e]))[e];
          if (!t)
            throw new Error(
              "Trying to fetch native bridge secret for user that does not exist. id: " +
                e
            );
          if (t.nativeBridgeSecret) return t.nativeBridgeSecret;
          const n = yc();
          return await this.setNativeBridgeSecret(e, n), n;
        }
        async setNativeBridgeSecret(e, t) {
          await this.db.chatbot.setNativeBridgeSecret(e, t);
        }
        async fetchStates(e, t) {
          return this.fetchStatesHandler.fetchStates(e, t);
        }
        async performHealthCheck() {
          await this.db.write("impossible_id", {
            rev: 0,
            state: { example: "yes" },
            metainfo: { random: { n: 0 } },
            metainfoMVCC: {},
            version: 0,
            lastUpdated: Date.now(),
            createdAt: Date.now(),
            userSharedStates: {},
          });
          const { entry: e } = await this.db.fetch("impossible_id");
          if (!e || "yes" !== e.state.example)
            throw new Error("Did not readback the correct statement.");
          this.opts.indexDB &&
            (await this.opts.indexDB.query({
              limit: 1,
              where: { id: { isOneOf: ["impossible_id"] } },
            }));
        }
        async doIOSPostAPN(e) {
          const {
              receiverId: t,
              receiverChatbotMetainfo: n,
              notification: r,
              payload: s,
              imageUrl: i,
              analyticsUserProps: o,
            } = e,
            a = n.appleDeviceToken;
          if (!a) return { success: !1, reason: "User not subscribed to APN" };
          if (n.appleDeviceTokenUpdatedAt) {
            if (Nf(n.appleDeviceTokenUpdatedAt, this.devOpts.dateNow()))
              return (
                Xl.info(
                  "iOSPostAPN - Apple device token is considered expired for: ".concat(
                    t
                  )
                ),
                {
                  success: !1,
                  reason:
                    "User has been determined to no longer be subscribed to APN",
                }
              );
          } else {
            const e = this.devOpts.dateNow();
            Xl.info(
              "iOSPostAPN - Apple device token update time being set for: "
                .concat(t, " to ")
                .concat(e)
            ),
              await this.db.chatbot.setAppleDeviceToken(t, a, e);
          }
          const c = n.lastSessionId || "sessionid-" + yc(),
            l = { aps: { ...r }, payload: { ...s } };
          return (
            i && ((l.aps["mutable-content"] = 1), (l.imageUrl = i)),
            this.iosNotifications.sendIOSPushNotification({
              receiverId: t,
              appleDeviceToken: a,
              rawPayload: l,
              analyticsEventProperties: {
                timestamp: this.devOpts.dateNow(),
                ...s,
              },
              analyticsUserProperties: o,
              userSessionId: c,
            })
          );
        }
        async doAndroidPushNotification(e) {
          const {
              receiverId: t,
              receiverChatbotMetainfo: n,
              notification: r,
              payload: s,
              imageUrl: i,
              analyticsUserProps: o,
            } = e,
            a = n.androidDeviceToken;
          if (!a) return { success: !1, reason: "User not subscribed to FCM" };
          const c = n.appleDeviceTokenUpdatedAt,
            l = this.devOpts.dateNow();
          if (c) {
            if (Rf(c, l))
              return (
                Xl.info(
                  "AndroidPushNotification - Android device token is considered expired for: ".concat(
                    t
                  )
                ),
                {
                  success: !1,
                  reason:
                    "User has been determined to no longer be subscribed to Firebase",
                }
              );
          } else
            Xl.info(
              "AndroidPushNotification - Android device token update time being set for: "
                .concat(t, " to ")
                .concat(l)
            ),
              await this.db.chatbot.setAndroidDeviceToken(t, a, l);
          const u = n.lastSessionId || "sessionid-" + yc(),
            d = r;
          return (
            i && (d.image = i),
            this.androidNotifications.sendAndroidPushNotification({
              receiverId: t,
              androidDeviceToken: a,
              notification: d,
              payload: s,
              analyticsEventProperties: {
                timestamp: this.devOpts.dateNow(),
                ...s,
              },
              analyticsUserProperties: o,
              userSessionId: u,
            })
          );
        }
        async getExtraLoginData(e) {
          const t = e ? this.devOpts.lookupGeoIp(e) : void 0,
            [n, r] = await Promise.all([
              "fb" === this.platform && null !== t && void 0 !== t && t.country
                ? this.ecpm.getECPM(t.country)
                : void 0,
              this.exchangeRateHandler.getExchangeRates(),
            ]);
          return { ecpmPerAdPlacement: n, exchangeRates: r, geolocation: t };
        }
        createPayloadEncoderAPI(e) {
          return {
            date: { now: () => this.devOpts.dateNow() },
            math: { random: () => Math.random() },
            kvStore: this.kvStore,
            getUserID: () => e.userId,
            getSessionID: () => e.sessionId,
            getReceiverID: () => e.receiverId,
            ...Wc({
              apiAccess: this,
              delayedActions: e.delayedActions,
              id: e.userId,
              sessionId: e.sessionId,
            }),
          };
        }
        handler(e) {
          var t = this;
          return async function () {
            t.devOpts.simulatedLatency &&
              (await Um(t.devOpts.simulatedLatency / 2));
            const n = t.devOpts.dateNow();
            let r;
            try {
              r = await e(...arguments);
            } catch (a_) {
              throw (Xl.error(a_), a_);
            }
            const s = t.devOpts.dateNow();
            return (
              t.devOpts.simulatedLatency &&
                (await Um(t.devOpts.simulatedLatency / 2)),
              { data: r, t: n, service: s - n }
            );
          };
        }
        isInitialDevelopment() {
          let e;
          try {
            e =
              "prod" !==
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.STAGE;
          } catch (a_) {
            e = !1;
          }
          return e && 1 === this.migrator.getLatestVersion();
        }
      }
      _a.object({
        records: _a.array(_a.object({ fields: _a.map(_a.unknown()) })),
        offset: _a.string().optional(),
      });
      n(167);
      function Gv(e) {
        return {
          sanitizePhoneNumber: () => Promise.reject(e),
          sendSms: () => Promise.reject(e),
        };
      }
      class Jv {
        pushRequestMetric(e) {}
        pushOutgoingRequestMetric(e) {}
        pushCustomMetric(e, t) {}
        pushMetrics(e) {}
        flush() {}
      }
      function Qv(e, t) {
        var n;
        const r = {
          context: { lambdaEvent: e, lambdaContext: t },
          tags: {
            requestId: null === t || void 0 === t ? void 0 : t.awsRequestId,
          },
        };
        if (
          !(function (e) {
            return !!e.httpMethod;
          })(e)
        )
          return r;
        const s =
            (null === (n = e.headers) || void 0 === n
              ? void 0
              : n["x-forwarded-for"]) || "",
          i =
            (function (e) {
              if (e)
                try {
                  return JSON.parse(e).id;
                } catch (a_) {
                  return null;
                }
              return null;
            })(e.body) || "";
        let o;
        try {
          (o = JSON.parse(e.body)), (o = zo(o, ["dataUrl"]));
        } catch (a_) {
          o = e.body;
        }
        delete o.auth;
        const a = { body: JSON.stringify(o, null, 4) },
          c = { awsRequestId: t.awsRequestId, functionName: t.functionName };
        return {
          ...r,
          user: { id: i, ipAddress: s },
          context: { ...r.context, lambdaEvent: a, lambdaContext: c },
          tags: { ...r.tags, httpMethod: e.httpMethod, path: e.path },
        };
      }
      const Yv = {
        200: "OK",
        204: "No Content",
        307: "Temporary Redirect",
        400: "Bad Request",
        403: "Forbidden",
        404: "Not Found",
        500: "Internal Server Error",
      };
      const Xv = {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, GET",
        "Access-Control-Allow-Headers":
          "origin, content-type, accept, authentication",
      };
      class Zv {
        constructor(e) {
          (this.options = e), (this.routes = []);
        }
        get(e, t, n) {
          this.routes.push({
            matcher: (t) => "GET" === t.method && t.url === e,
            handler: null !== n && void 0 !== n ? n : t,
            middlewares: n ? t : [],
            bodyParser: (t) => {
              const n = Bc[e].get.schema;
              if (!n) return null;
              const r = t.queryStringParameters,
                s = Object.entries(r).reduce((e, t) => {
                  let [r, s] = t;
                  if (!s) return e;
                  const i = n.getSchema(r);
                  return i instanceof _a.StringSchema ||
                    i instanceof _a.TupleSchema
                    ? { ...e, [r]: decodeURIComponent(s) }
                    : { ...e, [r]: JSON.parse(decodeURIComponent(s)) };
                }, {});
              return n.tryValidate(s), s;
            },
          });
        }
        post(e, t, n) {
          this.routes.push({
            matcher: (t) => "POST" === t.method && t.url === e,
            handler: null !== n && void 0 !== n ? n : t,
            bodyParser: (t) => {
              const n = Bc[e].post.schema;
              if (!n) return null;
              const r = JSON.parse(t.body);
              return n.tryValidate(r), r;
            },
            middlewares: n ? t : [],
          });
        }
        listen() {
          return async (e, t) => {
            const n = e.path,
              r = e.httpMethod,
              s = Date.now(),
              i = this.createRespond({ requestStartTime: s });
            if (!n)
              return i({ payload: { statusCode: 400, body: "Invalid path" } });
            if ("OPTIONS" === r)
              return i({ payload: { statusCode: 204, body: "" } });
            const o = n.match(/\/(v.+?|latest)\/(.*)/);
            if (!o || o.length < 2)
              return i({
                payload: {
                  statusCode: 404,
                  body: JSON.stringify({ message: "Not found" }),
                },
              });
            this.logRequest(e);
            const a = o[2],
              c = this.routes.find((e) => {
                let { matcher: t } = e;
                return t({ url: a, method: r });
              });
            if (c) {
              var l, u;
              const n = "".concat(r, "-").concat(a),
                s = (e) => i({ metricKey: n, ...e });
              let o;
              if (
                (null ===
                  (l = (u = this.options.errorReporter).setErrorContext) ||
                  void 0 === l ||
                  l.call(u, Qv(e, t)),
                "bodyParser" in c)
              ) {
                try {
                  var d;
                  o =
                    null === (d = c.bodyParser) || void 0 === d
                      ? void 0
                      : d.call(c, e);
                } catch (a_) {
                  return (
                    Xl.error(n, " Error parsing arguments: ", a_),
                    s({
                      payload: { statusCode: 400, body: "Invalid parameters" },
                    })
                  );
                }
                for (const n of c.middlewares) {
                  const r = await n({
                    body: o,
                    event: e,
                    context: t,
                    respond: s,
                  });
                  if (r) return r;
                }
              }
              try {
                return await c.handler({
                  body: o,
                  event: e,
                  context: t,
                  respond: (e) => s({ ...e }),
                });
              } catch (a_) {
                if (a_ instanceof Wm)
                  return a_.status
                    ? s({
                        payload: { ...a_.status, body: a_.message },
                        gzip: !0,
                      })
                    : s({
                        payload: { statusCode: 400, body: a_.message },
                        gzip: !0,
                      });
                await this.options.errorReporter.captureException(a_);
                let n = !1;
                try {
                  n =
                    "prod" ===
                    {
                      NODE_ENV: "production",
                      PUBLIC_URL: "",
                      WDS_SOCKET_HOST: void 0,
                      WDS_SOCKET_PATH: void 0,
                      WDS_SOCKET_PORT: void 0,
                      FAST_REFRESH: !0,
                      REACT_APP_STAGE: "prod",
                      REACT_APP_ENV: "prod",
                      REACT_APP_APP_VERSION: "2.8.0",
                    }.STAGE;
                } catch {
                  n = !1;
                }
                return s(
                  n
                    ? {
                        payload: {
                          statusCode: 500,
                          body: JSON.stringify({
                            message: t.awsRequestId,
                            code: a_.code,
                            subCode: a_.subCode,
                            clientExtras:
                              a_ instanceof nl ? a_.clientExtras : void 0,
                          }),
                        },
                      }
                    : {
                        payload: {
                          statusCode: 500,
                          body: JSON.stringify({
                            message: a_.message,
                            code: a_.code,
                            subCode: a_.subCode,
                            clientExtras:
                              a_ instanceof nl ? a_.clientExtras : void 0,
                            reqId: t.awsRequestId,
                            context: JSON.stringify(zo(o, ["auth", "dataUrl"])),
                          }),
                        },
                      }
                );
              }
            }
            return i({
              metricKey: "notfound",
              payload: {
                statusCode: 404,
                body: JSON.stringify({ message: "Not found" }),
              },
            });
          };
        }
        createRespond(e) {
          return (t) => {
            const { requestStartTime: n } = e,
              { gzip: r, metricKey: s } = t,
              i = t.payload.statusCode,
              o = (function (e) {
                return e in Yv;
              })(i)
                ? t.payload.statusDescription || Yv[i]
                : t.payload.statusDescription;
            let a = {
                ...t.payload,
                statusDescription: o,
                isBase64Encoded: !1,
                headers: { ...Xv, ...t.payload.headers },
              },
              c = 0;
            if (r) {
              const { body: e, byteLength: t } = a.body
                ? this.options.gzipToBase64(a.body)
                : { body: void 0, byteLength: 0 };
              (c = t),
                (a = {
                  ...a,
                  body: e,
                  isBase64Encoded: !0,
                  headers: {
                    "Content-Encoding": "gzip",
                    "Content-Type": "application/json",
                    ...a.headers,
                  },
                });
            } else {
              var l;
              c =
                (null === (l = a.body) || void 0 === l ? void 0 : l.length) ||
                0;
            }
            if (s) {
              const e = Date.now() - n;
              this.options.metrics.pushRequestMetric({
                endpoint: s,
                statusCode: a.statusCode,
                bytes: c,
                serviceTime: e,
              });
            }
            return a;
          };
        }
        logRequest(e) {
          let t = "";
          try {
            if (e.body) t = JSON.parse(e.body);
            else if (e.queryStringParameters) {
              t = { ...e.queryStringParameters };
              for (const e in t) t[e] = JSON.parse(t[e]);
            }
          } catch (a_) {
            t = e.body || "";
          }
          Xl.debug(
            "".concat(e.httpMethod, " ").concat(e.path),
            zo(t, ["dataUrl"])
          );
        }
      }
      function $v(e) {
        if (!e.startsWith("data:")) throw new ey("Invalid dataUrl");
        const t = e.substring(e.indexOf(":") + 1, e.indexOf(","));
        if ("image/jpeg;base64" !== t && "image/png;base64" !== t)
          throw new ey("Unsupported media type: " + t);
        return t;
      }
      class ey extends Error {
        constructor(e) {
          super(e), (this.name = "APIError");
        }
      }
      class ty {
        async assetExists(e) {
          return !1;
        }
        async uploadAsset(e) {}
        async uploadDataURLAsset(e) {
          const { extension: t, b64: n } = (function (e) {
            const t = $v(e),
              n = "image/jpeg;base64" === t ? "jpg" : "png";
            return {
              b64: e.substr(e.indexOf(",") + 1),
              mediaType: t,
              extension: n,
            };
          })(e);
          return il(n) + "." + t;
        }
      }
      class ny {
        linkRichMenuToUser(e) {
          return Promise.resolve();
        }
        unlinkRichMenuFromUser(e) {
          return Promise.resolve();
        }
      }
      const ry =
        "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJwbGF5ZXJJZCI6ImR1bW15LXVzZXIiLCJhcHBJZCI6ImR1bW15LWFwcCIsImV4cCI6NDc0MDk2NTk0MCwiaWF0IjoxNTg3MzY2MDE2fQ.JEA1IWdxQHkICDfEq6UCyInpvlNNxZ__2ZPP8CxU8XX0OSzcDOL8XOM5X72mgNmooXX4ll218Wu_Tqj0lc8WUQd66FUZL9GjYtM-v0Yg73Ky3gwqjzEOwW_Z5803iVKW8MotZ0YDoNLxtPRCeinzUbDh0qCU5OHkKaY-nXy-_rRDXXxGKmNqPN41Ox7srM9DMdheDdAjH3vmZWuV_QgAiRHjE-dv8i1KP4_PFKflOVhUYnWfBeyUhCXai1hHjCTjmij3Q1vB912NOodUgpvY5IQL_zVWGth-niCdMaQOeIB4e2x9zuV1788pfMEmzWdhAawyH1BVQvAkAaVA_inJfA";
      function sy(e) {
        var t, n, r, s;
        const i =
            jm(e.config) + (e.storageKeyPrefix ? "_" + e.storageKeyPrefix : ""),
          o = cu({ storage: e.storageOverride, prefix: i }),
          a = e.config.computedProperties
            ? Cu("main_index", e.config.computedProperties, {
                storage: e.storageOverride,
                prefix: i,
              })
            : void 0,
          c =
            e.config.sharedStates &&
            (function (e) {
              return Go(ku(e.sharedStates), (t, n) =>
                Cu(e.indexName + t, n.computedProperties, {
                  storage: e.storageOverride,
                  prefix: e.prefix,
                })
              );
            })({
              indexName: "main_index",
              sharedStates: e.config.sharedStates,
              prefix: i,
              storageOverride: e.storageOverride,
            }),
          l = {
            chatbotAssetUrls:
              null === (t = e.config.chatbot) || void 0 === t
                ? void 0
                : t.assets,
            errorReporter: e.errorReporter,
            postActivePushNotification: () => Promise.resolve({ success: !0 }),
            postAnalytics: e.postAnalytics,
            richMenuAPIClient: new ny(),
          };
        e.dateNow && (l.dateNow = e.dateNow);
        const u =
          ((d = "Airtable is disabled in offline mode"),
          { getTable: () => Promise.reject(d) });
        var d;
        const h = Object.keys(
          null !==
            (n =
              null === (r = e.config.ruleset) || void 0 === r
                ? void 0
                : r.abTests) && void 0 !== n
            ? n
            : {}
        ).reduce((e, t) => ({ ...e, [t]: { active: !0, rollOut: 1 } }), {});
        o.abTests.set(h);
        const p = new zv(e.config, {
            airtable: u,
            assetUploader: new ty(),
            createActionAPI: zl,
            crypto: {},
            db: o,
            encodeToken: () => ry,
            fetcher: null !== (s = e.fetcher) && void 0 !== s ? s : new Wl(),
            gzipToBase64: () => "",
            indexDB: a,
            narrowcastAPIClient: kf(
              "LINE chatbot broadcast is disabled in offline mode"
            ),
            options: l,
            platform: e.platform,
            scheduledActionsQueue: {
              enqueueScheduledActions: async () => ({
                successful: [],
                failed: [],
              }),
            },
            sharedStateIndexDBs: c,
            twilio: Gv("Twilio is disabled in offline mode"),
            webPush: {
              sendNotification: () =>
                Promise.reject(new Error("WebPush disabled in offline mode.")),
            },
            generateWebPlayerAuthToken: () => "",
            generateWebPlayerId: () => "",
            aiClient: If({
              apiKey: "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",
              dangerouslyAllowBrowser: !0,
            }),
          }),
          f = new Zv({
            errorReporter: p.errorReporter,
            metrics: new Jv(),
            gzipToBase64: () => ({ body: "", byteLength: 0 }),
          });
        f.post(jc.AFTER_CONTEXT_SWITCH, async (e) => {
          let { respond: t } = e;
          return t({ payload: { body: JSON.stringify({}), statusCode: 200 } });
        }),
          f.post(jc.READ_KEY_VALUES, async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleFetchKvPairs(t.keys);
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post(jc.READ_INTERNAL_KEY_VALUES, async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleFetchInternalKvPairs(t.keys);
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post(jc.LOGIN_OR_CREATE, async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleCreateOrLogin({
              id: t.id,
              sessionId: t.sid,
              onLoginActionArgs: t.onLoginActionArgs,
              prefetchKeys: t.prefetchKeys,
              prefetchInternalKeys: t.prefetchInternalKeys,
              skipOnLoginAction: !!t.skipOnLoginAction,
            });
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post(jc.REPLICATE, async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleReplicate({
              abTestsDynamicConfig: t.abTestsDynamicConfig,
              id: t.id,
              queue: t.queue,
              clientRandomSeed: t.clientRandomSeed,
              rev: t.rev,
              requestedProfileIds: t.requestedProfileIds,
              consistentFetchIds: t.consistentFetchIds,
              sessionId: t.sid,
              clientRequestId: t.crqid,
            });
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post(jc.FETCH_STATES, async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleFetchStates(
              t.ids,
              t.friendRevs,
              t.consistentFetchIds
            );
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post(jc.ASYNC_GETTER, async (e) => {
            let { body: t, respond: n } = e;
            const { args: r, id: s, name: i, sid: o } = t;
            async function a() {
              var e;
              const t =
                null === (e = await p.getReadOnlyEntry(s)) || void 0 === e
                  ? void 0
                  : e.entry;
              if (!t)
                throw new nl(
                  "Own entry not found inside asyncGetter",
                  "server_error",
                  "async_getter_error",
                  "fatal"
                );
              return t;
            }
            const c = (await a()).metainfo.clockOffset || 0,
              l = [],
              u = Wc({ apiAccess: p, delayedActions: l, id: s, sessionId: o }),
              d = Ko(p.asyncGetters.asyncGetters, i);
            if (!d) throw Error("Async getter not found: ".concat(i));
            const h = await d(r, {
              getOwnEntry: a,
              id: s,
              sessionId: o,
              clockOffset: c,
              consistentFetchIds: t.consistentFetchIds,
              ...u,
            });
            return (
              await p.resolveDelayedActions(l),
              n({
                payload: {
                  statusCode: 200,
                  body: JSON.stringify({ result: h }),
                },
              })
            );
          }),
          f.post(jc.UPLOAD_USER_ASSET, async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleUserAssetUpload(t.dataUrl);
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post(jc.WRITE_KEY_VALUES, async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleWriteKvPairs(t.pairs, t.opts);
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post(jc.INFER_GENDER_FROM_NAME, async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleInferGenderFromName(t.name);
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post(jc.SOCIAL_GRAPH_UPDATE_SELF, async (e) => {
            let { body: t, respond: n } = e;
            return (
              await p.handleSocialGraphUpdateSelf({
                playerId: t.id,
                nonPlayerFriendIds: t.nonPlayerFriendIds,
                meta: t.meta,
              }),
              n({ payload: { statusCode: 200, body: JSON.stringify("ok") } })
            );
          }),
          f.post(jc.SOCIAL_GRAPH_TRACK_INTERACTIONS, async (e) => {
            let { body: t, respond: n } = e;
            return (
              await p.handleSocialGraphTrackInteractions({
                senderId: t.id,
                interactions: t.interactions,
              }),
              n({ payload: { statusCode: 200, body: JSON.stringify("ok") } })
            );
          }),
          f.post("token", async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleGetToken(t.id);
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          }),
          f.post("testUsers", async (e) => {
            let { body: t, respond: n } = e;
            const r = await p.handleSetTestUsers(t.id, t.states);
            return n({ payload: { statusCode: 200, body: JSON.stringify(r) } });
          });
        const m = f.listen();
        async function g(t, n) {
          var r, s;
          const i = e.latency || 0;
          if ((await iy(i / 2), null === n || void 0 === n || !n.method))
            throw new Error(
              "Browser replicant could not determine HTTP method."
            );
          const o = {},
            a = n.headers;
          for (const e in a) o[e] = a[e];
          const c =
              null === (r = n.body) || void 0 === r ? void 0 : r.toString(),
            l = {},
            [, u] = /.*?((\/v|latest).*)/g.exec(t.toString()),
            [d, h] = u.split("?");
          h &&
            h.split("&").forEach((e) => {
              const [t, n] = e.split("=");
              l[t] = n;
            });
          const p = await m(
            {
              body: c || "",
              headers: o,
              multiValueHeaders: {},
              httpMethod: n.method,
              isBase64Encoded: !1,
              path: d,
              queryStringParameters: l,
              requestContext: { elb: { targetGroupArn: "" } },
            },
            {
              callbackWaitsForEmptyEventLoop: !1,
              functionName: "dev-server",
              functionVersion: "v0.0.0",
              invokedFunctionArn: "",
              memoryLimitInMB: "0",
              awsRequestId: yc(),
              logGroupName: "",
              logStreamName: "",
              getRemainingTimeInMillis: () => 0,
              done: () => {},
              fail: () => {},
              succeed: () => {},
            }
          );
          await iy(i / 2);
          const f = [["content-type", "text/plain;charset=UTF-8"]];
          for (const e in p.headers) f.push([e, p.headers[e].toString()]);
          return (null !== (s = e.responseOverride) && void 0 !== s ? s : oy)(
            p.body ? JSON.parse(p.body) : null,
            p.statusCode,
            f
          );
        }
        return (
          (g.storageOverride = e.storageOverride),
          (g.dbPrefix =
            jm(e.config) +
            (e.storageKeyPrefix ? "_" + e.storageKeyPrefix : "")),
          (g.serverReplicant = p),
          (g.db = o),
          (g.indexDB = a),
          g
        );
      }
      async function iy(e) {
        if (0 !== e) return new Promise((t) => setTimeout(t, e));
      }
      function oy(e, t, n) {
        return new Response(JSON.stringify(e), { status: t, headers: n });
      }
      function ay(e, t) {
        switch (e) {
          case "discord":
          case "fb":
          case "line":
          case "link":
          case "zoom":
          case "tiktok":
          case "web":
          case "mock":
            return e;
          default:
            if (t) return t;
            throw new Error("Unsupported platform: " + e);
        }
      }
      function cy(e, t) {
        return (n) =>
          (async function (e, t, n) {
            let r,
              { fetch: s } = e;
            try {
              r = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.AMPLITUDE;
            } catch {}
            if (!r)
              throw Error(
                "Cannot send analytics: the AMPLITUDE environment variable is not defined"
              );
            const i = (function (e) {
              const t = 2e3,
                n = 95e4,
                r = [];
              for (const s of e) {
                let e = r.at(-1);
                const i = JSON.stringify(s).length;
                (!e || e.events.length >= t || e.size + i >= n) &&
                  ((e = { events: [], size: 0 }), r.push(e)),
                  e.events.push(s),
                  (e.size += i);
              }
              return r.map((e) => e.events);
            })(t);
            for (const a of i) {
              const e = JSON.stringify({ api_key: r, events: a });
              try {
                var o;
                await Fm(
                  () => {
                    var t;
                    return s({
                      url: "https://api.amplitude.com/2/httpapi",
                      method: "POST",
                      body: e,
                      headers: { "Content-Type": "application/json" },
                      timeout:
                        null !==
                          (t =
                            null === n || void 0 === n
                              ? void 0
                              : n.timeoutMs) && void 0 !== t
                          ? t
                          : 5e3,
                    }).then(async (e) => {
                      if (e.statusCode < 200 || e.statusCode >= 400)
                        throw await kl.fromResponse(
                          "Amplitude API error response",
                          e
                        );
                    });
                  },
                  {
                    retries: 1,
                    retryOnlyIf: (e) =>
                      !(e instanceof kl) || e.statusCode >= 500,
                    linearBackoff:
                      null !==
                        (o =
                          null === n || void 0 === n
                            ? void 0
                            : n.linearBackoff) && void 0 !== o
                        ? o
                        : 500,
                  }
                );
              } catch (a_) {
                throw new Rc(a_.message, a);
              }
            }
          })(e, n, t);
      }
      class ly {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          (this.httpClient = e), (this.cache = t);
        }
        async get(e, t) {
          return (await this.getBatch([e], t))[e] || null;
        }
        async getBatch(e, t) {
          const n = t && t.forceFetch ? e : e.filter((e) => !(e in this.cache));
          n.length && (await this.fetchBatch(n));
          const r = {};
          for (const s of e) s in this.cache && (r[s] = this.cache[s]);
          return r;
        }
        async fetchBatch(e) {
          const t = await this.httpClient.doGetInternalKeyValuePairsRequest(
            { keys: e },
            {
              defaultErrorCodes: {
                code: "replication_error",
                subCode: "key_value_storage_error",
              },
              retryOptions: { retries: 8 },
            }
          );
          if (!t.data)
            throw new nl(
              "Invalid internal key value store fetch response.",
              "replication_error",
              "key_value_storage_error"
            );
          for (const n in t.data) this.cache[n] = t.data[n];
        }
      }
      class uy {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          (this.httpClient = e), (this.cache = t);
        }
        async get(e, t) {
          return (await this.getBatch([e], t))[e] || null;
        }
        async getBatch(e, t) {
          const n = t && t.forceFetch ? e : e.filter((e) => !(e in this.cache));
          n.length && (await this.fetchBatch(n));
          const r = {};
          for (const s of e) s in this.cache && (r[s] = this.cache[s]);
          return r;
        }
        async send(e, t, n) {
          return this.sendBatch({ [e]: t }, n);
        }
        async sendBatch(e, t) {
          for (const r in e)
            if (!e[r] || "string" !== typeof e[r])
              throw new nl(
                "Invalid value for key: '".concat(r, "'."),
                "replication_error",
                "key_value_storage_error"
              );
          const n = { pairs: e, opts: t };
          await this.httpClient.doSendKeyValuePairsRequest(n, {
            defaultErrorCodes: {
              code: "replication_error",
              subCode: "key_value_storage_error",
            },
            retryOptions: { retries: 8 },
          });
          for (const r in e) this.cache[r] = e[r];
        }
        async fetchBatch(e) {
          const t = await this.httpClient.doGetKeyValuePairsRequest(
            { keys: e },
            {
              defaultErrorCodes: {
                code: "replication_error",
                subCode: "key_value_storage_error",
              },
              retryOptions: { retries: 8 },
            }
          );
          if (!t.data)
            throw new nl(
              "Invalid key value store fetch response.",
              "replication_error",
              "key_value_storage_error"
            );
          for (const n in t.data) this.cache[n] = t.data[n];
        }
      }
      class dy {
        constructor(e) {
          var t, n, r;
          (this.opts = e),
            (this.clientActionsApi = new yl({
              abTests:
                null !==
                  (t =
                    null === (n = e.config.ruleset) || void 0 === n
                      ? void 0
                      : n.abTests) && void 0 !== t
                  ? t
                  : {},
              dynamicConfig: e.dynamicConfig,
            })),
            (this.assignmentsCache = Ho(
              null !== (r = e.metainfo.abTestAssignments) && void 0 !== r
                ? r
                : {}
            )),
            (this.changeEvents = this.opts.changeEvents.slice());
        }
        getBucketID(e) {
          return this.clientActionsApi.getBucketID(this.opts.metainfo, e);
        }
        getABTests() {
          return Go(this.assignmentsCache, (e, t) =>
            null === t || void 0 === t ? void 0 : t.bucketId
          );
        }
        getABTag() {
          return Object.keys(this.assignmentsCache)
            .filter((e) => this.includeInABTag(e))
            .sort()
            .map((e) => this.getTestTag(e))
            .join(",");
        }
        getUserBucketID(e, t) {
          var n;
          const r =
            null === (n = this.opts.config.ruleset) || void 0 === n
              ? void 0
              : n.abTests;
          if (null !== r && void 0 !== r && r[e]) return ml(t, e, r);
        }
        setOnChangedHandler(e) {
          (this.onABTestAssignmentsChanged = e), this.processChangeEvents();
        }
        handleReplicantActionCompleted() {
          var e;
          const t =
            null !== (e = this.opts.metainfo.abTestAssignments) && void 0 !== e
              ? e
              : {};
          Wo(this.assignmentsCache, t) ||
            (this.changeEvents.push(
              ...bl({
                newAssignments: t,
                oldAssignments: this.assignmentsCache,
              })
            ),
            (this.assignmentsCache = Ho(t)),
            this.processChangeEvents());
        }
        processChangeEvents() {
          if (!this.onABTestAssignmentsChanged || !this.changeEvents.length)
            return;
          const e = this.changeEvents;
          (this.changeEvents = []), this.onABTestAssignmentsChanged(e);
        }
        includeInABTag(e) {
          var t;
          const n =
            null === (t = this.opts.config.ruleset) || void 0 === t
              ? void 0
              : t.abTests;
          return !(null === n || void 0 === n || !n[e]) && !wl(e);
        }
        getTestTag(e) {
          const t = this.opts.config.ruleset.abTests,
            n = this.getBucketID(e),
            r = t[e].buckets.findIndex((e) => e.id === n);
          return "".concat(e.substring(0, 4), "-").concat(r);
        }
      }
      async function hy(e) {
        var t;
        const {
            clientAppName: n,
            devOpts: r,
            httpClient: s,
            isWebPlayable: i,
            loginToken: o,
            onLoginActionArgs: a,
            otp: c,
            prefetchKeys: l,
            prefetchInternalKeys: u,
            sessionId: d,
            sessionName: h,
            skipOnLoginAction: p,
          } = e,
          f =
            null !== (t = null === r || void 0 === r ? void 0 : r.dateNow) &&
            void 0 !== t
              ? t
              : Date.now,
          m = f(),
          g = i ? "doLoginOrCreateWebPlayerRequest" : "doLoginOrCreateRequest",
          v = await s[g]({
            sessionName: h,
            sid: d,
            skipOnLoginAction: p,
            prefetchKeys: l,
            prefetchInternalKeys: u,
            onLoginActionArgs: a,
            ...(i ? { clientAppName: n, loginToken: o, otp: c } : {}),
          });
        if (!v || !v.data) throw new nl("Malformed result.", $c.unknown_error);
        const y = py(m, f(), v);
        return { data: v.data, clockOffset: y };
      }
      function py(e, t, n) {
        if (!n.t || "undefined" === typeof n.service)
          throw new Error(
            "Malformed server result: missing timing information"
          );
        const r = n.t,
          s = t - e - n.service,
          i = r - Math.floor(s / 2);
        return Math.floor(i - e);
      }
      class fy {
        constructor(e) {
          (this.opts = e),
            (this.friendsIds = []),
            (this.friendsStates = {}),
            (this.fetchFriendsTimer = void 0),
            (this.externalFriendsStates = {}),
            (this.updateLocks = {}),
            (this.onFriendStatesReceivedHandlers = []),
            (this.messages = []),
            (this.isPaused = !1),
            (this.timestampLastFetched = 0),
            (this.didCallSetFriendsIds = !1),
            (this.isOffline = !1),
            (this.pendingOnFriendsChangedCall = !1),
            (this.fetchInterval = e.options.refreshFriendsStatesInterval || 0);
        }
        getTrackedUserIds() {
          return ll([...this.friendsIds, ...Object.keys(this.friendsStates)]);
        }
        setFriendsIds(e) {
          const t = !this.didCallSetFriendsIds;
          this.didCallSetFriendsIds = !0;
          const n = e.sort(),
            r = n.filter((e, t) => e !== n[t + 1]);
          return r.length === this.friendsIds.length &&
            this.friendsIds.every((e, t) => e === r[t])
            ? Promise.resolve(this.friendsStates)
            : ((this.friendsIds = r),
              this.fetchFriendsTimer && clearTimeout(this.fetchFriendsTimer),
              this.updateFriendsStates({
                isResponseToFirstSetFriendsIdsFetch: t,
              }));
        }
        getFriendsStates() {
          return this.externalFriendsStates;
        }
        setOnFriendsStatesChangedHandler(e) {
          this.onFriendsChanged = e;
        }
        setOnErrorHandler(e) {
          this.onErrorHandler = e;
        }
        stopCheckingForUpdates() {
          (this.isPaused = !0),
            this.fetchFriendsTimer && clearTimeout(this.fetchFriendsTimer);
        }
        async fetchOtherPlayerStates(e) {
          const t = e
              .filter((e) => !!this.friendsStates[e])
              .map((e) => ({ [e]: this.friendsStates[e].friendRev }))
              .reduce((e, t) => Object.assign(e, t), {}),
            n = await this.fetchStates(e, t);
          n && this.handleFetchStatesResponse(n);
          const r = {};
          for (const s of e) r[s] = this.friendsStates[s];
          return r;
        }
        pause() {
          this.stopCheckingForUpdates();
        }
        resume() {
          if (((this.isPaused = !1), this.fetchInterval > 0)) {
            const e =
              0 === this.timestampLastFetched
                ? 0
                : Math.max(
                    this.timestampLastFetched + this.fetchInterval - Date.now(),
                    0
                  );
            this.fetchFriendsTimer && clearTimeout(this.fetchFriendsTimer),
              (this.fetchFriendsTimer = setTimeout(
                () => this.updateFriendsStates(),
                e
              )),
              this.pendingOnFriendsChangedCall &&
                this.triggerOnChangedHandlers();
          }
        }
        handleReplicantMessage(e, t) {
          this.messages.push({ id: e, message: t });
        }
        handleReplicantActionCompleted(e) {
          for (const { id: r, message: s } of this.messages) {
            var t;
            if (this.friendsStates[r])
              this.applyMessageToState(r, s),
                this.updateLocks[r] || (this.updateLocks[r] = {}),
                (this.updateLocks[r][e] = (
                  null !== (t = this.updateLocks[r][e]) && void 0 !== t ? t : []
                ).concat([s]));
          }
          const n = this.messages.length;
          (this.messages = []),
            n &&
              ((this.pendingOnFriendsChangedCall = !0),
              this.triggerOnChangedHandlers());
        }
        handleReplicationResultStates(e, t) {
          for (const n in e) {
            const r = e[n];
            if (
              (Al(r.state, Tl(n, r), this.opts.config),
              (this.friendsStates[n] = r),
              this.updateLocks[n])
            )
              if (
                (delete this.updateLocks[n][t],
                Object.keys(this.updateLocks[n]).length > 0)
              )
                for (const e in this.updateLocks[n])
                  for (const t of this.updateLocks[n][e])
                    this.applyMessageToState(n, t);
              else delete this.updateLocks[n];
          }
          Object.keys(e).length > 0 &&
            ((this.pendingOnFriendsChangedCall = !0),
            this.triggerOnChangedHandlers());
        }
        clearLocks() {
          this.updateLocks = {};
        }
        async fetchFriendsStatesNow() {
          return this.updateFriendsStates();
        }
        setOnFriendsStatesReceived(e) {
          this.onFriendStatesReceivedHandlers.push(e);
        }
        clearFriendsStatesReceivedHandler() {
          this.onFriendStatesReceivedHandlers = [];
        }
        goOnline() {
          this.isOffline && ((this.isOffline = !1), this.scheduleFetchStates());
        }
        applyMessageToState(e, t) {
          if (this.opts.config.messages) {
            const n = this.friendsStates[e],
              { reducer: r } = Ko(this.opts.config.messages, t.name);
            r(n.state, t.args, { senderId: t.sender, timestamp: t.timestamp });
          }
        }
        async updateFriendsStates(e) {
          let t;
          const n = Object.keys(this.friendsStates)
            .map((e) => ({ [e]: this.friendsStates[e].friendRev }))
            .reduce((e, t) => Object.assign(e, t), {});
          try {
            (t = await this.fetchStates(this.friendsIds, n)),
              (this.timestampLastFetched = Date.now());
          } catch (a_) {
            Xl.error("Error fetching states: ", a_),
              (this.isOffline = a_.code === $c.network_error),
              this.onErrorHandler && this.onErrorHandler(a_);
          }
          return (
            this.isOffline || this.scheduleFetchStates(),
            t && this.handleFetchStatesResponse(t, e),
            this.friendsStates
          );
        }
        triggerOnChangedHandlers(e) {
          if (this.isPaused || !this.pendingOnFriendsChangedCall) return;
          this.pendingOnFriendsChangedCall = !1;
          const t = this.externalFriendsStates;
          this.externalFriendsStates = qo(
            this.externalFriendsStates,
            this.friendsStates
          );
          const n = t !== this.externalFriendsStates;
          if (n)
            for (const s in this.externalFriendsStates) {
              var r;
              this.externalFriendsStates[s].state !==
                (null === (r = t[s]) || void 0 === r ? void 0 : r.state) &&
                Al(
                  this.externalFriendsStates[s].state,
                  Tl(s, this.friendsStates[s]),
                  this.opts.config
                );
            }
          this.onFriendsChanged &&
            n &&
            this.onFriendsChanged(
              this.externalFriendsStates,
              null !== e && void 0 !== e
                ? e
                : { isResponseToFirstSetFriendsIdsFetch: !1 }
            );
        }
        async fetchStates(e, t) {
          var n, r;
          const s = [],
            i = e.filter((e) => !(e in t)).length > 100 ? 100 : 300,
            o = e.slice(0);
          for (; o.length > 0; ) {
            const e = o.splice(0, i);
            s.push({ ids: e });
          }
          const a =
              null !==
                (n =
                  null === (r = this.opts.options.devOpts) || void 0 === r
                    ? void 0
                    : r.dateNow) && void 0 !== n
                ? n
                : Date.now,
            c = s.map(async (e) => {
              const n = {};
              let r = e.ids;
              do {
                var s;
                const e = a(),
                  i = await this.opts.httpClient.doFetchStatesRequest({
                    ids: r,
                    friendRevs: t,
                    consistentFetchIds: this.opts.calcConsistentFetchIds(),
                  }),
                  o = a();
                if (o - e < Xc) {
                  const t = py(e, o, i);
                  this.opts.adjustClockOffset(t);
                }
                Object.assign(n, i.data.states),
                  (r =
                    null !== (s = i.data.unprocessedIds) && void 0 !== s
                      ? s
                      : []);
              } while (r.length > 0);
              return n;
            }),
            l = await Promise.all(c),
            u = Object.assign({}, ...l);
          for (const d in u) {
            const e = u[d];
            Al(u[d].state, Tl(d, e), this.opts.config);
          }
          return (
            u &&
              Object.keys(u).length > 0 &&
              (this.pendingOnFriendsChangedCall = !0),
            u
          );
        }
        handleFetchStatesResponse(e, t) {
          this.onFriendStatesReceivedHandlers.forEach((t) => t(e));
          for (const n in this.updateLocks)
            e[n] && (e[n] = this.friendsStates[n]);
          (this.friendsStates = { ...this.friendsStates, ...e }),
            this.triggerOnChangedHandlers(t);
        }
        scheduleFetchStates() {
          !this.isPaused &&
            this.fetchInterval > 0 &&
            (this.fetchFriendsTimer = setTimeout(
              () => this.updateFriendsStates(),
              this.fetchInterval
            ));
        }
      }
      class my {
        constructor(e) {
          this.opts = e;
        }
        hasPhoneNumber() {
          return this.opts.hasPhoneNumber();
        }
        async initiateOtp(e) {
          return this.opts.httpClient.doPostOtpInitiateAddReceiver(e);
        }
      }
      function gy(e) {
        const {
          isAsync: t,
          id: n,
          apiMetainfo: r,
          chatbotMetainfo: s,
          invokeTime: i,
          messages: o,
          onMessagePosted: a,
        } = e;
        function c() {
          if (!t)
            throw new Error(
              "Do not use this function in a sync Replicant action."
            );
        }
        function l() {
          return null;
        }
        const u = () => r().clockOffset || 0,
          d = {};
        function h(e, t) {
          return (r, s) => {
            if (t.isAdmin)
              throw Error(
                "Cannot post admin message ".concat(e, " from within an action")
              );
            t.schema.tryValidate(s),
              null === a ||
                void 0 === a ||
                a(r, {
                  name: e,
                  args: s,
                  sender: n(),
                  timestamp: i() + u(),
                  id: "0",
                });
          };
        }
        for (const v in o) {
          const e = o[v];
          if (!("isAdmin" in e && "schema" in e)) {
            const t = {};
            for (const n in e) t[n] = h("".concat(v, ".").concat(n), e[n]);
            d[v] = t;
          } else d[v] = h(v, e);
        }
        const p = Go(e.sharedStates, (t, r) => {
            const s = r;
            return {
              create: c,
              fetch: c,
              fetchOrCreate: c,
              count: c,
              search: c,
              setUserState: (r, i) => {
                var o, a, c;
                null === (o = s.schema.user) ||
                  void 0 === o ||
                  o.schema.tryValidate(i);
                const l = e.userSharedStates(),
                  u = {
                    rev:
                      null !==
                        (a =
                          null === (c = l[t]) ||
                          void 0 === c ||
                          null === (c = c[r]) ||
                          void 0 === c
                            ? void 0
                            : c.rev) && void 0 !== a
                        ? a
                        : 0,
                    state: i,
                    stateId: r,
                    stateName: t,
                    userId: n(),
                    version: 0,
                  };
                l[t] = { ...l[t], [r]: u };
              },
              deleteUserState: (n) => {
                var r;
                null === (r = e.userSharedStates()[t]) ||
                  void 0 === r ||
                  delete r[n];
              },
              postMessage: s.messages
                ? Go(s.messages, (e, t) => (e, n) => {
                    t.schema.tryValidate(n);
                  })
                : {},
            };
          }),
          f = Go(e.scheduledActions, (e, t) => {
            let { schema: n } = t;
            return (e) => {
              let { args: t } = e;
              n.tryValidate(t);
            };
          }),
          m = () => (t ? c() : cl(n(), r().random)),
          g = {
            isAsync: t,
            asyncGetters: Go(e.asyncGetters, (e, t) =>
              "function" === typeof t ? c : Go(t, () => c)
            ),
            fetch: c,
            math: { random: m },
            getUserID: () => n(),
            getSessionID: () => e.sessionId(),
            date: {
              now: () => (
                (g.meta.hasUsedDateNow = !0), i() + g.getClockOffset()
              ),
            },
            fetchStates: c,
            flushMessages: c,
            kvStore: { get: c, getBatch: c, send: c, sendBatch: c },
            loginLinks: { createLoginToken: c, createWebPlayerToken: c },
            getMentionCountForPagePost: c,
            abTests: {
              getBucketID: (t) => e.abTestsApiAccess().getBucketID(r(), t),
              assign: (t, s) => {
                e.abTestsApiAccess().assign(r(), n(), t, s);
              },
              unassign: (t) => {
                e.abTestsApiAccess().unassign(r(), n(), t);
              },
            },
            otp: { verifyOtp: c },
            postMessage: d,
            scheduledActions: {
              schedule: f,
              unschedule: l,
              rescheduleAllBy: l,
            },
            telegram: { getProfilePictureUrl: c },
            payments: {
              createXsollaPaymentToken: c,
              createCheckoutSession: c,
              createInvoice: c,
              createKomojuSession: c,
              createKomojuPayment: c,
              createPaymentIntent: c,
            },
            paymentSubscriptions: {
              initiate: c,
              initiateWithOTPVerification: c,
              verify: c,
              verifyOTP: c,
              getStatus: c,
              cancel: c,
            },
            searchPlayers: c,
            countPlayers: c,
            purchases: {
              getPurchaseHistory: () => Kl(r()),
              validatePurchase: c,
            },
            sendAnalyticsEvents: (t) => {
              const r = t.filter((e) => {
                let { userId: t } = e;
                return !t || t === n();
              });
              r.length > 0 && e.getAnalyticsCallback()(r);
            },
            reportError: l,
            sharedStates: p,
            meta: {
              hasUsedDateNow: !1,
              apiMetainfo: r,
              userSharedStates: e.userSharedStates,
            },
            chatbot: {
              sendMessage: l,
              sendLineMessage: l,
              sendInstagramMessage: l,
              sendTelegramMessage: l,
              sendMessengerMessage: l,
              validateSubscription: l,
              unsubscribe: l,
              setAppleDeviceToken: (e) => {
                e
                  ? ((s.appleDeviceToken = e),
                    (s.appleDeviceTokenUpdatedAt = g.date.now()))
                  : (delete s.appleDeviceToken,
                    delete s.appleDeviceTokenUpdatedAt);
              },
              getAppleDeviceTokenUpdatedAt: () =>
                s.appleDeviceTokenUpdatedAt || 0,
              appleDeviceTokenIsValid: () =>
                !(
                  !!s.appleDeviceTokenUpdatedAt &&
                  Nf(s.appleDeviceTokenUpdatedAt, g.date.now())
                ) && !!s.appleDeviceToken,
              setAndroidDeviceToken: (e) => {
                e
                  ? ((s.androidDeviceToken = e),
                    (s.androidDeviceTokenUpdatedAt = g.date.now()))
                  : (delete s.androidDeviceToken,
                    delete s.androidDeviceTokenUpdatedAt);
              },
              getAndroidDeviceTokenUpdatedAt: () =>
                s.androidDeviceTokenUpdatedAt || 0,
              androidDeviceTokenIsValid: () =>
                !(
                  !!s.androidDeviceTokenUpdatedAt &&
                  Rf(s.androidDeviceTokenUpdatedAt, g.date.now())
                ) && !!s.androidDeviceToken,
              linkRichMenuToUser: l,
              unlinkRichMenuFromUser: l,
              setEmail: (e) => {
                s.email = e;
              },
              setWebPushSubscription: (e) => {
                s.webPushSubscription = e;
              },
              subscribeSms: (e) => {
                if (!e) throw new Error("consentText is required");
                s.smsSubscribed = !0;
              },
              unsubscribeSms: () => {
                s.smsSubscribed = !1;
              },
            },
            generateOrGetNativeBridgeSecret: () => (
              s.nativeBridgeSecret || (s.nativeBridgeSecret = yc(m)),
              s.nativeBridgeSecret
            ),
            nukeUserMetainfo: () => {
              (r().random = { n: 0 }),
                (r().clockOffset = 0),
                delete r().purchaseHistory,
                delete r().lastSessionId,
                delete r().appVersion;
            },
            setClockOffset: (e) => {
              let t;
              try {
                t = {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.STAGE;
              } catch {}
              if ("prod" === t)
                throw new Error("setClockOffset() cannot be used in prod");
              r().clockOffset = Math.floor(e);
            },
            getClockOffset: u,
            getPushNotificationLastTargetedAt: c,
            getUserAssetUrl: (t) => e.userAssetsBaseUrl() + t,
          };
        return g;
      }
      class vy {
        constructor(e) {
          var t = this;
          (this.receivedProfiles = {}),
            (this.results = []),
            (this.analyticsCallback = () => {});
          const n = (r, s) => {
            for (const i in r)
              if ("function" === typeof r[i]) {
                const n = r[i];
                r[i] = function () {
                  const o = t.results[t.apiState.resultIndex];
                  if (
                    (t.apiState.resultIndex++,
                    t.apiState.apiCallQueue.push(s + i),
                    !o)
                  )
                    throw new nl(
                      "Client action trying to execute more api calls than server. Client queue: " +
                        t.apiState.apiCallQueue.join(", ") +
                        ". Server results array: " +
                        JSON.stringify(t.results),
                      "replication_error",
                      "async_action_api_error"
                    );
                  if (o.failed) {
                    if (o.async) return Promise.reject(ov(o.value));
                    throw ov(o.value);
                  }
                  for (
                    var a = arguments.length, c = new Array(a), l = 0;
                    l < a;
                    l++
                  )
                    c[l] = arguments[l];
                  if (s + i === "api.setClockOffset") {
                    const t = c[0];
                    "number" === typeof t &&
                      (e.apiMetaInfo().clockOffset = Math.floor(t));
                  }
                  if (
                    (s + i === "api.fetchStates" &&
                      (t.receivedProfiles = {
                        ...t.receivedProfiles,
                        ...o.value,
                      }),
                    "api.postMessage." === s && e.onMessagePosted(c[0]),
                    "api.abTests." !== s ||
                      ("assign" !== i && "unassign" !== i) ||
                      e.abTestsApiAccess()[i](e.apiMetaInfo(), e.id(), ...c),
                    s.startsWith("api.sharedStates") && "setUserState" === i)
                  ) {
                    const t = e.userSharedStates(),
                      [, , n] = s.split("."),
                      [r, i] = c,
                      o = {
                        rev: 0,
                        version: 0,
                        state: i,
                        stateId: r,
                        stateName: n,
                        userId: e.id(),
                      };
                    t[n] = { ...t[n], [r]: o };
                  }
                  return (
                    s + i === "api.sendAnalyticsEvents" && n.apply(r, c),
                    o.async ? Promise.resolve(o.value) : o.value
                  );
                };
              } else if ("object" === typeof r[i]) n(r[i], s + i + ".");
              else if ("isAsync" !== i)
                throw Error("Unsupported field in API: " + i);
          };
          this.apiState = { resultIndex: 0, apiCallQueue: [] };
          const r = ((e) => {
            const t = gy({ ...e, isAsync: !0 });
            return delete t.meta, t;
          })({
            id: e.id,
            sessionId: e.sessionId,
            apiMetainfo: e.apiMetaInfo,
            userSharedStates: e.userSharedStates,
            chatbotMetainfo: e.chatbotMetainfo(),
            invokeTime: e.invokeTime,
            messages: e.messages(),
            scheduledActions: e.scheduledActions(),
            computedProperties: e.computedProperties(),
            asyncGetters: e.asyncGetters(),
            sharedStates: e.sharedStates(),
            onMessagePosted: () => null,
            userAssetsBaseUrl: e.userAssetsBaseUrl,
            abTestsApiAccess: e.abTestsApiAccess,
            getAnalyticsCallback: () => this.analyticsCallback,
          });
          n(r, "api."), (this.api = r);
        }
        getAPI(e) {
          return (
            (this.receivedProfiles = {}),
            (this.apiState.apiCallQueue = []),
            (this.apiState.resultIndex = 0),
            (this.results = e),
            this.api
          );
        }
        getReceivedProfiles() {
          return this.receivedProfiles;
        }
        getAPIState() {
          return this.apiState;
        }
        setAnalyticsCallback(e) {
          this.analyticsCallback = e;
        }
      }
      class yy {
        constructor(e) {
          var t,
            n = this;
          (this.postedMessages = []),
            (this.invokeTime = 0),
            (this.analyticsCallback = () => {}),
            (this.api =
              ((t = {
                id: e.id,
                sessionId: e.sessionId,
                apiMetainfo: () => {
                  var t;
                  return (this.tempMetaInfo =
                    null !== (t = this.tempMetaInfo) && void 0 !== t
                      ? t
                      : Ho(e.apiMetaInfo()));
                },
                userSharedStates: () => {
                  var t;
                  return (this.tempSharedStates =
                    null !== (t = this.tempSharedStates) && void 0 !== t
                      ? t
                      : Ho(e.userSharedStates()));
                },
                chatbotMetainfo: e.chatbotMetainfo(),
                invokeTime: () => this.invokeTime,
                messages: e.messages(),
                scheduledActions: e.scheduledActions(),
                sharedStates: e.sharedStates(),
                onMessagePosted: function () {
                  for (
                    var e = arguments.length, t = new Array(e), r = 0;
                    r < e;
                    r++
                  )
                    t[r] = arguments[r];
                  return n.postedMessages.push(t);
                },
                userAssetsBaseUrl: e.userAssetsBaseUrl,
                abTestsApiAccess: e.abTestsApiAccess,
                getAnalyticsCallback: () => this.analyticsCallback,
              }),
              gy({ ...t, isAsync: !1 })));
        }
        getAPI(e) {
          var t;
          return (
            (this.postedMessages = []),
            (this.tempMetaInfo = void 0),
            (this.tempSharedStates = void 0),
            null !== (t = this.api.meta) &&
              void 0 !== t &&
              t.hasUsedDateNow &&
              (this.api.meta.hasUsedDateNow = !1),
            (this.invokeTime = e),
            this.api
          );
        }
        updateMetaInfo(e) {
          if (this.tempMetaInfo) for (const t in e) e[t] = this.tempMetaInfo[t];
        }
        updateUserSharedStates(e) {
          for (const t in this.tempSharedStates)
            e[t] = this.tempSharedStates[t];
        }
        getPostedMessages() {
          return this.postedMessages;
        }
        getInvokeTime() {
          return this.invokeTime;
        }
        setAnalyticsCallback(e) {
          this.analyticsCallback = e;
        }
      }
      class by {
        constructor(e) {
          (this.opts = e),
            (this.actionInvocationCallbacks = {}),
            (this.queue = []),
            (this.replicationBatch = {
              queue: [],
              batchId: yc(),
              requestedProfileIds: [],
              clientRandomSeed: -1,
            }),
            (this.replicationFlushPromise = null),
            (this.batchToRetry = null),
            (this.lockPromise = null),
            (this.flushTimer = null),
            (this.heartbeatTimer = 0),
            (this.isPaused = !1),
            (this.isOnline = !0),
            (this.onMessagesReceivedHandlers = []),
            (this.consistentFetchTimestamps = {}),
            (this.onMessagePosted = (e, t) => {
              !this.replicationBatch.requestedProfileIds.includes(e) &&
                this.opts.getTrackedUserIds().includes(e) &&
                this.replicationBatch.requestedProfileIds.push(e),
                (this.consistentFetchTimestamps[e] = t.timestamp),
                this.opts.hooks.onMessagePosted(e, t);
            }),
            (this.currentState = e.userData.state);
          const t = Tl(e.id, e.userData);
          Al(this.currentState, t, e.config),
            (this.externalState = Ho(this.currentState)),
            Al(this.externalState, t, e.config),
            (this.apiMetainfo = e.userData.metainfo),
            (this.chatbotMetainfo = e.userData.chatbotMetainfo),
            (this.metainfoMVCC = e.userData.metainfoMVCC),
            (this.revId = e.userData.rev),
            (this.syncApiCache = new yy({
              id: () => this.opts.id,
              sessionId: () => this.opts.sessionId,
              apiMetaInfo: () => this.apiMetainfo,
              userSharedStates: () => e.userData.userSharedStates,
              chatbotMetainfo: () => this.chatbotMetainfo,
              messages: () => this.opts.config.messages,
              scheduledActions: () => this.opts.config.scheduledActions,
              sharedStates: () => this.opts.config.sharedStates,
              ruleset: () => this.opts.config.ruleset,
              userAssetsBaseUrl: () => this.opts.userAssetsBaseUrl,
              abTestsApiAccess: () => this.opts.abTestsManager.clientActionsApi,
            })),
            (this.asyncApiCache = new vy({
              id: () => this.opts.id,
              sessionId: () => this.opts.sessionId,
              apiMetaInfo: () => this.apiMetainfo,
              userSharedStates: () => e.userData.userSharedStates,
              chatbotMetainfo: () => this.chatbotMetainfo,
              invokeTime: () => this.opts.now(),
              messages: () => this.opts.config.messages,
              scheduledActions: () => this.opts.config.scheduledActions,
              computedProperties: () => this.opts.config.computedProperties,
              asyncGetters: () => this.opts.config.asyncGetters,
              sharedStates: () => this.opts.config.sharedStates,
              ruleset: () => this.opts.config.ruleset,
              onMessagePosted: (e) => {
                this.consistentFetchTimestamps[e] = this.opts.now();
              },
              userAssetsBaseUrl: () => this.opts.userAssetsBaseUrl,
              abTestsApiAccess: () => this.opts.abTestsManager.clientActionsApi,
            })),
            e.config.sendActionAnalyticsWithClient &&
              this.setActionAnalyticsCallback(() => {
                throw new Error("Action analytics callback not set");
              }),
            this.resetHeartbeatTimer();
        }
        async enqueueAction(e, t, n) {
          const { promise: r, callback: s } = Lm();
          this.queue.push({
            type: t,
            fnName: e,
            args: n,
            callback: (t, r) => {
              void 0 !== t &&
                (this.actionInvocationCallbacks.cancelled && "cancelled" === t
                  ? this.actionInvocationCallbacks.cancelled(e, n)
                  : this.actionInvocationCallbacks.failed &&
                    this.actionInvocationCallbacks.failed(
                      e,
                      n,
                      t.message || t
                    )),
                s(t, r);
            },
            invokedAt: this.dateNow(),
            promise: r,
          }),
            this.resolveQueue();
          const i = await r;
          return "async" === t && (await this.lockPromise), i;
        }
        resetQueue() {
          this.queue.forEach((e) => e.callback("cancelled")),
            (this.queue = []),
            (this.replicationBatch = {
              queue: [],
              batchId: yc(),
              requestedProfileIds: [],
              clientRandomSeed: -1,
            }),
            this.batchToRetry &&
              (this.batchToRetry.queue.forEach((e) =>
                e.callback("cancelled", void 0)
              ),
              (this.batchToRetry = null),
              (this.lockPromise = null));
        }
        onRefresh(e) {
          (this.currentState = e.state),
            Al(this.currentState, Tl(this.opts.id, e), this.opts.config),
            (this.apiMetainfo = e.metainfo),
            (this.revId = e.rev),
            (this.isOnline = !0),
            this.resetHeartbeatTimer(),
            this.onStateChanged();
        }
        async retryLastRequest() {
          if (this.batchToRetry) {
            if (
              (this.flushReplication(),
              await this.replicationFlushPromise,
              !this.isOnline)
            )
              throw new Error("Retrying last request failed.");
            return !0;
          }
          return !1;
        }
        async waitForEmptyQueue() {
          if (0 !== this.queue.length || this.lockPromise)
            return (
              this.lockPromise ? await this.lockPromise : await Um(0),
              this.waitForEmptyQueue()
            );
        }
        async flush(e) {
          const t = e && e.skipErrorHandlers;
          this.flushReplication();
          const n = new Promise((n, r) => {
            this.replicationFlushPromise
              ? this.replicationFlushPromise
                  .then(() => {
                    this.replicationBatch.queue.length > 0 ||
                    this.replicationFlushPromise
                      ? this.flush(e).then(() => n())
                      : this.lockPromise
                      ? this.lockPromise.then(() =>
                          this.flush(e).then(() => n())
                        )
                      : n();
                  })
                  .catch((e) => {
                    t ? n() : (this.handleError(e), r(e));
                  })
              : n();
          });
          return t
            ? new Promise((e) => {
                this.waitForEmptyQueue()
                  .then(() => e(n))
                  .catch((t) => e(n));
              })
            : this.waitForEmptyQueue().then(() => n);
        }
        async checkForMessages() {
          if (!this.replicationFlushPromise)
            if (this.replicationBatch.queue.length > 0) this.flushReplication();
            else {
              Xl.debug("Sending heartbeat");
              const { promise: e, callback: t } = Lm();
              this.queue.push({
                type: "sync",
                fnName: Kc,
                args: [],
                callback: t,
                invokedAt: this.dateNow(),
                promise: e,
              }),
                this.resolveQueue(),
                e.catch((e) => {});
            }
          await this.replicationFlushPromise, await this.lockPromise;
        }
        getPurchaseHistory() {
          return Kl(this.apiMetainfo);
        }
        getExternalState() {
          return this.externalState;
        }
        setActionAnalyticsCallback(e) {
          this.syncApiCache.setAnalyticsCallback(e),
            this.asyncApiCache.setAnalyticsCallback(e);
        }
        pause() {
          (this.isPaused = !0),
            this.clearHeartbeatTimer(),
            this.isOnline && this.flush();
        }
        resume() {
          (this.isPaused = !1), this.resetHeartbeatTimer();
        }
        onMessagesReceived(e) {
          this.onMessagesReceivedHandlers.push(e);
        }
        removeMessagesReceivedHandler(e) {
          const t = this.onMessagesReceivedHandlers.indexOf(e);
          t >= 0 && this.onMessagesReceivedHandlers.splice(t, 1);
        }
        calcConsistentFetchIds() {
          var e;
          const t =
              (null === (e = this.opts.replicantOptions.devOpts) || void 0 === e
                ? void 0
                : e.maxRecentMessagesTime) || Jc,
            n = this.dateNow() - t;
          return Object.keys(this.consistentFetchTimestamps).filter(
            (e) => this.consistentFetchTimestamps[e] > n
          );
        }
        invokeOnMessagesReceived(e) {
          const t = e.filter((e) => !Fl(e));
          if (0 !== t.length)
            for (const n of this.onMessagesReceivedHandlers) n(t);
        }
        invokeAsyncAction(e, t, n) {
          const r = Ko(this.opts.config.actions, e.fnName);
          if ("async" !== r.type)
            throw new Error("Inconsistent async / sync function invocation.");
          this.actionInvocationCallbacks.preInvoke &&
            this.actionInvocationCallbacks.preInvoke(e.fnName, e.args);
          const s = r.fn(t, e.args, n);
          return (
            this.actionInvocationCallbacks.postInvoke &&
              this.actionInvocationCallbacks.postInvoke(e.fnName, e.args),
            s
          );
        }
        invokeSyncAction(e, t, n) {
          const r = Ko(this.opts.config.actions, e.fnName);
          if ("sync" !== r.type)
            throw new Error("Inconsistent async / sync function invocation.");
          this.actionInvocationCallbacks.preInvoke &&
            this.actionInvocationCallbacks.preInvoke(e.fnName, e.args);
          const s = r.fn(t, e.args, n);
          return (
            this.actionInvocationCallbacks.postInvoke &&
              this.actionInvocationCallbacks.postInvoke(e.fnName, e.args),
            s
          );
        }
        resolveQueue() {
          if (this.lockPromise) {
            const e = this.lockPromise;
            return void e
              .then(() => {
                this.lockPromise === e &&
                  ((this.lockPromise = null), this.resolveQueue());
              })
              .catch((e) => null);
          }
          let e = !1,
            t = !1;
          for (; this.queue.length > 0 && !this.lockPromise; ) {
            const n = this.queue.shift();
            if (n.fnName !== Kc)
              if ("sync" === n.type) {
                const t = n.fnName === zc,
                  r = Ko(this.opts.config.actions, n.fnName);
                if (t) {
                  if (r)
                    throw new Error(
                      "System action names should not be available."
                    );
                } else if (!r || "sync" !== r.type)
                  throw new Error(
                    "Inconsistent async / sync function invocation."
                  );
                this.apiMetainfo.clockOffset =
                  this.apiMetainfo.clockOffset || 0;
                const s = this.syncApiCache.getAPI(this.opts.now());
                let i;
                try {
                  t
                    ? _y({
                        state: this.currentState,
                        metainfo: s.meta.apiMetainfo(),
                        updatedAt: this.currentState.updatedAt,
                        fn: (e) => {
                          this.applyMessages(
                            {
                              metainfo: this.apiMetainfo,
                              state: this.currentState,
                            },
                            n.args
                          );
                        },
                        userSharedStates: s.meta.userSharedStates(),
                        config: this.opts.config,
                      })
                    : (i = _y({
                        state: this.currentState,
                        metainfo: s.meta.apiMetainfo(),
                        updatedAt: this.currentState.updatedAt,
                        fn: (e) =>
                          this.invokeSyncAction(n, this.currentState, s),
                        userSharedStates: s.meta.userSharedStates(),
                        config: this.opts.config,
                      }));
                } catch (a_) {
                  return (
                    (this.currentState = wy({
                      oldState: this.currentState,
                      newState: this.externalState,
                      metainfo: this.apiMetainfo,
                      userSharedStates: this.opts.userData.userSharedStates,
                      config: this.opts.config,
                    })),
                    this.queue.forEach((e) => e.callback("cancelled")),
                    (this.queue = []),
                    void n.callback(a_)
                  );
                }
                this.syncApiCache.updateMetaInfo(this.apiMetainfo),
                  this.syncApiCache.updateUserSharedStates(
                    this.opts.userData.userSharedStates
                  ),
                  this.syncApiCache
                    .getPostedMessages()
                    .forEach((e) => this.onMessagePosted(...e)),
                  this.replicationBatch.queue.push({
                    fn: n.fnName,
                    args: t ? n.args.map((e) => e.id) : n.args,
                    async: !1,
                    callback: n.callback,
                    invokedAt: n.invokedAt,
                    meta: s.meta.hasUsedDateNow
                      ? { now: this.syncApiCache.getInvokeTime() }
                      : void 0,
                  }),
                  (e = !0),
                  this.onStateChanged(),
                  t && this.invokeOnMessagesReceived(n.args),
                  n.callback(void 0, Ho(i)),
                  this.opts.hooks.onActionCompleted(
                    this.replicationBatch.batchId
                  );
              } else {
                if ("async" !== n.type)
                  throw new Error(
                    "Action of type ".concat(
                      n.type,
                      " should not be on the queue!"
                    )
                  );
                {
                  const { promise: r, callback: s } = Lm();
                  this.replicationBatch.queue.push({
                    fn: n.fnName,
                    args: n.args,
                    async: !0,
                    meta: { now: this.opts.now() },
                    callback: s,
                    invokedAt: n.invokedAt,
                  }),
                    (this.lockPromise = r
                      .catch((e) => n.callback(e))
                      .then((e) => {
                        if (!e) return;
                        const {
                            result: t,
                            batchId: r,
                            requestedProfiles: s,
                            serverUpdatedAt: i,
                            messages: o,
                          } = e,
                          a = this.asyncApiCache.getAPI(t),
                          c = Ko(this.opts.config.actions, n.fnName);
                        if (!c || "async" !== c.type)
                          return Promise.reject(
                            "Action " +
                              n.fnName +
                              " is not an action or is not async."
                          );
                        const l = _y({
                            state: this.currentState,
                            metainfo: this.apiMetainfo,
                            updatedAt: i,
                            fn: (e) => this.invokeAsyncAction(n, e, a),
                            userSharedStates:
                              this.opts.userData.userSharedStates,
                            config: this.opts.config,
                          }),
                          u = (e) => {
                            o.length > 0 &&
                              (_y({
                                state: this.currentState,
                                metainfo: this.apiMetainfo,
                                updatedAt: i,
                                fn: (e) => {
                                  this.applyMessages(
                                    {
                                      metainfo: this.apiMetainfo,
                                      state: this.currentState,
                                    },
                                    o
                                  );
                                },
                                userSharedStates:
                                  this.opts.userData.userSharedStates,
                                config: this.opts.config,
                              }),
                              this.invokeOnMessagesReceived(o)),
                              this.opts.hooks.onReplicationResultStates(
                                {
                                  ...this.asyncApiCache.getReceivedProfiles(),
                                  ...s,
                                },
                                r
                              ),
                              this.crosscheckAsyncAPICalls(
                                n.fnName,
                                this.asyncApiCache.getAPIState(),
                                t.length
                              ),
                              this.onStateChanged(),
                              n.callback(void 0, Ho(e)),
                              this.opts.hooks.onActionCompleted(
                                this.replicationBatch.batchId
                              );
                          };
                        if (
                          "undefined" !== typeof l &&
                          "function" === typeof l.then
                        )
                          return l.then(u).catch((e) => {
                            n.callback(e), this.handleError(e);
                          });
                        u(l);
                      })
                      .catch((e) => {
                        n.callback(e), this.handleError(e);
                      })),
                    (e = !0),
                    (t = !0);
                }
              }
            else
              this.replicationBatch.queue.push({
                fn: n.fnName,
                args: n.args,
                async: "async" === n.type,
                callback: n.callback,
                invokedAt: n.invokedAt,
              }),
                (e = !0),
                (t = !0);
          }
          e &&
            (!t && this.opts.replicantOptions.batchingMaxTime
              ? this.scheduleReplication()
              : this.flushReplication(),
            this.resetHeartbeatTimer()),
            (this.queue.length > 0 || this.lockPromise) && this.resolveQueue();
        }
        scheduleReplication() {
          if (!this.flushTimer) {
            let e = this.opts.replicantOptions.batchingMaxTime;
            if (this.replicationBatch.queue.length > 0) {
              const t =
                this.dateNow() - this.replicationBatch.queue[0].invokedAt;
              e = Math.max(0, this.opts.replicantOptions.batchingMaxTime - t);
            }
            this.flushTimer = Jm(() => this.flushReplication(), e);
          }
        }
        clearFlushTimer() {
          this.flushTimer &&
            (clearTimeout(this.flushTimer), (this.flushTimer = null));
        }
        flushReplication() {
          if (this.replicationFlushPromise) return;
          if (
            (this.clearFlushTimer(),
            0 === this.replicationBatch.queue.length &&
              (!this.batchToRetry || 0 === this.batchToRetry.queue.length))
          )
            return;
          this.batchToRetry ||
            ((this.batchToRetry = this.replicationBatch),
            (this.replicationBatch = {
              queue: [],
              requestedProfileIds: [],
              batchId: yc(),
              clientRandomSeed: -1,
            }));
          const e = this.batchToRetry,
            t = e.queue.slice(),
            n = e.queue[e.queue.length - 1].async ? t.pop() : null;
          if (t.some((e) => e.async))
            throw new Error("Too many async actions in batch.");
          -1 === e.clientRandomSeed &&
            (e.clientRandomSeed = this.apiMetainfo.random.n),
            (this.replicationFlushPromise = this.postReplicationQueue(e)
              .then((r) => {
                var s, i, o;
                if (((this.batchToRetry = null), r.newLastUpdated)) {
                  Sy({
                    state: this.currentState,
                    metainfo: this.apiMetainfo,
                    updatedAt: r.newLastUpdated,
                    userSharedStates: this.opts.userData.userSharedStates,
                    config: this.opts.config,
                  }),
                    (this.externalState = { ...this.externalState });
                  const {
                    id: e,
                    createdAt: t,
                    updatedAt: n,
                  } = this.currentState;
                  Al(
                    this.externalState,
                    {
                      id: e,
                      createdAt: t,
                      updatedAt: n,
                      userSharedStates: this.opts.userData.userSharedStates,
                      metainfo: this.apiMetainfo,
                    },
                    this.opts.config
                  );
                }
                const a = n ? 1 : 0;
                if (a !== r.results.length)
                  throw new Error(
                    "Invalid number of results received from server: " +
                      r.results.length +
                      " expected: " +
                      a
                  );
                for (const e of t) e.callback(void 0, void 0);
                var c, l;
                (null === n ||
                  void 0 === n ||
                  n.callback(void 0, {
                    result: r.results.shift(),
                    batchId: e.batchId,
                    requestedProfiles: r.requestedProfiles,
                    messages: r.messages,
                    serverUpdatedAt: r.lastUpdated,
                  }),
                !n &&
                  !this.lockPromise &&
                  r.messages.length > 0 &&
                  this.enqueueAction(zc, "sync", r.messages).catch((e) =>
                    this.handleError(
                      new nl(
                        "Error applying messages on the client: ".concat(
                          e.message || e
                        ),
                        "replication_error",
                        "message_errored",
                        "fatal"
                      )
                    )
                  ),
                null !== (s = r.metainfoDelta) &&
                  void 0 !== s &&
                  s.hasPhoneNumber &&
                  (this.apiMetainfo.hasPhoneNumber =
                    r.metainfoDelta.hasPhoneNumber),
                null !== (i = r.metainfoDelta) &&
                  void 0 !== i &&
                  i.paymentSubscriptionStatus) &&
                  (this.metainfoMVCC.paymentSubscription =
                    null === (c = r.metainfoDelta) || void 0 === c
                      ? void 0
                      : c.paymentSubscriptionStatus);
                if (
                  null !== (o = r.metainfoDelta) &&
                  void 0 !== o &&
                  o.purchaseHistory
                ) {
                  var u;
                  const e =
                    null !== (u = this.apiMetainfo.purchaseHistory) &&
                    void 0 !== u
                      ? u
                      : [];
                  this.apiMetainfo.purchaseHistory = e.concat(
                    r.metainfoDelta.purchaseHistory
                  );
                }
                n ||
                  this.opts.hooks.onReplicationResultStates(
                    null !== (l = r.requestedProfiles) && void 0 !== l ? l : {},
                    e.batchId
                  );
                (this.replicationFlushPromise = null),
                  (this.isOnline = !0),
                  this.opts.replicantOptions.batchingMaxTime
                    ? (this.clearFlushTimer(), this.scheduleReplication())
                    : this.flushReplication();
              })
              .catch((t) => {
                if (
                  ((this.replicationFlushPromise = null),
                  t.code !== $c.network_error)
                ) {
                  this.batchToRetry = null;
                  for (const n of e.queue) n.callback(t, void 0);
                  this.resetQueue();
                }
                this.handleError(t);
              }));
        }
        applyMessages(e, t) {
          const n = this.opts.config.messages;
          for (const s of t) {
            if (Fl(s)) {
              try {
                Mm(e, s);
              } catch (r) {
                if (!(r instanceof nl && "inapplicable_diff" === r.subCode))
                  throw r;
              }
              continue;
            }
            const t = Ko(n, s.name);
            if (!t) continue;
            t.schema.validate(s.args) ||
              t.reducer(e.state, s.args, {
                senderId: s.sender,
                timestamp: s.timestamp,
              });
          }
        }
        handleError(e) {
          (this.isOnline = !1),
            this.clearHeartbeatTimer(),
            this.opts.hooks.onError(e);
        }
        async postReplicationQueue(e) {
          var t;
          const { queue: n, requestedProfileIds: r, clientRandomSeed: s } = e,
            i = {
              abTestsDynamicConfig: this.opts.abTestsDynamicConfig,
              queue: n.map((e) => ({
                fn: e.fn,
                async: e.async,
                args: e.args,
                meta: e.meta,
              })),
              rev: this.revId,
              requestedProfileIds: r,
              consistentFetchIds: this.calcConsistentFetchIds(),
              sid: this.opts.sessionId,
              sessionName: this.opts.replicantOptions.sessionName,
              clientRandomSeed: s,
              crqid: yc(),
            },
            o = this.dateNow(),
            a = await this.opts.httpClient.doPostReplicationRequest(i),
            c = this.dateNow();
          if (c - o < Xc) {
            const e = py(o, c, a);
            this.opts.adjustClockOffset(e);
          }
          if (
            null === (t = a.data) ||
            void 0 === t ||
            !t.results ||
            "number" !== typeof a.data.rev
          )
            throw new Error("Invalid replication response.");
          return (
            (this.revId = a.data.rev),
            {
              results: a.data.results,
              messages: a.data.messages,
              metainfoDelta: a.data.metainfoDelta,
              requestedProfiles: a.data.requestedProfiles,
              lastUpdated: a.data.lastUpdated,
              newLastUpdated: a.data.newLastUpdated,
            }
          );
        }
        resetHeartbeatTimer() {
          this.clearHeartbeatTimer();
          const e = this.opts.replicantOptions.checkForMessagesInterval;
          e &&
            this.isOnline &&
            !this.isPaused &&
            (this.heartbeatTimer = Jm(
              () => this.scheduleCheckForMessages(),
              e
            ));
        }
        clearHeartbeatTimer() {
          this.heartbeatTimer &&
            (clearTimeout(this.heartbeatTimer), (this.heartbeatTimer = 0));
        }
        scheduleCheckForMessages() {
          var e;
          (null !== (e = this.replicationFlushPromise) && void 0 !== e
            ? e
            : this.queue.length > 0) ||
          this.replicationBatch.queue.length > 0 ||
          this.batchToRetry
            ? this.resetHeartbeatTimer()
            : (this.queue.push({
                type: "sync",
                fnName: Kc,
                args: [],
                callback: () => null,
                invokedAt: this.dateNow(),
              }),
              this.resolveQueue());
        }
        onStateChanged() {
          (this.externalState = wy({
            oldState: this.externalState,
            newState: this.currentState,
            metainfo: this.apiMetainfo,
            userSharedStates: this.opts.userData.userSharedStates,
            config: this.opts.config,
          })),
            this.opts.hooks.onStateChanged(this.externalState);
        }
        dateNow() {
          var e, t;
          return (
            (null === (e = this.opts.replicantOptions.devOpts) ||
            void 0 === e ||
            null === (t = e.dateNow) ||
            void 0 === t
              ? void 0
              : t.call(e)) || Date.now()
          );
        }
        crosscheckAsyncAPICalls(e, t, n) {
          if (t.resultIndex !== n)
            throw new nl(
              "Action "
                .concat(e, " used ")
                .concat(t.resultIndex, " api calls: ") +
                t.apiCallQueue.join(", ") +
                "; but server provided ".concat(n, " results!"),
              "replication_error",
              "async_action_api_error"
            );
        }
      }
      function wy(e) {
        const t = qo(e.oldState, e.newState);
        if (t !== e.oldState) {
          const { id: n, createdAt: r, updatedAt: s } = e.newState;
          Al(
            t,
            {
              id: n,
              createdAt: r,
              updatedAt: s,
              metainfo: e.metainfo,
              userSharedStates: e.userSharedStates,
            },
            e.config
          );
        }
        return t;
      }
      function Sy(e) {
        Al(
          e.state,
          {
            createdAt: e.state.createdAt,
            id: e.state.id,
            updatedAt: e.updatedAt,
            metainfo: e.metainfo,
            userSharedStates: e.userSharedStates,
          },
          e.config
        );
      }
      function _y(e) {
        const t = e.state.updatedAt;
        Sy({
          state: e.state,
          metainfo: e.metainfo,
          updatedAt: e.updatedAt,
          userSharedStates: e.userSharedStates,
          config: e.config,
        });
        try {
          const n = e.fn(e.state);
          return bc(n)
            ? n
                .then(
                  (n) => (
                    Sy({
                      state: e.state,
                      metainfo: e.metainfo,
                      updatedAt: t,
                      userSharedStates: e.userSharedStates,
                      config: e.config,
                    }),
                    n
                  )
                )
                .catch(
                  (n) => (
                    Sy({
                      state: e.state,
                      metainfo: e.metainfo,
                      updatedAt: t,
                      userSharedStates: e.userSharedStates,
                      config: e.config,
                    }),
                    Promise.reject(n)
                  )
                )
            : (Sy({
                state: e.state,
                metainfo: e.metainfo,
                updatedAt: t,
                userSharedStates: e.userSharedStates,
                config: e.config,
              }),
              n);
        } catch (n) {
          throw (
            (Sy({
              state: e.state,
              metainfo: e.metainfo,
              updatedAt: t,
              userSharedStates: e.userSharedStates,
              config: e.config,
            }),
            n)
          );
        }
      }
      class Ey {
        constructor(e, t) {
          (this.httpClient = e), (this.now = t), (this.calledUpdateSelf = !1);
        }
        async updateSelf(e, t) {
          (this.calledUpdateSelf = !0),
            await this.httpClient.doPostSocialGraphUpdateSelf({
              nonPlayerFriendIds: e,
              meta: t,
            });
        }
        async trackInteractions(e) {
          if (!this.calledUpdateSelf)
            throw Error(
              "socialGraph.updateSelf must be called before tracking interactions"
            );
          const t = this.now(),
            n = e.map((e) => ({ ...e, timestamp: e.timestamp || t }));
          await this.httpClient.doPostSocialGraphTrackInteractions({
            interactions: n,
          });
        }
      }
      class Ay {
        constructor(e) {
          this.httpClient = e;
        }
        async upload(e) {
          var t;
          if (e.length > 94e4)
            throw new nl(
              "Maximum payload size exceeded for dataUrl: " + e.length,
              "replication_error",
              "user_asset_upload_error"
            );
          $v(e);
          const n = await this.httpClient.doUploadUserAssetRequest(
            { dataUrl: e },
            {
              defaultErrorCodes: {
                code: "replication_error",
                subCode: "user_asset_upload_error",
              },
            }
          );
          if (null === (t = n.data) || void 0 === t || !t.assetUrl)
            throw new nl(
              "Invalid user asset upload response.",
              "replication_error",
              "user_asset_upload_error"
            );
          return n.data.assetUrl;
        }
      }
      class Ty {
        constructor(e, t, n, r, s, i, o, a, c, l, u, d, h) {
          var p,
            f = this;
          (this.id = e),
            (this.sessionId = t),
            (this.userData = n),
            (this.config = r),
            (this.options = s),
            (this.httpClient = i),
            (this.kvStore = o),
            (this.internalKvStore = a),
            (this.userAssetsBaseUrl = c),
            (this.chatbotAssetUrls = l),
            (this.extraData = u),
            (this.asyncGetters = {}),
            (this.invoke = {}),
            (this.extras = {
              getECPM: () => ({
                fb: this.extraData.ecpmPerAdPlacement
                  ? { perAdPlacement: this.extraData.ecpmPerAdPlacement }
                  : {},
              }),
              getExchangeRates: () => ({ ...this.extraData.exchangeRates }),
              getLastReceivedChatbotMessagePayload: () => {
                var e;
                return null === (e = this.userData.chatbotMetainfo) ||
                  void 0 === e
                  ? void 0
                  : e.lastReceivedMessagePayload;
              },
              afterContextSwitch: async (e) => {
                await this.httpClient.doPostAfterContextSwitchRequest({
                  contextSwitchEventId: e.contextSwitchEventId,
                });
              },
              setActionAnalyticsCallback: (e) => {
                this.queueManager.setActionAnalyticsCallback(e);
              },
            }),
            (this.paymentSubscriptions = {
              getStatus: () => {
                var e;
                return null ===
                  (e = this.userData.metainfoMVCC.paymentSubscription) ||
                  void 0 === e
                  ? void 0
                  : e.status;
              },
            }),
            (this.refreshToRetry = !1),
            (this.forbidInvocations = !1),
            (this.onStateChangedHandlers = []),
            (this.paused = !1),
            (this.onError = (e) => {
              throw new Error(
                "{message: ".concat(e.message, ", code: ").concat(e.code, " }")
              );
            }),
            (this.onMessagePosted = (e, t) => {
              this.friendsMngr.handleReplicantMessage(e, t);
            }),
            (this.handleActionCompleted = (e) => {
              this.friendsMngr.handleReplicantActionCompleted(e),
                this.abTestsManager.handleReplicantActionCompleted();
            });
          const m = {};
          for (const y in r.actions) {
            const e = r.actions[y];
            if ("function" === typeof e.fn && "string" === typeof e.type) {
              const t = e;
              m[y] = this.wrapAction(y, t.type);
            } else {
              const t = e,
                n = {};
              for (const e in t) {
                const r = this.wrapAction(
                  "".concat(y, ".").concat(e),
                  t[e].type
                );
                n[e] = r;
              }
              m[y] = n;
            }
          }
          this.invoke = m;
          const g = {},
            v = (e, t) =>
              this.httpClient.doAsyncGetterRequest({
                args: t,
                name: e,
                sid: this.sessionId,
                consistentFetchIds: this.queueManager.calcConsistentFetchIds(),
              });
          for (const y in r.asyncGetters) {
            const e = r.asyncGetters[y];
            if ("function" === typeof e) g[y] = (e) => v(y, e);
            else {
              const t = {};
              for (const n in e)
                t[n] = (e) => v("".concat(y, ".").concat(n), e);
              g[y] = t;
            }
          }
          (this.asyncGetters = g),
            (this.clockSyncOffset = this.options.clockOffset || 0),
            (this.currentTime = this.userData.lastInvokeTime || 0),
            (this.friendsMngr = new fy({
              config: r,
              options: s,
              httpClient: this.httpClient,
              adjustClockOffset: function () {
                return f.adjustClockOffset(...arguments);
              },
              calcConsistentFetchIds: () =>
                this.queueManager.calcConsistentFetchIds(),
            })),
            (this.abTestsManager = new dy({
              config: r,
              dynamicConfig: h,
              metainfo: this.userData.metainfo,
              changeEvents: d,
            })),
            (n.chatbotMetainfo =
              null !== (p = n.chatbotMetainfo) && void 0 !== p ? p : {}),
            (this.otp = new my({
              hasPhoneNumber: () => !!this.userData.metainfo.hasPhoneNumber,
              httpClient: this.httpClient,
            })),
            (this.platform = s.platform),
            (this.queueManager = new by({
              abTestsDynamicConfig: h,
              getTrackedUserIds: () => this.friends.getTrackedUserIds(),
              id: e,
              sessionId: this.sessionId,
              userData: n,
              config: r,
              replicantOptions: s,
              httpClient: this.httpClient,
              now: () => this.now() - (this.userData.metainfo.clockOffset || 0),
              adjustClockOffset: function () {
                return f.adjustClockOffset(...arguments);
              },
              hooks: {
                onStateChanged: (e) => this.handleOnStateChanged(e),
                onActionCompleted: (e) => this.handleActionCompleted(e),
                onMessagePosted: (e, t) => this.onMessagePosted(e, t),
                onReplicationResultStates: (e, t) => {
                  this.friendsMngr.handleReplicationResultStates(e, t);
                },
                onError: (e) => {
                  e.code !== $c.network_error &&
                    (this.friendsMngr.clearLocks(),
                    this.pause(),
                    (this.forbidInvocations = !0)),
                    this.onError(e);
                },
              },
              userAssetsBaseUrl: c,
              abTestsManager: this.abTestsManager,
            })),
            (this.socialGraph = new Ey(this.httpClient, () => this.now())),
            (this.userAssets = new Ay(this.httpClient)),
            r.onError && this.setOnError(r.onError);
        }
        get state() {
          return this.queueManager.getExternalState();
        }
        get userId() {
          return this.id;
        }
        get friends() {
          return this.friendsMngr;
        }
        get abTests() {
          return this.abTestsManager;
        }
        getChatbotSessionData() {
          return { sessionId: this.sessionId, appVersion: this.config.version };
        }
        onStateChanged(e) {
          this.onStateChangedHandlers.push(e);
        }
        removeStateChangedHandler(e) {
          this.onStateChangedHandlers = this.onStateChangedHandlers.filter(
            (t) => t !== e
          );
        }
        clearStateChangedHandlers() {
          this.onStateChangedHandlers = [];
        }
        onMessagesReceived(e) {
          this.queueManager.onMessagesReceived(e);
        }
        removeMessagesReceivedHandler(e) {
          this.queueManager.removeMessagesReceivedHandler(e);
        }
        setOnError(e) {
          this.onError = e;
        }
        pause() {
          (this.paused = !0),
            this.queueManager.pause(),
            this.friendsMngr.pause(),
            this.httpClient.pause();
        }
        resume(e) {
          this.forbidInvocations ||
            ((this.paused = !1),
            this.queueManager.resume(),
            this.friendsMngr.resume(),
            this.httpClient.resume(),
            (null !== e && void 0 !== e && e.skipCheckForMessages) ||
              this.checkForMessages());
        }
        isPaused() {
          return this.paused;
        }
        async fetchStates(e) {
          return this.friendsMngr.fetchOtherPlayerStates(e);
        }
        async waitForEmptyQueue() {
          return this.queueManager.waitForEmptyQueue();
        }
        async flush(e) {
          return this.queueManager.flush(e);
        }
        now() {
          return (
            (this.currentTime = Math.max(
              this.currentTime,
              Math.floor(this.dateNow() + this.clockSyncOffset)
            )),
            this.currentTime + (this.userData.metainfo.clockOffset || 0)
          );
        }
        adjustClockOffset(e) {
          var t;
          const n =
            (null === (t = this.options.devOpts) || void 0 === t
              ? void 0
              : t.clockSyncOffsetAllowedDifference) || Qc / 2;
          Math.abs(this.now() - (this.dateNow() + e)) > n &&
            (this.clockSyncOffset = e);
        }
        checkForMessages() {
          return this.forbidInvocations
            ? Promise.reject(
                new nl(
                  "Do not check for messages while out of sync. Refresh first!",
                  "replication_error",
                  "invoking_while_out_of_sync"
                )
              )
            : this.queueManager.checkForMessages();
        }
        async setTestUsers(e) {
          return (await this.httpClient.doPostTestUsers({ states: e })).data
            .testUsersMap;
        }
        getPurchaseHistory() {
          return this.queueManager.getPurchaseHistory();
        }
        getToken() {
          return this.httpClient.getToken();
        }
        async inferGenderFromName(e) {
          return (await this.httpClient.doPostInferGenderFromName({ name: e }))
            .data;
        }
        async refresh(e) {
          let t;
          this.friendsMngr.clearLocks(),
            this.queueManager.resetQueue(),
            await this.flush({ skipErrorHandlers: !0 }),
            e && this.httpClient.setSignature(e);
          try {
            t = await hy({
              httpClient: this.httpClient,
              devOpts: this.options.devOpts,
              sessionId: this.sessionId,
              skipOnLoginAction: !0,
              isWebPlayable: this.options.isWebPlayable,
            });
          } catch (a_) {
            throw ((this.refreshToRetry = !0), this.onError(a_), a_);
          }
          (this.forbidInvocations = !1),
            (this.refreshToRetry = !1),
            (this.clockSyncOffset = t.clockOffset),
            (this.currentTime = t.data.lastInvokeTime || 0),
            this.queueManager.onRefresh(t.data),
            this.resume({ skipCheckForMessages: !0 });
        }
        async retryLastRequest() {
          let e;
          return (
            this.refreshToRetry
              ? (await this.refresh(), (e = !0))
              : (e = await this.queueManager.retryLastRequest()),
            this.friendsMngr.goOnline(),
            e
          );
        }
        async uploadUserAsset(e) {
          return this.userAssets.upload(e);
        }
        async sendIOSPushNotification(e) {
          return (await this.httpClient.doPostAPN(e)).data;
        }
        getAppleDeviceToken() {
          var e, t;
          return (!(
            null === (e = this.userData.chatbotMetainfo) ||
            void 0 === e ||
            !e.appleDeviceTokenUpdatedAt
          ) &&
            Nf(
              this.userData.chatbotMetainfo.appleDeviceTokenUpdatedAt,
              this.dateNow()
            )) ||
            null === (t = this.userData.chatbotMetainfo) ||
            void 0 === t
            ? void 0
            : t.appleDeviceToken;
        }
        async sendAndroidPushNotification(e) {
          return (await this.httpClient.doPostAndroidPushNotification(e)).data;
        }
        getAndroidDeviceToken() {
          var e, t;
          return (!(
            null === (e = this.userData.chatbotMetainfo) ||
            void 0 === e ||
            !e.androidDeviceTokenUpdatedAt
          ) &&
            Rf(
              this.userData.chatbotMetainfo.androidDeviceTokenUpdatedAt,
              this.dateNow()
            )) ||
            null === (t = this.userData.chatbotMetainfo) ||
            void 0 === t
            ? void 0
            : t.androidDeviceToken;
        }
        async sendPushNotification(e) {
          const { notification: t, ...n } = e;
          let r;
          if ("text" in t) {
            const {
              text: { title: e, body: n },
            } = t;
            r = {
              ios: { alert: { title: e, body: n }, sound: "default" },
              android: {
                title: e,
                body: n,
                icon: "ic_launcher",
                sound: "default",
              },
            };
          } else r = t.overrideDefaultProps;
          return (
            await this.httpClient.doPostPushNotification({
              notifications: r,
              ...n,
            })
          ).data;
        }
        getNativeBridgeSecret() {
          var e;
          return null === (e = this.userData.chatbotMetainfo) || void 0 === e
            ? void 0
            : e.nativeBridgeSecret;
        }
        getGeolocation() {
          return this.extraData.geolocation;
        }
        getReplicantVersion() {
          return "29.5.3";
        }
        getUserAssetUrl(e) {
          return this.userAssetsBaseUrl + e;
        }
        getChatbotAssetUrl(e) {
          return this.chatbotAssetUrls[e];
        }
        setActionPreInvokeCallback(e) {
          this.queueManager.actionInvocationCallbacks.preInvoke = e;
        }
        setActionPostInvokeCallback(e) {
          this.queueManager.actionInvocationCallbacks.postInvoke = e;
        }
        setActionCancelledCallback(e) {
          this.queueManager.actionInvocationCallbacks.cancelled = e;
        }
        setActionFailedCallback(e) {
          this.queueManager.actionInvocationCallbacks.failed = e;
        }
        handleOnStateChanged(e) {
          this.onStateChangedHandlers.forEach((t) => t(e));
        }
        wrapAction(e, t) {
          return (n) => {
            let r = !1;
            try {
              r =
                "prod" ===
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.STAGE;
            } catch {}
            return (
              r ||
                void 0 === n ||
                (function (e) {
                  let t;
                  try {
                    t = JSON.parse(JSON.stringify(e));
                  } catch {
                    return !1;
                  }
                  return Wo(t, e);
                })(n) ||
                (Xl.warn(
                  [
                    "Action ".concat(
                      e,
                      " was called with an argument that can't be sent to the server."
                    ),
                    "Argument: " + av(n, 4),
                    "Would be sent as: " + JSON.stringify(n, null, 4),
                  ].join("\n")
                ),
                Xl.warn(
                  "Above Warning may become an EXCEPTION in future release, please fix it!"
                )),
              this.forbidInvocations
                ? Promise.reject(
                    new nl(
                      "Trying to invoke ".concat(
                        e,
                        " while state is out of sync. Refresh first!"
                      ),
                      "replication_error",
                      "invoking_while_out_of_sync"
                    )
                  )
                : this.queueManager.enqueueAction(e, t, n)
            );
          };
        }
        dateNow() {
          var e, t;
          return (
            (null === (e = this.options.devOpts) ||
            void 0 === e ||
            null === (t = e.dateNow) ||
            void 0 === t
              ? void 0
              : t.call(e)) || Date.now()
          );
        }
      }
      class Py {
        constructor(e) {
          (this.options = e),
            (this.signatureRefreshOffset = Sc({ hours: 1 })),
            e.initialSignature
              ? this.setSignature(e.initialSignature)
              : this.refreshSignature();
        }
        pause() {
          this.timeoutHandle &&
            (clearTimeout(this.timeoutHandle), delete this.timeoutHandle);
        }
        resume() {
          if ((this.pause(), !this.options.obtainSignature)) return;
          const e = this.getTimeUntilSignatureUpdate();
          e > 0
            ? (this.timeoutHandle = Jm(() => this.refreshSignature(), e))
            : this.refreshSignature();
        }
        async getSignature() {
          return (
            this.getTimeUntilSignatureUpdate() <= 0 &&
              (this.refreshSignature(),
              this.isSignatureExpired() &&
                (await this.refreshSignaturePromise)),
            this.signature
          );
        }
        setSignature(e) {
          if (((this.signature = e), this.options.obtainSignature)) {
            this.pause();
            try {
              const t = e.split(".")[1],
                n = Gm(t),
                r = JSON.parse(n);
              if (r.exp)
                (this.signatureExpiresAt = Sc({ seconds: r.exp })),
                  (this.signatureRefreshOffset = Sc({ minutes: 1 }));
              else {
                const e = Sc({ seconds: r.issued_at });
                this.signatureExpiresAt = e + Sc({ hours: 24 });
              }
            } catch (a_) {
              this.signatureExpiresAt = this.options.now() + Sc({ hours: 24 });
            }
            this.resume();
          }
        }
        async getToken() {
          return (
            this.isTokenExpired() && this.refreshToken(),
            await this.refreshTokenPromise,
            this.token
          );
        }
        setToken(e) {
          this.token = e;
          try {
            const t = e.split(".")[1],
              n = Gm(t),
              r = JSON.parse(n);
            this.tokenExpiresAt = Sc({ seconds: r.exp });
          } catch (a_) {
            throw new nl(
              a_.message,
              "authorization_error",
              "invalid_signature"
            );
          }
        }
        refreshSignature() {
          const e = this.options.obtainSignature;
          e &&
            (this.refreshSignaturePromise ||
              (this.pause(),
              (this.refreshSignaturePromise = e()
                .then((e) => this.setSignature(e))
                .finally(() => delete this.refreshSignaturePromise))));
        }
        refreshToken() {
          return (
            this.refreshTokenPromise ||
              (this.refreshTokenPromise = this.options
                .obtainToken()
                .then((e) => this.setToken(e))
                .finally(() => delete this.refreshTokenPromise)),
            this.refreshTokenPromise
          );
        }
        getTimeUntilSignatureUpdate() {
          return void 0 === this.signatureExpiresAt
            ? 0
            : this.signatureExpiresAt -
                this.options.now() -
                this.signatureRefreshOffset;
        }
        isSignatureExpired() {
          return (
            this.getTimeUntilSignatureUpdate() <= this.signatureRefreshOffset
          );
        }
        isTokenExpired() {
          if (void 0 === this.tokenExpiresAt) return !0;
          const e = this.signatureRefreshOffset / 2;
          return this.tokenExpiresAt - e < this.options.now();
        }
      }
      const Iy = {
          Accept: "application/json, text/plain, */*",
          "Content-Type": "text/plain",
        },
        Cy =
          "Please check the following:\n- Is the backend endpoint URL configured correctly?\n- Is the backend infrastructure provisioned?\n- Is the backend deployed?";
      class ky {
        constructor(e) {
          var t;
          (this.id = e.id),
            (this.endpoint = e.endpoint),
            (this.version = e.version),
            (this.retryOptions = e.retryOptions),
            (this.signatureManager = new Py({
              initialSignature: e.signature,
              obtainSignature: e.obtainSignature,
              obtainToken: () =>
                !this.id || e.isWebPlayable
                  ? this.doGetTokenWebPlayerRequest()
                  : this.doGetTokenRequest(),
              now: () => e.now(),
            })),
            (this.fetchFn =
              null !== (t = e.fetchOverride) && void 0 !== t
                ? t
                : fetch.bind(window));
        }
        pause() {
          this.signatureManager.pause();
        }
        resume() {
          this.signatureManager.resume();
        }
        getToken() {
          return this.signatureManager.getToken();
        }
        async doLoginOrCreateRequest(e) {
          const t = await this.postRequest(jc.LOGIN_OR_CREATE, e);
          return this.signatureManager.setToken(t.data.token), t;
        }
        async doLoginOrCreateWebPlayerRequest(e) {
          const t = await this.postRequest(jc.LOGIN_OR_CREATE_WEB_PLAYER, e);
          return (
            (this.id = t.data.id),
            this.signatureManager.setToken(t.data.token),
            this.signatureManager.setSignature(t.data.webPlayerAuthToken),
            t
          );
        }
        async doFetchStatesRequest(e) {
          return this.postRequest(jc.FETCH_STATES, e);
        }
        async doAsyncGetterRequest(e) {
          const { result: t } = await this.postRequest(jc.ASYNC_GETTER, e);
          return t;
        }
        async doPostAfterContextSwitchRequest(e, t) {
          await this.postRequest(jc.AFTER_CONTEXT_SWITCH, e, t);
        }
        async doPostReplicationRequest(e) {
          return this.postRequest(jc.REPLICATE, e);
        }
        async doSendKeyValuePairsRequest(e, t) {
          return this.postRequest(jc.WRITE_KEY_VALUES, e, t);
        }
        async doGetKeyValuePairsRequest(e, t) {
          return this.postRequest(jc.READ_KEY_VALUES, e, t);
        }
        doGetInternalKeyValuePairsRequest(e, t) {
          return this.postRequest(jc.READ_INTERNAL_KEY_VALUES, e, t);
        }
        async doUploadUserAssetRequest(e, t) {
          return this.postRequest(jc.UPLOAD_USER_ASSET, e, t);
        }
        async doPostAPN(e, t) {
          return this.postRequest(jc.IOS_POST_APN, e, t);
        }
        async doPostAndroidPushNotification(e, t) {
          return this.postRequest(jc.ANDROID_POST_PUSH_NOTIFICATION, e, t);
        }
        async doPostPushNotification(e, t) {
          return this.postRequest(jc.PUSH_NOTIFICATION, e, t);
        }
        async doPostTestUsers(e, t) {
          return this.postRequest("testUsers", e, t);
        }
        doPostInferGenderFromName(e, t) {
          return this.postRequest(jc.INFER_GENDER_FROM_NAME, e, t);
        }
        async doPostOAuthGetAccessToken(e, t) {
          return this.postRequest(jc.OAUTH_GET_ACCESS_TOKEN, e, t);
        }
        async doPostOtpInitiateAddReceiver(e, t) {
          return (await this.postRequest(jc.OTP_INITIATE_ADD_RECEIVER, e, t))
            .data;
        }
        async doPostOtpInitiateLogin(e, t) {
          return (await this.postRequest(jc.OTP_INITIATE_LOGIN, e, t)).data;
        }
        async doPostSocialGraphUpdateSelf(e, t) {
          await this.postRequest(jc.SOCIAL_GRAPH_UPDATE_SELF, e, t);
        }
        async doPostSocialGraphTrackInteractions(e, t) {
          await this.postRequest(jc.SOCIAL_GRAPH_TRACK_INTERACTIONS, e, t);
        }
        setSignature(e) {
          this.signatureManager.setSignature(e);
        }
        async doGetTokenRequest() {
          return (await this.postRequest(jc.TOKEN, {})).data.token;
        }
        async doGetTokenWebPlayerRequest() {
          return (await this.postRequest(jc.TOKEN_WEB_PLAYER, {})).data.token;
        }
        async postRequest(e, t, n) {
          var r;
          const s =
            !this.id &&
            (e === jc.LOGIN_OR_CREATE_WEB_PLAYER ||
              e === jc.OAUTH_GET_ACCESS_TOKEN ||
              e === jc.OTP_INITIATE_LOGIN)
              ? t
              : {
                  ...t,
                  id: this.id,
                  auth:
                    e === jc.LOGIN_OR_CREATE ||
                    e === jc.LOGIN_OR_CREATE_WEB_PLAYER ||
                    e === jc.TOKEN ||
                    e === jc.TOKEN_WEB_PLAYER
                      ? await this.signatureManager.getSignature()
                      : await this.signatureManager.getToken(),
                };
          if (null !== (r = Bc[e].post.schema) && void 0 !== r && r.validate(s))
            throw new nl("Invalid parameters", "replication_error");
          const i = JSON.stringify(s);
          if (i.length > 95e4)
            throw new nl(
              "Client payload too large",
              "replication_error",
              "payload_too_large"
            );
          let o;
          const a = this.endpoint + "/v" + this.version + "/" + e,
            c = {
              ...this.retryOptions,
              ...(null === n || void 0 === n ? void 0 : n.retryOptions),
            };
          try {
            o = await Fm(
              () => this.fetchFn(a, { method: "POST", headers: Iy, body: i }),
              c
            );
          } catch (l) {
            throw (function (e) {
              const t = new nl(
                "Client request failed: "
                  .concat(e.error.message, "\n\n")
                  .concat(Cy),
                "network_error",
                void 0,
                "error",
                {
                  body: e.body,
                  method: e.method,
                  path: e.path,
                  reason: e.error.message,
                }
              );
              return (t.stack = e.error.stack), t;
            })({ error: l, method: "POST", path: e, body: i });
          }
          return await this.parseTextAndHandleError(
            o,
            e,
            null === n || void 0 === n ? void 0 : n.defaultErrorCodes
          );
        }
        async parseTextAndHandleError(e, t, n) {
          const r = await e.text();
          if (e.status >= 502)
            throw new nl(
              "Status code: " + e.status + ", message: " + r,
              "server_error"
            );
          if (403 === e.status) {
            let e;
            try {
              const t = JSON.parse(r);
              (null === t || void 0 === t ? void 0 : t.subCode) in el &&
                (e = t.subCode);
            } catch (a_) {}
            throw new nl(
              (
                (r || "") +
                "\n\nPlease check the following:\n- Is the backend endpoint URL configured correctly? Make sure you're targeting the right deployment stage."
              ).trim(),
              "authorization_error",
              e
            );
          }
          if (e.status >= 400) {
            var s;
            let t = r,
              i =
                null !== (s = null === n || void 0 === n ? void 0 : n.code) &&
                void 0 !== s
                  ? s
                  : $c.unknown_error,
              o = null === n || void 0 === n ? void 0 : n.subCode,
              a = {};
            try {
              const e = JSON.parse(r);
              e.message && (t = e.message),
                e.code in $c && (i = e.code),
                e.subCode in tl && (o = e.subCode),
                e.clientExtras &&
                  "object" === typeof e.clientExtras &&
                  (a = e.clientExtras);
            } catch (a_) {}
            throw (
              (404 === e.status &&
                (t = (
                  (t || "") +
                  "\n\nPlease check the following:\n- Is the backend endpoint URL configured correctly? Make sure you're targeting the right deployment stage.\n- Is the current app version deployed to the backend?"
                ).trim()),
              new nl(t, i, o, void 0, void 0, a))
            );
          }
          try {
            return JSON.parse(r);
          } catch (a_) {
            throw new nl(
              "Payload not JSON: " + r + " for API call: " + t,
              "unknown_error"
            );
          }
        }
      }
      async function Oy(e) {
        var t, n, r, s;
        const {
          config: i,
          id: o,
          options: a,
          internalKeyValueStorePrefetchKeys: c,
          keyValueStorePrefetchKeys: l,
        } = e;
        if ((tm(i), !o && !a.isWebPlayable)) throw new Error("Invalid ID");
        let u;
        const d = new ky({
          id: o,
          isWebPlayable: a.isWebPlayable,
          endpoint: a.endpoint,
          version: i.version,
          fetchOverride: a.fetchOverride,
          signature: a.telegramAuthorizationData
            ? ((h = a.telegramAuthorizationData),
              Object.keys(h)
                .filter((e) => void 0 !== h[e])
                .sort()
                .map((e) => "".concat(e, "=").concat(h[e]))
                .join("\n"))
            : a.signature,
          retryOptions:
            null !==
              (t =
                null === (n = a.devOpts) || void 0 === n
                  ? void 0
                  : n.retryOptions) && void 0 !== t
              ? t
              : { retries: 1, linearBackoff: 500 },
          obtainSignature: a.obtainSignature,
          now: () => {
            var e, t, n;
            return (
              (null === (e = u) || void 0 === e ? void 0 : e.now()) ||
              (null === (t = a.devOpts) ||
              void 0 === t ||
              null === (n = t.dateNow) ||
              void 0 === n
                ? void 0
                : n.call(t)) ||
              Date.now()
            );
          },
        });
        var h;
        const p = yc(),
          f = await hy({
            clientAppName: e.clientAppName,
            httpClient: d,
            devOpts: a.devOpts,
            isWebPlayable: a.isWebPlayable,
            loginToken: a.loginToken,
            onLoginActionArgs: a.onLoginActionArgs,
            otp: a.isWebPlayable ? e.otp : void 0,
            prefetchKeys: l,
            prefetchInternalKeys: c,
            sessionId: p,
          }).catch((e) => {
            var t;
            throw (null === (t = i.onError) || void 0 === t || t.call(i, e), e);
          }),
          m = f.clockOffset;
        a.clockOffset = m;
        try {
          f.data.state = i.stateSchema.tryDecode(f.data.state);
        } catch (C) {
          throw new Error("User state invalid: " + C.message);
        }
        const {
            abTestsDynamicConfig: g,
            extraData: v,
            prefetchedKeys: y,
            prefetchedInternalKeys: b,
            userAssetsBaseUrl: w,
            chatbotAssetUrls: S,
            abTestChangeEvents: _,
            ...E
          } = f.data,
          A = new uy(d, y),
          T = new ly(d, b),
          P = {
            ...a,
            batchingMaxTime:
              null === a.batchingMaxTime
                ? null
                : null !== (r = a.batchingMaxTime) && void 0 !== r
                ? r
                : Sc({ seconds: 3 }),
            checkForMessagesInterval:
              null === a.checkForMessagesInterval
                ? null
                : null !== (s = a.checkForMessagesInterval) && void 0 !== s
                ? s
                : Sc({ seconds: 10 }),
          };
        u = new Ty(
          "id" in f.data ? f.data.id : o,
          p,
          E,
          i,
          P,
          d,
          A,
          T,
          w,
          S,
          v,
          _,
          g
        );
        const I =
          "webPlayerAuthToken" in f.data ? f.data.webPlayerAuthToken : void 0;
        return { replicant: u, webPlayerAuthToken: I };
      }
      const xy = {
        fetch: (e) =>
          fetch(e.url, {
            body: "body" in e ? e.body : void 0,
            headers: e.headers,
            method: e.method,
          }).then(async (t) => {
            const n = {};
            return (
              t.headers.forEach((e, t) => {
                n[t] = e;
              }),
              {
                body: await t.text(),
                headers: n,
                statusCode: t.status,
                url: e.url,
              }
            );
          }),
      };
      let Ny;
      const Ry = () =>
        Ny || ((Ny = document.getElementById("coin-container")), Ny);
      function Dy(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const n = Ry();
        if (!n) return;
        const r = {
            top: "".concat(50 * Math.random(), "px"),
            left: "calc(".concat(2 + 30 * Math.random(), "vh)"),
          },
          s = (function (e) {
            let { className: t, content: n, style: r } = e;
            const s = document.createElement("div");
            return (
              (s.className = t),
              (s.innerHTML = n),
              Object.keys(r).forEach((e) => {
                const t = r[e];
                t && (s.style[e] = t);
              }),
              s
            );
          })({
            className: "point-up ".concat(t && "boosted"),
            content: "+".concat(e),
            style: r,
          });
        n.append(s),
          setTimeout(() => {
            s.remove();
          }, 400);
      }
      let My;
      const jy = () => {
        var e;
        return (
          My ||
          ((My =
            null === (e = document.getElementById("ripple-templates")) ||
            void 0 === e
              ? void 0
              : e.children[0]),
          My)
        );
      };
      const Ly = (_a.unknown(), (e) => e)({
        debugPanel_assign: pc((e, t, n) => {
          n.abTests.assign(t.testId, t.bucket);
        }),
        debugPanel_setClockOffset: pc((e, t, n) => {
          n.setClockOffset(t.clockOffset);
        }),
        debugPanel_getClockOffset: pc((e, t, n) => n.getClockOffset()),
      });
      const Uy = 864e5;
      function Fy(e) {
        return {
          getEntryTimestamps: async (t, n) => {
            const r = await n.fetchStates(t);
            return Aa(t, (t) => {
              var n, s;
              const i = null == (n = r[t]) ? void 0 : n.state;
              if (!i) return;
              if (null == e ? void 0 : e.getPlatformStorage)
                return e.getPlatformStorage(i);
              return null == (s = i.gcinstant) ? void 0 : s.platformStorage;
            });
          },
          getFriendAnalytics: async (t, n) => {
            if (
              !(function (e, t) {
                var n, r;
                const { ageGroup: s, friendIds: i, updatedAt: o } = e;
                return (
                  (!s ||
                    (s._searchable &&
                      (s.type instanceof _a.StringSchema ||
                        s.type instanceof _a.TupleSchema))) &&
                  (null == i ? void 0 : i._searchable) &&
                  (null == i ? void 0 : i.type) instanceof _a.ArraySchema &&
                  (null == (r = null == i ? void 0 : (n = i.type).getItemSchema)
                    ? void 0
                    : r.call(n)) instanceof _a.StringSchema &&
                  (null == o ? void 0 : o._searchable) &&
                  (null == o ? void 0 : o.type) instanceof _a.IntegerSchema
                );
              })(e.computedProperties)
            )
              throw Error(
                "Missing required searchable computed properties for the getFriendAnalytics async getter: `friendIds` and `updatedAt`"
              );
            const r = [...t.friendIds],
              s = n.date.now(),
              i = new Date(s).setMinutes(0, 0, 0) - 90 * Uy,
              o = ["friendIds", "updatedAt"];
            !!e.computedProperties.ageGroup && o.push("ageGroup");
            const a = await n.searchPlayers({
                fields: o,
                where: { id: { isOneOf: r }, updatedAt: { greaterThan: i } },
                limit: Math.min(r.length, 1e4),
              }),
              c = { adult: 0, teen: 0, unknown: 0 },
              l = {};
            for (const e of a.results) {
              l[e.id] = {
                friendIds: e.friendIds || [],
                updatedAt: e.updatedAt,
              };
              c[
                "adult" === e.ageGroup
                  ? "adult"
                  : "teen" === e.ageGroup
                  ? "teen"
                  : "unknown"
              ] += 1;
            }
            const u = { ...By(l, s), playerFriendCount: r.length };
            l[n.getUserID()] = { friendIds: r, updatedAt: s };
            const d = (function (e) {
                const t = new Set();
                for (const n of Object.values(e))
                  for (const r of n.friendIds)
                    if (!e[r] && (t.add(r), 1e5 === t.size))
                      return Array.from(t);
                return Array.from(t);
              })(l),
              h = { ...l };
            for (; d.length > 0; ) {
              const e = d.splice(0, 1e4),
                t = await n.searchPlayers({
                  fields: ["friendIds", "updatedAt"],
                  where: { id: { isOneOf: e }, updatedAt: { greaterThan: i } },
                  limit: e.length,
                });
              for (const n of t.results)
                h[n.id] = {
                  friendIds: n.friendIds || [],
                  updatedAt: n.updatedAt,
                };
            }
            const p = (function (e, t) {
              const n = {
                clusterSize1D: 0,
                clusterSize3D: 0,
                clusterSize7D: 0,
                clusterSize14D: 0,
                clusterSize30D: 0,
                clusterSize90D: 0,
                clusterConnections1D: 0,
                clusterConnections3D: 0,
                clusterConnections7D: 0,
                clusterConnections14D: 0,
                clusterConnections30D: 0,
                clusterConnections90D: 0,
                clusterConnectedness1D: 0,
                clusterConnectedness3D: 0,
                clusterConnectedness7D: 0,
                clusterConnectedness14D: 0,
                clusterConnectedness30D: 0,
                clusterConnectedness90D: 0,
              };
              for (const { friendIds: r, updatedAt: s } of Object.values(e)) {
                for (const e of [1, 3, 7, 14, 30, 90])
                  t - s < Uy * e && (n["clusterSize".concat(e, "D")] += 1);
                for (const i of r)
                  if (e[i])
                    for (const r of [1, 3, 7, 14, 30, 90])
                      t - s < Uy * r &&
                        t - e[i].updatedAt < Uy * r &&
                        (n["clusterConnections".concat(r, "D")] += 1);
              }
              return (
                (n.clusterConnectedness1D = n.clusterSize1D
                  ? n.clusterConnections1D / n.clusterSize1D
                  : 0),
                (n.clusterConnectedness3D = n.clusterSize3D
                  ? n.clusterConnections3D / n.clusterSize3D
                  : 0),
                (n.clusterConnectedness7D = n.clusterSize7D
                  ? n.clusterConnections7D / n.clusterSize7D
                  : 0),
                (n.clusterConnectedness14D = n.clusterSize14D
                  ? n.clusterConnections14D / n.clusterSize14D
                  : 0),
                (n.clusterConnectedness30D = n.clusterSize30D
                  ? n.clusterConnections30D / n.clusterSize30D
                  : 0),
                (n.clusterConnectedness90D = n.clusterSize90D
                  ? n.clusterConnections90D / n.clusterSize90D
                  : 0),
                n
              );
            })(h, s);
            return {
              activeFriendCounts: u,
              ageGroupDistribution: c,
              clusterCounts: p,
            };
          },
          lineGetDebugFriendCounts: async (e, t) => {
            const n = (function (e, t) {
              if (t <= 0) throw Error("chunkSize must be greater than 0");
              const n = [];
              for (let r = 0; r < e.length; r += t) n.push(e.slice(r, r + t));
              return n;
            })(e.socialFriendIds, 1e3);
            let r = 0;
            for (const s of n)
              r += await t.countPlayers({ where: { id: { isOneOf: s } } });
            return { playingFriendCount: r };
          },
          lineIsSubscribedToChatbot: (e, t) => t.chatbot.isSubscribed(),
        };
      }
      function By(e, t) {
        function n(n) {
          return Object.values(e).filter((e) => t - e.updatedAt < Uy * n)
            .length;
        }
        return {
          activeFriendCount1D: n(1),
          activeFriendCount3D: n(3),
          activeFriendCount7D: n(7),
          activeFriendCount14D: n(14),
          activeFriendCount30D: n(30),
          activeFriendCount90D: n(90),
        };
      }
      Gf(_a.string().optional(), () => {}),
        Gf(_a.array(_a.string()), () => []),
        Gf(_a.int(), () => 0);
      const Vy = "0001_example",
        qy = "0004_invite_copy",
        Hy = "0005_invite_message",
        Wy = "0006_daily_reward",
        Ky = "0010_localization",
        zy = "0011_earn_page_buttons",
        Gy = {
          abTests: {
            [Vy]: { buckets: [{ id: "a" }, { id: "b" }] },
            [qy]: { buckets: [{ id: "control" }, { id: "active" }] },
            [Hy]: {
              buckets: [
                { id: "control" },
                { id: "miner" },
                { id: "teamfun" },
                { id: "teamcrypto" },
              ],
            },
            [Ky]: { buckets: [{ id: "control" }, { id: "localized" }] },
            [Wy]: {
              buckets: [
                { id: "control" },
                { id: "PreInvite" },
                { id: "PostInvite" },
                { id: "EarnQuest" },
              ],
            },
            [zy]: { buckets: [{ id: "control" }, { id: "with-buttons" }] },
          },
        },
        Jy = 1e3,
        Qy = "fallback-pic",
        Yy = {
          first_interaction: _a.boolean().default(!0),
          team_creation_start_time: _a.int(),
          migratedAt: _a.int().default(0),
          migrationForced: _a.boolean().default(!1),
          energy: _a.int().default(Jy),
          last_energy_refresh: _a.int().default(0),
          free_rocketman_used: _a.array(_a.int()),
          free_energy_recharge_timestamp: _a.int(),
          energy_limit_level: _a.int(),
          energy_recharge_level: _a.int(),
          rocketman_used: _a.array(_a.int()),
          tap_level: _a.int(),
          has_auto_tap: _a.boolean(),
          session_start_time: _a.int(),
          last_session_time: _a.int(),
          first_session: _a.boolean().default(!0),
          streak_days: _a.int().default(0),
          consecutive_days: _a.int().default(0),
          unclaimed_rewards: _a.int().default(0),
          last_reward_granted: _a.int(),
          last_ad_reward_time: _a.int().default(0),
          score: _a.int().default(500),
          balance: _a.int().default(500),
          taps: _a.int(),
          session_taps: _a.int(),
          team_id: _a.string().optional(),
          unsynced_team_score: _a.int(),
          invite_friend_nudge_time: _a.int().optional(),
          league: _a.string(),
          boosterPurchases: _a.object({
            autoTaps: _a.int(),
            multiTaps: _a.int(),
            rechargeLimits: _a.int(),
            rechargeSpeeds: _a.int(),
          }),
        },
        Xy = {
          username: _a.string(),
          is_premium: _a.boolean().default(!1),
          referrer_id: _a.string(),
          bot_menu_version: _a.string(),
        },
        Zy = _a.object({
          user_id: _a.string(),
          contribution: _a.int(),
          username: _a.string().optional(),
        }),
        $y = { friends: _a.array(Zy) },
        eb = {
          profile: _a.object({
            name: _a.string(),
            photo: _a.string(),
            photoLastUpdated: _a.int(),
            photoLastChecked: _a.int(),
          }),
        },
        tb = {
          migration: _a
            .object({ score: _a.int(), balance: _a.int() })
            .optional(),
        },
        nb = {
          followOnYoutubeTimestamp: _a.int().default(0),
          earnings: _a.object({
            followOnX: _a.boolean().default(!1),
            joinCommunity: _a.boolean().default(!1),
            inviteFriends5: _a.boolean().default(!1),
            inviteFriends10: _a.boolean().default(!1),
            inviteFriends100: _a.boolean().default(!1),
            followOnYoutube: _a.boolean().default(!1),
            joinAnnouncement: _a.boolean().default(!1),
          }),
        },
        rb = _a.object({ ...Yy, ...Xy, ...$y, ...eb, ...tb, ...nb });
      class sb {
        constructor() {
          this.migrations = [];
        }
        addMigration(e, t) {
          if (e !== this.migrations.length + 1)
            throw new Error("Migration version " + e + " not consecutive!");
          this.migrations.push(t);
        }
        getLatestVersion() {
          return this.migrations.length + 1;
        }
        applyMigration(e, t) {
          const n = t - 1;
          if (n < 0 || n >= this.migrations.length)
            throw new Error(
              "Invalid migrationIndex: " +
                n +
                " when trying to migrate to version " +
                t
            );
          this.migrations[n](e);
        }
      }
      const ib = _a.object({
          name: _a.string(),
          photo: _a.string().optional(),
          description: _a.string(),
          inviteLink: _a.string(),
        }),
        ob = {
          global: {
            schema: _a.object({
              profile: ib,
              score: _a.int(),
              membersCount: _a.int(),
              createdAt: _a.int(),
              modifiedAt: _a.int(),
              migration: _a.object({ score: _a.int() }).optional(),
            }),
            migrator: new sb(),
          },
        };
      function ab(e, t) {
        return { schema: e, reducer: t, isAdmin: !1 };
      }
      const cb = (e) => e,
        lb = Bl(
          _a.object({ score: _a.number(), timestamp: _a.number() }),
          (e, t, n) => {
            let { timestamp: r, score: s } = t;
            e.global.membersCount++,
              (e.global.score += s),
              (e.global.modifiedAt = r),
              1 === e.global.membersCount && (e.global.createdAt = r);
          }
        ),
        ub = {
          joinTeam: lb,
          addMember: lb,
          removeMember: Bl(
            _a.object({
              userId: _a.string().optional(),
              score: _a.number(),
              timestamp: _a.number(),
            }),
            (e, t, n) => {
              var r;
              let { userId: s, timestamp: i, score: o } = t;
              (s = null !== (r = s) && void 0 !== r ? r : n.senderId),
                (e.global.score -= o),
                e.global.membersCount--,
                (e.global.modifiedAt = i);
            }
          ),
          updateTeamProfile: Bl(
            _a.object({
              profile: _a.object({
                name: _a.string().optional(),
                photo: _a.string().optional(),
                description: _a.string().optional(),
                inviteLink: _a.string().optional(),
              }),
              timestamp: _a.number(),
            }),
            (e, t, n) => {
              (e.global.modifiedAt = t.timestamp),
                Object.assign(e.global.profile, t.profile);
            }
          ),
          addScore: Bl(_a.object({ score: _a.number() }), (e, t, n) => {
            let { score: r } = t;
            (e.global.score += r), (e.global.modifiedAt = n.timestamp);
          }),
          setMigrationData: Bl(_a.object({ score: _a.number() }), (e, t, n) => {
            let { score: r } = t;
            e.global.migration = { score: r };
          }),
        },
        db = cb({
          kickFromTeam: ab(_a.object({}), (e, t) => {
            delete e.team_id;
          }),
        }),
        hb = ((e) => {
          for (const [t, n] of Object.entries(e))
            if (!n._payload && !n._searchable)
              throw Error(
                "Invalid shared state computed property ".concat(
                  t,
                  ": computed property must be either searchable or payload"
                )
              );
          return e;
        })({
          profile: Gf(ib, (e) => e.global.profile),
          membersCount: Gf(_a.number(), (e) => e.global.membersCount),
          score: Gf(_a.number(), (e, t) => e.global.score),
          modifiedAt: Gf(_a.int(), (e) => e.global.modifiedAt),
          createdAt: Gf(_a.int(), (e) => e.global.createdAt),
        }),
        pb = (function (e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
          if (!e.global) {
            if (Object.keys(t).length > 0)
              throw Error(
                "Cannot define messages for a shared state without a global schema"
              );
            if (Object.keys(n).length > 0)
              throw Error(
                "Cannot define computed properties for a shared state without a global schema"
              );
          }
          return { schema: e, messages: t, computedProperties: n };
        })(ob, ub, hb),
        fb = { teams: pb },
        mb = (e) => e,
        gb = 864e5,
        vb = 36e5,
        yb = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9,
          10: 10,
        },
        bb = { 0: 1, 1: 2, 2: 3, 3: 4 },
        wb = {
          0: 0,
          1: 500,
          2: 1e3,
          3: 1500,
          4: 2e3,
          5: 2500,
          6: 3e3,
          7: 3500,
          8: 4e3,
          9: 4500,
          10: 5e3,
        },
        Sb = {
          duration: 2e4,
          cooldown: 36e5,
          limitPerDay: 3,
          multiplier: 5,
          chance: 20,
          freeCooldown: gb,
        },
        _b = 288e5,
        Eb = 1 / 3,
        Ab = [
          [2e4, "Bronze"],
          [2e5, "Silver"],
          [2e6, "Gold"],
          [1e7, "Platinum"],
          [1 / 0, "Diamond"],
        ],
        Tb = { Bronze: 1, Silver: 2, Gold: 4, Platinum: 8, Diamond: 16 },
        Pb = {
          AutoTap: [2e4],
          MultiTap: [
            2e3, 4e3, 8e3, 16e3, 32e3, 64e3, 128e3, 256e3, 512e3, 1024e3,
          ],
          RechargeLimit: [
            2e3, 4e3, 8e3, 16e3, 32e3, 64e3, 128e3, 256e3, 512e3, 1024e3,
          ],
          RechargeSpeed: [2e3, 4e3, 8e3],
        },
        Ib = (e) => (void 0 === e ? "" : e.toLocaleString());
      function Cb(e) {
        return e < 1e3
          ? e.toString()
          : e < 1e6
          ? (e / 1e3).toFixed(1).replace(/\.0$/, "") + "k"
          : (e / 1e6).toFixed(1).replace(/\.0$/, "") + "M";
      }
      const kb = [
          [1e3, "K"],
          [1e6, "M"],
          [1e9, "B"],
          [1e12, "T"],
        ],
        Ob = (e) => {
          if (e < 1e3) return e.toString();
          let t = 0,
            n = "";
          for (const [i, o] of kb) {
            if (e < i) break;
            (t = i), (n = o);
          }
          if (0 === t) return e.toString();
          const r = e / t,
            s = r === Math.round(r) ? r : r.toFixed(1);
          return "".concat(s).concat(n);
        },
        xb = [0, 500, 1e3, 2500, 5e3, 15e3, 25e3, 1e5, 5e5, 1e6, 5e6],
        Nb = xb.length - 1,
        Rb =
          "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(
            ""
          ),
        Db = 62,
        Mb = new Map(Rb.map((e, t) => [e, t]));
      function jb(e) {
        if (!Number.isInteger(e))
          throw new TypeError(
            "Expected an integer, got `".concat(e, "` (").concat(typeof e, ").")
          );
        if (e < 0) throw new TypeError("The integer must be non-negative.");
        if (0 === e) return Rb[0];
        let t = "";
        for (; e > 0; ) (t = Rb[e % Db] + t), (e = Math.floor(e / Db));
        return t;
      }
      function Lb(e) {
        const t = Mb.get(e);
        if (void 0 === t)
          throw new TypeError(
            "Unexpected character for Base62 encoding: `".concat(e, "`.")
          );
        return t;
      }
      function Ub(e) {
        const t = Number(e);
        return (
          (e = Number.isSafeInteger(t) ? jb(t) : e) +
          "-" +
          jb(Date.now()) +
          jb(Number(Math.random().toString().substring(2)))
        );
      }
      function Fb(e, t, n) {
        return n - e < t;
      }
      function Bb(e, t, n) {
        return e + t - n;
      }
      function Vb(e) {
        var t;
        const n =
          wb[null !== (t = e.energy_limit_level) && void 0 !== t ? t : 0];
        if (void 0 === n)
          throw new Error("getEnergyLimit - extraEnergyLimit is undefined");
        return Jy + n;
      }
      function qb(e) {
        var t;
        return bb[
          null !== (t = e.energy_recharge_level) && void 0 !== t ? t : 0
        ];
      }
      function Hb(e) {
        const t =
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
              ? e.free_rocketman_used
              : e.rocketman_used,
          [n] = [...t].sort((e, t) => t - e);
        return n;
      }
      function Wb(e) {
        for (let t = 0; t < Ab.length; t++) {
          const [n, r] = Ab[t];
          if (!(e.taps >= n)) return r;
        }
        return "Bronze";
      }
      function Kb(e) {
        return Tb[Wb(e)] + yb[e.tap_level];
      }
      function zb(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        const r = Kb(e);
        if (n) return r;
        const { multiplier: s } = Gb(e, t);
        return r * s;
      }
      function Gb(e, t) {
        const n = Hb(e),
          r = Hb(e, !0),
          s = !!n && Fb(n, Sb.duration, t),
          i = !!r && Fb(r, Sb.duration, t);
        return s || i
          ? { multiplier: Sb.multiplier, free: !!i, duration: Sb.duration }
          : { multiplier: 1, free: !1 };
      }
      function Jb(e, t) {
        var n;
        const r = [];
        (e.free_rocketman_used || []).forEach((e) => {
          Fb(e, Sb.freeCooldown, t) && r.push(e);
        });
        let s = 0;
        if (r.length === Sb.limitPerDay) {
          const [t] = ([...e.free_rocketman_used] || []).sort();
          s = t;
        }
        return {
          rocketmanUseCount: r.length,
          nextRocketmanExpiry: s,
          lastEnergyUsed:
            null !== (n = e.free_energy_recharge_timestamp) && void 0 !== n
              ? n
              : 0,
        };
      }
      function Qb(e, t) {
        const n = parseInt(e);
        if (!t) {
          const t = 10,
            r = (isFinite(n) ? n : e.length) % t;
          return "https://notgemz-game.s3.amazonaws.com/media/"
            .concat(Qy, "-")
            .concat(r, ".png");
        }
        return t;
      }
      function Yb(e, t) {
        switch (t) {
          case "AutoTap":
            return e.has_auto_tap ? 1 : 0;
          case "MultiTap":
            return e.tap_level;
          case "RechargeLimit":
            return e.energy_limit_level;
          case "RechargeSpeed":
            return e.energy_recharge_level;
        }
      }
      function Xb(e, t) {
        return Pb[e][t];
      }
      const Zb = (e, t) => e.last_ad_reward_time + 6e5 - t;
      function $b(e) {
        return parseInt(e.getUserID());
      }
      const ew = {
        Bronze: { regular: 2500, premium: 5e4 },
        Silver: { regular: 12e3, premium: 125e3 },
        Gold: { regular: 25e3, premium: 25e4 },
        Platinum: { regular: 5e4, premium: 5e5 },
        Diamond: { regular: 1e5, premium: 1e6 },
      };
      function tw(e, t) {
        const n = (function (e) {
            return e >= 17174448e5 && e <= 17180496e5 ? 5 : 1;
          })(e),
          { regular: r, premium: s } = ew[t];
        return { regular: r * n, premium: s * n };
      }
      function nw(e) {
        return e.unclaimed_rewards ? e.streak_days - e.unclaimed_rewards : -1;
      }
      function rw(e) {
        let t = 0;
        const n = nw(e);
        if (-1 === n) return 0;
        for (let r = n + 1; r <= e.streak_days; r++) t += xb[r];
        return t;
      }
      const sw = {
          ...mb({
            score: Gf(_a.int(), (e) => e.balance),
            name: zf(_a.string(), (e) => e.profile.name),
            photo: zf(_a.string(), (e) => e.profile.photo),
            league: Gf(_a.string(), (e) => Wb(e)),
            migrated: Gf(_a.boolean(), (e) => 0 !== e.migratedAt),
            migrationForced: Gf(_a.boolean(), (e) => e.migrationForced),
            teamId: Gf(_a.string().optional(), (e) => e.team_id),
          }),
        },
        iw = (e) => e,
        ow = iw({
          getPlayersByLeague: async (e, t) => {
            let { league: n } = e;
            console.log("getPlayersByLeague", { league: n });
            return (
              await t.searchPlayers({
                where: { league: { isAnyOf: [n] } },
                limit: 100,
                sort: [{ field: "score", order: "desc" }],
              })
            ).results.map((e, t) => ({
              rank: t + 1,
              picture: e.photo,
              username: e.name,
              score: e.score,
              league: n,
            }));
          },
        }),
        aw = iw({
          getFriends: async (e, t) => {
            let n = [];
            const r = (await t.getOwnState()).friends.slice(0, 100),
              s = r.map((e) => e.user_id),
              i = await t.fetchStates(s);
            return (
              r.forEach((e) => {
                const t = e.user_id,
                  r = i[t].state;
                if (e) {
                  var s, o;
                  const i = null !== (s = Wb(r)) && void 0 !== s ? s : "Bronze";
                  n.push({
                    username: r.username,
                    contribution:
                      null !== (o = e.contribution) && void 0 !== o ? o : 0,
                    picture: Qb(t, r.profile.photo),
                    team: r.team_id,
                    score: r.score,
                    league: i,
                  });
                }
              }),
              n
            );
          },
          getPlayerTeamId: async (e, t) => {
            var n;
            let { userId: r } = e;
            const s = await t.fetchStates([r]);
            if (null === s || void 0 === s || !s[r]) return;
            return null !== (n = s[r].state.team_id) && void 0 !== n
              ? n
              : void 0;
          },
        }),
        cw = 5e5,
        lw = iw({
          getRecommendedTeams: async (e, t) =>
            (
              await t.sharedStates.teams.search({
                where: { membersCount: { greaterThan: 0 } },
                limit: 100,
                sort: [{ field: "membersCount", order: "desc" }],
              })
            ).results.map((e) => uw(e)),
          getTeamsLeaderboard: async (e, t) => {
            let { limit: n } = e;
            const r = await t.sharedStates.teams.search({
              where: { membersCount: { greaterThan: 0 } },
              limit: Math.min(null !== n && void 0 !== n ? n : 100, 100),
              sort: [{ field: "score", order: "desc" }],
            });
            return r.results.map((e, t) => {
              for (
                ;
                (null === (n = r.results[t - 1]) || void 0 === n
                  ? void 0
                  : n.score) === e.score;

              ) {
                var n;
                t--;
              }
              return uw(e, t);
            });
          },
          getTeamWithMembers: async (e, t) => {
            let { teamId: n } = e;
            const { state: r, rank: s } = await lw.getTeamWithRank(
              { teamId: n },
              t
            );
            if (!r) throw new Error("Team not found");
            const i = (
              await t.searchPlayers({
                where: { teamId: { isAnyOf: [n] } },
                limit: 100,
                sort: [{ field: "score", order: "desc" }],
              })
            ).results.map((e, t) => ({
              name: e.name,
              photo: e.photo,
              score: e.score,
              rank: t + 1,
            }));
            return {
              id: n,
              ...r.profile,
              members: r.membersCount,
              score: r.score,
              players: i,
              rank: s,
            };
          },
          getTeamWithRank: async (e, t) => {
            let { teamId: n } = e;
            const r = await t.sharedStates.teams.fetch(n);
            if (!r) throw new Error("Team not found");
            const s = await t.sharedStates.teams.count({
              where: { score: { greaterThan: r.global.score } },
              sort: [{ field: "score", order: "desc" }],
            });
            return { state: r.global, rank: s + 1 };
          },
        });
      function uw(e, t) {
        return {
          id: e.id,
          ...e.profile,
          members: e.membersCount,
          score: e.score,
          rank: Number.isNaN(Number(t)) ? void 0 : (t || 0) + 1,
        };
      }
      const dw = iw({ ...ow, ...aw, ...lw }),
        hw = dw,
        pw = {
          addFriend: ab(
            _a.object({ friendId: _a.string(), bonus: _a.int() }),
            (e, t, n) => {
              let { friendId: r, bonus: s } = t;
              void 0 === e.friends.find((e) => e.user_id === r) &&
                (e.friends.push({ user_id: r, contribution: s }),
                (e.score += s),
                (e.balance += s));
            }
          ),
          addFriendContribution: ab(
            _a.object({ friendId: _a.string(), bonus: _a.int() }),
            (e, t, n) => {
              let { friendId: r, bonus: s } = t;
              const i = e.friends.find((e) => e.user_id === r);
              void 0 !== i && (i.contribution += s);
            }
          ),
          addReferrerScore: ab(_a.object({ bonus: _a.int() }), (e, t, n) => {
            let { bonus: r } = t;
            (e.score += r), (e.balance += r);
          }),
          addRewards: (function (e, t) {
            return {
              schema: e,
              reducer: t,
              description:
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : "",
              isAdmin: !0,
            };
          })(_a.object({ rewards: _a.int() }), (e, t, n) => {
            let { rewards: r } = t;
            (e.score += r), (e.balance += r);
          }),
        },
        fw = { ...pw, ...db };
      const mw = (e) =>
          (function (e, t, n) {
            return function (e) {
              return Go(e, (e, n) => ({ schema: t[e], action: n }));
            };
          })(0, e),
        gw = (e) =>
          Object.entries(e).reduce((e, t) => {
            let [n, { action: r }] = t;
            return { ...e, [n]: r };
          }, {}),
        vw = [
          "android",
          "facebook",
          "instagram",
          "ios",
          "line",
          "telegram",
          "zoom",
          "sms",
          "webpush",
        ];
      function yw(e) {
        if (!vw.some((t) => e.renderers[t]))
          throw Error(
            "renderTemplate must define at least 1 renderer among " +
              vw.join(", ")
          );
        return { args: e.args, renderers: e.renderers };
      }
      function bw(e) {
        const t = {};
        for (const n in e) {
          const { args: r, renderers: s } = e[n],
            i = (e) => ({
              analyticsUserProperties: e.analyticsUserProperties,
              args: e.args,
              name: n,
              payload: e.payload,
              renderers: s,
            });
          (i.argsSchema = r), (t[n] = i);
        }
        return t;
      }
      const ww = [
          "5796798150",
          "6572248057",
          "6090664772",
          "6540606306",
          "6319323425",
          "116583682",
          "6705915763",
          "6170825979",
          "2045194985",
          "5639787089",
          "5460500341",
        ],
        Sw = "https://notgemz-game.s3.amazonaws.com/media/notifications/",
        _w =
          "https://notgemz-game.s3.amazonaws.com/media/NotGemzallthethingsyouneedtoknow.html",
        Ew = 6e5,
        Aw = [
          "poitns.mp4",
          "lego.mp4",
          "dance party-n.mp4",
          "channel 5.mp4",
          "bleaaah.mp4",
        ],
        Tw = [
          "red pill blue pill.jpg",
          "missing you.mp4",
          "I miss you.mp4",
          "goalie.mp4",
          "f1.jpg",
        ],
        Pw = {
          reengagement: {
            messages: [
              "You're missing out on your Points!\nCome back to continue earning",
              "Your coins are waiting for you!\nCome back to continue earning",
              "You are dropping in the gemz coin leaderboards!\nCome back to continue earning",
            ],
            media: [
              "spongebob.mp4",
              "spock.gif",
              "pudgy.gif",
              "lookback meme.jpg",
              "gemz dance.mp4",
              "cartman.mp4",
            ],
          },
          energyRecharged: {
            message: "Charged up.\nReady to earn.\nLet's tap!",
            medias: [
              "recharged.gif",
              "iron man.mp4",
              "dragonball 100K.gif",
              "charged up.gif",
              "8ns6t6.mp4",
            ],
          },
          friendJoined: {
            message:
              "Your friend *{friendName}* joined gemz!\nHere's a bonus of *{bonus} coins*",
            medias: ["slam dunk.mp4", "queen.mp4", "billboard.mp4"],
          },
          friendSilver: {
            message:
              "Your referred friend *{friendName}* just reached Silver League!\nHere's a bonus of *{bonus} coins*",
            medias: Aw,
          },
          friendGold: {
            message:
              "Your referred friend *{friendName}* just reached Gold League!\nHere's a bonus of *{bonus} coins*",
            medias: Aw,
          },
          friendPlatinum: {
            message:
              "Your referred friend *{friendName}* just reached Platinum League!\nHere's a bonus of *{bonus} coins*",
            medias: Aw,
          },
          friendDiamond: {
            message:
              "Your referred friend *{friendName}* just reached Diamond League!\nHere's a bonus of *{bonus} coins*",
            medias: Aw,
          },
          teamRankUp: {
            message:
              "You're climbing up the leaderboard!\nKeep earning and carry on.",
            medias: Tw,
          },
          teamRankDown: {
            message:
              "Defend your spot on the leaderboard!\nCome back and earn more coins.",
            medias: Tw,
          },
          autobotTimesUp: {
            message:
              "Your TapBot has finished earning for you.\nCome back and claim your coins before they are lost.",
            medias: [
              "pixel planet.gif",
              "mission accomplished.gif",
              "looney.gif",
              "happy end.mp4",
              "bender.mp4",
            ],
          },
        };
      function Iw(e) {
        return e[Math.floor(Math.random() * e.length)];
      }
      const Cw = {
          startCmdGroup: "Play gemz!",
          startCmdPrivate: {
            play: "\ud83d\udd79\ufe0f Let's go",
            community: "\ud83e\udd19 gemz community",
            howToPlay: "\ud83c\udf93 How to play",
            invite: "Invite Friend",
          },
          inviteCmd: "Invite now!",
          howToPlayCmd: "\ud83c\udf93 How to play",
          localCmd: "\ud83d\udcbb Run local app!",
          defaultPlayButton: "Play gemz!",
          menuPlayButton: "Play Now",
        },
        kw = {
          startCmdGroup: "\ud83d\udc8eTap & Earn with gemz! \ud83d\udc8e",
          startCmdPrivate: [
            "Hi {username}! This is gemz.",
            "Tap on the coin and earn Gemz Points. ",
            "What will Gemz Points do? You\u2019ll find out soon enough.",
            "Got any friends? Invite them to the game and earn even more coins together.",
            "Gemz Points are the future. Come join the fun.",
          ].join("\n"),
          howToPlayCmd:
            "Want to learn about gemz? Find all you need to know here!",
          localCmd: "Proxy: {proxy}",
        },
        Ow = 864e5;
      var xw;
      const Nw =
          null !== (xw = "prod")
            ? xw
            : {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.STAGE,
        Rw = "https://ff.notgemz.gemz.fun",
        Dw = {
          botName: Nw
            ? {
                alpha: "GemzcoinReplicantAlphaBot",
                bravo: "GemzcoinReplicantBravoBot",
                dev: "GemzcoinReplicantDevBot",
                prod: "gemzcoin_bot",
              }[Nw]
            : "GemzcoinLocal",
          playUrl:
            (Nw &&
              {
                alpha: "https://notgemz.alpha.pnk.one",
                bravo: "https://notgemz.bravo.pnk.one",
                dev: "https://notgemz.pnk.one",
                prod: Rw,
              }[Nw]) ||
            Rw,
          migrationUrl:
            "prod" === Nw
              ? "https://notgemz.game.prod2.pnk.one"
              : "https://notgemz.game.dev.pnk.one",
          sentryDNS:
            "https://b30872fe6a5951ca2dd8d9dd82c928f1@o4505230490861568.ingest.us.sentry.io/4507338261659648",
        };
      function Mw(e, t, n) {
        const r = new URL(Dw.playUrl);
        return (
          n && r.searchParams.set("uid", n),
          void 0 !== t && r.searchParams.set("payload", JSON.stringify(t)),
          { type: "web_app", text: e, web_app: { url: r.toString() } }
        );
      }
      function jw(e, t, n) {
        return [[Mw(e, n, t)]];
      }
      const Lw = _a.object({ callToAction: _a.string(), link: _a.string() }),
        Uw = yw({
          args: _a.object({
            caption: _a.string(),
            callToAction: _a.string(),
            url: _a.string(),
          }),
          renderers: {
            telegram: (e) => {
              let { args: t } = e;
              const { caption: n, callToAction: r, url: s } = t;
              return {
                text: n,
                reply_markup: {
                  inline_keyboard: [[{ text: r, web_app: { url: s } }]],
                },
              };
            },
          },
        }),
        Fw = (function (e, t) {
          return { assets: e, ...bw(t) };
        })(
          {},
          {
            reengagement: yw({
              args: _a.object({
                userId: _a.string(),
                iteration: _a.int().min(1),
              }),
              renderers: {
                telegram: (e) => {
                  let { args: t, payload: n } = e;
                  const { userId: r, iteration: s } = t,
                    { messages: i, media: o } = Pw.reengagement;
                  return Vw({
                    userId: r,
                    message: i[(s - 1) % i.length],
                    payload: n,
                    media: Iw(o),
                    key: "reengagement",
                  });
                },
              },
            }),
            energyRecharged: qw("energyRecharged"),
            friendJoined: Hw("friendJoined", {
              friendName: _a.string(),
              bonus: _a.string(),
            }),
            friendSilver: Hw("friendSilver", {
              friendName: _a.string(),
              bonus: _a.string(),
            }),
            friendGold: Hw("friendGold", {
              friendName: _a.string(),
              bonus: _a.string(),
            }),
            friendPlatinum: Hw("friendPlatinum", {
              friendName: _a.string(),
              bonus: _a.string(),
            }),
            friendDiamond: Hw("friendDiamond", {
              friendName: _a.string(),
              bonus: _a.string(),
            }),
            teamRankUp: qw("teamRankUp"),
            teamRankDown: qw("teamRankDown"),
            autobotTimesUp: qw("autobotTimesUp"),
            startCmdGroup: yw({
              args: _a.object({
                caption: _a.string(),
                callToAction: _a.string(),
                botLink: _a.string(),
              }),
              renderers: {
                telegram: (e) => {
                  let { args: t } = e;
                  const { caption: n, callToAction: r, botLink: s } = t;
                  return {
                    text: n,
                    reply_markup: { inline_keyboard: [[{ text: r, url: s }]] },
                  };
                },
              },
            }),
            startCmdPrivate: yw({
              args: _a.object({
                caption: _a.string(),
                btns: _a.object({
                  play: Lw,
                  community: Lw,
                  howToPlay: Lw,
                  invite: Lw.optional(),
                }),
              }),
              renderers: {
                telegram: (e) => {
                  let { args: t } = e;
                  const { caption: n, btns: r } = t,
                    s = [
                      [
                        {
                          text: r.play.callToAction,
                          web_app: { url: r.play.link },
                        },
                      ],
                      [
                        {
                          text: r.community.callToAction,
                          url: r.community.link,
                        },
                      ],
                      [
                        {
                          text: r.howToPlay.callToAction,
                          web_app: { url: r.howToPlay.link },
                        },
                      ],
                    ];
                  return (
                    r.invite &&
                      s.push([
                        { text: r.invite.callToAction, url: r.invite.link },
                      ]),
                    { text: n, reply_markup: { inline_keyboard: s } }
                  );
                },
              },
            }),
            inviteCmd: yw({
              args: _a.object({
                caption: _a.string(),
                callToAction: _a.string(),
                referralLink: _a.string(),
              }),
              renderers: {
                telegram: (e) => {
                  let { args: t } = e;
                  const { caption: n, callToAction: r, referralLink: s } = t;
                  return {
                    text: n,
                    reply_markup: { inline_keyboard: [[{ text: r, url: s }]] },
                  };
                },
              },
            }),
            howToPlayCmd: Uw,
            localCmd: Uw,
          }
        ),
        Bw = Fw;
      function Vw(e) {
        const { userId: t, message: n, payload: r, media: s, key: i } = e,
          o = {
            inline_keyboard: jw(Cw.defaultPlayButton, t, {
              ...r,
              notif: { key: i, media: s },
            }),
          },
          a = "".concat(Sw).concat(s),
          c = s.split(".").pop();
        switch (c) {
          case "jpg":
          case "jpeg":
          case "webp":
          case "png":
            return { photo: a, caption: n, reply_markup: o };
          case "gif":
            return { animation: a, caption: n, reply_markup: o };
          case "mp4":
          case "video":
            return { video: a, caption: n, reply_markup: o };
          default:
            throw new Error(
              "Unsupported extension: "
                .concat(c, ' for notification media "')
                .concat(s, '"')
            );
        }
      }
      function qw(e) {
        const { message: t } = Pw[e];
        return yw({
          args: _a.object({ userId: _a.string() }),
          renderers: {
            telegram: (n) => {
              let { args: r, payload: s } = n;
              const { userId: i } = r,
                o = Iw(Pw[e].medias);
              return Vw({
                userId: i,
                message: t,
                payload: s,
                media: o,
                key: e,
              });
            },
          },
        });
      }
      function Hw(e, t) {
        const { message: n } = Pw[e];
        return yw({
          args: _a.object({ userId: _a.string(), tokens: _a.object(t) }),
          renderers: {
            telegram: (t) => {
              let { args: r, payload: s } = t;
              const { userId: i, tokens: o } = r,
                a = Object.entries(o).reduce((e, t) => {
                  let [n, r] = t;
                  return e.replace("{".concat(n, "}"), r);
                }, n);
              return Vw({
                userId: i,
                message: a,
                payload: s,
                media: Iw(Pw[e].medias),
                key: e,
              });
            },
          },
        });
      }
      const Ww = {
          sendReengagementMessage: _a.object({
            chatId: _a.number(),
            iteration: _a.int().min(1),
          }),
          sendEnergyRechargedMessage: _a.object({ chatId: _a.number() }),
          sendAutobotCooldownMessage: _a.object({ chatId: _a.number() }),
          sendTeamRankUpdateMessage: _a.object({
            chatId: _a.number(),
            iteration: _a.int().min(1),
            previousRank: _a.int().optional(),
          }),
        },
        Kw = mw(Ww)({
          sendReengagementMessage: (e, t, n) => {
            let { chatId: r, iteration: s } = t;
            n.chatbot.sendTelegramMessage({
              chatId: r,
              message: Fw.reengagement({
                args: { userId: e.id, iteration: s },
                payload: {
                  $channel: "CHATBOT",
                  feature: "reengagement",
                  $subFeature: "reengagement_24h",
                },
              }),
              receiverId: e.id,
            }),
              n.scheduledActions.schedule.sendReengagementMessage({
                args: { chatId: r, iteration: s + 1 },
                notificationId: "reengagement",
                delayInMS: 864e5,
              });
          },
          sendEnergyRechargedMessage: (e, t, n) => {
            let { chatId: r } = t;
            n.chatbot.sendTelegramMessage({
              chatId: r,
              message: Fw.energyRecharged({
                args: { userId: e.id },
                payload: {
                  $channel: "CHATBOT",
                  feature: "energy",
                  $subFeature: "energy_recharged",
                },
              }),
              receiverId: e.id,
            });
          },
          sendAutobotCooldownMessage: (e, t, n) => {
            let { chatId: r } = t;
            n.chatbot.sendTelegramMessage({
              chatId: r,
              message: Fw.autobotTimesUp({
                args: { userId: e.id },
                payload: {
                  $channel: "CHATBOT",
                  feature: "autobot",
                  $subFeature: "autobot_timesup",
                },
              }),
              receiverId: e.id,
            });
          },
          sendTeamRankUpdateMessage: async (e, t, n) => {
            let { chatId: r, iteration: s, previousRank: i } = t;
            const o = e.team_id;
            if (!o) return;
            const a = await n.asyncGetters.getTeamWithRank({ teamId: o });
            if (!a) return;
            if (!i)
              return void n.scheduledActions.schedule.sendTeamRankUpdateMessage(
                {
                  args: { chatId: r, iteration: s + 1, previousRank: a.rank },
                  notificationId: "teamRank",
                  delayInMS: Ow,
                }
              );
            const c = {
              args: { userId: e.id },
              payload: {
                $channel: "CHATBOT",
                feature: "team",
                $subFeature: "team_rank_update",
              },
            };
            n.chatbot.sendTelegramMessage({
              chatId: r,
              message: a.rank > i ? Fw.teamRankUp(c) : Fw.teamRankDown(c),
              receiverId: e.id,
            }),
              n.scheduledActions.schedule.sendTeamRankUpdateMessage({
                args: { chatId: r, iteration: s + 1, previousRank: a.rank },
                notificationId: "teamRank",
                delayInMS: Ow,
              });
          },
        }),
        zw = Ww,
        Gw = gw(Kw),
        Jw = {
          Bronze: 0,
          Silver: 1e4,
          Gold: 125e3,
          Platinum: 375e3,
          Diamond: 75e4,
        },
        Qw = {
          Bronze: 0,
          Silver: 2e4,
          Gold: 25e4,
          Platinum: 75e4,
          Diamond: 15e5,
        },
        Yw = {
          Bronze: 0,
          Silver: 1e4,
          Gold: 125e3,
          Platinum: 375e3,
          Diamond: 75e4,
        };
      function Xw(e, t, n) {
        (e.team_id = t.teamId),
          (e.unsynced_team_score = 0),
          n.sharedStates.teams.postMessage.addMember(t.teamId, {
            score: e.score,
            timestamp: n.date.now(),
          }),
          n.scheduledActions.schedule.sendTeamRankUpdateMessage({
            args: { chatId: $b(n), iteration: 1 },
            notificationId: "teamRank",
            delayInMS: 0,
          });
      }
      function Zw(e, t) {
        const n = e.team_id;
        if (!n) return;
        const r = e.score - e.unsynced_team_score;
        (e.unsynced_team_score = 0),
          t.sharedStates.teams.postMessage.removeMember(n, {
            score: r,
            timestamp: t.date.now(),
          }),
          t.scheduledActions.unschedule("teamRank"),
          delete e.team_id;
      }
      function $w(e, t) {
        const n = e.team_id;
        n &&
          (t.sharedStates.teams.postMessage.addScore(n, {
            score: e.unsynced_team_score,
          }),
          (e.unsynced_team_score = 0));
      }
      const eS = {
          followOnX: 1e4,
          joinCommunity: 2e3,
          inviteFriends5: 15e4,
          inviteFriends10: 3e5,
          inviteFriends100: 3e6,
          followOnYoutube: 5e4,
          joinAnnouncement: 2e4,
        },
        tS = {
          followOnX: () => {},
          joinCommunity: () => {},
          inviteFriends5: (e) =>
            e.friends.length < 5
              ? "invite ".concat(5 - e.friends.length, " more friends")
              : void 0,
          inviteFriends10: (e) =>
            e.friends.length < 10
              ? "invite ".concat(10 - e.friends.length, " more friends")
              : void 0,
          inviteFriends100: (e) =>
            e.friends.length < 100
              ? "invite ".concat(100 - e.friends.length, " more friends")
              : void 0,
          followOnYoutube: () => {},
          joinAnnouncement: () => {},
        },
        nS = 864e5;
      function rS(e, t) {
        let n = t.username;
        void 0 === n &&
          ((n = t.first_name),
          t.last_name && (n = "".concat(n, " ").concat(t.last_name))),
          (e.username = n),
          (e.is_premium = Boolean(t.is_premium));
      }
      function sS(e, t, n) {
        if (0 === t) return;
        const r = n.date.now();
        if (
          ((function (e, t) {
            (e.free_rocketman_used = e.free_rocketman_used.filter((e) =>
              Fb(e, Sb.freeCooldown, t)
            )),
              (e.rocketman_used = e.rocketman_used.filter((e) => Fb(e, nS, t)));
          })(e, r),
          oS(e, r),
          e.energy < t && (t = e.energy) <= 0)
        )
          return;
        const s = Wb(e);
        e.session_taps += t;
        const i = zb(e, r) * t,
          o = Kb(e) * t,
          { multiplier: a } = Gb(e, r);
        (e.score += i),
          (e.taps += o),
          (e.balance += i),
          1 === a && (e.energy -= t),
          e.team_id && (e.unsynced_team_score += i);
        const c = Wb(e);
        if (s !== c) {
          const t = Yw[c];
          if (((e.score += t), (e.balance += t), e.referrer_id)) {
            const r = (e.is_premium ? Qw : Jw)[c],
              s = e.referrer_id;
            n.postMessage.addFriendContribution(s, {
              friendId: n.getUserID(),
              bonus: r,
            });
            const i = (function (e) {
              switch (e) {
                case "Silver":
                  return Fw.friendSilver;
                case "Gold":
                  return Fw.friendGold;
                case "Platinum":
                  return Fw.friendPlatinum;
                case "Diamond":
                  return Fw.friendDiamond;
              }
              return Fw.friendSilver;
            })(c);
            n.chatbot.sendTelegramMessage({
              chatId: parseInt(s),
              message: i({
                args: {
                  userId: s,
                  tokens: { friendName: e.username, bonus: Ib(r) },
                },
                payload: {
                  $channel: "CHATBOT",
                  feature: "friend",
                  $subFeature: "friend_levelup",
                },
              }),
              receiverId: s,
            }),
              n.sendAnalyticsEvents([
                {
                  eventType: "Bonus",
                  eventProperties: { nature: "ownProgression", amount: t },
                },
                {
                  userId: s,
                  eventType: "Bonus",
                  eventProperties: { nature: "friendProgression", amount: r },
                },
              ]);
          }
        }
      }
      const iS = async (e, t, n) => {
        const { booster: r, level: s, price: i } = n;
        try {
          if (e.balance < i)
            throw new Error(
              "User does not have enough points to buy this item"
            );
          e.balance -= i;
          const n = {};
          switch (r) {
            case "AutoTap":
              (e.has_auto_tap = !0),
                (e.last_session_time = t.date.now()),
                (e.boosterPurchases.autoTaps += 1),
                (n.purchasedAutoTaps = e.boosterPurchases.autoTaps);
              break;
            case "MultiTap":
              (e.tap_level = s),
                (e.boosterPurchases.multiTaps += 1),
                (n.purchasedMultiTaps = e.boosterPurchases.multiTaps);
              break;
            case "RechargeLimit":
              (e.energy_limit_level = s),
                (e.boosterPurchases.rechargeLimits += 1),
                (n.purchasedMultiTaps = e.boosterPurchases.rechargeLimits);
              break;
            case "RechargeSpeed":
              (e.energy_recharge_level = s),
                (e.boosterPurchases.rechargeSpeeds += 1),
                (n.purchasedMultiTaps = e.boosterPurchases.rechargeSpeeds);
          }
          t.sendAnalyticsEvents([
            {
              eventType: "AcquireBooster",
              eventProperties: { booster: r, level: s },
              userProperties: n,
            },
          ]);
        } catch (a_) {
          throw (console.log("Failed to buy booster", a_), a_);
        }
      };
      function oS(e, t) {
        const n = t - (e.last_energy_refresh || 0),
          r = Math.floor(n / 1e3) * qb(e),
          s = Vb(e),
          i = e.energy + r;
        i >= s
          ? ((e.energy = s), (e.last_energy_refresh = t))
          : i !== e.energy && ((e.energy = i), (e.last_energy_refresh = t));
      }
      const aS = async (e, t, n) => {
          const { referrer: r, telegramUser: s } = t,
            i = Boolean(s.is_premium);
          rS(e, s),
            (e.first_interaction = !1),
            r && (await cS(e, { referrerId: r, isPremium: i }, n));
        },
        cS = async (e, t, n) => {
          if (e.referrer_id) return;
          const r = t.referrerId;
          if (r === n.getUserID()) return;
          if ("0" === r) return;
          const s = t.isPremium || !1,
            i = (function (e, t) {
              const n = tw(e, "Bronze");
              return t ? n.premium : n.regular;
            })(n.date.now(), s);
          (e.score += i),
            (e.balance += i),
            (e.referrer_id = r),
            e.friends.push({ user_id: r, contribution: i }),
            n.postMessage.addFriend(r, { friendId: n.getUserID(), bonus: i });
          const o = await n.asyncGetters.getPlayerTeamId({ userId: r });
          o && Xw(e, { teamId: o }, n),
            n.sendAnalyticsEvents([
              {
                eventType: "Bonus",
                eventProperties: { nature: "joinInvite", amount: i },
                userProperties: { referrerId: r, friendCount: 1 },
              },
              {
                userId: r,
                eventType: "Bonus",
                eventProperties: { nature: "inviteSuccess", amount: i },
              },
            ]),
            n.chatbot.sendTelegramMessage({
              chatId: parseInt(r),
              message: Bw.friendJoined({
                args: {
                  userId: r,
                  tokens: { friendName: e.username, bonus: Ib(i) },
                },
                payload: {
                  $channel: "CHATBOT",
                  feature: "friend",
                  $subFeature: "friend_joined",
                },
              }),
              receiverId: r,
            });
        },
        lS = (e, t) => {
          let { earningKey: n } = t;
          if (e.earnings[n]) return;
          const r = tS[n](e);
          if (r) throw new Error(r);
          const s = eS[n];
          (e.balance += s), (e.score += s), (e.earnings[n] = !0);
        };
      function uS(e, t) {
        return e * (1 + Math.random() * t - t / 2);
      }
      async function dS(e, t) {
        let n,
          r = 0;
        for (; r < t.attempts; ) {
          r += 1;
          try {
            return await e();
          } catch (c) {
            if (((n = c), t.shouldRetryError && !t.shouldRetryError(c)))
              throw c;
          }
          if (r >= t.attempts) break;
          if (t.backoff)
            if ("exponential" in t.backoff) {
              var s, i;
              const e = t.backoff.exponential.delay,
                n =
                  null !== (s = t.backoff.exponential.base) && void 0 !== s
                    ? s
                    : 2;
              await hS(
                uS(
                  e * n ** (r - 1),
                  null !== (i = t.backoff.exponential.fuzz) && void 0 !== i
                    ? i
                    : 0
                )
              );
            } else if ("linear" in t.backoff) {
              var o;
              const e = t.backoff.linear.delay;
              await hS(
                uS(
                  e * r,
                  null !== (o = t.backoff.linear.fuzz) && void 0 !== o ? o : 0
                )
              );
            } else if ("fixed" in t.backoff) {
              var a;
              await hS(
                uS(
                  t.backoff.fixed.delay,
                  null !== (a = t.backoff.fixed.fuzz) && void 0 !== a ? a : 0
                )
              );
            }
        }
        throw n;
      }
      async function hS(e) {
        return new Promise((t) => setTimeout(t, e));
      }
      function pS(e, t) {
        var n, r, s;
        return {
          name:
            null !== (n = e.title) && void 0 !== n ? n : "Team ".concat(e.id),
          description: null !== (r = e.description) && void 0 !== r ? r : "",
          photo: t,
          inviteLink: e.username
            ? "https://t.me/".concat(e.username)
            : null !== (s = e.invite_link) && void 0 !== s
            ? s
            : "",
        };
      }
      function fS(e, t) {
        e([{ eventType: "MigrationSuccess", eventProperties: t }]);
      }
      function mS(e, t) {
        e([{ eventType: "MigrationFailure", eventProperties: t }]);
      }
      function gS() {
        let e =
            !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
          { regular: t, premium: n } =
            arguments.length > 1 ? arguments[1] : void 0;
        const r = Cb(t),
          s = Cb(n);
        return ""
          .concat(
            e ? "\nPlay Gemzcoin with me and earn Gemz points!\n" : "",
            "\n\ud83c\udfc6+"
          )
          .concat(r, " Gemz Points as a first-time bonus\n\ud83d\udc8e+")
          .concat(s, " Gemz Points if you have Telegram Premium\n");
      }
      function vS(e) {
        if (e.length > 64)
          throw Error(
            "Bot link start parameter ".concat(
              e,
              " exceeds Telegram limit of 64 characters"
            )
          );
        const t = (function (e) {
          const t = e
            .split("")
            .map((e, t) => (((e) => /[a-zA-Z]/.test(e))(e) ? t : -1))
            .filter((e) => -1 !== e);
          if (0 === t.length) return e;
          const n = t[Math.floor(Math.random() * t.length)];
          return e
            .split("")
            .map((e, t) => (t === n ? e.toUpperCase() : e))
            .join("");
        })(Dw.botName);
        return "https://t.me/".concat(t, "/tap?startapp=").concat(e);
      }
      function yS(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const n = gS(!0, arguments.length > 2 ? arguments[2] : void 0),
          r = encodeURIComponent(n),
          s = encodeURIComponent(vS(e));
        return t
          ? "tg://msg_url?url=".concat(s)
          : "tg://msg_url?url=".concat(s, "&text=").concat(r);
      }
      const bS = async (e, t, n, r) => {
          var s;
          if (null === (s = n.from) || void 0 === s || !s.id) return;
          const i = tw(t.date.now(), "Bronze");
          t.chatbot.sendTelegramMessage({
            chatId: n.chat.id,
            message: Bw.inviteCmd({
              args: {
                caption: gS(!1, i),
                callToAction: Cw.inviteCmd,
                referralLink: yS(n.from.id.toString(), !0, i),
              },
              payload: {
                $channel: "CHATBOT",
                feature: "invite",
                $subFeature: "bot_invite_cmd",
              },
            }),
            receiverId: e.id,
          });
        },
        wS = async (e, t, n, r) => {
          var s;
          null !== (s = n.from) &&
            void 0 !== s &&
            s.id &&
            t.chatbot.sendTelegramMessage({
              chatId: n.chat.id,
              message: Bw.howToPlayCmd({
                args: {
                  caption: kw.howToPlayCmd,
                  callToAction: Cw.howToPlayCmd,
                  url: _w,
                },
                payload: {
                  $channel: "CHATBOT",
                  feature: "howtoplay",
                  $subFeature: "howtoplay_guide",
                },
              }),
              receiverId: e.id,
            });
        },
        SS = {
          NODE_ENV: "production",
          PUBLIC_URL: "",
          WDS_SOCKET_HOST: void 0,
          WDS_SOCKET_PATH: void 0,
          WDS_SOCKET_PORT: void 0,
          FAST_REFRESH: !0,
          REACT_APP_STAGE: "prod",
          REACT_APP_ENV: "prod",
          REACT_APP_APP_VERSION: "2.8.0",
        }.LOCAL_PROXIES
          ? JSON.parse(
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.LOCAL_PROXIES
            )
          : void 0,
        _S = {
          "/start": async (e, t, n, r) => {
            var s, i;
            if (Boolean(null === r || void 0 === r ? void 0 : r.create))
              return (
                (e.team_creation_start_time = t.date.now()),
                void (await xS({
                  chatId: n.chat.id,
                  text: "Specify the public channel in the format:\n      <i>@Telegram</i>",
                  parseMode: "HTML",
                  fetch: t.fetch,
                }))
              );
            const o = n.from;
            if (null === o || void 0 === o || !o.id) return;
            if (!Dw.playUrl)
              throw Error(
                "Missing playUrl configuration for stage ".concat(
                  {
                    NODE_ENV: "production",
                    PUBLIC_URL: "",
                    WDS_SOCKET_HOST: void 0,
                    WDS_SOCKET_PATH: void 0,
                    WDS_SOCKET_PORT: void 0,
                    FAST_REFRESH: !0,
                    REACT_APP_STAGE: "prod",
                    REACT_APP_ENV: "prod",
                    REACT_APP_APP_VERSION: "2.8.0",
                  }.STAGE
                )
              );
            const a = {
                play: {
                  callToAction: Cw.startCmdPrivate.play,
                  link: Dw.playUrl,
                },
                community: {
                  callToAction: Cw.startCmdPrivate.community,
                  link: "https://t.me/gemzfun",
                },
                howToPlay: {
                  callToAction: Cw.startCmdPrivate.howToPlay,
                  link: _w,
                },
              },
              c = null === r || void 0 === r ? void 0 : r.ref;
            if (c) {
              const e = new URL(a.play.link),
                t = { $key: c };
              e.searchParams.set("payload", JSON.stringify(t)),
                (a.play.link = e.toString());
            }
            const l = kw.startCmdPrivate.replace("{username}", e.username),
              u = [
                [{ text: a.play.callToAction, web_app: { url: a.play.link } }],
                [{ text: a.community.callToAction, url: a.community.link }],
                [
                  {
                    text: a.howToPlay.callToAction,
                    web_app: { url: a.howToPlay.link },
                  },
                ],
              ];
            a.invite &&
              u.push([{ text: a.invite.callToAction, url: a.invite.link }]);
            const d = {
                chatId: n.chat.id,
                text: l,
                replyMarkup: { inline_keyboard: u },
              },
              h = (await xS({ ...d, fetch: t.fetch })).message_id,
              p = await NS(n.chat.id, t.fetch);
            null !== (s = p.pinned_message) &&
              void 0 !== s &&
              null !== (i = s.from) &&
              void 0 !== i &&
              i.is_bot &&
              (await (async function (e) {
                return await OS(
                  "unpinChatMessage",
                  { chat_id: e.chatId, message_id: e.messageId },
                  e.fetch
                );
              })({
                chatId: n.chat.id,
                messageId: p.pinned_message.message_id,
                fetch: t.fetch,
              })),
              await (async function (e) {
                return await OS(
                  "pinChatMessage",
                  {
                    chat_id: e.chatId,
                    message_id: e.messageId,
                    disable_notification: e.disableNotification,
                  },
                  e.fetch
                );
              })({
                chatId: n.chat.id,
                messageId: h,
                fetch: t.fetch,
                disableNotification: !0,
              });
          },
          "/invite": bS,
          "/help": wS,
          "/local": async (e, t, n, r) => {
            if (
              "prod" ===
              {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.STAGE
            )
              return;
            if (!SS) return;
            const s = SS[e.id];
            s &&
              t.chatbot.sendTelegramMessage({
                chatId: n.chat.id,
                message: Bw.localCmd({
                  args: {
                    caption: kw.localCmd.replace("{proxy}", s),
                    callToAction: Cw.localCmd,
                    url: "".concat(s, "?uid=").concat(e.id),
                  },
                  payload: {
                    $channel: "CHATBOT",
                    feature: "local",
                    $subFeature: "local_testing",
                  },
                }),
                receiverId: e.id,
              });
          },
          "/updateBotMenu": async (e, t, n, r) => {
            ww.includes(e.id) &&
              (xS({
                chatId: n.chat.id,
                text: "Updating the bot menu.\nThe process might take a few minutes...",
                fetch: t.fetch,
              }),
              await (function (e) {
                const t = {
                  $channel: "CHATBOT",
                  feature: "bot",
                  $subFeature: "bot_menu",
                };
                return OS(
                  "setChatMenuButton",
                  { menu_button: Mw(Cw.menuPlayButton, t) },
                  e
                );
              })(t.fetch),
              xS({
                chatId: n.chat.id,
                text: "Bot Menu Updated!\nIt might take another few minutes for the change to take effect",
                fetch: t.fetch,
              }));
          },
          "/generatePayload": async (e, t, n, r) => {
            if (!ww.includes(e.id)) return;
            const s = {
                $channel: null === r || void 0 === r ? void 0 : r.$channel,
                feature: null === r || void 0 === r ? void 0 : r.feature,
                $subFeature:
                  null === r || void 0 === r ? void 0 : r.$subFeature,
              },
              i = Ub("0");
            await t.kvStore.send(i, JSON.stringify(s), {
              expiresInMs: 31536e6,
            });
            const o = "https://t.me/"
                .concat(Dw.botName, "/tap?startapp=")
                .concat(i),
              a = "https://t.me/".concat(Dw.botName, "?start=ref_").concat(i);
            xS({
              chatId: n.chat.id,
              text: "Payload: "
                .concat(JSON.stringify(s, null, 2), "\n\nOne-Tap link:\n")
                .concat(o, "\nBot link:\n")
                .concat(a),
              fetch: t.fetch,
            });
          },
        },
        ES = {
          "/start": async (e, t, n, r) => {
            t.chatbot.sendTelegramMessage({
              chatId: n.chat.id,
              message: Bw.startCmdGroup({
                args: {
                  caption: kw.startCmdGroup,
                  callToAction: Cw.startCmdGroup,
                  botLink: "t.me/".concat(Dw.botName),
                },
                payload: {
                  $channel: "CHATBOT",
                  feature: "bot",
                  $subFeature: "bot_start",
                },
              }),
              receiverId: e.id,
            });
          },
          "/invite": bS,
          "/help": wS,
          "/local": async () => {},
          "/updateBotMenu": async () => {},
          "/generatePayload": async () => {},
        },
        AS = _a
          .object({
            id: _a.int(),
            is_bot: _a.boolean(),
            first_name: _a.string(),
            last_name: _a.string().optional(),
            username: _a.string().optional(),
            is_premium: _a.boolean().optional(),
          })
          .additionalProperties(),
        TS = _a
          .object({
            message_id: _a.int(),
            from: AS.optional(),
            chat: _a
              .object({ id: _a.int(), type: _a.string() })
              .additionalProperties(),
            text: _a.string().optional(),
            entities: _a
              .array(
                _a
                  .object({
                    type: _a.string(),
                    offset: _a.int(),
                    length: _a.int(),
                  })
                  .additionalProperties()
              )
              .optional(),
          })
          .additionalProperties(),
        PS = _a
          .object({ update_id: _a.int(), message: TS })
          .additionalProperties(),
        IS = _a
          .object({
            update_id: _a.int(),
            callback_query: _a
              .object({ id: _a.string(), from: AS })
              .additionalProperties(),
          })
          .additionalProperties(),
        CS = {
          async onWebhook(e, t, n) {
            if (
              !(function (e) {
                return "platform" in e && "telegram" === e.platform;
              })(t)
            )
              return;
            const r = t;
            IS.isValid(r)
              ? await (async function (e, t) {
                  await OS(
                    "answerCallbackQuery",
                    {
                      callback_query_id: e.callback_query.id,
                      text: "Game started!",
                      url: ""
                        .concat(Dw.playUrl, "?uid=")
                        .concat(e.callback_query.from.id),
                    },
                    t
                  );
                })(r, n.fetch)
              : PS.isValid(r) &&
                (await (async function (e, t, n) {
                  const r = "private" === t.chat.type ? "private" : "group",
                    [s] = t.entities || [],
                    i = t.from;
                  if (null !== i && void 0 !== i && i.is_bot) return;
                  if (
                    "bot_command" !==
                    (null === s || void 0 === s ? void 0 : s.type)
                  ) {
                    return void (
                      n.date.now() - e.team_creation_start_time < Ew &&
                      (await (async function (e, t, n) {
                        const r = t.text;
                        if (!r) return;
                        try {
                          const s = await NS(r, n.fetch),
                            i = s.id.toString();
                          if (await n.sharedStates.teams.fetch(i))
                            return void (await xS({
                              chatId: t.chat.id,
                              text: "This team already exists. Please enter a different address in the format:\n        <i>@Telegram</i>",
                              parseMode: "HTML",
                              fetch: n.fetch,
                            }));
                          if (e.balance < cw)
                            return void (await xS({
                              chatId: t.chat.id,
                              text: "This player does not meet the requirements to create a team.\nCreating teams cost ".concat(
                                cw.toLocaleString(),
                                " points"
                              ),
                              parseMode: "HTML",
                              fetch: n.fetch,
                            }));
                          n.sharedStates.teams.create(i),
                            (e.balance -= cw),
                            Xw(e, { teamId: i }, n);
                          const o = pS(s, void 0);
                          n.sharedStates.teams.postMessage.updateTeamProfile(
                            i,
                            { profile: o, timestamp: n.date.now() }
                          ),
                            await xS({
                              chatId: t.chat.id,
                              text: "Team ".concat(
                                o.name,
                                " has been created!"
                              ),
                              replyMarkup: {
                                inline_keyboard: [
                                  [
                                    {
                                      text: "Start earning coins!",
                                      web_app: { url: "".concat(Dw.playUrl) },
                                    },
                                  ],
                                ],
                              },
                              fetch: n.fetch,
                            });
                        } catch (a_) {
                          n.reportError(a_),
                            await xS({
                              chatId: t.chat.id,
                              text: "Can only create a team for a public channel or chat",
                              fetch: n.fetch,
                            });
                        }
                      })(e, t, n))
                    );
                  }
                  const [o] = (t.text || "").split("@".concat(Dw.botName));
                  if (o.includes("@")) return;
                  const a = o.split(" "),
                    c = a[0],
                    l = (function (e) {
                      if (void 0 === e || "" === e) return {};
                      return e
                        .split(/(?<!\\)_/)
                        .reduce(
                          (e, t, n, r) => (
                            n % 2 === 0 &&
                              r[n + 1] &&
                              (e[t] = r[n + 1].replace(/\\/g, "")),
                            e
                          ),
                          {}
                        );
                    })(a[1]);
                  if (i)
                    if (e.first_interaction) {
                      var u;
                      const t = DS(
                        null !==
                          (u = null === l || void 0 === l ? void 0 : l.ref) &&
                          void 0 !== u
                          ? u
                          : null === l || void 0 === l
                          ? void 0
                          : l.referral
                      );
                      await aS(e, { telegramUser: i, referrer: t }, n);
                      Boolean(t);
                      n.sendAnalyticsEvents([
                        { eventType: "JoinBot", eventProperties: {} },
                      ]);
                    } else rS(e, i);
                  const d = "private" === r ? _S : ES,
                    h = d[c];
                  h && h(e, n, t, l);
                })(e, r.message, n));
          },
        };
      const kS = (function (e, t, n) {
        var r, s, i, o;
        return {
          assets: null !== (r = e.assets) && void 0 !== r ? r : {},
          events: t,
          opts: {
            maxDaysSinceLastSession:
              null !==
                (s =
                  null === n || void 0 === n
                    ? void 0
                    : n.maxDaysSinceLastSession) && void 0 !== s
                ? s
                : 10,
            maxMessagesPerSession:
              null !==
                (i =
                  null === n || void 0 === n
                    ? void 0
                    : n.maxMessagesPerSession) && void 0 !== i
                ? i
                : 5,
            onGameEndTimeoutMinutes:
              null !==
                (o =
                  null === n || void 0 === n
                    ? void 0
                    : n.onGameEndTimeoutMinutes) && void 0 !== o
                ? o
                : 1,
          },
        };
      })({}, CS);
      async function OS(e, t, n) {
        const r = {
            url: "https://api.telegram.org/bot"
              .concat(
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.TELEGRAM_BOT_TOKEN,
                "/"
              )
              .concat(e),
            method: "POST",
            headers: {
              Accept: "application/json",
              "Content-Type": "application/json",
            },
            body: t ? JSON.stringify(t) : void 0,
          },
          s = await n(r);
        if (s.statusCode < 200 || s.statusCode >= 400) {
          const e = Error(
            "Telegram API error response: "
              .concat(s.statusCode, " ")
              .concat(s.body)
          );
          throw ((e.fetchOptions = r), e);
        }
        const i = JSON.parse(s.body);
        if (!i.ok) {
          const e = Error(
            "Telegram API error: ".concat(s.statusCode, " ").concat(s.body)
          );
          throw ((e.fetchOptions = r), e);
        }
        return i.result;
      }
      async function xS(e) {
        return await OS(
          "sendMessage",
          {
            chat_id: e.chatId,
            text: e.text,
            parse_mode: e.parseMode,
            reply_markup: e.replyMarkup,
          },
          e.fetch
        );
      }
      async function NS(e, t) {
        return await OS("getChat", { chat_id: e }, t);
      }
      const RS = 10;
      function DS(e) {
        if (!e) return;
        if (e.includes("-"))
          try {
            const t = e.split("-"),
              n = t[0];
            return t[1].length > 20
              ? n
              : (function (e) {
                  let t = 0;
                  for (const n of e) t = t * Db + Lb(n);
                  return t;
                })(n)
                  .toString()
                  .padStart(RS, "0");
          } catch {
            return;
          }
        return e;
      }
      const MS = {
          username: _a.string(),
          is_premium: _a.boolean(),
          referrer_id: _a.string(),
          chat_id: _a.number(),
          first_interaction: _a.number(),
          last_interaction_chat_bot: _a.number(),
          last_start_message_id: _a.number(),
        },
        jS = {
          team_id: _a.string(),
          energy: _a.number(),
          last_energy_refresh: _a.number(),
          free_rocketman_used: _a.array(_a.number()),
          free_energy_recharge_timestamp: _a.number(),
          energy_limit_level: _a.number(),
          energy_recharge_level: _a.number(),
          rocketman_used: _a.array(_a.number()),
          tap_level: _a.number(),
          has_auto_tap: _a.boolean(),
          last_session_time: _a.number(),
          first_session: _a.boolean(),
        },
        LS = { s: _a.number(), t: _a.number(), b: _a.number() },
        US = {
          friends: _a.array(
            _a
              .object({
                user_id: _a.string(),
                username: _a.string().optional(),
                contribution: _a.number(),
              })
              .additionalProperties()
          ),
        };
      function FS(e) {
        return Object.fromEntries(
          Object.entries(e).map((e) => {
            let [t, n] = e;
            return [t, n.optional()];
          })
        );
      }
      const BS = _a
        .object({ ...FS(MS), ...FS(jS), ...FS(LS), ...FS(US) })
        .additionalProperties();
      async function VS(e, t) {
        if (e.migratedAt) return;
        const n = {},
          r = Date.now();
        let s, i;
        try {
          s = await dS(
            async () => {
              const e = {
                  url: "".concat(Dw.migrationUrl, "/player/platform-storage"),
                  method: "POST",
                  body: JSON.stringify({ userId: t.getUserID() }),
                  headers: { "Content-Type": "application/json" },
                },
                n = await t.fetch(e);
              if (200 !== n.statusCode) {
                const t = Error(
                  "Failed to fetch player state: status "
                    .concat(n.statusCode, " body: ")
                    .concat(n.body)
                );
                throw ((t.fetchOptions = e), t);
              }
              return n;
            },
            {
              attempts: 6,
              backoff: { exponential: { delay: 500, base: 1.8, fuzz: 0.1 } },
            }
          );
        } catch (o) {
          throw (
            (mS(t.sendAnalyticsEvents, {
              errorCode: "player_state_fetch_failed",
              errorMessage: o.message,
              elapsedMs: Date.now() - r,
            }),
            o)
          );
        }
        try {
          i = JSON.parse(s.body);
        } catch (o) {
          throw (
            (mS(t.sendAnalyticsEvents, {
              errorCode: "player_state_invalid_json",
              errorMessage: o.message,
              elapsedMs: Date.now() - r,
            }),
            o)
          );
        }
        if (!BS.isValid(i)) {
          const e = BS.validate(i);
          throw (
            (mS(t.sendAnalyticsEvents, {
              errorCode: "player_state_invalid_schema",
              errorMessage: "Invalid legacy player state: ".concat(e),
              elapsedMs: Date.now() - r,
            }),
            new Error("Invalid legacy player state: ".concat(e)))
          );
        }
        if (
          ((e.migratedAt = Date.now()),
          t.sendAnalyticsEvents([
            {
              eventType: "Debug",
              eventProperties: {
                message: "Migrating user state",
                responseBody: s.body,
              },
            },
          ]),
          0 === Object.values(i).length)
        )
          return (
            (n.didMigrateUser = !1),
            (n.elapsedMs = Date.now() - r),
            void fS(t.sendAnalyticsEvents, n)
          );
        void 0 !== i.username && (e.username = i.username),
          void 0 !== i.is_premium && (e.is_premium = i.is_premium),
          void 0 !== i.referrer_id && (e.referrer_id = i.referrer_id),
          void 0 !== i.energy && (e.energy = i.energy),
          void 0 !== i.last_energy_refresh &&
            (e.last_energy_refresh = i.last_energy_refresh),
          void 0 !== i.free_rocketman_used &&
            (e.free_rocketman_used = i.free_rocketman_used),
          void 0 !== i.free_energy_recharge_timestamp &&
            (e.free_energy_recharge_timestamp =
              i.free_energy_recharge_timestamp),
          void 0 !== i.energy_limit_level &&
            (e.energy_limit_level = i.energy_limit_level),
          void 0 !== i.energy_recharge_level &&
            (e.energy_recharge_level = i.energy_recharge_level),
          void 0 !== i.rocketman_used && (e.rocketman_used = i.rocketman_used),
          void 0 !== i.tap_level && (e.tap_level = i.tap_level),
          void 0 !== i.has_auto_tap && (e.has_auto_tap = i.has_auto_tap),
          void 0 !== i.last_session_time &&
            (e.last_session_time = i.last_session_time),
          void 0 !== i.first_session && (e.first_session = i.first_session),
          (e.first_interaction = !1),
          void 0 !== i.s && (e.score = i.s),
          void 0 !== i.t && (e.taps = i.t),
          void 0 !== i.b && (e.balance = i.b),
          void 0 !== i.friends &&
            (e.friends = i.friends.map((e) => {
              let { user_id: t, username: n, contribution: r } = e;
              return { user_id: t, username: n, contribution: r };
            })),
          (e.migration = { score: e.score, balance: e.balance }),
          (n.didMigrateUser = !0),
          (n.userScore = e.score),
          (n.userBalance = e.balance),
          (n.userEnergy = e.energy),
          (n.userFriendCount = e.friends.length);
        if (void 0 !== i.team_id && "NO_TEAM" !== i.team_id) {
          const a = {
            url: "".concat(Dw.migrationUrl, "/teams/platform-storage"),
            method: "POST",
            body: JSON.stringify({ teamId: i.team_id }),
            headers: { "Content-Type": "application/json" },
          };
          try {
            s = await dS(
              async () => {
                const e = await t.fetch(a);
                if (200 !== e.statusCode) {
                  const t = Error(
                    "Failed to fetch team state: status "
                      .concat(e.statusCode, " body ")
                      .concat(e.body)
                  );
                  throw ((t.fetchOptions = a), t);
                }
                return e;
              },
              {
                attempts: 6,
                backoff: { exponential: { delay: 500, base: 1.8, fuzz: 0.1 } },
              }
            );
          } catch (o) {
            throw (
              (mS(t.sendAnalyticsEvents, {
                errorCode: "team_state_fetch_failed",
                errorMessage: o.message,
                elapsedMs: Date.now() - r,
              }),
              o)
            );
          }
          let c;
          try {
            c = JSON.parse(s.body);
          } catch (o) {
            throw (
              (mS(t.sendAnalyticsEvents, {
                errorCode: "team_state_invalid_json",
                errorMessage: o.message,
                elapsedMs: Date.now() - r,
              }),
              o)
            );
          }
          e.team_id = c.tg_username;
          const l = await t.sharedStates.teams.fetchOrCreate(e.team_id),
            u = 0 === l.global.createdAt;
          if (((n.didCreateTeam = u), u)) {
            try {
              const r = pS(await NS(e.team_id, t.fetch), c.photo);
              t.sharedStates.teams.postMessage.updateTeamProfile(e.team_id, {
                profile: r,
                timestamp: t.date.now(),
              }),
                (n.didAcquireTeamProfile = !0),
                (n.teamName = r.name);
            } catch (a_) {
              t.reportError(a_, {
                effect: "Failed to fetch chat for team ".concat(e.team_id),
              });
              const s = {
                name: c.name || "Team ".concat(e.team_id),
                description: c.description || "",
                photo: c.photo,
                inviteLink: "https://t.me/".concat(e.team_id),
              };
              t.sharedStates.teams.postMessage.updateTeamProfile(e.team_id, {
                profile: s,
                timestamp: t.date.now(),
              }),
                (n.didAcquireTeamProfile = !1),
                (n.teamName = s.name);
            }
            t.sharedStates.teams.postMessage.setMigrationData(e.team_id, {
              score: c.s,
            }),
              t.sharedStates.teams.postMessage.addScore(e.team_id, {
                score: c.s,
              });
          }
          t.sharedStates.teams.postMessage.addMember(e.team_id, {
            score: 0,
            timestamp: t.date.now(),
          }),
            (n.teamID = e.team_id),
            (n.teamPoints = l.global.score),
            (n.teamMemberCount = l.global.membersCount);
        }
        (n.didMigrateTeam = void 0 !== e.team_id),
          (n.elapsedMs = Date.now() - r),
          fS(t.sendAnalyticsEvents, n);
      }
      const qS = {
          grantYoutubeReward: _a.object({ earningKey: _a.string() }),
          forceMigrate: _a.unknown(),
        },
        HS = mw(qS)({
          grantYoutubeReward: (e, t) => {
            let { earningKey: n } = t;
            lS(e, { earningKey: n });
          },
          forceMigrate: async (e, t, n) => {
            await VS(e, n);
          },
        }),
        WS = qS,
        KS = gw(HS),
        zS = mw({ ...WS, ...zw })({ ...KS, ...Gw }),
        GS = (e) => e,
        JS = GS({
          cheat_AddPoints: pc((e, t) => {
            let { points: n } = t;
            (e.balance += n), (e.score += n), (e.taps += n);
          }),
          cheat_SetTaps: pc((e, t) => {
            let { taps: n } = t;
            e.taps = n;
          }),
          cheat_SendReengagementMessage: pc((e, t, n) => {
            n.chatbot.sendTelegramMessage({
              chatId: e.id,
              receiverId: e.id,
              message: Bw.reengagement({
                args: { userId: e.id, iteration: 1 },
                payload: {
                  $channel: "CHATBOT",
                  feature: "reengagement",
                  $subFeature: "reengagement_24h",
                },
              }),
            });
          }),
          cheat_SendLevelUpMessage: pc((e, t, n) => {
            n.chatbot.sendTelegramMessage({
              chatId: e.id,
              receiverId: e.id,
              message: Bw.friendJoined({
                args: {
                  userId: e.id,
                  tokens: { friendName: e.username, bonus: "100" },
                },
                payload: {
                  $channel: "CHATBOT",
                  feature: "friend",
                  $subFeature: "friend_joined",
                },
              }),
            });
          }),
        }),
        QS = 432e5,
        YS = 36e5,
        XS = GS({
          onLogin: fc(async (e, t, n) => {
            await VS(e, n);
          }),
          startSession: pc((e, t, n) => {
            var r;
            Object.assign(e.profile, t.profile);
            const s = n.date.now();
            oS(e, s),
              (e.session_taps = 0),
              n.scheduledActions.unschedule("autobot"),
              n.scheduledActions.schedule.sendReengagementMessage({
                args: { chatId: $b(n), iteration: 1 },
                notificationId: "reengagement",
                delayInMS: gb,
              });
            const i =
              s -
              (null !== (r = e.invite_friend_nudge_time) && void 0 !== r
                ? r
                : 0);
            let o = 0;
            if (e.taps > 0) {
              o = i - 432e5;
            }
            let a = 0;
            if (e.has_auto_tap) {
              let t = s - e.last_session_time - YS;
              if (t > 0) {
                t > QS && (t = QS);
                const r = Math.round(t / 1e3),
                  s = Kb(e) * r;
                (e.balance += s),
                  (e.score += s),
                  (a += s),
                  n.sendAnalyticsEvents([
                    {
                      eventType: "CollectAutoTaps",
                      eventProperties: { amount: s },
                    },
                  ]);
              }
            }
            const c = (function (e, t) {
                const n = e - t;
                return n >= gb && n < 1728e5;
              })(s, e.last_reward_granted),
              l =
                !e.streak_days &&
                (function (e, t) {
                  return e - t >= gb;
                })(s, e.last_reward_granted);
            return (
              c || l
                ? ((e.consecutive_days = 1),
                  (e.last_reward_granted = s),
                  e.streak_days === Nb
                    ? e.unclaimed_rewards
                      ? (e.streak_days = Math.min(e.streak_days + 1, Nb))
                      : ((e.streak_days = 1), (e.unclaimed_rewards = 1))
                    : ((e.streak_days = Math.min(e.streak_days + 1, Nb)),
                      (e.unclaimed_rewards += 1)))
                : (function (e, t) {
                    return e - t > 1728e5;
                  })(s, e.last_reward_granted) &&
                  ((e.streak_days = 1),
                  (e.last_reward_granted = s),
                  (e.unclaimed_rewards = 1),
                  n.sendAnalyticsEvents([
                    {
                      eventType: "reward_forfeited",
                      eventProperties: {
                        max_day_returned: e.consecutive_days + 1,
                      },
                    },
                  ]),
                  (e.consecutive_days = 1)),
              (e.last_session_time = s),
              { inviteDrawerDuration: o, botEarnings: a }
            );
          }),
          onAdminCreateUser: fc(async (e, t, n) => {
            if (!e.migratedAt) {
              n.sendAnalyticsEvents([
                {
                  eventType: "Debug",
                  eventProperties: {
                    message: "User created via admin API",
                    userId: n.getUserID(),
                  },
                },
              ]);
              try {
                await VS(e, n), (e.migrationForced = !0);
              } catch (r) {
                throw new Error("Migration failed: ".concat(r.message));
              }
            }
          }),
          tap: pc((e, t, n) => {
            sS(
              e,
              (function (e) {
                return e > 100 && (e = 100), e;
              })(1),
              n
            );
          }),
          setProfilePicture: fc(async (e, t, n) => {
            const r = await n.telegram.getProfilePictureUrl(e.id, "160x160");
            r
              ? ((e.profile.photo = r),
                (e.profile.photoLastUpdated = Date.now()))
              : (e.profile.photoLastChecked = Date.now());
          }),
          buyBooster: pc((e, t, n) => {
            const { booster: r } = t,
              s = Yb(e, r),
              i = "AutoTap" === r ? Boolean(s) : Number(s);
            try {
              if ("AutoTap" === r) {
                if (i) throw new Error("User already has this product.");
                const t = Xb(r, 0);
                iS(e, n, { booster: r, level: 1, price: t });
              } else {
                const t = i + 1,
                  s = Xb(r, i);
                if (!s)
                  throw new Error("User has reached max level of this item");
                iS(e, n, { booster: r, level: t, price: s });
              }
            } catch (a_) {
              throw (console.error("Failed to buy booster", a_), a_);
            }
          }),
          buyBuff: pc((e, t, n) => {
            const r = t.buff,
              s = n.date.now(),
              i = Jb(e, s);
            if ("Rocketman" === r) {
              if (i.rocketmanUseCount >= 288e5)
                throw new Error("Cannot use more free rocketman at the moment");
              return (
                e.free_rocketman_used.push(s),
                void n.sendAnalyticsEvents([
                  { eventType: "UseRocketman", eventProperties: {} },
                ])
              );
            }
            if ("FullEnergy" === r) {
              if (Bb(i.lastEnergyUsed, _b, s) > 0)
                throw new Error("Cannot use more free energy at the moment");
              return (
                (e.free_energy_recharge_timestamp = s),
                (e.energy = Vb(e)),
                void n.sendAnalyticsEvents([
                  { eventType: "UseFreeEnergy", eventProperties: {} },
                ])
              );
            }
            throw new Error('Buff unsupported: "'.concat(r, '"'));
          }),
          grantAdReward: pc((e, t, n) => {
            if (Zb(e, n.date.now()) > 0) return;
            const r = Vb(e);
            (e.energy += Math.round(r * Eb)),
              (e.last_ad_reward_time = n.date.now());
          }),
          claimEarning: pc((e, t, n) => {
            let { earningKey: r } = t;
            lS(e, { earningKey: r });
          }),
          claimYoutubeReward: pc((e, t, n) => {
            e.earnings.followOnYoutube ||
              e.followOnYoutubeTimestamp ||
              ((e.followOnYoutubeTimestamp = n.date.now()),
              console.log("claimYoutubeReward"),
              n.scheduledActions.schedule.grantYoutubeReward({
                args: { earningKey: "followOnYoutube" },
                notificationId: "youtube-reward",
                delayInMS: vb,
              }));
          }),
          updateInviteFriendNudge: pc((e, t, n) => {
            e.invite_friend_nudge_time = n.date.now();
          }),
          handleFirstEntry: fc(async (e, t, n) => {
            e.first_interaction && (await aS(e, t, n));
          }),
          claimDailyReward: pc((e, t, n) => {
            if (!e.streak_days || !e.unclaimed_rewards) return;
            const r = rw(e);
            (e.balance += r),
              (e.score += r),
              (e.unclaimed_rewards = 0),
              n.sendAnalyticsEvents([
                {
                  eventType: "retention_reward_claim",
                  eventProperties: { return_day: e.consecutive_days + 1 },
                },
              ]);
          }),
        }),
        ZS = GS({
          asyncCreateTeam: fc(async (e, t, n) => {
            if (e.balance < cw)
              throw new Error("Insufficient balance to create a team.");
            e.balance -= cw;
            const { teamId: r, ...s } = t;
            n.sharedStates.teams.create(r),
              n.sharedStates.teams.postMessage.updateTeamProfile(r, {
                profile: s,
                timestamp: n.date.now(),
              }),
              Xw(e, { teamId: r }, n);
          }),
          joinTeam: pc((e, t, n) => {
            Zw(e, n), Xw(e, t, n);
          }),
          leaveTeam: pc((e, t, n) => {
            Zw(e, n);
          }),
          updateTeamProfile: pc((e, t, n) => {
            e.team_id &&
              n.sharedStates.teams.postMessage.updateTeamProfile(e.team_id, {
                profile: t,
                timestamp: n.date.now(),
              });
          }),
          syncTeamScore: pc((e, t, n) => {
            $w(e, n);
          }),
          getTeamWithMembersWithScoreFix: fc(async (e, t, n) => {
            const r = await n.asyncGetters.getTeamWithMembers(t);
            if (r)
              return (
                (function (e, t, n) {
                  var r, s;
                  const { team: i } = t;
                  if (!i) return;
                  if (i.score >= 0) return;
                  if (!e.team_id) return;
                  if (i.id !== e.team_id) return;
                  const o = i.score,
                    a =
                      null !==
                        (r =
                          null === (s = i.players) || void 0 === s
                            ? void 0
                            : s.reduce((e, t) => e + t.score, 0)) &&
                      void 0 !== r
                        ? r
                        : 0;
                  a < 0
                    ? n.sendAnalyticsEvents([
                        {
                          eventType: "fix_negative_team_score_failed",
                          eventProperties: {
                            message:
                              "Players with negative scores exist in this team",
                            teamId: i.id,
                            oldScore: o,
                            newScore: a,
                          },
                        },
                      ])
                    : ((i.score = a),
                      n.sharedStates.teams.postMessage.addScore(i.id, {
                        score: -o + a,
                      }),
                      n.sendAnalyticsEvents([
                        {
                          eventType: "fix_negative_team_score",
                          eventProperties: {
                            teamId: i.id,
                            oldScore: o,
                            newScore: a,
                          },
                        },
                      ]));
                })(e, { team: r }, n),
                r
              );
          }),
        }),
        $S = {
          ...XS,
          ...ZS,
          ...("prod" !==
          {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_STAGE: "prod",
            REACT_APP_ENV: "prod",
            REACT_APP_APP_VERSION: "2.8.0",
          }.STAGE
            ? JS
            : {}),
        },
        e_ = "America/Los_Angeles";
      const t_ = {
          async onSessionEnd(e, t, n) {
            (e.last_session_time = n.date.now()), $w(e, n);
            const r = $b(n);
            if (e.has_auto_tap) {
              const e = QS + YS;
              n.scheduledActions.schedule.sendAutobotCooldownMessage({
                args: { chatId: r },
                notificationId: "autobot",
                delayInMS: e,
              });
            }
            if (
              (n.sendAnalyticsEvents([
                { eventType: "Tap", eventProperties: { taps: e.session_taps } },
              ]),
              e.energy !== Vb(e))
            ) {
              const t = Math.max(
                0,
                (function (e) {
                  const t = Vb(e),
                    n = qb(e),
                    r = (t - e.energy) / n;
                  return Math.ceil(1e3 * r);
                })(e)
              );
              n.scheduledActions.schedule.sendEnergyRechargedMessage({
                args: { chatId: r },
                notificationId: "energyRecharged",
                delayInMS: t,
              });
            }
          },
        },
        n_ = new sb(),
        r_ =
          {
            NODE_ENV: "production",
            PUBLIC_URL: "",
            WDS_SOCKET_HOST: void 0,
            WDS_SOCKET_PATH: void 0,
            WDS_SOCKET_PORT: void 0,
            FAST_REFRESH: !0,
            REACT_APP_STAGE: "prod",
            REACT_APP_ENV: "prod",
            REACT_APP_APP_VERSION: "2.8.0",
          }.APP_VERSION || "2.8.0";
      if (!r_)
        throw Error(
          "define either APP_VERSION or REACT_APP_APP_VERSION environment variable"
        );
      const s_ =
        (tm(
          (i_ = {
            eventHandlers: t_,
            stateSchema: rb,
            actions: $S,
            messages: fw,
            computedProperties: sw,
            ruleset: Gy,
            scheduledActions: zS,
            asyncGetters: hw,
            chatbot: kS,
            migrator: n_,
            appName: "gemzcoin",
            version: r_,
            onLoginAction: "onLogin",
            sharedStates: fb,
          })
        ),
        (i_.ruleset = (function (e) {
          return {
            ...e,
            abTests: {
              "0000_placebo_2": { buckets: [{ id: "a" }, { id: "b" }] },
              "0000_placebo_3": {
                buckets: [{ id: "a" }, { id: "b" }, { id: "c" }],
              },
              "0000_placebo_4": {
                buckets: [{ id: "a" }, { id: "b" }, { id: "c" }, { id: "d" }],
              },
              "0000_placebo_5": {
                buckets: [
                  { id: "a" },
                  { id: "b" },
                  { id: "c" },
                  { id: "d" },
                  { id: "e" },
                ],
              },
              ...(null === e || void 0 === e ? void 0 : e.abTests),
            },
          };
        })(i_.ruleset)),
        em(i_, i_.modules));
      var i_;
      const o_ =
        ((a_ = (function (e, t) {
          const { getPlatformStorage: n } = t || {},
            r = {},
            s = { ...vc };
          if (n)
            try {
              const t = e.stateSchema.getDefault(),
                r = n(t);
              if (void 0 !== r && "object" !== typeof r)
                throw Error("invalid value (".concat(r, ")"));
            } catch (h) {
              throw Error(
                "Cannot locate platform storage in Replicant state schema: ".concat(
                  h.message,
                  ". Check the getPlatformStorage option."
                )
              );
            }
          else Object.assign(r, mc), Object.assign(s, gc);
          const i = e.stateSchema.getFullSchema(),
            o = Object.keys(r).filter((e) => i[e]);
          if (o.length > 0)
            throw Error(
              "Cannot extend Replicant state schema with ".concat(
                o,
                ": keys already exists in local configuration. Try renaming the state properties."
              )
            );
          const a = _a.object({ ...i, ...r }),
            c = Fy({
              computedProperties: e.computedProperties || {},
              getPlatformStorage: n,
            }),
            l = Object.keys(c).filter((t) => {
              var n;
              return null == (n = e.asyncGetters) ? void 0 : n[t];
            });
          if (l.length > 0)
            throw Error(
              "Cannot extend Replicant async getters configuration with ".concat(
                l,
                ": keys already exists in local configuration. Try renaming the async getters."
              )
            );
          const u = Object.keys(s).filter((t) => {
            var n;
            return null == (n = e.actions) ? void 0 : n[t];
          });
          if (u.length > 0)
            throw Error(
              "Cannot extend Replicant actions configuration with ".concat(
                u,
                ": keys already exists in local configuration. Try renaming the actions."
              )
            );
          if (e.getReceiverUserProperties)
            throw Error(
              "Cannot extend Replicant configuration with getReceiverUserProperties: key already exists in local configuration."
            );
          let d = null == t ? void 0 : t.amplitudeTimeZone;
          try {
            ({
              NODE_ENV: "production",
              PUBLIC_URL: "",
              WDS_SOCKET_HOST: void 0,
              WDS_SOCKET_PATH: void 0,
              WDS_SOCKET_PORT: void 0,
              FAST_REFRESH: !0,
              REACT_APP_STAGE: "prod",
              REACT_APP_ENV: "prod",
              REACT_APP_APP_VERSION: "2.8.0",
            }).AMPLITUDE_TIME_ZONE &&
              (d = {
                NODE_ENV: "production",
                PUBLIC_URL: "",
                WDS_SOCKET_HOST: void 0,
                WDS_SOCKET_PATH: void 0,
                WDS_SOCKET_PORT: void 0,
                FAST_REFRESH: !0,
                REACT_APP_STAGE: "prod",
                REACT_APP_ENV: "prod",
                REACT_APP_APP_VERSION: "2.8.0",
              }.AMPLITUDE_TIME_ZONE);
          } catch {}
          if (!d)
            throw Sr(
              "INVALID_PARAM",
              "amplitudeTimeZone is undefined: define the value either in extendReplicantConfigForAnalytics parameters or with the AMPLITUDE_TIME_ZONE environment variable"
            );
          return {
            ...e,
            stateSchema: a,
            actions: { ...e.actions, ...s },
            asyncGetters: { ...e.asyncGetters, ...c },
            getReceiverUserProperties: (e, t) =>
              (function (e, t, n) {
                const r = Ta(e);
                return r ? Pa(r, t, n) : null;
              })(n ? n(e) : e.gcinstant.platformStorage, t.date.now(), d) || {},
            sendActionAnalyticsWithClient: !0,
          };
        })(s_, { amplitudeTimeZone: e_ })),
        { ...a_, actions: { ...a_.actions, ...Ly } });
      var a_;
      const c_ = o_;
      var l_, u_, d_, h_, p_;
      const f_ = new URLSearchParams(document.location.search),
        m_ = f_.get("payload"),
        g_ = {
          playerId:
            null !== (l_ = f_.get("uid")) && void 0 !== l_ ? l_ : "ANON",
          useMock: null !== (u_ = f_.has("mock")) && void 0 !== u_ && u_,
          useLocal: null !== (d_ = f_.has("local")) && void 0 !== d_ && d_,
          simulateRocketman:
            null !== (h_ = f_.has("rocket")) && void 0 !== h_ && h_,
          skipQR: null !== (p_ = f_.has("noqr")) && void 0 !== p_ && p_,
          payload: m_ ? JSON.parse(m_) : {},
        };
      if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
        const e = [
            "\n %c %c %c \u2730 Gemzcoin " + "2.8.0" + " \u2730  %c %c %c \n\n",
            "background: #9eacbe; padding:5px 0;",
            "background: #9eacbe; padding:5px 0;",
            "color: #9eacbe; background: #030307; padding:5px 0;",
            "background: #9eacbe; padding:5px 0;",
            "background: #beccde; padding:5px 0;",
            "color: #beccde; background: #fff; padding:5px 0;",
          ],
          t = window.console;
        window.console.info.apply(t, e);
      }
      const v_ = g_.useLocal ? "local" : "prod",
        y_ = { amplitudeTimeZone: e_ },
        b_ = {
          local: {
            ...y_,
            adBlockId: "51",
            amplitudeKey: "4a9568ca708d3d60c0df2d2f022ff98c",
            replicant: { endpoint: "", offlineMode: !0, oldGameApiUrl: "" },
          },
          alpha: {
            ...y_,
            adBlockId: "51",
            amplitudeKey: "4a9568ca708d3d60c0df2d2f022ff98c",
            replicant: {
              endpoint:
                "https://gemzcoin-dev.us-east-1.replicant.gc-internal.net/gemzcoin-alpha",
              offlineMode: !1,
              oldGameApiUrl: "https://notgemz.game.dev.pnk.one",
            },
          },
          bravo: {
            ...y_,
            adBlockId: "51",
            amplitudeKey: "4a9568ca708d3d60c0df2d2f022ff98c",
            replicant: {
              endpoint:
                "https://gemzcoin-dev.us-east-1.replicant.gc-internal.net/gemzcoin-bravo",
              offlineMode: !1,
              oldGameApiUrl: "https://notgemz.game.dev.pnk.one",
            },
          },
          dev: {
            ...y_,
            adBlockId: "49",
            amplitudeKey: "4a9568ca708d3d60c0df2d2f022ff98c",
            replicant: {
              endpoint:
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.REACT_APP_REPLICANT_ENDPOINT ||
                "https://gemzcoin.us-east-1.replicant.gc-internal.net/gemzcoin-dev",
              offlineMode: !1,
              oldGameApiUrl: "https://notgemz.game.dev.pnk.one",
            },
          },
          prod: {
            ...y_,
            adBlockId: "50",
            amplitudeKey: "9a2c9db91b4af221af54a57f6fd0f1b7",
            replicant: {
              endpoint:
                "https://gemzcoin.us-east-1.replicant.gc-internal.net/gemzcoin",
              offlineMode: !1,
              oldGameApiUrl: "https://notgemz.game.prod2.pnk.one",
            },
          },
          staging: {
            ...y_,
            adBlockId: "49",
            amplitudeKey: "ebd14e7807f4e5c5a3e465990b98ab1b",
            replicant: {
              endpoint:
                "https://gemzcoin.us-east-1.replicant.gc-internal.net/gemzcoin-dev",
              offlineMode: !1,
              oldGameApiUrl: "https://notgemz.game.dev.pnk.one",
            },
          },
        }[v_];
      let w_ = (function (e) {
          return (
            (e.InviteBonus = "invite-bonus"),
            (e.FollowX = "follow-x"),
            (e.JoinCommunity = "join-community"),
            (e.Invite5 = "invite-5"),
            (e.Invite10 = "invite-10"),
            (e.Invite100 = "invite-100"),
            (e.JoinYoutube = "join-youtube"),
            (e.JoinAnnouncement = "join-announcement"),
            (e.DailyReward = "daily-reward"),
            e
          );
        })({}),
        S_ = (function (e) {
          return (
            (e.Bronze = "Bronze"),
            (e.Silver = "Silver"),
            (e.Gold = "Gold"),
            (e.Platinum = "Platinum"),
            (e.Diamond = "Diamond"),
            e
          );
        })({}),
        __ = (function (e) {
          return (e.Blue = "blue"), (e.Purple = "purple"), e;
        })({}),
        E_ = (function (e) {
          return (
            (e.AutoTap = "AutoTap"),
            (e.MultiTap = "MultiTap"),
            (e.RechargeSpeed = "RechargeSpeed"),
            (e.RechargeLimit = "RechargeLimit"),
            e
          );
        })({}),
        A_ = (function (e) {
          return (
            (e.Rocketman = "Rocketman"),
            (e.FullEnergy = "FullEnergy"),
            (e.AutoBotReward = "AutoBotReward"),
            (e.AutoBotFirstSession = "AutoBotFirstSession"),
            e
          );
        })({});
      const T_ = () => ({
          energy: 1e3,
          energyPerSecond: 1,
          energyLimit: 1e3,
          rocketmanMultiplier: 1,
          lastRocketmanStart: 1715210856700,
          pointsPerTap: 3,
          score: 436,
          balance: 436,
          league: S_.Bronze,
          isFirstSession: !0,
          platformStorage: {},
          lastAdEnergyRewardTime: 0,
        }),
        P_ = {
          startSession: async () => ({
            player: T_(),
            startTime: 1715221083068,
            botEarnings: 100,
            inviteDrawerDuration: 0,
          }),
          listTeams: async () => [
            {
              id: "-4192078186",
              score: 1e3,
              members: 1,
              name: "Cai Team 4 - with a really long name to test ellipsis stuff",
              creatorId: "6540606306",
              photo:
                "https://notgemz-game.s3.amazonaws.com/media/-4192078186.jpg",
              description: "Please work live :D",
              inviteLink: "https://t.me/+TjAvWd8f0W4wYmIx",
              rank: 1,
              players: [],
            },
            {
              id: "-4130903336",
              score: 300,
              members: 0,
              name: "Cai Dota Team - with a really long name to test ellipsis stuff",
              creatorId: "6540606306",
              photo:
                "https://notgemz-game.s3.amazonaws.com/media/-4130903336.jpg",
              description: "We shall conquer the world&#33;",
              inviteLink: "https://t.me/+SHFI_M8wMJliM2Yx",
              rank: 2,
              players: [],
            },
          ],
          getEarnAchievementStates: async () => ({
            InviteBonus: !1,
            FollowX: !1,
            JoinCommunity: !1,
            Invite5: !1,
            Invite10: !1,
            Invite100: !1,
          }),
          leaderboard: async () => [
            {
              id: "-4192078186",
              score: 1e3,
              members: 1,
              name: "Cai Team 4 - with a really long name to test ellipsis stuff",
              creatorId: "6540606306",
              photo:
                "https://notgemz-game.s3.amazonaws.com/media/-4192078186.jpg",
              description: "Please work live :D",
              inviteLink: "https://t.me/+TjAvWd8f0W4wYmIx",
              rank: 1,
              players: [],
            },
            {
              id: "-4130903336",
              score: 300,
              members: 0,
              name: "Cai Dota Team - with a really long name to test ellipsis stuff",
              creatorId: "6540606306",
              photo:
                "https://notgemz-game.s3.amazonaws.com/media/-4130903336.jpg",
              description: "We shall conquer the world&#33;",
              inviteLink: "https://t.me/+SHFI_M8wMJliM2Yx",
              rank: 2,
              players: [],
            },
          ],
          friends: async () => [
            {
              team: "FooBar",
              picture: "",
              username: "Foo",
              league: S_.Bronze,
              score: 1e4,
              contribution: 10,
            },
            {
              team: "FooBar",
              picture: "",
              username: "Foo",
              league: S_.Bronze,
              score: 1e4,
              contribution: 10,
            },
            {
              team: "FooBar",
              picture: "",
              username: "Foo",
              league: S_.Bronze,
              score: 1e4,
              contribution: 10,
            },
          ],
          getTeam: async (e) => ({
            id: "-4192078186",
            score: 10,
            members: 1,
            name: "Cai Team 4",
            creatorId: "6540606306",
            photo:
              "https://notgemz-game.s3.amazonaws.com/media/-4192078186.jpg",
            description: "Please work live :D",
            inviteLink: "https://t.me/+TjAvWd8f0W4wYmIx",
            rank: 1,
            players: [],
          }),
          leaveTeam: (e) => ({
            player: T_(),
            team: {
              id: "-4192078186",
              score: 10,
              members: 1,
              name: "Cai Team 4",
              creatorId: "6540606306",
              photo:
                "https://notgemz-game.s3.amazonaws.com/media/-4192078186.jpg",
              description: "Please work live :D",
              inviteLink: "https://t.me/+TjAvWd8f0W4wYmIx",
              rank: 1,
              players: [],
            },
          }),
          joinTeam: async (e, t) => ({
            player: T_(),
            team: {
              id: "-4192078186",
              score: 10,
              members: 1,
              name: "Cai Team 4",
              creatorId: "6540606306",
              photo:
                "https://notgemz-game.s3.amazonaws.com/media/-4192078186.jpg",
              description: "Please work live :D",
              inviteLink: "https://t.me/+TjAvWd8f0W4wYmIx",
              rank: 1,
              players: [],
            },
          }),
          getShop: async (e) => ({
            buffs: {
              Rocketman: { available: 3, maxUses: 3, timeLeft: -1715192362020 },
              FullEnergy: { timeLeft: -1715192362020 },
            },
            boosters: {
              MultiTap: { price: 8e3, level: 3, maxedOut: !1 },
              RechargeLimit: { price: 2e3, level: 1, maxedOut: !1 },
              RechargeSpeed: { price: 2e3, level: 1, maxedOut: !1 },
              AutoTap: { price: 2e4, level: 0, maxedOut: !1 },
            },
          }),
          buyBooster: (e, t) => ({ player: T_() }),
          buyBuff: (e, t) => ({ player: T_() }),
          giveAdReward: (e) => T_(),
          getPlatformStorage: (e) => T_().platformStorage,
          setPlatformStorage: (e, t) => (T_().platformStorage = t),
          getLeagueLeaderboard: async (e) => [
            {
              rank: 1,
              username: "foo",
              picture: "",
              score: 0,
              league: S_.Bronze,
            },
          ],
          getLanguageCode: () => "en",
        },
        I_ = {
          getFriends: async () => [
            {
              username: "Mock friend 01",
              contribution: 150,
              picture: "",
              team: "foo",
              score: 2e3,
              league: S_.Silver,
            },
            {
              username: "Mock friend 02",
              contribution: 400,
              picture: "",
              team: "foo",
              score: 3e3,
              league: S_.Gold,
            },
            {
              username: "Mock friend 03",
              contribution: 100,
              picture: "",
              team: "foo",
              score: 1e3,
              league: S_.Bronze,
            },
          ],
        };
      function C_(e) {
        var t, n, r;
        const s =
          null === (t = Telegram) ||
          void 0 === t ||
          null === (n = t.WebApp) ||
          void 0 === n ||
          null === (r = n.initDataUnsafe) ||
          void 0 === r
            ? void 0
            : r.user;
        return (
          (null === s || void 0 === s ? void 0 : s.username) ||
          (null === s || void 0 === s ? void 0 : s.first_name) ||
          (null === s || void 0 === s ? void 0 : s.last_name) ||
          e.username ||
          e.id
        );
      }
      function k_(e, t) {
        var n, r, s;
        const i =
          null === (n = Telegram) ||
          void 0 === n ||
          null === (r = n.WebApp) ||
          void 0 === r ||
          null === (s = r.initDataUnsafe) ||
          void 0 === s
            ? void 0
            : s.user;
        return Qb(
          t,
          (null === i || void 0 === i ? void 0 : i.photo_url) || e.profile.photo
        );
      }
      var O_ = (function (e) {
        return (
          (e.TEAMS_LIST = "teams"),
          (e.TEAMS_TOP_100 = "teams/top100"),
          (e.TEAMS_GET = "teams/get"),
          (e.TEAMS_JOIN = "teams/join"),
          (e.TEAMS_LEAVE = "teams/leave"),
          (e.START_SESSION = "start-game"),
          (e.SUBMIT_POINTS = "add-points"),
          (e.BUY_BOOSTER = "player/booster"),
          (e.BUY_BUFF = "player/buff"),
          (e.SHOP_GET = "shop"),
          (e.AD_REWARD = "player/adreward"),
          (e.PLATFORM_STORAGE = "player/platform-storage"),
          (e.PLATFORM_STORAGE_SET = "player/platform-storage-set"),
          e
        );
      })(O_ || {});
      let x_ = g_.useLocal
        ? "http://localhost:8080"
        : "https://notgemz.game.".concat(v_, ".pnk.one");
      g_.useLocal || "https://notgemz.notif.".concat(v_, ".pnk.one");
      const N_ = (e) => "".concat(x_, "/").concat(e),
        R_ = (e) => {
          const t = async (e, t) => {
            const n = await fetch(e, t);
            if (200 === n.status) return n.json();
            {
              const e = await n.text();
              throw new Error("Woops something went wrong: ".concat(e));
            }
          };
          return {
            get: () => t(e),
            post: (n) =>
              t(e, {
                method: "POST",
                body: JSON.stringify(n),
                headers: { "Content-Type": "application/json" },
              }),
          };
        };
      function D_(e, t) {
        var n;
        const r = Gb(e, t);
        return {
          energy: e.energy,
          energyPerSecond: qb(e),
          energyLimit: Vb(e),
          rocketmanDuration: r.duration,
          rocketmanMultiplier: r.multiplier,
          lastRocketmanStart:
            null !== (n = Hb(e, r.free)) && void 0 !== n ? n : 0,
          pointsPerTap: zb(e, t),
          score: e.score,
          balance: e.balance,
          league: Wb(e),
          isFirstSession: e.first_session,
          lastAdEnergyRewardTime: e.last_ad_reward_time,
        };
      }
      function M_(e, t, n) {
        return { player: D_(e, n), team: t };
      }
      const j_ = g_.useMock
          ? P_
          : {
              startSession: async () => {
                const e = await CO.invoke.startSession({
                  profile: {
                    name: C_(CO.replicant.state),
                    photo: k_(CO.replicant.state, CO.replicant.userId),
                  },
                });
                return (
                  (t = CO.state),
                  (n = CO.playerTeam),
                  (r = CO.now()),
                  (s = e.botEarnings),
                  (i = e.inviteDrawerDuration),
                  {
                    ...M_(t, n, r),
                    startTime: r,
                    botEarnings: s,
                    inviteDrawerDuration: i,
                  }
                );
                var t, n, r, s, i;
              },
              listTeams: () =>
                CO.replicant.asyncGetters.getRecommendedTeams({}),
              leaderboard: () =>
                CO.replicant.asyncGetters.getTeamsLeaderboard({}),
              getTeam: async (e) => {
                var t, n, r;
                let s = await CO.replicant.asyncGetters.getTeamWithMembers({
                  teamId: e,
                });
                if (
                  (null !== (t = s) &&
                    void 0 !== t &&
                    t.id &&
                    null !== (n = CO.playerTeam) &&
                    void 0 !== n &&
                    n.id &&
                    s.id === CO.playerTeam.id &&
                    s.score < 0 &&
                    (s =
                      await CO.replicant.invoke.getTeamWithMembersWithScoreFix({
                        teamId: e,
                      })),
                  s)
                ) {
                  if (
                    s.id &&
                    null !== (r = CO.playerTeam) &&
                    void 0 !== r &&
                    r.id &&
                    s.id === CO.playerTeam.id
                  ) {
                    var i, o;
                    const e =
                      null === (i = s.players) || void 0 === i
                        ? void 0
                        : i.find(
                            (e) =>
                              e.name.toLowerCase() ===
                              CO.state.username.toLowerCase()
                          );
                    if (e) return s;
                    const t = {
                      name: CO.state.username,
                      photo:
                        null === (o = CO.state.profile) || void 0 === o
                          ? void 0
                          : o.photo,
                      score: CO.state.score,
                      rank: 1,
                    };
                    s.players
                      ? (s.players.push(t),
                        s.players.sort((e, t) => t.score - e.score),
                        s.players.forEach((e, t) => {
                          e.rank = t + 1;
                        }))
                      : (s.players = [t]);
                  }
                  return s;
                }
              },
              leaveTeam: async () => (
                await CO.invoke.leaveTeam(), M_(CO.state, void 0, CO.now())
              ),
              joinTeam: async (e, t) => (
                await CO.invoke.joinTeam({ teamId: t }),
                M_(
                  CO.state,
                  await (CO.state.team_id
                    ? CO.replicant.asyncGetters.getTeamWithMembers({
                        teamId: CO.state.team_id,
                      })
                    : void 0),
                  CO.now()
                )
              ),
              buyBooster: async (e, t) => (
                await CO.invoke.buyBooster({ booster: t }),
                M_(CO.state, CO.playerTeam, CO.now())
              ),
              getShop: async (e) => (
                CO.track("OpenShop", {}),
                (function (e, t) {
                  const {
                      rocketmanUseCount: n,
                      lastEnergyUsed: r,
                      nextRocketmanExpiry: s,
                    } = Jb(e, t),
                    i = Boolean(Yb(e, "AutoTap")),
                    o = Bb(r, _b, t);
                  return {
                    buffs: {
                      Rocketman: {
                        available: 3 - n,
                        maxUses: 3,
                        timeLeft: Bb(s, gb, t),
                      },
                      FullEnergy: { timeLeft: o },
                    },
                    boosters: {
                      ...["MultiTap", "RechargeLimit", "RechargeSpeed"].reduce(
                        (t, n) => {
                          const r = Number(Yb(e, n)),
                            s = Pb[n][r];
                          return (
                            (t[n] = { price: s, level: r + 1, maxedOut: !s }), t
                          );
                        },
                        {}
                      ),
                      AutoTap: {
                        price: Pb.AutoTap[0],
                        level: Number(i),
                        maxedOut: i,
                      },
                    },
                  };
                })(CO.state, CO.now())
              ),
              buyBuff: async (e, t) => (
                await CO.invoke.buyBuff({ buff: t }),
                M_(CO.state, CO.playerTeam, CO.now())
              ),
              giveAdReward: async (e) => {
                await CO.invoke.grantAdReward();
                return M_(CO.state, CO.playerTeam, CO.now()).player;
              },
              getPlatformStorage: (e) =>
                R_(N_(O_.PLATFORM_STORAGE)).post({ userId: e }),
              setPlatformStorage: (e, t) =>
                R_(N_(O_.PLATFORM_STORAGE_SET)).post({
                  userId: e,
                  platformStorage: t,
                }),
              getLeagueLeaderboard: (e) =>
                CO.replicant.asyncGetters.getPlayersByLeague({ league: e }),
            },
        L_ = g_.useMock
          ? I_
          : { getFriends: async (e) => CO.asyncGetters.getFriends() };
      async function U_(e) {
        var t;
        await (null === (t = CO.replicant) || void 0 === t
          ? void 0
          : t.invoke.cheat_AddPoints({ points: e })),
          window.location.reload();
      }
      const F_ = {
        Taps: {
          "+100k": async () => {
            U_(1e5);
          },
          "+10k": async () => {
            U_(1e4);
          },
          "+1k": async () => {
            U_(1e3);
          },
          "+100": async () => {
            U_(100);
          },
          "-100": async () => {
            U_(-100);
          },
          "-1k": async () => {
            U_(-1e3);
          },
          "-10k": async () => {
            U_(-1e4);
          },
          "-100k": async () => {
            U_(-1e5);
          },
          before_silver: async () => {
            !(async function (e) {
              var t;
              await (null === (t = CO.replicant) || void 0 === t
                ? void 0
                : t.invoke.cheat_SetTaps({ taps: e })),
                window.location.reload();
            })(19999);
          },
        },
        Ads: {
          "Grant reward": async () => {
            var e;
            await (null === (e = CO.replicant) || void 0 === e
              ? void 0
              : e.invoke.grantAdReward()),
              window.location.reload();
          },
        },
        Bot: {
          "Send reengagement message": async () => {
            var e;
            await (null === (e = CO.replicant) || void 0 === e
              ? void 0
              : e.invoke.cheat_SendReengagementMessage()),
              window.location.reload();
          },
          "Send friend joined message": async () => {
            var e;
            await (null === (e = CO.replicant) || void 0 === e
              ? void 0
              : e.invoke.cheat_SendLevelUpMessage()),
              window.location.reload();
          },
        },
      };
      class B_ {
        get visible() {
          return this._visible;
        }
        get loading() {
          return this._loading;
        }
        get data() {
          return this._data;
        }
        constructor(e, t, n, r) {
          var s = this;
          (this.id = e),
            (this.app = t),
            (this.fetcher = n),
            (this.opts = r),
            (this.onUpdateListener = void 0),
            (this._visible = !1),
            (this._loading = !1),
            (this._data = void 0),
            (this.onUpdate = () => {
              this.onUpdateListener
                ? this.onUpdateListener()
                : console.warn(
                    "Component '".concat(
                      this.id,
                      "' onUpdate called. But no listeners set."
                    )
                  );
            }),
            (this.fetch = (e) => {
              this._loading ||
                ((this._loading = !0),
                this.fetcher(e)
                  .then((e) => {
                    this._data = e;
                  })
                  .catch(() => {})
                  .finally(() => {
                    var e;
                    (this._loading = !1),
                      this.onUpdate(),
                      (null === (e = this.opts) || void 0 === e
                        ? void 0
                        : e.onFetchComplete) && this.opts.onFetchComplete();
                  }),
                this.onUpdate());
            }),
            (this.show = function () {
              var e;
              let t =
                !(arguments.length > 0 && void 0 !== arguments[0]) ||
                arguments[0];
              var n;
              null !== (e = s.opts) &&
                void 0 !== e &&
                e.onOpen &&
                (null === (n = s.opts) || void 0 === n || n.onOpen());
              t && s.app.closeAllPages(), (s._visible = !0), s.onUpdate();
            }),
            (this.hide = () => {
              var e, t;
              null !== (e = this.opts) &&
                void 0 !== e &&
                e.onClose &&
                (null === (t = this.opts) || void 0 === t || t.onClose());
              (this._visible = !1), this.onUpdate();
            }),
            (this.attachEventListener = () => (e) => (
              (this.onUpdateListener = e),
              () => {
                this.onUpdateListener = void 0;
              }
            )),
            (this.setData = (e) => {
              (this._data = e), this.onUpdate();
            }),
            (this.rerender = () => {
              this.onUpdate();
            });
        }
      }
      const V_ =
          n.p + "static/media/qr_gemzcoin_local.042bbba98b28949cdc90.png",
        q_ = n.p + "static/media/qr_gemzcoin_dev.23fe8319de9917e07f68.png",
        H_ = n.p + "static/media/qr_gemzcoin_staging.fd5a23903aea93a43b08.png",
        W_ = n.p + "static/media/qr_gemzcoin.831381e2cfe40b9779b3.png";
      const K_ = n.p + "static/media/menu.1e7a560a8ebc79c9779181ae9253c1ba.svg";
      const z_ = n.p + "static/media/1.8bd7e56bde7a23abb97da2f78c745ad4.svg";
      const G_ =
        n.p +
        "static/media/btn_clicker_circle.40b7fbfb00ca2b4cccd21b44bc218f14.svg";
      const J_ =
        n.p +
        "static/media/btn_clicker_dark.e758574c643ee5dda5a6777f9395ab61.svg";
      const Q_ =
        n.p +
        "static/media/btn_clicker_light.2d98969e4496241443ede0b5c30ff23c.svg";
      const Y_ =
        n.p +
        "static/media/btn_clicker_transparent.1cff4bb63a775a9bb5a6ce9780c3f6f5.svg";
      const X_ =
        n.p + "static/media/button_x.68feca04fc94eaf23537eb7b062829ff.svg";
      const Z_ =
        n.p +
        "static/media/button_arrow_back.a073a6d4b3c933c742f243b0e8e8e04e.svg";
      const $_ =
        n.p +
        "static/media/button_arrow_right.43f5c01b0dede5e5e96a0a2e315d96d2.svg";
      const eE =
          n.p +
          "static/media/gem_dust_white.683e8ee0440c3938b9b7c9ea1a8be81f.svg",
        tE = n.p + "static/media/gem_bronze.4209adec90175b77948b.png",
        nE = n.p + "static/media/gem_silver.58baaa9ea95c67e161ed.png",
        rE = n.p + "static/media/gem_gold.eab20d32ededbf2060d1.png",
        sE = n.p + "static/media/gem_platinum.0660683cae0c6bc64e11.png",
        iE = n.p + "static/media/gem_diamond.ff3e11dbb5ddee22ad77.png",
        oE = n.p + "static/media/robot.1d0acc99005f0dce0030.png",
        aE = n.p + "static/media/battery.9b4fbc435052eb77fb2b.png",
        cE = n.p + "static/media/rocket.dcd96df3ca0bf9eacb84.png";
      const lE =
        n.p +
        "static/media/earn_astronaut.17d5d431a6c1b010ca500ddfc4c7350c.svg";
      const uE =
        n.p + "static/media/icon_check.7495328f3125c027ff475e89f7eb232e.svg";
      const dE =
          n.p + "static/media/icon_x.02a25c3953c005adf82f966838187fe7.svg",
        hE = n.p + "static/media/community.bb9db240c69c8b685a88.png",
        pE = n.p + "static/media/invite5.6f9cab5309254e803e7a.png",
        fE = n.p + "static/media/invite10.ba38f4cef354e49df786.png";
      const mE =
        n.p + "static/media/player.40895fdde5376b764cf723498717fae2.svg";
      const gE = n.p + "static/media/coin.aa85afa501ac070a0075acdbf447f128.svg";
      const vE =
        n.p + "static/media/finger_up.9c052c39fabf3a0cb6d2d8dc4914eb1d.svg";
      const yE = n.p + "static/media/copy.bd9d4b4ef963bb1836eb53485e16d5c1.svg";
      const bE =
        n.p + "static/media/copy_success.24f08815a51d495377955ff9396389ba.svg";
      const wE =
        n.p + "static/media/friends.700739e5bf239c4e2b8291f71b54b42f.svg";
      const SE =
        n.p + "static/media/booster.bdd6209136f839fb775a02e349a6f9ca.svg";
      const _E = n.p + "static/media/earn.ee118d0b9d66d615addaf7f2c6a40b56.svg";
      const EE =
        n.p + "static/media/leaderboard.f098f30d46cd34118bc0a839496cbccb.svg";
      const AE = n.p + "static/media/king.eb1786df2d41ee1448f4ea67ed747bde.svg";
      const TE =
        n.p + "static/media/astronauts.805ee12143ce7266358c74370f428a35.svg";
      const PE =
        n.p +
        "static/media/astronauts_create_team.6a2dcb77c2a4d2522ac1b8ca7d78c992.svg";
      const IE =
        n.p +
        "static/media/astronaut_outofenergy.fb3765c11a6ced00ee7d4913031b6647.svg";
      const CE =
        n.p +
        "static/media/astronaut_maintenance.6e2e1a9fd74ee2faaff82b15d6592657.svg";
      const kE =
        n.p +
        "static/media/telegram_premium.658c90e78a32be9d1db946285de7d362.svg";
      const OE =
        n.p + "static/media/energy_white.745dfc35d474c289d3f6511b8fa3ae8a.svg";
      const xE =
        n.p + "static/media/energy_yellow.d28e888efbd169d4a77cca8d99017150.svg";
      const NE =
        n.p + "static/media/silver_medal.b7734e0c0de57c820182930a4b0b2cc3.svg";
      const RE =
        n.p + "static/media/gold_medal.538d12c23cc3f11e19e0a18980434ce0.svg";
      const DE =
        n.p + "static/media/bronze_medal.3eb8f12bc83efeceb696bd947c256065.svg";
      const ME =
        n.p + "static/media/mock_portrait.35dbe54f5a888500010219c8b2011eac.svg";
      const jE = n.p + "static/media/char.18320aac20b0814137c17dcddaa34184.svg";
      const LE = n.p + "static/media/fire.c94ffbd05bd20d88b7380180125a5bd0.svg";
      const UE =
          n.p + "static/media/share.f4b580ea3a7807ff4657f0eee038ba05.svg",
        FE = {
          qrcode: { local: V_, dev: q_, staging: H_, prod: W_ },
          btn_clicker_circle: G_,
          btn_clicker_dark: J_,
          btn_clicker_light: Q_,
          btn_clicker_transparent: Y_,
          button_x: X_,
          button_arrow_back: Z_,
          button_arrow_right: $_,
          coin: gE,
          finger_up: vE,
          copy: yE,
          copy_success: bE,
          menu: K_,
          example: z_,
          friends: wE,
          booster: SE,
          earn: _E,
          leaderboard: EE,
          king: AE,
          astronauts: TE,
          astronauts_create_team: PE,
          astronaut_outofenergy: IE,
          astronaut_maintenance: CE,
          telegram_premium: kE,
          energy_white: OE,
          energy_yellow: xE,
          mock_portrait: ME,
          medal_silver: NE,
          medal_gold: RE,
          medal_bronze: DE,
          astronaut: { char: jE, fire: LE },
          gem_dust: eE,
          league: {
            [S_.Bronze]: tE,
            [S_.Silver]: nE,
            [S_.Gold]: rE,
            [S_.Platinum]: sE,
            [S_.Diamond]: iE,
          },
          boosters: {
            [E_.AutoTap]: oE,
            [E_.MultiTap]:
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACBaSURBVHgB7X15rKTXVee5935LrW/t3W27bZyQzjKRJ1GcjCckTmYYmElCZkZkFCFmmBnJESNmNGILSEDTIEAIBCGJDEYgQkAEErHFwB9IQAIEs4UsDgRiu41Nb+5+r99Sr6q+7d7LOefe+9VXr90Of1RV2nl9rM9fdW3v+87vnv2cWwC36KYiAQec7BmQF/7VbSfaqnWHAXHIVFZGdnClVOKJo//52atCgIUF0oEGZPPX105GqvNfVKv136P20vEoSjvIEaF1tWfy4bl8b/DRy5vjh1/yvzcGsCA6sICc/8X+em9p+eHW8trbk5XblIi7yI0IHEtQKEwG1eBysXP+qZ/Jt+V33/auSyNYAEk4gGQ/DCqKone1Vg5/XbJ+Sol0GTnRQiwSPNORAqguRL1jSXdt/UHZHv0naxezeA8kIE9vdY5Ilf63pL8WCWI+swEPQWc1+beMIO6vtaI0/V+ffs/KMiyADiQg41316qSVnoYIpYFt9g3sNlp0iaqs1Wm/4thh8yJYAB04QEj1dHrmtIpVDMb4J2/0brTwElkUxUuQi7tgAXTgAPnkuyCysbhTSNV49rmkZPKcELKdZeYULIAOnso6fjxWII7yY0sS8jwqy5PRWhpjVmEBdOAAuXxllBaZXbKkrqyeftGG/1nWbe7Mak3kmWjBAujAASIzHWE0nk4x/XmkxCIgBN5oLAwsgA4cIKpy8QQxmiXEPg+fGSd8j9a2qioNC6ADB0g7AovhBuJh8X/7JWO/lDgbg3hAp7OYnNaBA+ToHcLBQJJh9kuHD8aDLWETgioLjOh0zK1IfV6EEYhg+8Fq60YL30uPIbVmrS7hlg2ZBw0LKzh9aIjhN1r0+9QYpeCjW0Z9LjQuAXWWld60Q7ATjq63J5azitYqAbeM+jxoe8NKXQCZde9pPVeEHh6G1IolsapgAXTgAOknVqC2UtdbjueyJSEwFBZNSQ4LoAMHiE6tQsc3EqSz2LAHTdS0J9PgCMFK65aEzIOuXrYS2a2s3W83biAh4ByAqjQL4dXBi0OOglIKIvevL5JY9IGj97NuxSHzoF4PVZYwUQ3E88Yh/kSeVmRvScg8KIqwRmvpcKmT69MngXyzgz/Egnh14AApjI2RxdLWkbq5QTqrAZTEElV0C5C5kGphjCcoDnF5KufWNoJw0Xwg6odmMTb9IAICiirlhpKG16Xg7T7tFewIIqLNrWzvPEhpcnmp18dF6s8frYf0iet1WAQdPBsyshFG3YokxFAml9UWxXwNKdlPCIgF2YYF0JclIGfOgPzw14N6rteSbqQkOb4VSofWYBmUEiZJxmYuy5V5pRQw2FtMTT2CLwP6ozPQuv1Y798kkX2zkuKlZQWHzTqoJ7/KDnBtP1Ea8wk0zH/2lRvvfvpTWz8qoxikQTBMVSIoVah5eBse3F1Pgh1e0Wvbgw0IZ72//43qH+Efo0f+MrKvGJ/UD3zsY9flk/7+fa27WlL8n7gl/oeM4/UkiWUHQ3FwdVpkun5zWRbfWGX6788d+rGH9CV13mrM+Gp6rWK1ZVFlCbIldUq+eaaHQuBXxrAAuukAoXmNZ46mpy7+Ynpf9KJPv0QO9dH/8DVWR3Dp/GNvSD+5faX1V6//6Z0teu9vftPKSiupfjxJ5Nvbyz2ZtNsg4xSIe4KzHZbUkkRJ6OWj4avVYPg+dbX85apAw069CwiI9VIiSG3tNxNeZXFUGB1AQD51pnXq6RPq/7U6ydvjVnokTuK0vSyVUy9V1V0tsu7R8rOf/J7e9+3+6d4fH7one6tU6j+2+h2Z9vqgUgQkSjCOC43TwDaCJEXF6O9Gcbfdv/Y/dze16q3ZiYSwygp2JJiehj3BU9IWBwuQD3798l291fKXEIzXdFb6cUTMpeI3rXZKfxsdp0tFnA6H9+ti++FLL+49uGLg66JIplGSgEqI4SmQgeA2UQ8IcF+VZokhX2n1+F4y2smBVBZlcQkUZ9ibdgQmn/XPoTO2EF7N9Y88/l5I263+nRbK48bYJRUpU2Z2Y7hnL71snJ0XZ52v+Sf/f/nu5cPFL/TW0vsRDEg6PWYw5Sscc13tQiUVrXJYu628Z+Xy6OGNDdM5cpLibsnvkwrfH/kZD5YSwUwVVCLExwr/XLtP3ewZlGNgRru3GO9p6QZLxCRQ5z9vE1gAzQUQsgNX7u6+XNvoHVEreluc9o9gNoiWrjDajnpFvrEBvT949lerDx75/PZjHz6n37J+Au6PYoWqhVY5HooOBCOsdkoEanrdImAdOHHn+J7znxeiqtxKJyli8PDPIHJ+GoqvBh8r5q3EqDBKU4g7EkY71ntQkk+O+xKmRKQRMMpIvHAl5OLJ/ltxYT7UWe4cb/eXhfLqh27WmGrVVsVtZTZ65Xhn521PrHa/ZWcIb8EXFYXDpKLYL6WVTp/xn6MUB7MMM+cKX2t1MDiQBvKRdSucQGNACIymuhfuuQglBdUSXUecSigy/D7MqEsG3ANfiwxMHntC0BUsgGYOyJMPd18Bkf3BTr93ort6CKJWHxdty98w8tc4z0byeIa5R1ypHs5L3R/uOhVDaocOBgIlhVe8B8Spn9KrJwUluqvZMADiXCE+riPB42pCouqKY4gSkpiKU1QEvIoJ+NQBE94PbppKMEACI/wXqJcVC/gm9I5Ot/pLeI9dXJzoSkZdVg2Osehiyoz1edzqQn9t987VroW9kaE5DORJNJEMmvkLyQRmuFvJqPn4n2SA8rFgQJzRDuNoohHkgUse0mvKGf0olhAnhpnNTgCpuABkswE7SIiky1mMlzXT1Mnj/xcwCLD/XqVpxF4S2gOIOn6VK3cQk6M2qvgWrtQU3ckUTt1ZgfYhH4NCzKP7F83LE/wcvUYSIpTkl8dD6TwhKSdMFWGFh9lBv/LxOqQijyxyeIcUO/8dAkH7w7gzSSX7DKjalIwxIzB3OzJTQAZrnXW0A7dHsbMBxHQGQ3imCG+gyT6SR0TqCUt4cSIYEMG8wf8FY87UMLKs692YGTEpxkR6lod3BcZ6MJp/Lwx0EpgoESrygPjvcoA1K4Q+4ehjGH5K2M7JazB3OzJTQDbPy2W8yZTVQOTHi70unppuZcamvKIJEGrKyfPgY6rGvLg/iVAsEvwaSQgxtY14Vz58cCrRu7pTEuKBAc90VFtRQqCAlzJ8wDPqKUx7WFVdJyGpjWLRz9fmb0dmCkim25VSkVUYqMnIMdwv+8aK9cAIFzeohBgkYDhQbiE2V3qTsSH6li7wIyC7PcM42Hr4JtySgumFoOq4RKDaU3HiL41sVuwWRy1dobSrfUXRBoxX5EqnD3OmmQIy1kVFoYZil5UMMt3gBIBp5pItSJg5aSuCrPDuppSNGCJIhZo8JkAISJTCVodUDsJR+ULTVC2jAeKUPaF1olx4I4LdCdcWyIMCto7U0QFoi7F+YQGiyzJXSlVszOtoOaxU0WCOX/kyYkD6SwiMcjcvpqSjKS1elRGQuKpJCpOOAvRgoSzQKcjHYPNdn5MKdqBRMycDbXIEb8zg1ZfmWkX9HYQzvbfyIEPwttpZLg/BnGmmXsOxY6ORjJeHqJdXJiqgwVymZvOAY3i7FyFzdcPjDExqAghQz2uwB4BGPVXQSjWmQUqME3ZZvUSYyhVxx0frtBDo/QUCQQcCgimSKs/q0RBOvXtl6STDv994o27ctUiqa0XVEZgzzRSQFy8DJY1Gkwi3MdFa28uwYvGmyxFX7TAtwXzXaKF1mYEodpGpPWRqGyauL4FBUnANynwP35fj5xDMjsHgENXl9g7ysYBoPHAZX+Wk0vrkIjFWlwUeFEyOAfFxwGOQylJFbjZ7VpjkqvC68PtdrcT1/lIuLO3AbT46mVvDw0wB+QTeyhuzas8iU+14E78dE4RRjzsLwIbAi+oPeMPZFlTZHjIm44yrxlssMZ1Bz2F6BW3EHggZN5KLyFB8r8asYDkaYkA4RqnIONoebgto9ZDJyGzKh7Hn5hcFN8PRPCEylzK8Faq3bA9TLntOUlkCdO60qikcGDpzIPoSb+gDxm859ZEz6GmdhQLmRDMF5B1noTz3UL7bXt4ClY/Y8FKkLuP2xFDjzWvMQ1TZiBlc4aotxzlrFgcIrtA8r2MEbtfhegitVMtFpWyYQTFEVZUbKHIJG5exnJeUkPYKVGOCYwypHCBcqLL0OYO2xmm8AqP7PBPeYNP7tJeO0gPhpcrqSeQuuOvx5IkxkH/8wgAEyV67qHW7vwVpt42GmmKGXVYfnDjEg25Wo5ogIHSBZzzyUQWVEZyBzQ+NkDHOwJc5he9oF2LnPmOmGCi7a0piukJ3GWORJYATXwFeTQl+L/09yk9RrELuFAWRxFeSRLIfVVmyZORDksLL0EEpjjqUUdCTjEsjsSj8nidxWx49dlcPV9fe3DY0mykgtI7+YEck64MSFK5wEzk9Lj0YXGiimVYCBZlSMiAaM69oA3DVXtsUsH6yZKmg1V8VBlaOLkFv/Qhqvx6DFFp3rE9rcCxB3w0+lc5plcS7x4l/j6unsD1Bu2WqjG1EVaD6Q0ndO/95kJgE7awdxbiRYhI09MLlckQdv7DRX4KRSWGONFNA3vUqiN4pbHs8wIAtKjiJJzkaFn7lCVelYwOLKqdEpiMYg20Ju6jTh5hKz8eaMyejbSwmLSloLy9DsnwYROuw85qszzmxJyZhuvUznBteHJENDdN4YFQurUuNxKiiWmjvqmwb8sEODC58AXHEuKi7hNLQYXC52igdIFUu+sMt3YE50kwBeedbQPVK26Vq3BBvvr2EBaHYdXN4SNwqJ9VTkEoClo5nn0XJ6AtYRo9p94pFA43AjAT01iTHKYieM7iq65msYLpDJND+eMK/p35vOCbpG4GZ6DhdhgidApPtQrZzFUbXrrIkpz1cDGnqSwIcTLYqoXowR5opIMUQVGvVJBp1/NYlTLBjvJBial3uyxWS1iG3k4DbvKJgZ0fAvffiikX3d/OigqVcQzYie+PVDHpdohruKz41Y5v9/77RdFSQnH1ROaf0KUjtQCfpYEy0CaOtqzC8toELS0J3ZYmje3QYOr3+C0hC9CW0o0ehjeksmnaFp78Qw+q6hk6X6uG2rsYSD8aooq4iGFtYmLr3VQYOneygVJRw4WkLg2diyFEolg9XsIrubYRMEgrjE7hWJyUnoTbdgmyop/A/H63vp2bAWgPkA0Oalk5XIUZgltrL0B5eg/HWJmxf3ghv7WHMdBzmSDMFZGt7WX2FKhTZ0rWjGnLMT124SDEBqiHkYyu1nCIp8PldrGO00F+59z4DR25HtdGiVP0Qjp4cwWf+JmIpuoqq7PBde/haxxluirbtrvtjIuSiQqyiJqAYdh3qhCMbZEXlgNRldRmLZhbA1t/pNBq+t7WCEpvixzroULRhsHEN9jbHyXAIt8McabYqKxYUpyEDBfQTOlcw2JKwg4FbRsZ7JNhApi0L97xEw9E7YuiuLXOhiggrjbB+TMLRwwaeOi/h/HkFd2yOsYhFIFj+LLmrJlSzLNTNDWJfMDjJw7jUDTVPEHNF0ncVzCYQTKGOQp91NkpgcU1hArODdizpYQU0Pi+LbPi2D72t86F3fnR0EeZAMwXkX9+zXQrZzikeoDxTgozvrVo4Upq6CVBFimvaaTfFVATecOpaZp03Q8/HcPfpjH2iiygh1y6jc9Ab8IfJsDqbElIyAK4OL32lUbpuRdtIx3vXWEc5JOhuc08jSUftIOzPr/rcW0j3qBa/P0ZJXDnBV3X/K8zu93/u3qXvevnZ3WswY5opIGgDdf8uKIlBSTtxDLIhiytc6ptS576zhJsLIOQT3RAGBXO9ZQV3v7iElb6E4ZaCwTVUVTBAkGNXUQRRaycONo2cTpU0QRMuqItMAhX3beHflb6ULAVM1d5rajoBvpimqOeigzHRuirG2TdsPTN+BF98BGZMMwWk/zoMwkd23OoKXyb1N80dmtK1eIJXMz56J6LUSCiXEsM5Al82sK4MDK5auHxOwQoa/P5ayZKnlI9vlPAqK7SNWq/S6NC+JUuyVArO2GLuM8pcCZhLhrQVbyia7Sev0mq7orjxQqE96a72OsW4+rbPnIn/4pVn967ADGmmgLzqIuinjog9ZlIUTZJ8kZzcny+/CeWYwPtR8aqGkA9nUBQyO2kLjGUwXsGI/Zkn0N70EaRjGs8YPCbuPVNBp3VZAGOslxBSkU5KMXWOKRfMAsQFGAID82mSa/vBnkDDa57u6w32JWQFqNkubcuXtZaqV+MLvwczpJkCQq2h537G7jHDYcJ8F6GbCRhS+kIU1N4QnZuTZZRuidB9TtsWOgjEeGTgwgUFTz4lYXVNQx9t8xKGaN2e5m7G5lCt0YKHNKPUYFXRAR6piiVE5D7NEpwBticUWsgvklT30b6QvvQsVzBnej/czIAQ2UpcDTPgxhd3hAyepqiTjMFwEuM5V0IqSxjPKOG7PImp6DKjlKxgqiXPJDy7JeASxi/nLjCEbI+8eQIUDijp0JYn1WJMQN5+SMBLT2s4cqzw4cok7+Wauccu2AwNeZM7gYnKajgRTCwxEWZeXgYzppkDonO7Zbq21ucu8QdORUnfuhlWpveI+HWD6s0Yl5llZimulzsjjuXUZQvrWO/QvAmD4BagvMIUS2lhXBEQmI6h0oZ3sOiMpQ24tGXg8csAX/0agFMvLtiRkJgRpmKWSlBiKlKrY59K2BfBhxMf+jrbj0/fYf8IIvHA7LZumjkgmOG+RBUmBCMKLmdoapYcL2CanLra/VCNwRuVWoH2E0+hoEQNN/QY16HrKqGEojRo1AtYxqTj7kDCaCyhrAgY1w5EH+MD/xckZYyA7eUWfvuPAd6CInT63hxofEEkguMZaXwJt2b4flAmR+3BWe0zLvbQB35qBRXn9jbMiGYOCErEFW1shRceBW/KrfaIPS/XMZJwNZG8G2oppXQ4pUMsu7OZUz9kgOnmNdU4bL1KpaT6CBp29MJyBIRaSSsEhaJ/46WD1BUWBmGEKm6EScwOaqtBZuCxf0B3+is1xj/aq66G3bB+WOe6pGUwTrausbMnR+NyWnRO9KuZjinMozXyIl77GI8W+MIOz22QvqYYgJqak5avl5Petn70IGPJ0Sp22VXyhvxgZuhUFKJE3MiIG84Wt/r0OjeIYHlW+JSJYP5pBGmE6ZndXZSmIW1cJhEUjGY2NAarujbqYdSBSVyvkxy5LhTwmw1Y78WhxBTrJ/ZmurHZzAEpx8WG6SZjZOYq+EFK9kx8RpVbBsmAytBILfxziXsPSRRV+6jJAMEgtcLNCajzBfVTYdYxQhe2SrUbejK8zzEzlX0I6xQcKk2M8A30sQSwhsDs7UnY3MUUDqZvqBYTdgMQIRXd7Jbks+/zCrs9cFuQO7vrMuQIbw9amBCeIc0cENNVm3gfO3jBJ1wKg56duLvXG0+AuneL0hT0iFpM8X1GOUCEr0eIQnFwqSnY0y4AdPvqgq8Iuq+j1UsgVZi6iduuLtPHen0fpSVJNNSbKDd7wOqIvamujKvDmKqeVXTdKyXX6HEJXH7g7Gz3Ypw9IHm8VSl9GS/8NITGt6Ae6sY3cCtvKmXuUxRE3gsjYHgeBMEwfmSN0h8qLrmUy/OBPpjkrzA2bIbhy8S4mjuuIEaLm1Qcta06z40/AKGjxV1P6AcLUlFC6NMicayllXoC0FHAl5+AGdPMATl8dW9veKJzriqrB4zfbWdqoxA77bk4aqbA/SVFDjzetkf4XV2p6Zkkp1RsX2wUGtlChtd9lYvYK5eM9Dkt8ryi1PVYRZwTaywMPtNrcnJdJnSiOMngHi3aTZmkA1WermyFp/MwY5o5ICd/ArLP/bB5UlfKT7gasM0Q3Db0ci0xDYBCncIqP85muQ7CtQySEk2qLHbM8ZOzboIK+Pt4fZMXhKuYvLG6p4pAKp1EUepD1ANE3uW1fiakbu7z3kLdGlTyd1Z4LdQNo0s7KnLxtzBjmr3bi07O35yRf1vlZqyrql1v8BIMZPD5bVAbCqYbFULNG9xjKizRQ5oPxHSI5XwSMoiMv9fptWjwRyxLldWx71isDQtgcdl/pauT1zUBBlRP/r51U7kEAm0q4Iw4dcjkGPjmqK5IYsRVm+vHYcY0l4mgLBNPtQuzgTr8dtbjLWKm09E0eFnrbVqR7HZ6dSECIN7QgovKaYcrkFRXdx6b67uNJtsr1eTUFj8vIz9s415n54BH38jbTibZAhYpF3S6Rm3B0mG5sUIzIPRYFwREDmVG7UsIeGkf7y4XT8GMaT4jWoW6UIzNE1VhTpqqEKy6Iu0ZUI9KTYBhNRUMqvBVO6/KgkZj91gy08h95u0waDLX19AtTGwIMd5Kr868SnO5NOPG5aQvBdRdutYZ8KA+tfbS4dSU5h4uPLDsSZ32JcaxWS4+9urvhZk3zM0FkGSpm4Hefgx17evRuEcJrzI8qM+JbEL4qQjhVuNkcjYAIhqpcDlxSZVrRODBUZ76lLUaFLWZsrRXDILif8TW+GZp3l1cTjLNoaAFtv7ZCtre3QHoJIO9KrQZTk3l3NjnGvhgz5T2UZgDzXQ+JNAjcCkbj9WjZW4zahUlV5G3QvL7itiGB1P31dZdIgb218MnwzeRO6TfrYG6KXg4iIZLYx9gKi8FDmQhGgNCU7MnnoJdq6+NFg9db+6au3OUCj5yNuYkHZiu+dzuXjxzgw4wJ0DOnqX0VPmpPLMXy6xyfbw+6g4BFoT9RYyeeDm1t2MnBjcEcGGKSjQG/UPEH+bT+d8eFOmnecGPpDXaWZm8KqslwjdPGB5ZKJyaIiCyER7U3ehiD8SoxNzZr735/YOZ19OJ5gIIUbmTP11l8rNlTh3tkzTIREomKQmwpiExtiExRN41rcHwI2ihhiE8MPXA574Bn9qNDl8nfCAZvCl3Pab2pjwY2ZhHJaqC3FxUVeic5JjOR8F5ZrxbPSLm9LPecwPkgQ9AtrspHilGdlBkBa8y8lRMsCfWzV8EF7NWXyE6rr0wqJnoKEhMY9SN76SZi3oOmirPujNnbK3xhtvNnjAQbLxzvma+dmoIH3HVV2OO7INv/tn8SZgTzXUQHmvqf1qM7d+VY3NfmeauOMR1dtcpAt65YoMsnfGdWOfKXZ7vcp+kWUTjPQ03uanqamp4UXU4Msl9sUlnQXGS64BxNq/izvyKo3JSVdT2itLxRJ7pj8Icaa6AtEc7/6T73d8qcnOfGpVoczOXihdyEnIQMTCUOPdbYNDvF/ClVT5OabZ/gg8qGxIzlYYBCPULu+/Xc0KBqR5N8IElu+XsUVUekNIDgmCUbDfcUcif+9yonIsxDyRgzvTou1unVo/Ax6NI3NFejqDV60LabmNit8OFKt5kwG+XUSchZXPXBzkx5FOel4D6tz+CLQLjBkLrzKxzGExts0ztVJgwrkZzjXWaPwCCQFQ0oeUkIx8KOxqIz1eXon/7+l9x2wvOi+a+VcTPf6LafvCNyToKxuuQKYoz8KHZobbX0+tC7P+NWhaIxr66U+POvrxbe2Yhd2bqwBBs05tytoukwcUZpTtKD0hFUkHDp9Z16FMQOJTXxntw5g2/MPhzmDMtZFMuYcX7caG+Fu3Jv5Oy4OZr/s+gpCQ+I+xrHu4DoaHOOvVlvCqru9mD+gqJwFBirRrucwDCAxTAICBYRWkX9JVOVdEMo9bGS4cDgg6apB4OxIeubux9GBZAc5cQop/+w3L44JvU00qKr8Gb7ROjpLB1SlD4dhtXUxcQtsoIPyUhms3TYTOYetC8KS318PkkZR6ibl8/4aNOifhUOksK2RKOwt2R+TkhA385HsTf+dZfymfaoXgjWgggRA/dX13YSNUOerVvwhtOyOCKwEgm6w29YyhLRw2ZY7xoMp+TlLbhXZkpgw1NFUWvVR6EqqrPunCSUZUkGYZH1gkElAq3J6OF85hx+Oavev/gM2dhMbQwQM5+HMw3v04/FiVJjF7lK5FPLddO4w2u7+awPgap9y4xk1RKqAY2JQHMZAuNunpYF5WC91TW0kGxEGegi8rZClZTzl5QYZDG7GicDr9oB9fCd7wmHf2O+Ph8gsDnooUBQvTQx0H/1/vLR3tpolBS3kh1J2Nsveqtl4JJDSOAYGr1Vasp//yUHeGPBC+qqhOEXOVje1Hy5gJUqCIwXJnXSQSf2Yi77pXd3eiHrmyOPnD6PYv5ubxAc3d7b0Sf/t72t2Ia6rtxER9KOrRRMQ34SEjSiEusYc6cOuipcdvNvHv3mBushU8Yuu+zdaBnG0AUnEejc5kXtSdVVZa7UhiE0iUH6MxgCLu7O5Dvf9P7ht8DsDjJCLQQL+u56Nnx+OHjSecc1ih+oBiKl5O0JKXr6IgLakYoeCu+KC45ujc82xG5/iyl6izu9GihU1ehhGtKX+WjGgYFesGdLX0vV+UkQ+eu0U5FJkOsP7BxufMjAMOFg0H0JZMQIvKt/vzdrTsjJb8dmfGNuOqXKIses7TwxpPcME2bzNCMh+t8VJOdIaZSKsBqi8HwQV+d/iDviYx23gChDNPAAuMMCjzt5d5K9d5Dg+w9t/8kjOFLRF9SQAK992shfe3LOl+tUvud6A6/UijRDz11tPUWlzkiwQC5oNLtDhEKWXUixbruEjewY1kaNKkm16vgzgyIQIAESo2wRSmHo6H8TRSj99559+izL5/jxjL/EropAAn0+9/SObHah6+VwnwDgvJafKrNA5sYHKpQ6pAwtfloSPY2vF92vLjs7jP5PKBVCX6eJKIqJO3xWI3G8Puoqj6o9c7vvuMjsAc3Ad1UgASiX8dZWVu6e2VF32cLeIMR4rRQ5pgUYl1GtoeMj1wTpGWmh743BkC7DK9z3pwkkMNVaTlEYDbQtj+BQDxaaPkbX3jp9mfPnl3MD9f/S+mmBKRJf/0gdEZwaHlPZKudRKyjh3QC7cfxWJi1cSGOJEqsIDBtVHUp1swVSQF5uYPMZsMCrqUSnrVWnEcwnkRF9oyI1aUvvGhn52YDItBND8gXIYH2JzlF9n55LXp26H5scJBLs6muVX/3O5B/BBbzw/S36MuU/hlM/6R1WWKA4QAAAABJRU5ErkJggg==",
            [E_.RechargeSpeed]:
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAABY9SURBVHgB7V0JmBTlmf7+Orr6nJMZGO5LjQQhcigGYzCauLqbY5OYzUESFRQFxehgRCBLMHmemKxrEmNMMIeaeGwwjyZEDLIqQrIYjSgxyA06DDDM2dMzfVR3Hf++f1X3TM8IMQIzXT3Dq0V3VVd1d/1vfd/7HX/1MDqNHmj+BUXCpJzvN81tbAG1UD9DotPoAn+Q/GWcFmjMfJhsClMBcJqQLAQZxOkORaI7mUmb2Q30NhUACp2GS4ZMq8igm8miViyrqUA4bSECCi0DGQvIJA2uahNG5RUqEAa1hfBHqRwE3EoZWgFCiBhFsdwPMU9SgTBoLSSrGQthFbc5ZLh4lhK0lQqIQWkhfA0FQMIySoOMDNwUJ3FptpoW/VS9lVJUQAw6QhzLMOhOEHGTQ4aNjTJxm9HvlEb6PyowBp/L8tFyEHItrEMjSXa3SdQkWfQIWwUHVmAMGgvhT0PAExDwNATcZETVQaK0RRSzyGbSE622/Sp5AIPCQvhGuKkkBNyGZnCQMQxkDEUinswQV1ln0giurl5EcfIABjwhjoC3wE1x+gYI0ajST3T2MKKGDpw9t0zmeyxyQ3w7eQQDmhDHMlAKARmwDJARgIe+YDzR4RhRPEW2zPZlmP1T8hAGtoUIy7Ag4IIMv0o0fRxRArrRAEKwanN17a6M8SZ5CIwGILoE3IaAizP04bqb9j6imhFI/bZAyBPQdd/eRCJwedmC2H7yEAachThuKkGLXAHHBpRvaTLc1KjpRPVNRNEEzlqydB58rPS5j71NHsOAIsQR8CbHTa1wBFyBeUwaTTTxP6AZONXte539Mmpg96H4sIfYE09Y5DEMGEIcy7Ag4AYsQ5AhXNWkMUQT5uPJBKK9LxG1p4hrshlNVz7wvut31ZEHMSAI4UILj+YJuDir0eVEZ82DfsyGmwIZ++qcPTNayRuGFHqGMceheQ5Fn6nH1lCFbdKtkglC3LoU0TiI97SrcHafIDKQgP9tHZGOJLBU44fNMfeM/+K2ffQl8iSK2kKEZpRYtBB1qCUk1ECczQhYxpTPwDL+HTsg+T66nugIxFzTeFyp2n2wqez3XrUOgaK1kMOrKWjbtAyWscTp9PmwsbqEaCbICH4RKxHUql4k2rWZyNLILA0mo2bl9y9e9KInSiTHQ1ES4kRTNgTcphuxqlEI/w7BP+d+kij0FaxUYakneutxoma0N4JB0rWSl/ceHfN7+C/yMorTQmxHwEX4pBHqhBTBaZz7EaIyhLcE/RAdWGEdu0WY6yO7TDPq2qsfvvTatY3kcRQVIULAw6IHLgRc6EUASzkYmXw+yFiElYnujiZqhTt/i9xDJV6i8mYq27Cvo+opKgIUDSHCTdk5AReSjKIthfH1J55DVPFlcnIN53SiyDf+F3kHXJY/RGZYSTR2lDz4qXlrO6kIUBRRlhDwDNFyKZeBC82IIL49+yyi4VchC7mAnGqhmK0g+kx7XsCjBj2RQE9k49/2TVhPRQLPE1K/ZmSgfIhyp8phGUIzxARPDDSdiWLh8GtAxkXOZnKSkAb8/yRC3bgIc0kPqdGWRNlPvnLbrxNUJPC0yxIZeFxqWe63zfnMyFqG0I1xKKMPvxKvXkKu7xJ1Eh0G8hei/YiiJBAUtCnGw+t3H6wq2KS3E4FnCdm+ZmRFVGmrLTeTYroOOZYh3NQIRFEThWVcjg0l2b2FdeyDOT3pVnODYcqEtPjWHaO+9+kbf9dKRQRPuqwtcFPVatvCUpaqdSaxidDWLyYmDId2/xvI+Bi5ZPDsAsaS0I36HdhPJ+7PmE3pkvVXXDvzDSoyeI6QtatrgmODsRUVLLVCSnDN8UgBkDEEyd6Z/wrtFrkGyiNdvTVRM4F11P0BdXX0yX1pJIH20bdayn/A2CqbigyeclnCMiaEo3dWZpI3yjGQIbRa9DTKhyCigl5oKItQDfVsdCLMTa4latrvBFoc5MUyFU9ta/R7YlrPe4WXLISND3euqNBT8+U27pbQReU2UAbLOBeR1WexMorcr5yrDcI6LHilQ8/haO5cXik50hhNVj60ePEf01SE8ISFCAEfEozVVidjy1g7uWMuwwo0hFXnIQsvnYsN51DP60eQgkpIDAl460HnTCxNNtoS1Q8l64y/U5Gi4BYi3FSV1r5oSCZR65Ah4ExMEMXCSSBDWAYspMdXFTsgVbS2IOd4Gau2Q4hOkYYdDWc9MmPBVoOKFAW1ECHg44Ox5ZV6otbRDDHOYtwZko1psIgRgowPEjm19XzAOjg6gK0Ic5NtzlnYqsSbWyseu+zz6zwz6e1EUDBChGWcEYl+qyKZXCS1c83ZKDRDQlh13tlEYz8FYlDBdUoiOc1g2QXRVAb1qiboh+w0cCnJg7tMQ3uEihyFIoRNDEdXlKdS86Qod+/PcL4JBv+csURnfBR7zMF6KP+Q7COEnO8hanseVd2UexysSuq0n2fRxo6mB6uGJZz7n3BsotdbZJFI9NqcW3H2T7iPuY14CBqMJ1XOApLshNEhjXV1HMOGhOed1NkZp0ik06AjlGKrhD89wYGhfoYQ8OpwtHZIKrGMIWLN3ixDzsh+APWpKcg1FJRFnMSPZXfoFebG70begV6Tne5+KUUpnmYGF+phokcrhsQg6tGstXu9He9+neW2cOrZ4MVa3iFc3EiC55yJPfH+zOTc3Z9z7pNMLvE/yHPt6+gE0a8WUr9lZCAcbVsYSeu1DhligBzNwNcYORJkINdQ/oW6SyK9yQABHNl4y8ZuMnKDpyJ9ZMhCxBlZ3HV/CnUPem6x847J94T2MfYROaeZty2T3Wb1eg+cA1cJVNELzLLvo5NAvxFyGAIe6GhbXqKnaiWRZ4iTEoNm4TRGgYzZ0Avl09gwlHqOVA5i2xF4hzWQkOZ3xodydhGSIwbPn33MDW7+IOcTRHn75S9mdsnWLR0yMr2Oy35FkGHZmvxH2bJuYlef3P3t/UKIsIxQR/O3IonMIqkVZJjZTxZkDEfmPRuWERRZeDV1k5B/+YvnOCizDUL+ck+XQ9RzXaJu7c9FbfkEiM89Fkm5fXP3UOXeR7i9NHVbSv4i9gkxw5aVh9KSujL01WQDnST6nBCnhB5vWRFIZuY7ZIgTFCciBqO8EmSch5O6AitjqKdm8He+U/JNaEVbt3XkG1C+y+ltCUQ9yctP9u28dSu7Li4UCYuK4WHCBDJiqnzeZ+EABethyIiirDZ15buha0+ejNzX6zPUry+pKJP02lBHZhnDODomn/vE0gqiS5CFD7saK+8n198c66vlLnVconwvHkQSLirquVvJ7V7HsOx75T/mRKIr0el1bP5nCVNABcDEZ73WRLQbzS4j4RLCcayN95QtsoOZdluV71f2mN9AVHXKiph9ZiF8CwWSHclF/rhVy8Rv6gjLcMYEJy3DwV+E9utQYRl4fAcZPd4p+4h92Jm4asdTt//IH8jeYMdYZ8d5PZ8gXOg2Ksev/RnNLsP9vlKg+2v4OFkhI54m7d5gRv/OqSRDoE8IObyWgnoHLQ/EzVpYhub44NwFqiAH/BCKhKPQ16DZ5LZfc2DHecw9F1e3Su9u2Mc7/ljPc+viCyL0MzYR7XgalpFxt/GcWHCnJ2OUstZoKvyfzb6an0+eu+OE843j4ZQTIizDiNG3lQQtRG1Ko+x5OWC4ymdCuM+Gq3LIEC/kTyQ81kDz47zeOyT+RySKkEumbnfV27qExYEME7nNjseI9uI7iRzQsLPfHfsEGWWq1Po2Xas9vLnqdzMe6Jt62SklhIukagN9Q9FpHusgrSsxy16A/Ez0Yc9Bb0MRLzyZOypPxmVi2byMdSUB+eqcq8nnK3W+xxA1LzVvXcYeYbzXRCwfoHem7TnLiOFhA9GeR9HrQlnGwHbTzuqGOIyRXq40N+nawk4zvKGvyMh9o1MC/hxVkpgzlaSlTulB/EBFLpHKjhmPIGBXfThH26nQOh8uAhkxjs4FzN3ohrmu+x+6/TzD4b32Y7nXxXiKrH3yLFLG3EVujpNDLtQDGebjsIzfYml330xYhpm9TEBGotT31wONZUumXLVzM/UxTomF8Gdx6VnOT1Xc0pVE5YjILQCLGvhAo3vwxJgIMoRHERf2sYKjHI71/HjeLGc04gcCSquJV8yhd9bFxE4I/biwDLipPSKSwnbLyuYlIDLCKB7wvbKrofSWmVfvfImuoj7HSfdD+F9Q51DoWxjnpbAOzSEknV2EYed7nPyos3cCR8fZ3vuY/NflvEXqtYjXA0GU8S8iFrmQ3PlDOQgy4JosiPfenxG9Ec9GgXmaUc54Ihx4MaaXzT3vml1b+usWhpOykI61NMRK0ndlneaCDJ9DhljyiXi3wMnK7p+DTO8krzfyLaS3teTIz+CNzp1BVPUJrIykntkg3JSF0HbXr+GmYtn8wu4Ky3k5s1uk0JPphLJs1Gd37qV+xEkREhlKZ9gZ+jC3SIee64SyNA+7EuHeZ8bdRJd3F1PzBo6xfJIU55F1XeG8+znLT1PyCHLe18Z/KVJRffV3abyBg0aAhDGoHEuTqVvoxQ7CNa0nOvArkNHqujUh3pb75laJZLRJ2rNvHgrfdPGiHUepn3FyGvIMvSxdTtMSJgWTGY4ANsiDDPUE2Z252cNr63GWvyGZdodWTLlKyW5oFQzmHaA7g+0imF3E+6R72kxzQ0Vpta/jXj83L+kqCFZBvGd8HNZ2KTk37jgQZCC7t34DvcDyenb+nLAMUSoB6XaZnIrJgQfW7a745tW3bGunAuCURVmFwMqVK6Ubxv/omip/9EeSzv0OGT4wN+dyeKmrya0C5FxVJx6Qfe/7Psho664cCCGXGZkROd5MgfsOxn3fmTVXxL6FQVHf9PnxIb95f4k/fruU4n5Xh3A6U6fAXaH969yekCMDwmZvJHr750SvoI7D5W43hadmqdR+JB363psNyj1XLN5X0OlDRUvIU9+fUza6cttKfzozkbJdQpoEEs7+JOwepHQ1RpAQ2Ugf9v2S6NUjbnHQCTjgJRFy8zIldqC95Hqejj1zxeKWgs/lKlpCJlfUfbacd17Bcr2KSpTyJyO8VS6iLsFxOoxbiQ6CjNfqsV/WMgRPKBJmwr4jrengirPm7kfXq3/C2ndDUdyw0xsb7502a5jSuFRJWAEnCVWQY8z5EFEFhNxpcgnoWctAR3UzIlddclu7ooSDeCxV4tu3s7nyqhGfeftB8ggZAkVnIa+unq7WaHV3BPXUOLfzCL8zdSIiK3F7grjHUIwt3BRHM6vuF0RbQYatdJdvNGYnA+rf324N33rutTtfII+hqCxk9XXXqX459tVh1PYJKY1sTmjBOJTyp4hS/ixy6zCiu/ca0aEfE/1pNyJduTtJhSElwtpLjfHQ/MnX7PccGQJFZSEXTHthxnjt0FKpw87mG+g6nvcRtFTETBXRVxGa8TrRWyiHvAQLMVTKTeKxQ8xsV/0vNTT65+4on34YmSF5EUVDyH8t+XKo2r/ua4GUPsG54n2oSM5CSb1EkCGquBnXTTWI0PZNVzNyHUpUbNuZtvatBvnrMxYfOOhVMgSKgpA1Kyf5zhv74oIqq/1TTq2M42vPnAR39Tlykz/Rb/8rLANkbIKFGJrrokRQFZb1Tl/g4b2Hta/PWly4hO+fRVEQMqLaN7WSWm+UErbPKXNMGIF8A66KppM7tRTCfegBaMY26LnP7algsSNSIsa0hzt1tqIYyBDwvKivv+eyijOC9UvDyaQbVUVKEOJ+GKnGZeSotJjJ2IDQdj0sJC46W1K2FMKMo6b/ezvi4aVjvnQwSkUCz1vIhJL9C8ozsUuc/oofCd/F0I2ImOGIVjDfjtD2J0hM/gIJEa1H1bkFzowoTY1p7a6j6er7Liyye0U8bSHr75kzsUZquFnRzVKyIAhTxqOkLkR8DJY6okZk4JtBRlyYjur84KURUWIxrq1KdWj3F+ONO561kNd+MXv4aHn7f4c6EkPJxHVz1nCi80GGjIxc3I5wEAL+LFIJ3XZ/KMAnkx5U9x1K+msfOVj/9KpTPF+qv+BJC1lz5ZVypXXkM2WZ9sudomEFdOMCCLgyG2RADhpgGZv+BAEXZOCaUlXKhNTdR1Pqktcj9euKlQwBT1rI2Dl7p1UpjUvkDlMlFfnG7DMhGZeLKSToSD1MtO45ZOCIriQZpRAfGWHfngYj9IVx19YhzPJOXepE4DkL2Xzvh6omBg6vCiRSox3rOH8sJOOjGOZSonq0Xdc96/5cuOh9+1We0AKbm1P+z439ah0SkOImQ8BrhLARwcNzS8zoJU4VdwRKI1NnQh8g5s1PwU09TxRLuTfIBBSQEdzSnNIWj5x32Nu/2/ce4ClCdv1k0sUj+ZGvyXHTR0OgGx+dAX0AIYfWEa19kqg16ZIRlI2kGnj8wIHyT4+/fuCQIeAZQtbcMzIwVGlc7tPTI0lG1DTj/RBzVHCb0NPYtAGhreFOEdKYmZSCj8cyoTumrtrfRAMM3vglB9SqKkLR68vM6EecebUzxyLMnUbUtpPombVEHRnn0rE1lkpQ4FdvtQVrp97WUDQ/SvZe4AlChg5r+2CJ1HYLxaHJE5BvTJ8KzUBF9jmEtrEuMjp1Uu+ykr77p97WOCDJECi4y3r1rumlATmxxJfOjKLSMKxjAtoayDU2/ZmopdMlI8B0Q5G/3dlR/sPyW9oLMl+qv1BQC9l770St2r//5qAZ/xhBx+lS5BsKhPvpV2AhuvPtTJ/UZGbkOwI3Gr90bjUb4CiYhYhpoGFFnxWi5AJmyiqdU0MURoK9GW3XFkEGsy2/3BzPaDccso1HaZCgYBby1g/HVdeEWpbKycxwGjOM6ByEuRt2ER1NuX8fKiDvSujB28oXdzxDgwgFsRBhHdXBtpu1TOJCKkEGPikCzTjgkuETDT91a9pQr3utuWMDDTIUZG5v/Q/GTakJ1m+UM6yCLhxN9DbSif2dzk2VuqxujdvKgiGNyddZERcJTxT9Tkj0vpoxAS32c01PX0pnVKIuFUdrI+mQkZL9T8ZN9fbqRR37aJCiX13WxpVzFFmNf8FnpOZQJbp/nSDjYFJMXktlFN+zJpUtABme+jN2/Y1+I0TcvzN56PbZIZ68mUmyQhZKIUdAhp9ZIOPRqKV+pWRBQwsNgIrtyaDfCKn/0aiaiBL/pmTbw4hDGtp04j5YBik/aE5otw+7IT7g6lIngn4Je9dcSXK5Epvn4+kL3duNufgrzUmLyXd3xoy7R91uFMWfkugP9Ashl11ScllQil/PdHyeuKVPYe0WKbccbjD+Z9wqZ+rbaWTR54Rs/3FVOCB3rpAydo37iazOsNndWpPxCMgw6TR6oE8JEbWqKqV5sWrpFzg34Gp0yDD4zdom/jR7gjz3Z0+9gD4V9Rq1+aIIiy9Eb5zbEttpcbrKt4jWnibj+OgzQuq+M7pcUdK3SoY1wpbZLtvmN6nX0/Ne/qOOXkCfuCzhqoYEmm7UKDPHkJStqZT5+dJbadBm3+8FfWIhFYHOczVZn2dy+eWErs0/TcY/j1Ney2q7q7zUP1T/mWrb5Uldu6F0ENelTgSn3ELsss4ZVoa3xKOB+afJeO845Rrii5t/62DqnhFL2uvpNN4z/h+kMlTQCc6gvQAAAABJRU5ErkJggg==",
            [E_.RechargeLimit]: aE,
            [A_.Rocketman]: cE,
            [A_.FullEnergy]: aE,
          },
          earn_astronaut: lE,
          earn_check: uE,
          earn_x: dE,
          earn_community: hE,
          earn_inviteBonus:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACZVSURBVHgB7XwJsGRXed5/7tZ7v+63zy6NhMQiIQebxcSSQ2FwCBgwWGCDiQNU4QBlcKowroCpkWI7xBAbUAKxwQm7AS2AAAOp2JSG3RZaENJIaEGzv5m39t5915PvP+fc2/fNgkbSDEKu/qfu9PJu3+V859++/z+XaCITmchEJjKRiUxkIhOZyEQmMpGJTGQiE5nIRCYykYlMZCITmchEJjKRiUxkIhN5uGLTz7lISeIqIov+DYm9e+lfvIiHs/NXr6HC+Vat6trSHrR64aUjaourKaGzKHIPOffPlBZHSfgkR9JltmfNAZOqRVZCIu5bQhz342hJJuJIYrv73V6lZZdWgwv/gAIhSNLjXM4YkHs+4j21Uii82nGs50Z+Uh8Ng6PtVviVeJDc8Mw/owfpLMiP99CsnPNeX64VXuOVvAu9gluwXYeEZREGm2ScUAKVicJYJlE0iKN4leLk/iiI9wV+/L1hMPzhyhrd+5yrKaLHqZwRIIc/Ub2y0qy+1yuVFvGxgIGg0A9o2Bn6nfXhXZ12/D6nH3/5l/6C2mdyvD17yLqSyAkbVJbL5A49EsWyNzMz6/zX+mztBcWpZsEpTZHtlnCF1viHkpURSpBElGCTkU9JHOBjIOMgGAx7o5YMgu/5QXR90Iu/e+tNw6OvuI5iehzJTwWE7fehzzRe0pyuf6RQn5rVu2OWxhHFYUgRQBn1h9RZG/Raq6O/C4Lkfz37KroDszk54TjWze+leRG7W2wKdydkXYQ9dsSh3JVIKuNQYn5bsbmws/nE8vSc51a3kXDrOJ2DTRog1JHMJZvvJBQhCaE5Ad72KI4GJIMhBYP+qN/u3Tbs+5+MeoPrn/AWWqHHifxUQI5+rvm79Znp9xYbM4uWcNXuUsZ6i0MMgE9x4Ctt8XsDGnT8EczJPuz1Y4DQk0lSxtCdL0hMS0ELliXqtkV2AhTCICZ/GNNoSOQVLTrvSfNUmVsgt3YewKicfDFSnuKyhcGH/xZrgKIRNKZD8ahN4ahLw1bvqD8Y3TAchJ/tt4c/vOyPqE/nUH7wBnLj86g+XaUeJoJPD1NOCQgcq7V0QfXi+pa5fyhNb91qOVXsyQGZnplShtps8M0nAbRlRFGAWRoySLHaAAY2qcZKSv0+jvlvCQYqpmAYUq+DzxjHxV01Wti9hYoNgFGcpU0DzluqDSddLgMiNCDqTwyMZbSmT0mwQbHfwfngbvqjI4Pu4LZ+d/TlaJD8c78dLGHnwS9eRcOzEQx89z9RSZadpycieVWpLJ5crthLToG+aIvKV3e/YaNzpuc4JSDta+sXUnXqY7Utu/+1cBvYyzO2XNLYXGAkEwASjzA5h8aWYyCSWJk0/QrzFkUKhDiMoBUhBiek0SCgQTekTouoOefR9otmqb7lfLLL242ZsvTAqvMYMGSgBlprQ2rCLD1R1IbfWXbulqT6nQzauIYuLhf+JvQxEQasze1Rf7Q86PsHEKDcglnxrVkv3jv/ZurRI5Cvvp22VwX9l1rDelFt2purTJWpUC6Q41oRAo7v9AeDP97xO51/OpNjnQSIvJa8VmnrX9Xmt73JrmwXZBX0AIn8rDXAQAswDRUwEqDIxMcGYOJY2fVEaUyIV4CB96EfYkAQDHR9aq3hfSDogqc0qLkN2jF9Mdx82WiiMIBH5tgDc/xAf298iVDXBSBsRGIC14lrFRZPHteAmh4Hv4362TETBkpNIAYpoHAwwjUN7u33+jf2/fhTl7wp+JGgnz6jWSP8El1Q9qyXCEu8oTHj7Kw2y1SqlcirlskplMj2amThesLB+vH28aVXzL1s5VsPpSnOiV8cjyuX16u1V1rFKQ2G5eQAEWNAeKZasf4egyh4S1w1eIICNYclRwUYBJHAccQWxZY+ThSxDyFqQDsqjSq55aYBwzLDoCMpint46WEwBwAWgxrH2ZwQZsAxGEhPcG5rhA1A2GVcDo5lFUlrEDarBNx4iKFhyIVtdf2kNQjX500FVJrpX1QbdN7SXV3/zfs+2P3YvkFyY6cXHFwg3AzkSJlcKH2xZnnzOOEv4Vae0/TcZ3tl5/xSxXMK1QIhCiW3WCSnCCC8Oq4DgQmuySvMLkzZ3nuO3hgjuFw/RGcKyD3/e7ZWqHpvLtSaM8Kqmm+NWdgkxnbzluBvlgEJN88TgP/xq8AdWDbPSondkNeJSOUSMOlqPOa31ag4NY2xm9fnUZsxUfABMmxhBvfVTI4QPHBkJxQItjq3ZdvYeMCRNlqR2pRZg3kSbk2Dokyg0GY3u25HAaM+GvdjuQHZxUHBqzYuLNaW/rS70nmzWKM71rrRUoJT1myr6ZasHa7n7CxWijMlAOACAKdQQHiODQ7D8vRkEDaCErswnmAYP2/qvGc0R6O3PvjR+p+c/9r9ozMCZKoaX16sVp8nnIpQIJgb1xgYE5BKasvVV8aGq89sPjiZw6BjwCTPXoAiWFfxm9EgpCGsx/zWMtVmp8mtbNUzWl28VGZFIkqisI0IrqtNXhRQ0B9QZ71P3Y1ABQwWQGDgiyXWsgKVpyqYoTw4RXU+iwCeVdSDw5rDt8r3lJo8Ye4pvSW1Lw9shapWQRSrG1sqM60to85ARlEs4A/I9VxogIcN+xXKMElVUgGPjd8q056OlzWezJYJOqgId7zltbPbD30PH254SEAe/CgVHcf+bbdcqWo7zAMkzEU7Y80wuYiObvhjYi4gBS79jd54FieJDk/ZqbfXYB5qBZrf1aRCHWB4Tb0v+yN23Owr4ISTkM0UTB+0DEkfdVZ7tLEyoCoGv9aoKIDDIOJQm44fGFCx3KXmfI1KAMYtwn67AMSB1sDvCDVgFW1+lcQGnIQ2JZ587QDFQv7rIimtegUqVHoiRjCgtcgjx8OxC3W8byggMg1MAUjHKY3+pMwSWrswNe1U2287dC19dccraHgqQDJb9NbfqjylVq//kVetNy2lbp4yBVkUQwb5TTeQaoo0M89ERcxcqOiI/xwpkxWOQHwt96ndimn3UxBVLWwhp7LDAK8jNlLOu4M4oau0QkVqiNKG7T6tL3VpZkuNZrbNUKnOfqdIxSprWZ2mFxvYL8E+bXUe5X/UeSN9bOlr/4HvBInc/ZjtRO0nW814C9rleAwC/EKBHXUN/mGWRGFWm0MrtQxWbhLmJm06Nvwe9yIw4RzP3U6jePVpQevm6/ad7OAzDfGE88uOZ29ROQNfON9EYgCRzmYglEg10JmDT0NR5Ud4f5gNNlsqKEDoC9/RbUfUnMXMa1bVLCOOyniiqGgqUJEUh9Eq+ol1AsoRUGu5R1NzZWosTpNXrqoAIvVhwgzkQqUOcPrUWlqGaRtQgPC6WPahLSOciwfVV7beYm1xitr5s5lRQyDGoXZmzvi1qPyVbUf6e74Xth7ZxBQ5ACjThAyIJDT5k45GVf4G7SxO1X/v+b89+026bvXW0wIC0vByMBwlyTlEPFQnZV9AbG54N0uMzVR6cmlmopqFaThqQFR2G44cjlbAbMWhTgqrUy4+OwqMJFjXiaa5YM5ftGYkSjuUqYLf4NM2FmHiqlPKeaZaK3KDwcdAREKV6Sa1ji/T2oEjKsQuVgIwAQCk6JvZPsKYFnEcX9t+ZXaKeqDTSSdyAQaH0LZrBj45GYRsLFIw0nEJNSAmSFH0juQ8LcK5xVMTr/QGJOBvOpEtV4DcuYc8HOuZHBkloEQEZqglTaxvG9WTOafFMzozS/FYY9KZYaIyHjB27hZmmO1yRCQxSBE4MAyK0zM3pn+nQFCmK1HvI0RUg1affCSRs9saVKxPw2Q0zcClpmKcBKbhve3ENLNrmqozi3Ts3h+DZ+siSQMwZXbGcMqsKQVsAMaBxggEARbnL3bJ+AOXxskpZVF+eotjbs34Tjk2SWpM0lxJxias1qZXTXSZJsyxVSg7v3Xw4tqnJHW/k895FCCF7TQfS7ktSbjkwBGRCr1xuo4+CbEJC8fOPb2g/KzI7HCqJVrFhSwoUL1SkcpVj9ZXfGrM93XI6rpaQ4zzU68MBpy/P0Sy1hvS1GyFytOzCDHnlJnRgKT+LDUVuREz11aol2jbpXVE/Q/SxuFDSEoHAMZDThDhWkKAi+jNQ6jLm8PXONSay+AIz2hgaprsMUDSyiHE5zccmtEMaZJPBkJrhuH+DCiJVIDwtdfLXuFVh6/t3kI5B69GGFHmTrsqCgk4KGEHepD4AHYITQFIOAHbW5lepDIz45tXNl3aY3XP7KutTAKKSohW6tRc6NHa8hodO9ihrUjUCuWS3g8DytFUEmoezB8Fytxw1tvYupXc6lYit7l55lJuYEROQ4WZsXhxEAbPPYF9yyIdvut2RGp9mLCQCgGStWJMbgFOFtrCE8NBBGU5rvIZlvIV/N7RG6X0TN5v5CcA6XBd+QxtltT4KRJWv/L9yURPYsTR/OK6Bedl/rL7N4g/f5gCokbx9b9mP6PecF8pMi5Iz1SV4rHWUJI7WaApDKWaCAdTe6lmijTXqpNEPZsdlUGzH3FdQS4AXzo0QrgaAKjYUClDGrSH1GsP1HsmImugSxtbtoH93aFDYxX5GUAsm/KhdWbzN32n74UnkFuqUX1+Ae9j6q51FLHJs1RxbWGsKB7+HIdM4+tQm7k5tvs6OgvV/UvjM4UyR6EBIfUXvt5HgWFeWSMSrR3qNTakK5+XcylBFT+U68+61P/2dXt13cbmMVz5vnx6qVp8KQ9aijpfLEdcfPJEGvtuZoFCXwFkzA2HdAoEPVsyZ2toFQUKNMVGXF+suFSrJjTohbR2bIBEz1fggISD6bCQ5EErFuAD5rdqMJypnN84kcLJScocnMi7mfc2IqsKNKXabFB3dUNpiyI+4zhjqGMDDMXGvMRRVm7QmhAb8xjlfERak4mysoR6rwY+fTVmKmXAx0w4yIxkbtZJvnbNV+J1bbKuwpgXqRT5obqZRPFCQlESgi8YILGjVJ9tQ1nkbly9h+3V4NlqFmrLZWnnzxGKsjDsQJFoNZs0V1ug6Z0byL5bqsjFN2s7DpQAVESRQ+IG9p1SHFSmDSfxoKfg6PK+JA1fpchh41J5ZgdddMUctY4epP137KPusT7MF/Loko0IDBQHsnGniPcuby5xCdnxHMwJD+EvJpYD02bl/Uvq/+IsMJFJnEWKPC6JImGlAiF/efxSKLq7R0Xr1/H2PjVxrrqJaP836CmFgnipTiv0DznRSjL10uqtVC6MtMZEkaLb9cnizLSpPCRL2nMOMeXDlG2uAB9ETeVpKtRmsXFhahGJ4jwi0TncdF1rheXQOImj0wOi3ibjO81HfFk4TpkmsWku1WdpbtcWDHJM7fURwmvWUi4VREZjEsNaa2uhI7n0fLkKpsnEOezOQFFASA1GnEap6ZzR7zOiwxKOjGS1esnoE3v3munzzbfTrzdmrK97FYc5fIwDk3VaSzSBB7fGGsLNBvy9yUmYT1J/d2z1amNGCccQbewMOSqyPR3np7lJ5piFmcHpQJ7A/5BFpxeZ+52Z/un3+q4pYw6ysu9pBETkcOMwHfjRj+nog21yLORKmA9uwcLsdaA9rgqXC+DMCiUmEF3l/C3HURNOpBwcSVOI0xNYgcSmKpEGt8Qk0mTAktq0M7/XH3WijeCCbb/fXVXT9sqn0UoQyZdTnMykWoF6N3KBRCV0rC2xKjZpxNPZw6863JPj2SfGTLDKQ4QJgcke2/9NTtje7Igti06rERkjkAdCbAaC8nlCikfep+QjJqlMoltqgpKZo4XtRfi2Ea0eR42EiQplJbQfSAdS0f3ZtdAYiLRskGmNGfTs+/T8ZPKzMcuAHb1BMPr8B26MjihAPv3P5L/iMjqE0P+p0NiZOJJwH2MAklgaEDQYrNL8HaOfyITS+oQGg5RfUSc0fkZkg0+UzfxNJOQYxFNLfpAfwpfIcdir8RJjIJQJzNV30tmtrpfp9DrNLFapVJSoaPqmxIy/xyZgMVGkbYnM7GzWys3mUjtu/VmkeGy6V6HA5LwrGQafet+XogMZufjpm+neH15K3xqB/hkNxS4EHNwNYsqwRisMGABMaU7qpNLjW5Zl0LeyyFeYHURKd6dJZD4S+2kmJU/QbZLT/Cb/tciXePlW3Zw/O4GZVbu7qspXm6kAmILi4lqriAL7DIr2qSoFIGNuyDhrDmjyk0lKc9lGU05zeXy8YOgz+AmF0V++/yvxSgbI1diuvZWOv/wK+gcw33v7I0yOSOyIQlGOYyFUAU9tbMa01qgLk0Y7HHNTpuojROrUSV84J4kp3bAJBLFpUMwd5V5S/ujEItkpfEO+dmPlzaGd04y8hoqT36sCGMqDxToIzQrIUEeVDdZXUXIeJVmIL2U6Gcd5G8nN5ksaGkhjJHPWDBMaAcQI5nHQ7st+2z9Qn4re/d+/QOFJvb3XfZ+i62+jQy+6jP4fQLgXUekFUoqtfFwoBzYMK2/KUum6iLCNgzcmSxi7LhUw+hSWGWSRH0T11qacPp88wJu0KccCZBpzmnwkrUBmvNeJ+4oTvsr/jtRvLEc3KzTnXJixhPrIl7qdxCTDiZl4IvMXMhk7duXc4zgzW+krWxx/4ONYA+qt9am3Ed4d+8meJ7yFbjOjcWq58XaKPn873f2a59NnO2vUjRPxDByvwAFEZLg0mXAeAo7YksaBayCEMIOfOjShP+h7T8Z2VP0tlzNkjQnp705nlvLOXJxi25ytZ0ldViJIDzQORjZpSw44nlBcD6nUHZpdgBnDcZaXQO2MTBOGTEw2PjbvSZR23MQqGJKwJhxSD/tgI8Bebxzvh+1V//ZOK7kKwcPbnvWn9IP0fA/Z/f7Z71Dw1Gn6PmpB9+FcFwkpFtTwGr/JYFhC5sZufDMyu7f83+Px2Gf75rRAHfQMfIvRxrGcaKmNlqK+IkHzc5+WmgxZ3V6Of7NJQ3PfKxsTKpqIzZSFZLFcc5XT77Yi6vdMzpHL1aJQ136iMGUAIoAXMDUkN46P2qsr0W3DnnwXKhx/cUWZ9u76882Vw5O6Tk4lV99E0R6i6y96FT3QT+SHS1L8q8TR1ocjDhu0OmfzaZSl6ufGzo4xwc1xrodilwQaPGssY1W0DRbj/CMlKvOM7inFRA2bWk2JMk1gp9k+SKsP3k2liodkcIq8+iKSzxld8UtL1HntynxVHjRhomdLdZU0F+oKiEMPoAK6oUEo+aB+vFDla5ad5mqkTNWoF4fdbnRDv0fXBUP67gs/RMdOd0dnvD5kL479+R/R0ssvoa+OYvF03MZOMi4hNV0i1YScxmho0lui9CdmcksTBJhZa/6e+Y5T+ZVTySZtMW9M+MvX1V3t0vEHl2Eu1ijsr4BcbWHAQG6C1hH5soHYHLZqR62b9BSpqvitUN0RN7vYIqQOAOl1dcAT+VyqRsAEcNik8Wu/Ex3qtpM/uPzPac8nv0d3/93NP70Z72Ev2AEonZdcSndCK38B2rEti01UuCsz582SZvTaRAnKt3xq4MaJpMjnJ/rX5rNFZyZ5p0+U5iDCQcl4bp6m5mvIvAWFCDN7Gx0Uv8DlJR0AFiqWQRGgqclU+KT5jAGEWWCpK5pMShJJk6NFAARagFI+fw02CREsNrziu3jYp//xnDJ96Oq9Z7aO5hGtoPriHbR0+420T0biJbjnssmTlAlQttaS4yCGzZdIw2OtKVorDIgy1SyRc+z5AX4IX3IqyaIlU+qF32Lqv1RDbWR+i+oFYzPTPrZM/dUVsCfrKGFHOo+ydFN5Vg01pdhEdVBqWp2dNZmIKVGrABJqtU0UGulXBmQwoNt6bXrbJdec2TINljPyIae4X3YP3/34q+U7Aku8G4BMZ1ZDzfpxaTdLmGTK4VBmYtTfHA2SpZojzCSyTFObTJFOB5jGDliOQT+JHqGcCeP9VC1lSl0TlxNK3gwVm1sp6i9TZ+kQtVE0ax1vUXX6IOom81SY2qpKugykotZlWnIYJ8PqTOw/wfuVq2BtN4h6A53+WKH6cy8J5fte+Qk6Sg9DHvEaw6uvJrriibQPXOQU8o+nEafB2bVqUDQtZQbfGmcgJ46dllRT8m1HKRDpAOd5LJnb8iRi3rHnNEvVVDzS7bG26gHmrLw01aDKVFF18reOd2jt6BpFI/gY2dedkAoUX/uORBecKNFZO1MeoY/vkCgPh/BVfZ0OcKoRBPITKDpfc+EduhX1TOVRLfr8v/so+o2L6RZcgIeh/GUyvlvRKKTNVz7BVn4kk3HuIgy1kvmTfPdHPinchOCJABCNGeCc9qRg5fmrHJ3CHJZTbFIZwNQarmJ/D9y9Rkf2r1PY2yArGeDXOt+QiTZVqgnD1538UaSLT0zEtlrctwx3I+VHKKQ9V36GWvQw5VGvwv3SPho+dwd9E7WbhUSKS/mY6VjYqu1XZq5BgWT6gBUI6cwXJvayKANHSVpxzBhTcbI7SVnXrKKXNmBI2kTRZ5/FWAPViTQLzSbKKTWgMWVUNEO1COmBewe0stRHZIbAiLvlWUPCWPFPXAZWYEQ68WNfOBjKDlzTB6oBveN3r1MdIg9bzsqy6K/dT/GvXUK3Ih25GHb/iZaZ4KoPWujMnWPzlIpXDdKSMmee1xJt7jQXpc0Xf2dmOFmb/UU6yKq7o4dgqKU6H3UHvtEemaPh9eFpDG46IewMfMutkVcuUq2Gukg5pOPIyg8fBBC+XrrAvca81iWOdJlCX4KmRhxH3l6u01t/428evmakctbWqX/tTuo+94n0j6jvPAHc14XCxLF2yvOlJ7StHNErcoEAZZR9mrNoE5YraJl9xy05IOn8VRqt3kcbB+6ltYP7aePIURq2kWvEMDcSwFimkkk5jRFys3nLJYBKUS3u4SpTqSpophmT54S0/0CskkCL+9akqQjyNaR4q6hLrgYxffYT36IuPUI5qw8OeMaVNCqt0fdxkReCgNzNJelazaZ6A9W2sqvumymFcSara/L8XoOhkdLLoHVOIbIZbIpXaYNcOtO5+wWhmoMiEzdRcGN361iLjvxkg/qIRW0xwOarJj1SvzyxBznXeZktEmJnHurkz4GDdBE2I3Rqt2NQ8QJVRWk4PKIxM8EOXR4tOPTpD3/jka3EYjmrgHBN+O/vpNaLn0Q/8Dx65s6d9o6dF03R9LYmVRpl1ajG3M6oF6hwkTc9Iy0dT9l2BkAKkNhUUXRpc6JoqeUGdmmavEqDyo1FmlrcRg0kgRbB/h/p0NGfdGjU6VCBOxUt7oSXWmOk6TI07Uy6rcdXEZVaccXrU3i5nkw0X4f9bQC4vKITeJgncgzLneZTKNbdgp9+6sN7KaRHKOfk0Rqv+1V64uK8eN228xC7LDYxWBVyCp7q4HA9m4YAZASnyDVryxr7EGW6jLaQicj0/4YUFKl5EWO7ryQXaQlS6zZq01OoZfCqLp+Wj47o+KGO6l50bV8tIuLuGL14dbR54+UQqgvfB0kYmHBXh7i6PSim9ZbWZM/VFIoxVxESxWue9iewEI9CHlFi+FCCi3wBzNUOB/rLjQ+aM+JsEupeiDGTi+CWOlSuRMrBx1yJ48YxbgqIRJZMao5R1x9Ua2bs6vZUXqKW9uJuouDTnATHYlDmL1AN2rPblujIfct05MEuHT3Qox0XtlA/b1ABmbvternyuPYlKtcwTW6qATzW9Q1WTvCTNABuHeTerOC4eOl5kpeqfDSx6VraNDsevpwTQFB/Oc9XRJt+wAAvdFEG1zhSnvxMLwQ+99m6OvtNizy8MTAqKmCLz9oRZCVRoTpdPFgvBqVKQq0llDnfkstNeClZeYYa20pUrJSocXSZDt7bQa0aCeCxIe26sEf1uSbykOJ4Epg2niwBxIXykm/OM1SIi0OjFEHtjnJRXVzvA6USfX7Dob9+8btgJx+lnBtAYK47XUGd9RESrh7h+mFGXJVAhdy3OwjJByvKWzGIlQNP2LbzTFS5hFCFICW8PIETL5MVK7al4KpVUk6xgxleBxasgcxBpb7G3JYJEiynSKXmFlosVahcP05H7l+nowd5JfA67do9otntNWTrVdMISON2T2hHYJq+uQtfgWLWuc5Myz87vkyfgwXsTPeoc/mHH7nfyMs5AQRhercHGmF1OaZCqaOqZR5KodwQ4I9UUR9MKPcjReQ6QA91BNTtmYxTla9yFfxQvQAyEIEANIhnKFfaVjGrez1JjaZNM1t4cCs47kCtbrK8ijKNavWTcHI+RofJ3DTtFKrUWBBqvUitsUaH7u/TPXf1qXncp90XDeF3KsrPMSBqXf0wzBq/fbwPWOtDLmFTiGj6J//+k2fnoTt5OSeAwPfex3Z2bYPzDl5a0EGByFXOmrtVem1U2wY6B+n3Qhr5kWq3aTQsmt9WoNoMgIBGRYjINo711YqrmR1bqDo7pKWfrNHSwSEdPbRBM3M9mt9eUo3ZhcpQ5Q6Wa5qy1XpCU+/IMnJu6itQuTlDW8tlqs9s0PLBDTpywKfbvt+mWRxvepZbSIXiqhLTmxYGXOMAGJFIKfZ9IqDb6RzIOYmy/u2TqW4L8SKY++I4/8KgwzzxM066HeQKLV03GA617Z6fs2hxZ0lV4yqNKThczphLKgpjk1GdnVGmqlzlvMZC2EmqE2TtOGZv31d1DfY4Vq5mr3OONO/Q7/X6DV2P4VW7VRCLUzgeO/G1VdTLj8cwT2YbskZLaAb8HTSDKXUA4gOcd3p30Tc/vv/sPiuM5ZwA8vzLqAui9OmuLS7kXmndoaI7VfjpDVw7YA2CJaAKfHKzSbT9/Co1tyJfac6SV51VCyxt+AZeQxONhhQOhgCIG55tchG9Vac8mp5DRo3EbdAJaeXoSC1p4GKSbSeKR9OS1jUi3YO8aZGRVC2hRVxEreFQpRSpSt+RJaKNlgjAlgQAw+WIVxWeQrmKSfSuF/5P+sj5rz37YLCcE0C+fif1f/OpdBey5udhQJsq7kn0TfXhJzC2araBMqJ6nWh23qbF81CjAOPqFhtgyLnhukx6XYqvFoGuHFrDgI+ou9anYX+kwuVitahWWDXmylSB5nBus7Y0pNZKH2PvI/yOTYJJlHao6yUUGhTVM2UW0ViG3uf17Uyng0o/HETyjeARb4MLux1pyxfw6/cEq/TlS15x7p7BdU4AYfnSnXT8ZZfQnRiHS/ixTByYQt1DOPM2/OTd+C6oYSwrCMEasy6KQ1W15s/idn/1mA2h6thJ0AMQPbrz1jb1Wr7quFedHMPQrLLSCz0rjYpaUFoooDbRD5Clq+d4qUU3DjTGsnU4rFcxxVnvlDQLaTj648VCzCJEIVMyFCHwu+Z3PkY33PBS+sab3kff/twtdPi6fef2gWjnxKkbkf/hs/SP/+e19FIUay6HL9+BmtUarNQdsBKy6MpPey5nuzqlC2DD2BwJtfYQ2iEKKmMOAzjwgz01g7ftKKjl0QWYGDY1fm9EG0traklasVxQOQp3qs8sIMwtB9RpRXTgHoS4SEIXdwD9eTh/qCVrV9pzy3kGr2fsrfeoD5PnDxOlUaUixY5NvqpZ/gwfGXguAVHyuo/SIbx85torybryWpXvyWtfT6+yLbHLUU9UQiQTJWq2i7QpQtHgBfiOLrVRxVs5MqAd53k0sw3VveYU2UUOcREWT8ERWUu0dN9hJMy2MmmFkoCWWOTBzyxs99SDbvhRUEsHuqBPujQ1jSiuWVB/V12EQ34qno/AIdLRFJw3KxBKBt+Kpmk//YzlnANiRKpnHxrqCaH+HGafaxZkcYlNLfQXthg3PmAnfirD4Qc6oChiRF9TVJnhteoLqMTqZ3jZcRcADekn92yoJHT3xRWaXqypJDRUaxcHqrGtCc0IBhHoDpRpV8BtLY0UB6VSFKbwdVKuvtALgeW9cHEfePHVjz7zfrjyswJkk2DMDyL6GsHClBgQXucXoCRqmcoWd/xxVLZ8tE/HED1t3YoIaAphcKUJHKY068tZuc0PgAEtUrBp7mKPFncvkFebhunzFHFYGfaou7xKLuxPZQZJ4baYtgyH1IV52lju0/pyINfX5T04fQnX08B8aAGXm8FUv/0F7//ZawfLYwIIxvoHGLGbQTZeYWak6qYPkNHzrGWKJBjG/v77/Q1o0gIzI2mvlKoGikgleUyz8MpZz01oegsvj5tWj+xQHZMY2UK5Sn5loDStiChMeAW1+okfNcsrgG2KbxsNkt8/tEJhHVE3tGRDlOgAwHjEFb9HK48JIC/5EB2+/o20xwvo+qQgZtTzGANdo0j0cge/vZ58dDRMtsw0xYttTF1F8MGn2ByaqqVxWgt81Ls9+IxiHTUQt2hKummKYPHDXmiw0eKn+ij+S60h5ARj4N/n9+TbnvdXdIv4OXoA82NlsngAbvr7N8tnI0f842okrnA8ud2x4whh6P5uT35wo03fcxzxjUJRP2CBGwtG3Q55SaieicUHiX2EtsstvcaRIwRF06frMSLN1iK8W13q83O6WsWSM4IjP9bvjL449IO//YV30hF6J/1cyWNjsoy88IN077ffTn/oR3InFOMCOHlm5e+7qUQPXNKm54ApaTBzzxrCEVEAYlL5HDdUiPKTgtZWRiAbvazvNmuoU09P4MwbPqMdHx62e7/nlt2OSMLVFmKFn9enXz+mgLD8yntUQ8BdZsvki2+EUeJl4a4uk8axZmADpjtCW1H5PYzs8lKInEGAexooItFSBSepEj6mXIadAX4o+XHo36Czw5CfU3nMATmtJHQUtewV5Cvzemmi1N2C/HyDSK8O7q0PfzAYJKV+N3xKf6OrTJQLQpKB4Qc8DzswVZ3RCqqRX6bHifzcAjJl00HYlK9jsr8GUZhIl4UlxkeMeqMB6JO/hOn6xUE3fnJ3rSeYxfX8QOUy/EjaETgvgHU3CovnhCo/F3LOuKxHKx+/mYJXX0L/JG25CzniLte1vHRFQ+SHLfBa/+2yW+SHf1ylg/Dfv2rJZIF9SMQh80Bn3/0Nf3XQTf7zs/ZMADkr8qlbqPfaX6GbKJK3JpEchGF8DKXc24Ne+NexTP528f3k/8d/R61Rj+6Da3ky+JMafEeCustgNIjvAVv7jq9J+iK3J9HjRAQ9jsT0cZ9ycL/wh9RArekCD0VH5H5dVPTufua7aY0mMpGJTGQiE5nIRCYykYlMZCITmchEJvIvRf4/pexDkV1/WNsAAAAASUVORK5CYII=",
          earn_invite5: pE,
          earn_invite10: fE,
          earn_invite100:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAACLgSURBVHgB7X15mFzVdee5y1tr70WtFQkhSyAjSyAWs1kCY8Y2m50BAiZj7BA7X+KZODOeeOzMeGQ5M8nEX/jmj2DHicmCF4jBwRgDwiyS2CVMG7RvLbUkt9RqdasX9VpV772b331V1aqqbqmqWi0QuM+nUnW9eu8u55x7lt+57xXRFE3RFE3RFE3RFE3RFE0+MZqiCdHTC8gyesz55KmVStHiQKlHMlGv+ZZ2GqLToPeNQBTmsn4eWbIn4fQEgWju7+9eTRTQJFPrvHn23r726ynw7+F+cKUIaDon4llGnT4Xj09vML+xpHWwo3hc+p2Ff1am94VAno9RfcDFdZjyCqZoaRCoWBAEP1AOPfDJbjpOk0RrptM8Y1j8L+mrz9iBclwcs8FBCIRG8DpOrN+J2l+5qGPo+4Vr1jZYiyKCZS7vGGmtpg9J72H6ZTQ6jfjQneDJZ81scIFJZGJCUmsZ7MZfMs9Y8kaj+fXLOgeP0GlQaJ66jN8Vw/6fuNlgaYyR1IIw8t/r/vTfTCkbwlmiVmIM68nT33me/7uMGy6Wx9erWSXvSYGsw7i9hFxJavjLpqeudRRFIuAEBDI6oSFiVq/n3R5LuA/j46hAwBHOajBlP0smk1bn0B9KP/vnbkDxJMv1w4tPghPRLcZtY50Zsx+m9UMh4zc1UaRvSK2grGe0LFhgUktLulJ/75pAVmFONxOJngTNMSxz6YqjmZ9XYpS2x2ttOse3xZ/JjPf5qCI3ioscvESZ7kVDHjFmMDVdX6e1c02S5r0undsPGcnvzGpvr+h8N8IUDvr937b94LNJpaTuR6oTg1GMpSHeHmHIfcIyX7Kj/MlUS/cbOM3X8+tNi9siQXCFPxJ43kjXFbjkxUqr5B0XyCsNDbGewcG4Y2SuOUbqStjjZcGQf+6eeclW2t/79smuWwczsLZZXgaz8Jd2xv9IXBGLsNwEQkdYmCYjFSiWYZx1JWPu9824/aq27ppBNjM+rrBqBuzeh4hOHQ2tm0f28DH5547v35MgJSKseFWwAB+OCNf5mWHJp8iy9jROsw7R7LYM20u+PuODOMkmVecqxTOKYuT7H6aV9ArlTdnJ6B0VyIY6ig+ke75t82CF8Gi2rVTUCjXZpyNHB+7fMi3yx0uODm4e71rWLK8QKvj7qB9cEMdnWx8r0TU2wk25A4I4KEz5JhfmJsNteLFua0u/1sp1MXOR4Xn3SsWmZT0nQTR86FRj5b3ik5byv4iVIRwqNVFK8hY7Ff2GmUg8l9hysDfU+r2l19+O19uKHJg3oVcvV8qiKugdE8jzEWpKZ/jqiB/8PgRhaDtssZwH1irVE/jLuWQrMPYt5ct6HUyN8PzvxX21KEZFq0KTIp+Z8tdWxPmHrKleNQbttobZc0fopmafre4dNYEW8653ssEHVUAG80cuRwc7TmY+1tWb55sj2a8lAhV1qTQUhRlMW8n4N00KnktuOdhzsvlurKOIlVUXcz1FNNA/PLKsZXMdmus+ZdR3xgWiTcU1MUoxYveDITdDNQ2tKlrjChou8IoyNmRwdaz8+pcTlPID/pWYFyyOlw1Y+1Juy5etuuj/b2jtfQqHAkYDirq6iJpL27EVzY5ALhA+k4KcfLfeeOMVWe/LbqAuclSpMNBfwFxjLbnmhuSujpMKQ1NWURLXX8SD3DgFsdQ015PUTackTmeYrqunRUKxf4xl1W1JRVaBE+UJkBS8w2X2nnKt9ZhY4frq9worY5S0UxW8W0SjDzbUnbdGL7STafyqcJ7qUjhkbjAKBAsFMe65V0dpkeOp/xRRGFJxd9q0CtEWqY9+66VdHQepAhlZihqK4jw/VscQe7plXcVA4owKZG3SWKrS9E8RT90IYZCVH5wqewXQIm7wFtNS7cXX69VhZYP/EvFV0ii/hviAGXf+itnW09TcfEpHuTJFixE8XKkni77ESNo///XZs83y894EH13Gv4DVERnbH8uIqPmTQPBtd+Ss7CkJwuSSlK/nG2jRMzbsSfnu5CFaI69K0MUsm/3HiEdLEmHEcXLy9JI2zU2+KXqL28AyutkJ1GVO+TQUIk7HeFVE3Mcb93Z0VgolHY8ulQGSahVqYOAY8uAFdtuYEHswai5w/Mzt9lhTBW2Sb8qI+9OGXV0DVIHWga8Q3C0qHTSEA0NjQ8PZ85fIQVHp2kkXyDNxqoN2fUFm6L/HfGpIVugkHDBnw5ZtvNa4vXOkcPxjLk0XWfpTJGPR8hyDOD/kRK2/3bq3c/+1VWS/WApMR3Msp6kj0hC7qIUyxedoJgryvugENNtQpeNDvjFipiLf87LOlmqy7cCmWSob/EeuSOSVQF817Yjqhxs7dbg9aSZrFfKEl1yaYXr0F2aWvpmoQhiUG6jihtxpCXsb5U2B5l3A6UrbpwvNsdqK1SFftJ3gjWvp1DG9ppei1AiTcX0hgPAQxma8MFsvYayI0kI7CG6wy9eNYgGz5K/tqPPi7La2EaqCpCQXqyxWMFB6/FAqkfaCiuyYNIFc9QYtQ2TxEzDxj+phHqoSBumwiKW5bT6fstuPFJi0PkkJM6C7sDqM8gEiB2i3ItEfRVsGjlXRPFSUrmQ+3TDaHwILz/NmriqbO5z9p0yfPmCMHV+3EbEeTG1vP1wtYovVaMBEi+IOEPp6ToxVhGxOWyCPwCL8Mkq3QbN+nPLpmkZ4v2iYCFF+vZ/8pfTwhNhhRa1/Y9tPmBAjoCsRn14/ambyryBgI0bU+YE01evV4lHQzEugJPUy34Y2f4Jx+5slqQwx9HmhoxWgpD/yzJj1MG+kx1kVq/FEp4S4AHhjoa0gBNAGM1kY4Qo0YYHoSWjYO+XSvTBT90U9WhgPQu04wfCcze7mltykxhMI4/2Y8L/yQbGtuF0roHOw5F1e2pY2VW+ZCefR1L6eqiB13RZMnlOI7vLFCbQUjBSf81qElmIV3SSobIxSHOYx67GmzQOdVAOpLF0BIUwfHTuF0uSAfSqWOyYkEI3zvGDBLmfpu1aW7kt6dA4iKRoTRwYUyIj1lG/wA2PUWa8iy3idu8YjjZ2dg4XD6x2aRVkEBao87WADlms93GB2ba2l2ANGJ3jp2b5p8uNUMI+NhKiavmx7FCsOHnSomuW8B6Znf7X9FQi410sWZ78q5n467S8aydL5la6tWSAv2DTX76C/RqXsRwhpb0dc52h/MWp789oMBvbLuP3wgGTdfYPZa8vb8bVqOua6AdnQXpiwCmN3uhsh6tLyiN0T7Liv1I5i01aJYEob0ejyAjvzEVOaKd6X/0hiiObDVH1EJ6zFNgznDVkJ66csFu+jGmlAUmuWVKaghHrlIXJz4KdSla6tSSB/r30fpy86WfqjVEDTIAzm5u3yqE8gNiwc6wWrPvY/Uw3u1wYGRuZwX8V4me/w9ZwNsW3B3S2jdvWVBCUw8JvQphBl5wvbfFm5RhfVQHGPXMlEv9DrZLQtJQYywx8ozB0mbTn81RxRbmoFb4/axhMaPKQaCW1O8xRLwf+N9otjAKFZxYSyJoEsdKgp6tOt9XBYelWMFmpCO8mGRMT8qXNO8o747IY7mzqO3//mke40C9SycoCO5YRxGKHkHlp9whwYXuiAL7GK8wDtXDkbiqai35u1v3cT1UBXjNB+26TvB0yNWkw4ajudYRd3L6iL6IBE+nQz/JVRElrr4MoxNggn0larudIErncyrl7GREebZYxlgEYMVrq2psQwBiwIDrdPx+qFniB1D5D3MbPO/Ts3yh+K7+vZx6gn1AQUIi5A9DK9PLHDNYNGzP5XxbKHRs3VcjLe2E43W/mMevRcXRg15e6sY9Rsy7VV3JzxLwAuxYU6UWrlnKeRSaNYQUsR91wlyxyc4vyocMVT8e1tE6rHj2BlgkdL/SA0wTnilAaUMrlY1vIR+o3L6fPCYI8JwY+CsVnhGL+0Z0c/55038O3EvuN7WBHOg8n+HvIJp7iNUOOlaDNd+Uzjrq7+wvGXd9ASrJBPWKrMlqMiZyWcf56xo/0w1Uhr9CKWHFrOjlLRhCVTIzqJ0UxDf9FiPEM7c+7IVyOu9XJNoW4RIedYDi58qCQP4WwAPrCiP6pphYQamqbd8Nm3D57rNvb55gLbYAfr9na3sf2l2vtEjBrkCH3aCMLy6Sj5AOnMuPkjCHJj8fmGT5dDeI2izFwxS7wlI+wptFExhi+nTxBlNmWDIIt2C3BI2CYXPcfbuiIwVzqAcFlZdEWmuaNu0OqmCdC6CE0H0rsawo7ykj5Zl2E5fVRhE8yEsKwwKQv3Hp3Yf1RMq9AuQuGViF7qSiptGiZxUExKuGuKQbpVYYxOd0N4iVLhaRRY7mR9ZgdNgJ5PUTwxQJ91i0Lo3KLjXcDqU1CA840x5hSncDZIkUhFB1xOOr55UdGlCBIWaaikcFxbRGnJ7U1po79SG2cEfr/SRtSSpa9A63lxpg0m+EBNm4/1Uknd4zqLzsMkLjbKEkc9EV+yY32JRM2rI0xzhujDZgEsLLwAYQDT6FAZZOaIhsoRBY66jOnamyjRUvMmuzU6lYTw0W5glCTA5DtR5wW6oq1iyH5GBIJI6RbXp+XFiWLIfYMfdhLWC4uu7RoqOs5Qxr0KS9wRZecLk7e6rrEFAqmZOc9GqQHI0Z9BKebwojaZ4MdMix/Ed5foglVpeVYrgOiMR9IbUXGs2X+YEVrEFb8ZQrGL56EMftSIWZvYozS5YW81hFDSQRg5GkoWK+CIr9yjx9MWPXpidTzbRK7w6UpRnLxRPmUQYp8Y9l5ZXqEANR7Bjqc0OFlQijykRNwULUMjqhdwyoVClaE50GR8vzl+PD48kXAX5doFWBnLYBVYcZ+E+ksmS0eraoMmmRpsugyh6yXlWyx0TUFaRnN9Y/SQdhoFivZRA5Kmi8qdGXIPAIn22oBH+2tlztbcDsYF0Ig6WRS0AbnNSNvccGwkbWCFnFs+eXw/bKFeztrahqlGCnEzYFgyHVxUstIhZORcuwcoWlUIPakCeUQn1B59HHY7XuLMSZcM5Vt1dfaqGbJzI1t9AqnF6piBSGdu+fmIzY6bDt/Y1NFR827yfTGKG0zcxhWbVnw8YJRF1LbJH8kkoQTJsmQQnGMj3OLbaAL0MgpqMLsrdAWqJIzW5QVL7FrQ0lIV5DOpApkboySE8VGDSkNdvfECucSP6+ucreVYFM67ELY8VQ6DKkP8Jm6isjcBSmWoTqX9q5mv6kcTWArDqz5pG7vhyGdyvdGluD/9nxBHIch2mgCZGTofOc3sMZuvODA9KXZVu8onVSDBEF0GG7q0ZKsOXj6SIh6x36bNY7UdwvhgObKrl4+SrHUANfYJ2vLrEerOs8L61IlxIIQ+mIhY7fAdc/EqTVh1v5yGMo5Zs7nSBLD0XsxjermQA8Y7I4a1p9p2Jk0gj4Rbj+hjMAVmibbrenTMepqbzr5y5obXKFpQXvnXuYCulRx0OituTi4nnQMhn1nh6PfyZg2+3xkaPo5JN/BSyxJ+b5hij/IHKuJNJRdhhi9GgDIEdLMs292kFcuw5DZhnnqXZDFNmkAaHZqBQX0k3JZfdFwJ1mPEjJ807Dgw5paA+bAu8B/zx5RpgXUBntmxfH7tN9ysMGgpxnF1eSkW/sHjUu6i1Pwh9Kf9RynzdIQl+c6Zu/t7qAb6BaJKPkJfwoqMG2PnMWK4cn1H0FQxISzQpAnEytAyMGJuWYSBIMn6qUnmG+OZnqwZQiX1Y20567Ki9oZq4vZiWge/gLr4H8NszhgzMcG6HZu9xZqbs6jlOOU+y0Nm7SnlUI0mMpYkE2j2jHCvcdHxMMS25aZEwnqxWoeuafJ8iEJ0RaVQCeyqyih1uN4+Nm4dA7a+gY9TaPRDhRW123KLVmLF3WmVBRVhlIfQUxrm7vAAo/G2iTE/UI3bFtcGJzlDCBACWjjOKs8IV64d6WE1QfiTIpDNMD3IPT5llLWna/vHhrKf394TuXrczjV0MZ5A4OTTQVAzzmZnaXGUyB27c4QyTl30ofqMeSB/iJWvED1wz/PnzTLnuVQlaf8R+DQfA50+JsyX7FA0GXuqoavyxrrycZwW6UH1CroVWjmznIPSEAeaGmL/Y5Ynfz3etTrc5flb0IoJgjSZ8qNUA+kNF1gdN+iws2x1KCDLzZbjPknt7eGqgyKMwcbCbaYewuVMOk5V0vNE5yqf/lrv4S0xVwhKuGs+z2LutlqjxNPeudhMVA+86HeMsWZCBahFWNx/Odk3vqPEOQk+dt+1Zg5qfMqgGgjB6vk6Ox8n4x/QUV6deehoUe1+jDkMi1ccvl9VvhFWK+E6kxYzj24HPHNOuWVAgasTyrgu+fb+mgtcp71CECNeDJtzlVE6YEJFrj8+I/H/ZiX6TxphwLmOuV0vHBSjYYmqHlVJcOZJQIE/whjOGeM7pNziRoyfFyekjFPfeGoLFLiHowZPFUgXvlAUvhdBzDdg30oLXLodR75S12i8Vu3esWI6LYGAERIcvQEeMlUe1HuM9XM7aK1ll4imMIHTELijDlY6FzkHf0rSVZj1fwZj5o5x5oAtjJj55PCwXXJ/E5jZq8pMib5uYNhbcvho31WV+kVxhqHeszZFNGRSUTk736eTjDxmDycnVMM5LYFACB+CifiUNU5CJB25pTtGbTQBGvaC2cd6vHMrnbdSg7cefRb9fyumwb2i78IyBPAzkbKemJn3HQWSgnQ5uGQFakYIpRoHh9N3naw/rQAvEM2aDQWAlt2HFRkpY2AgIuZL0ab4WrZ/f1X7gMvpdH3IH4AJc8fYbSRhQojDdKz7lGYHguvEhDLF4wgl66umkYz3iVWraO3q1Sdf9nBMiTlEOwDoZcz87SeacrgVP24knB96Iy4Qgu6S1YD8aDsO6BLtzOJ+9fajY8PZW16NijuPD/hvKUELGfGPOZI9N5z2ezDIqzGY30dH58AqWOX1G0IQYybsB9zmA1VB7ePRhAXyCnIiMOHjTlmUpAcGh7bTilg/m94ylK3QeYsqq5XrtiylZM9g5ta7H0j+cDX1bgKcbvwK2vn53AMT9I01LhKbC3Hul8Gg66CpVvlSFxHjpUiCrUnuGmfHuke74ad2o6Q8s3js2g/qm3U6B/zvoL0O1NyBhQXz/YDu0rdg4fsYTKOtEd3CnWCj89aVSMdcE3X8dYyo5vJv8fwnRC8TfTpJ9Fi0rBEgqoP2tNhXp8v4P1eqK+j8BRP7OSZ6TfFxvST09oweRr/BEnvJ5Lwnq9RVNmePDnlhgvI7YMZyMEboW93K75IlU+yNzHC+0HBg4MWTOdb9RBfh7VG8zivvWyOgetlqhmszqLmrFc0gGjcKCaubUfthpzH6zYbWrj0TAUQLNKEVojUUJbxPlGd04cwtuTVwzBeotfK9FB8Cz/cR/R/E7fcjN/hA4biesBZ0oGgOmHM3UugsTITMKrpQZ20QgKG11KLSO3JDLnDWbSTt75Jtv8lo4KTmbh7RW61EX8K19+PjguK+dduF7LBcY8dEcXqPWdR8Jj4zunp3dG5rY2vXhIVR6L9mgtbOgPZcVn7zpo4wgF095zD/SLVagtR5LfCs/0t5c1QgrY16d6SuMDXgYz26mqaUgc9GHeWYVgxkhszhbMhOuQ9Q3HqkeM/XyQhRw7O4/r/hz5IoTLfJ8y9W9hqdK4XRYI+Az0g0pf53bFfXnkuAk9Fp0kR9yJVgxqKSUJez49yUW+P1xiOpnT1VJ0TX5jajPbg/V7v4FiY6q/CdoLEY+XgUCsMU+62Y/XeRefF/ijW3V3Uzj750LgBbYONve4L/RaDUjSxQDafUJPgKwPiHhSlfsRqiP0CF8bXYriNVo7mVqGaBaEQVmnOHlXsyUUhhVGPKA+SIp2F8D07EhoIxD+0nOoREYjWS5eUMjj23a2d8yn+n4LP6uSW32/Xu39jx2LpYc1tPrf1DA37TGw3+a78v/4UrcWPgBx+Ck7YQ7bn4W+8Vs5jgvUyKNm6KN82kuc4W1o4393Z0XzvB3Y0no5qcuo7DryO6C+biH2BO3II0A/0v5X4nlTTvS7b2tp1OlHEkStOyvrwHoN2nlR8sJj+Iq7JxhgyXrA8VwG0yYj4WxJwnZ7V27WOTxBz9kLKoNWBYzDKzWYV5Zi1g9sOAgvoat3cOno7TrkQ1CeRxhH2w4Q8liG4q7GjXI8swlpWNkT+NsMiD0zs6aqq4jUd6v9qhWCwlIt55Ks0uVll/sZ/1F6JDCSjkKDf5bm7SRpPbW7vduqO63nAmmfROUk0mC451IUzV5cXFGKY3Q0esf3NjzrONezsmVI8upzBU7e8/Rv2kfcEbeovmwXMS8TrTl0fITC9IdA+zZp2/6AB1Qltwz1qqSSA4eQUE0li8E1ChZhxtin13WktnC50hCk3gwb6aSqvvVao67H0i5zNWFoNpuiwqI9aPB73IDpqiSaGqBZLIYVYLC2GoXh3DSlnDni/nzds/qZHGbzNVLRAjfEABZQoXhImSFIdc29pC6yceVb1TpMP1R/JpjX7/GfJOdRrQ0Zmiqn0IRt4v6ERto7BB2Q/Sp52dTjY9hRq3P2PG8eb29szlYD4iwwBg5F1NlhF5xsu2Qn00VLIShaZtzyAqYJz3O5zv7ve8o2wB7R5oIYUoMoL5XoOlfwRmuvOGCdwePRGqWiAY3BIv3Ep1gjw/iHokm+hdoCdzRbEFWLFHMK6Z4JTGGYcQdJjIiz5jdh2VVxDtBBPnI1Trxgq/zMt4K5FtanBSPwtLP+fiphxwqEYCTnukfmbmfvbzGAWtMgQR6CaudwgxOvJ6wvz6c72ZTR8j2kdnkKoWCAZ/I04evcNJo3bRqLVGWv7GM6k52qyshz706WeAEWkYayE0dg76vxfMWoTPXfis7//W0XjAcn/YlPUtnOPlN1H4tt4mhbweXws9aUn5FY5XJoAvzHgX6n0BWU8twHVptGk7+a2oaUWJob7sg2i89RlF9xuO8/RHh6vfjVgLVWVDdYZ+K9EGqOClRn4iKNH67uz43TOn9T2Wywkmh3RS+Ivwnp/wlgJtNvTzJD+EdxSLaDbeGzAG/XAXs/hBxoJOaEV4p23+c+G9GBcbZ5fLKEavJ+Ln2zCKvteVNp1k9eun90mxZnqj8SeL20cO0CRTVSvkZjAIE2ssAvoUM+Ve23K2UnPfpERYqK+ksAqmw6brJ1TfyHJ1iib8rff+ykItQr8KzCowu5jBE/HSBWRXkyxrsyBMV6dc+uET6LoXtZnsCL9762L6mwtr3DNQiaoSCLQi0wj7XIBKuMH3GSn7r7rpSEv9BM2VNkW/BNPR5uXQwGuQc38YTG7SqwLvUW0+NNO1HdLvmikFOJzGea+iv8L5wC7DJwnAbSihnwGin/WL/0b0O+BKh+l747EShCW2AC/bGt577MrN5mBmjmPITMK23kgz2jJ/+9CkR5dVCSSZqxfVFSYWWLLZdoI1s1uo5t3peqcKVGrOs3Cy+PhVndtIvSeXcozXAyoUngr1llq0fjztQBEpC8j8iECYzjk/CIS4naOwpHyVDMivE4z3kcF2K48yADTPA7IrhOCHpSt/Ve/ZG8jp8FFi1CtBbwFAF0OKTWCLTzVUlUDA9UvBsDCaCu/dQCnOYOZIuCurStK+ASviXszqDzGZc9FxnZayLjQVyqKFwlAVbYV4F9OP+hZsWN+8oJ9PhVr+PkhxDzeMvVgE/QDaLClFq2GJvZbl7huwsj01obUhWFNyr/8ZEUIxVSUQjCLJc49hlShEDZlRc+Nhu6cmIPE1OGPY389hFSzXK0GvAmecAahxPufNjH5WZlqDmTAluwwpN0OrWwIpDqtMxrfIiIqoaDFVbB+qY8Ozm9o8eGFG2xF/hFOo+Rky7wpVJRCctAGvQcwqoQx50Lbkxrk1OjMt1Fh+VRQ6PYUp0gJIM8GGuCEOCMYOgfm7DMt6m1y+xYqpg4ktfX2lZiNdqtFt9J6kqvMQL9yBqW9PowE/Xbu6XY1MdydKKujwayWbEgqkb6gRvFPvGocQNhmW8bySfJ+ZyR7uVXZ/UF8/Mmt2i8/W0/saN6tKIAj5eiCMtVDHW7jk+4Vt1rwrD0LIHCR6AGHJ5WD+JUzfTG8br+qHnwQsMGHttwhDvsUDtounjKMNu7qGTlQeYR17oP5nDOB/D9Iuoj/YJfih9rmpT+pfkKEJEnCHuYdSzp0986Yt3bOAcs+5XBn+LMdZB/Sd1bSVaOmuiPnQkSXT5tNp0qrcQ0unBHA6BAYaO1x3ed/seB1N0Rmj962W6lV4KUrOyPBShvB3DmXCoERv8LtO7/2CP9yN8DsNJ5UWnPuOwfemfW/Q86jz40R71ufSoyhCyYU49zZc25LH195CRPPKHXRmakDvNYGwYgjk6dxjgpeB6Qul6z+d6Q9NoQYhNQyv4fXP4cTbAp3BqjDpjIscbC/93G8AhD9+gKy8mwk6DKQ3EgRKZ7trcXw32vk0rmnCaxnlN4V74fMU6dEgCDdg6AertSDQzt5Bk4Npnc0CYajqJTTUjpfOOfSjHj+IV9TP1TPSWhjQ8kuAHGg8bCflHreki09pLTAknpaVq5OEpCORAiqgil46ZEwXHc/jQcO6bmLnkOXRLU/6XC0x/VRVCKcD/b5hcL5hehDcd+EkCOWsEYh28s/BpGBA9WBIg9QhNtEd2sxg8sNhIQMRePGANdals33NZK2+4X2CdIJ5BYS4EhAZ4nNF1/n5z5xK9w9T0ff6VYDktZAygv3CEMZXV2YyVT/XZDw67Zs+J0gM5sbEhOugUjMw6bkAG5fi+LVgxBxopIOBTXNp9KmeoSD03wXMq1DrKByjomMlHVEVg6HSPcRjbsTJwTZe/lxfcnYMMLFtAj/DGLNZQ3QO28aBaMycRYcy+rkm7/z9IROhTcASD6Ouou/rxuw+g84/ynOrIqHvZNX4VjHiW7LliE5vsJVUloWYae6hpIWQnOlHEnI+IF3jNeBnT+hlqAx2PJ4wN/dnAptngpnC4ocYl4P1+4+1TMZW1jMmED2pNbDfMvcbj1rzL9d1efx9Ht71z8klwHSjIIDC+3g1jyr6Gl01+es0FqZ/a3BI37+BAwOc8aNYk51478M3mYAC1w8CV0rZA/ThEDfFgfB5RoFylKcaAFoOMMZ7AdMfkY48VH/PsdxTIFaHgivcXs1OxzyNR5MuEL2hDoxeBgFcgo8r0UETBHABmJ0qVPrCn8yjEyug1ptUijkAhmXwnxcEgYnw9TjcfYeGd8jguwFKbucG22fYVjs66xOOPzjY1ZeeaVFwuJ74zL462eEaftPmjjSjswMjO22BaC35IYQwjehW/P1hMPeTeM0D40Wx+Sn+dbZKRaciTc89OZuR/onTNNd1D31DqSF2SFO+igqIrnW0+JbVJcmz0cGAYTgde7a39V9CdNZtT6qGJiSQdeAzyromnG8SDF+W0b9oAIFAAK6dvz25+Haz4pp1ORWbGTBb11xQ86BuYcoDXIrt8OoHGBdtyECOMf2UcFT/gmRkd1PWPUz792fYO1A0eiepZoEgOpoN5n4GjPwP0Pg5eJ2j431d5ygWQlUrQD8gUpscyTsMS77NDOPXzOTNEcds8er8jlRzzwA7Qxnx2Uo1CQQl2AgYfj+EcE/4y2eUE0JBEBV6Ckjwo5zTMGrWbcwQb0nXaTYcsRO2qH3m3u72s8WOv5tUUx4Cc1QHQVwTzQvjZJsQCitA23+kzgOo/HUzy2i2IvJx4cudiGg6sw1GN5zpyG/bCqhENQkkRaRNyK4I0XxGJT9iMEphPA9sCFW/Vjje17krXjJi1jbFWds6FJ1GQbmaf+vgt4Nq9iE7iK7A6vge/lyMFUBSsgPSMTfAD7RAFENInAYQXu0IlNmSMeOd896HjvdM0oSirDbAHIALvmTG7GEh5S/sJmoeu+lgit5xUu8eFjZFUzRFUzRFUzRFU3R2078DvGi5ZMlVxWgAAAAASUVORK5CYII=",
          earn_announcement:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAfkSURBVHgB7ZZ7bFPXHce/5z58fa99/cSO83LsJEAA8QwIlakMrd0fq1oNFQkhrdvajhJpTJOG0NpKezA6bWUalGnr+GMwTVWlduuklWlD6soEWwcMyIDxang4ODzixLGdOLbjx33td23IoK0qQPSv9icdn3vOuT6/z/m97gE+7cI+anLHjh1y6uDODR6PvHa8aL27/U8XtjLGTHwCInxw4sCBA8KhPet3Clxlw9yojHFNWPHtL7XxtPR9fALCf3BiZeTsRklIf69QMRDyOdEWU5Ev8bM6QtETJxOpJB6w3AHwxrYvtrQGh94o1TSXqjIEPRKaOxTkJzn3xUuJry/u8PUu644ePnklk8cDEu72Qbwp3edUKiEdFro7eLhcJnxehnCTgu7ZAfiDwhPMyg48+4XoT//w6hY3HoBMB+G5A6+62di2swNXCh2lKo9ZrTysqozY/CYkEgqujRVQLDFkRgsYHc6jWLSSJlxbdu+//BoFqIX7lGkLFK++vqo4lu8YSRlgAkNVM8HRvoyc5PZLZBEF87q9WLQgjCVL2xDr9MQUqfC7p1cG3/vOms8txX3KdAx86zHhpdRgcV4yx8HhEiBaJpycE+4ZLsDhh7fFiViLFz6Fh8flQCCoQPXJ4DhExzM3nlscD85+pHfJocPnk0Xcg9QB/rV3jyoP/33nUKKkpHQBFu3qMCkIVTc41QlO8sDRFII33gS1ScaMAAEQiNctIkCAqldmul6ZPzE+0rewPYDXf/abY79+6y3jrgGe+3JtBS5e+Oa1UQOTLhWWTr7RDURbfCgxEYIqQ410Qnb5CcYN3qdCJpBASELILVC2ODAj5KJ1UappU4/88/C+Nctmxof7L6cH7grga58Pf6P8fnJlTnRB6YpBcUpkfg7tbSrGpjiofhnheAyiyIMREGNO+qcK5vJCCrsRaHYi7BfR5JUoY1RIMh8q5DPreiLyww8tmn38+EAq87EAj/aIL4wMjndNBINgHi8ESSJlDnS1Sxie4OFw1hBpkcGLOuyKzOzcYXb8itRTjEg+iEEfvG0KImERrUEnIpE6SGd+LN3X2xlqWff4k0fe+ffJ8ocALu3bJyVPvL1NKxdchRlhmLwDumZBtgx0dFApLgtIJlJIJ8YwlcnAKk+As0rg+So4XiMA8yYMWUXwgfcGobZ50NJKQRuR0dzs5izUlg4lB56Z3xao9l8e74/FmLR69Sph796DOut/++n5uf1/PG2wKRzne2hTCbxloctroHOuFynKivOnr0Alq9QMo65LcfEIkc9b2lVEon74mwOQ/R7wkkrBIzdg6hk+BbMwhsmro0icy+BofwqXLuRP+CTW3DMn4Lx8VXhMKE0MxuNU+0Y48m2W0o9O5ICJ9hCHksYhnytgaLgKj0xWcfIQeIZSUUMqlcOp0xnwQhIelfzf7EK0w4fWeACBFgLy+cE7PJRFrfDNa0Vvdw49vcO4eCq15OA/BhHvBr3j3iQQ70zFRdFfliE7AJfDggcGWiJOnM0YOELUg8M18JxG1iEr08EE+pGoWDkc1Oh5ZEzDpSS55VgaTieD3yehrVVFvMuP9s4Qgq0hOMk1SrwHC6NxhGeFcO3kMbTHQ8sERSt0jVYYJgxKJ/oAeUQTQbKCr0nC0NE0RrJlCkg76izY9bZGKVrVDNjVxrpZgO3VBhwjOAZxWMOZC0VI76XgcvMIU1DGOjzoJsXtXRHwbjcqNY2sKUlCrVoOXyvwMKi6+SmgA4IJr2hhslJF4kYWomDVT2Urs5tp2s2ixmDYvcWmx1XDoo0boLfg+IyJwasa/nO2AMe7N+AhoEiAx/J5MgqYvCEUpwwpXaJUo4KicAZkswrFw+NiIksbmQgFGUU8u005SDH1ht2zxthg0/ONNau+ZgPWx2S1MiVMsQRkcjqKmSpWLA4iMVRJCKUKWKbIUSEh82lVlGs1BGMyJjMliJRAwTBfz3vLsiHodHWIhkLTaoBMP9+m/A4we47eo+IKTbcwq5mnnqH/1Pg+oVDmtCIBuCd0lFGB2yNirFhGDTqZi6vfBzjysm1Yy+SmXdFo1vQzbkI0QHFHq8/XQWxAE8sXSLiWzafnr1q3T5jSHRM1qk/jWQ1pejEUlVAl5dlR0EeHlHONK4O9sV03rZuKGgpZw9+NYf3Btohl/j9WDL3uAt2yhEKlpvvawxJzyrx9nJ9v3rw9IxDVmRqZI0u+mRl1o1Ch+xBvIJex4FK4xqbT5r1lcgsaBRutmk5eKFWr3IQgCtc1w/CVLWsOBbdeLqmbRafn/XDzwsuu+KKRvr6+qR88NfsZDtpL6azx5oYfJbf3bWVgP9mwqmf06n/PN4dk1hl3UHHQcOpc2crn+Qpj/CTHO4bJjDeqZS1Ft5McXQ5Ge2Zp2wRvsyj7+N9+ZePh9faNiIRtXx/ZywUDT4ATzmx6+cwC3IXU7fv82q5tqjj1XTeloSE6Tki+x5/c+ONfXaeNP/Kb/pdX5uwZL1nPRufGzL++eXarrne8E1QurW5rNZ83fV04dir/w12/H9h61wC2vPjUkod5qvJC96P7t2zZon/cn3a/8FC3oowc0jlnOEpV7vqFEeiUKqbiwaEjQ1e6F6zpffHlXeO4F4B7ld2bli4ORnO7qmZpebmiIDtm1hJJ/W8Oo239L/58dPRu97lvgFvy2i+/Gkd5IuoUus+s3fRKDp/JPcr/AH/namshc2iMAAAAAElFTkSuQmCC",
          earn_player: mE,
          earn_daily_reward:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGsAAABkCAYAAACB6c7ZAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAotSURBVHgB7Z1tbBTHGcefvbOp34CzhZHtWOIMlKbQ4MPnMy4Y7Aio0go1rVS3agVN2oQPVHLbqJXabw1CkdKmRGkrNYrSKCgfmkq1lFL4UCXQOIlNHL/pTG3c2pieK2xejM1Rzr4zvvN2/usesfdednZ9L7tmftKBb3fuuZ357+w+N/O/OYniUF9b2yTL8o9Ill0kSU4SZAovHlJu7onOzk6feqe09InH43HZZPlNRSRBtjmdH4k81+b1+qMbHohV73Y/tUD0CtvgIIFZ8LFe9ni0l9nwT319vVMIZUqc8vz8O9EnSs/a7Xb/GzvUJdfm5FBZXh4Vsf8F6SUQDtNIIBB3nyxJJ7p6ep6X6tzurzHF3lEX+J7TSd+srBRCZZAboRD90Oul6+x/FX52/6qyMaGeUu9p2bqVvs/EEkJlFlzFfutyxWt3x6zd3pSjpOay/GBrOXsBelQiJLafSkqI8vPJrMijo5QupIqKFdc92fFBsGbW/m/6fMvfl4iJpUrTXY7EOYZUXEz248dJglgmRp6epsirr5J85w6lilTWXZ6YoPDLLyfc/5WysnhirbeRDqT9+00vFMAx2tixpjTmli0pqzt6p1RbS3rRJ5aJL31q0BNSSopPUiNtqUushe5usgqRjz6iVCKj7sEgpQQWRx4YIL3oSvdwYwy/8AJJHg+ZGRxnqpMM3P9wn1lx3f8vlJH7qe7cHG8iv/suPYxku+66LoOC7BLTs+S5OZq/eZME2SPMhp7iESNWxO+n0N27JMgeoQTbxWXQQgixLIQQy0IIsSyEEMtCCLEsREzqfpHNbV0igRmJEWsGjyWTkQLzIC6DFkKIZSFiLoMFhYWUX1BIguwyNXkrZluMWJWbqujHvzhJguzyg299PWabuAxaCCGWhRBiWYiYe9aa3BwqL15HAvMRK1aOncpL1pPAfBg2sw8ODtLIyAjNz89rli0tLaW6ujoqKCjQLDs8PEyXL1/miutwOGjv3r0pj1vIPr7s2bNHia+Fz+cjr9fLHdflclEFLNgGMHTPwgHyVhxMTk5SV1cXV9z+/n7uuH6/n9ra2jTLzczM6IqL8oirVR7luru7dcVFO/CWV2NIrFu3bul9iSKYFmh8vaABZmdnk5bxqXzjPKBBETsZdw14VRB3fHycjGCqbPD+/ftkJrR6QKaPV6TuFkKIZSGEWBZCiGUhhFgWQohlIYRYFsJUYkUiEUoH6YprFKPHY0gsI5/ceUYnjMSdm5tTHit973hx7927pxlXb8MjrtaISyIMDeTiIMfGxpQBWrvdrlk+GAzStWvXNMvhe0l64mIEAeW1sNlsNDo6SuXl5briYjA3GRAKA8SVlZW0Zs0a4omLdti1axcZwZBYmzdvpr6+PpqamuJ+TVVVlWaZ7du3U0dHh664xcXFyiMZGOVGr9XTcxET9UzGjh07qLW1VZl90ENGR93dbjcdOHCA8rDaDAcQqrm5WbMcGgdxizmXRUDcY8eOccU9fPgwd1z0wCNHjmiWQ/2PHj3KHRdTLnrKq5F2u93L7Lc1TIjfv/YaCbJLvWpRE4notEjdLYQQy0KsaI06zPfwzOlgOjtbceWwn8Ljv6OFwCXlb1vhTsqpbCFbnjOm7IL/QwrfPsPSPJaI2NeT3dFI9g1f1XyPdLWDGsNiIWubmJjgKouDbGpq4vJKwM/Am11peSUg0rzvpCJSlAX/B8r2nLLvUu6WX5OU4yA5NEZz/3pW2ad+vZS3iT6zo5VsRdVx30OPtwMg40UWaQTDHgxeoUDUe8ATV08aHPVKxGN+7CTdv/KTZUItJXzjLZobbFb2h/oPxQgVRRES+wP9cd9fj7cD6BFWjeU9GKi4ekQADYwepQUECnZsZOV9SctB0LnBb8QIz1OneAgPxhIit/9KqQYnAO5p2WRVZoPhqdSLBSJpisuLSN0txOrsWWlyiM1n2Sm3KsWavkFpIV1xeVmVYt0cX5/y3hUMMLEms/uFjVUplmNzI/X+nVIGhP/kb0SljzZSNlmVYjkbjtK9/zqorXWxR6wEvB5CYSSjokZ76CmdrAoPhnrly9wCB32x5c9KQ3ewbPvaFTLEzf8svj4YclDjz96jVJFRD8b09DTphWf210hcjF7EqzwuWV9+aYTWrHPSP9qJRrykiyE2OtbHLqW56zbRfiZUwQZnTBmMuGj5P9TweDsSYWggF28Gj0IJ58L0gUCAa4hKlmVlYHTjxo3c3o7r168n3F+wYRMdONFF/X/8KV3peEvJ5nY2EOUXJYnJeuOl9sXMr6LmSap95nWlp8YDJwnGMjGzzOvBwPFm1IOBUWO9HgxYAbSIejACAf4bjZYHAw1d++wfFOGGzpxU7j+7n4gvGASCUBBs57dP0We/1ELJQDucO3eOy7Sz9HiNejAMT+v39vYqDRvk+BUBVOrgwYNcng09cVFxeDt4PQ2T//yAet84RjO3ffT5OpaIbP90n+/y4qUPotY+8wa7jPL9lglmHyDYHY5F9XGc8ILwiBVvWv+h82DM3h6jD395SBGspGyxhymfoVivKv1cI+uFr8e9P2Ua4cGgxZ7zxEvDtPVQiyLQ+JVFofB8/8/fM4VQiXhof3qu+junlARilvUwCMR72csmKxILqSvPHBSu1bm5ucQLb9yioiIuq0AUzOwu+1J3yaOUzx64DyzNVlccN0XHq8aQWJidRRLAO1OqZ10JTNPrmYH1eDzkdDo1y2EJBD3f2q+urqZt27ZplsN6IJiq5yXjHgwcoJ4GxVl38eJFzXJoTL1T5TwLhiBj07u8Ao+3Ar1Rj1AA5Y3YF4AhsYxMv/NcJox6MLQa9Y7B337UOh6j3wbJqFjpwmzrYJgNMa1vIYRYFkKIZSGEWBZCiGUhhFgWQohlIUwlVtDgL2wn+vXRKKnydqQqrtHPk4bEMvLtCZ5pfSPrSmC2Wus1KKPXK4HRCa2TB/YG03swUJGBgQFurwSm6XksAIg1NDSky4OBuPn5+UnLYcQfXgneuDjzcXLt27cvabmoB0Nv3Ix6MOCngAeDZyGSKFglWouamhplNF9PXIxia9kFatms64ULF3TF5V0Hw0hco6PuK/Jg4MEDKg0PBg9Xr16l9vZ2CoVCXHEbGhq4vB0YzD179ixXXHgkcHLxeDsQ9/z589weDLQDT1zhwbAQwoNhEQIJEhCI5Vu6YWR4mATZZTiOBuzyd9fGuteyr6kjrfzT22+TIHu8cupUzDYmVpu98pFHMG359NIdnR9/TEVr19IXHnuMBJkDHeVXL76otL8KX1dv73EJf9W73e8z5ZrUJcpZVgTTCIQTpBfcp/pYdh3vA7MsSSe6enqeV8TyeDwuaWHhffZE234kyCyS5P2kp0f5FK1kg93d3V6bLD9HAnPBhJLC4Qe/1Pkgde/s6zstRSJYbtNHAjPwm/xw+PFOr9cX3SDFK1VfU/O0bLM9SbLsYk+dJMgUPtZ7zrB71F86e3ra1Dv/B0xTAQ7Pft/hAAAAAElFTkSuQmCC",
          share: UE,
        },
        BE = {
          [E_.AutoTap]: {
            image: FE.boosters.AutoTap,
            name: "booster_autotap_name",
            desc: "booster_autotap_desc",
            effect: "booster_autotap_effect",
          },
          [E_.MultiTap]: {
            image: FE.boosters.MultiTap,
            name: "booster_multitap_name",
            desc: "booster_multitap_desc",
            effect: "booster_multitap_effect",
          },
          [E_.RechargeLimit]: {
            image: FE.boosters.RechargeLimit,
            name: "booster_rechargelimit_name",
            desc: "booster_rechargelimit_desc",
            effect: "booster_rechargelimit_effect",
          },
          [E_.RechargeSpeed]: {
            image: FE.boosters.RechargeSpeed,
            name: "booster_rechargespeed_name",
            desc: "booster_rechargespeed_desc",
            effect: "booster_rechargespeed_effect",
          },
          [A_.Rocketman]: {
            image: FE.boosters.Rocketman,
            name: "buff_rocketman_name",
            desc: "buff_rocketman_desc",
            effect: "buff_rocketman_effect",
          },
          [A_.FullEnergy]: {
            image: FE.boosters.FullEnergy,
            name: "buff_fullenergy_name",
            desc: "buff_fullenergy_desc",
            effect: "buff_fullenergy_effect",
          },
          [A_.AutoBotReward]: {
            image: FE.boosters.AutoTap,
            name: "buff_autobotreward_name",
            desc: "buff_autobotreward_desc",
            effect: "buff_autobotreward_effect",
          },
          [A_.AutoBotFirstSession]: {
            image: FE.boosters.AutoTap,
            name: "buff_autobotfirstsession_name",
            desc: "buff_autobotfirstsession_desc",
            effect: "buff_autobotfirstsession_effect",
          },
        };
      function VE(e) {
        return e && e.Math == Math ? e : void 0;
      }
      const qE =
        ("object" == typeof globalThis && VE(globalThis)) ||
        ("object" == typeof window && VE(window)) ||
        ("object" == typeof self && VE(self)) ||
        ("object" == typeof n.g && VE(n.g)) ||
        (function () {
          return this;
        })() ||
        {};
      function HE() {
        return qE;
      }
      function WE(e, t, n) {
        const r = n || qE,
          s = (r.__SENTRY__ = r.__SENTRY__ || {});
        return s[e] || (s[e] = t());
      }
      const KE = "production",
        zE = Object.prototype.toString;
      function GE(e) {
        switch (zE.call(e)) {
          case "[object Error]":
          case "[object Exception]":
          case "[object DOMException]":
            return !0;
          default:
            return rA(e, Error);
        }
      }
      function JE(e, t) {
        return zE.call(e) === "[object ".concat(t, "]");
      }
      function QE(e) {
        return JE(e, "ErrorEvent");
      }
      function YE(e) {
        return JE(e, "DOMError");
      }
      function XE(e) {
        return JE(e, "String");
      }
      function ZE(e) {
        return (
          "object" === typeof e &&
          null !== e &&
          "__sentry_template_string__" in e &&
          "__sentry_template_values__" in e
        );
      }
      function $E(e) {
        return (
          null === e ||
          ZE(e) ||
          ("object" !== typeof e && "function" !== typeof e)
        );
      }
      function eA(e) {
        return JE(e, "Object");
      }
      function tA(e) {
        return "undefined" !== typeof Event && rA(e, Event);
      }
      function nA(e) {
        return Boolean(e && e.then && "function" === typeof e.then);
      }
      function rA(e, t) {
        try {
          return e instanceof t;
        } catch (Yr) {
          return !1;
        }
      }
      function sA(e) {
        return !(
          "object" !== typeof e ||
          null === e ||
          (!e.__isVue && !e._isVue)
        );
      }
      const iA = HE(),
        oA = 80;
      function aA(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (!e) return "<unknown>";
        try {
          let n = e;
          const r = 5,
            s = [];
          let i = 0,
            o = 0;
          const a = " > ",
            c = a.length;
          let l;
          const u = Array.isArray(t) ? t : t.keyAttrs,
            d = (!Array.isArray(t) && t.maxStringLength) || oA;
          for (
            ;
            n &&
            i++ < r &&
            ((l = cA(n, u)),
            !("html" === l || (i > 1 && o + s.length * c + l.length >= d)));

          )
            s.push(l), (o += l.length), (n = n.parentNode);
          return s.reverse().join(a);
        } catch (n) {
          return "<unknown>";
        }
      }
      function cA(e, t) {
        const n = e,
          r = [];
        let s, i, o, a, c;
        if (!n || !n.tagName) return "";
        if (
          iA.HTMLElement &&
          n instanceof HTMLElement &&
          n.dataset &&
          n.dataset.sentryComponent
        )
          return n.dataset.sentryComponent;
        r.push(n.tagName.toLowerCase());
        const l =
          t && t.length
            ? t
                .filter((e) => n.getAttribute(e))
                .map((e) => [e, n.getAttribute(e)])
            : null;
        if (l && l.length)
          l.forEach((e) => {
            r.push("[".concat(e[0], '="').concat(e[1], '"]'));
          });
        else if (
          (n.id && r.push("#".concat(n.id)), (s = n.className), s && XE(s))
        )
          for (i = s.split(/\s+/), c = 0; c < i.length; c++)
            r.push(".".concat(i[c]));
        const u = ["aria-label", "type", "name", "title", "alt"];
        for (c = 0; c < u.length; c++)
          (o = u[c]),
            (a = n.getAttribute(o)),
            a && r.push("[".concat(o, '="').concat(a, '"]'));
        return r.join("");
      }
      const lA = "undefined" === typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__,
        uA = ["debug", "info", "warn", "error", "log", "assert", "trace"],
        dA = {};
      function hA(e) {
        if (!("console" in qE)) return e();
        const t = qE.console,
          n = {},
          r = Object.keys(dA);
        r.forEach((e) => {
          const r = dA[e];
          (n[e] = t[e]), (t[e] = r);
        });
        try {
          return e();
        } finally {
          r.forEach((e) => {
            t[e] = n[e];
          });
        }
      }
      const pA = (function () {
        let e = !1;
        const t = {
          enable: () => {
            e = !0;
          },
          disable: () => {
            e = !1;
          },
          isEnabled: () => e,
        };
        return (
          lA
            ? uA.forEach((n) => {
                t[n] = function () {
                  for (
                    var t = arguments.length, r = new Array(t), s = 0;
                    s < t;
                    s++
                  )
                    r[s] = arguments[s];
                  e &&
                    hA(() => {
                      qE.console[n](
                        "".concat("Sentry Logger ", "[").concat(n, "]:"),
                        ...r
                      );
                    });
                };
              })
            : uA.forEach((e) => {
                t[e] = () => {};
              }),
          t
        );
      })();
      function fA(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        return "string" !== typeof e || 0 === t || e.length <= t
          ? e
          : "".concat(e.slice(0, t), "...");
      }
      function mA(e, t) {
        if (!Array.isArray(e)) return "";
        const n = [];
        for (let r = 0; r < e.length; r++) {
          const t = e[r];
          try {
            sA(t) ? n.push("[VueViewModel]") : n.push(String(t));
          } catch (a_) {
            n.push("[value cannot be serialized]");
          }
        }
        return n.join(t);
      }
      function gA(e, t) {
        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return (
          !!XE(e) &&
          (JE(t, "RegExp")
            ? t.test(e)
            : !!XE(t) && (n ? e === t : e.includes(t)))
        );
      }
      function vA(e) {
        let t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return (
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
        ).some((n) => gA(e, n, t));
      }
      function yA(e, t, n) {
        if (!(t in e)) return;
        const r = e[t],
          s = n(r);
        "function" === typeof s && wA(s, r), (e[t] = s);
      }
      function bA(e, t, n) {
        try {
          Object.defineProperty(e, t, {
            value: n,
            writable: !0,
            configurable: !0,
          });
        } catch (r) {
          lA &&
            pA.log(
              'Failed to add non-enumerable property "'.concat(
                t,
                '" to object'
              ),
              e
            );
        }
      }
      function wA(e, t) {
        try {
          const n = t.prototype || {};
          (e.prototype = t.prototype = n), bA(e, "__sentry_original__", t);
        } catch (n) {}
      }
      function SA(e) {
        return e.__sentry_original__;
      }
      function _A(e) {
        if (GE(e))
          return { message: e.message, name: e.name, stack: e.stack, ...AA(e) };
        if (tA(e)) {
          const t = {
            type: e.type,
            target: EA(e.target),
            currentTarget: EA(e.currentTarget),
            ...AA(e),
          };
          return (
            "undefined" !== typeof CustomEvent &&
              rA(e, CustomEvent) &&
              (t.detail = e.detail),
            t
          );
        }
        return e;
      }
      function EA(e) {
        try {
          return (
            (t = e),
            "undefined" !== typeof Element && rA(t, Element)
              ? aA(e)
              : Object.prototype.toString.call(e)
          );
        } catch (n) {
          return "<unknown>";
        }
        var t;
      }
      function AA(e) {
        if ("object" === typeof e && null !== e) {
          const t = {};
          for (const n in e)
            Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
          return t;
        }
        return {};
      }
      function TA(e) {
        return PA(e, new Map());
      }
      function PA(e, t) {
        if (
          (function (e) {
            if (!eA(e)) return !1;
            try {
              const t = Object.getPrototypeOf(e).constructor.name;
              return !t || "Object" === t;
            } catch (a_) {
              return !0;
            }
          })(e)
        ) {
          const n = t.get(e);
          if (void 0 !== n) return n;
          const r = {};
          t.set(e, r);
          for (const s of Object.keys(e))
            "undefined" !== typeof e[s] && (r[s] = PA(e[s], t));
          return r;
        }
        if (Array.isArray(e)) {
          const n = t.get(e);
          if (void 0 !== n) return n;
          const r = [];
          return (
            t.set(e, r),
            e.forEach((e) => {
              r.push(PA(e, t));
            }),
            r
          );
        }
        return e;
      }
      function IA() {
        const e = qE,
          t = e.crypto || e.msCrypto;
        let n = () => 16 * Math.random();
        try {
          if (t && t.randomUUID) return t.randomUUID().replace(/-/g, "");
          t &&
            t.getRandomValues &&
            (n = () => {
              const e = new Uint8Array(1);
              return t.getRandomValues(e), e[0];
            });
        } catch (r) {}
        return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (e) =>
          (e ^ ((15 & n()) >> (e / 4))).toString(16)
        );
      }
      function CA(e) {
        return e.exception && e.exception.values
          ? e.exception.values[0]
          : void 0;
      }
      function kA(e) {
        const { message: t, event_id: n } = e;
        if (t) return t;
        const r = CA(e);
        return r
          ? r.type && r.value
            ? "".concat(r.type, ": ").concat(r.value)
            : r.type || r.value || n || "<unknown>"
          : n || "<unknown>";
      }
      function OA(e, t, n) {
        const r = (e.exception = e.exception || {}),
          s = (r.values = r.values || []),
          i = (s[0] = s[0] || {});
        i.value || (i.value = t || ""), i.type || (i.type = n || "Error");
      }
      function xA(e, t) {
        const n = CA(e);
        if (!n) return;
        const r = n.mechanism;
        if (
          ((n.mechanism = { type: "generic", handled: !0, ...r, ...t }),
          t && "data" in t)
        ) {
          const e = { ...(r && r.data), ...t.data };
          n.mechanism.data = e;
        }
      }
      function NA(e) {
        if (e && e.__sentry_captured__) return !0;
        try {
          bA(e, "__sentry_captured__", !0);
        } catch (t) {}
        return !1;
      }
      function RA(e) {
        return Array.isArray(e) ? e : [e];
      }
      const DA = 1e3;
      function MA() {
        return Date.now() / DA;
      }
      const jA = (function () {
        const { performance: e } = qE;
        if (!e || !e.now) return MA;
        const t = Date.now() - e.now(),
          n = void 0 == e.timeOrigin ? t : e.timeOrigin;
        return () => (n + e.now()) / DA;
      })();
      let LA;
      (() => {
        const { performance: e } = qE;
        if (!e || !e.now) return void (LA = "none");
        const t = 36e5,
          n = e.now(),
          r = Date.now(),
          s = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t,
          i = s < t,
          o = e.timing && e.timing.navigationStart,
          a = "number" === typeof o ? Math.abs(o + n - r) : t;
        i || a < t
          ? s <= a
            ? ((LA = "timeOrigin"), e.timeOrigin)
            : (LA = "navigationStart")
          : (LA = "dateNow");
      })();
      const UA = "undefined" === typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
      var FA;
      function BA(e) {
        return new qA((t) => {
          t(e);
        });
      }
      function VA(e) {
        return new qA((t, n) => {
          n(e);
        });
      }
      !(function (e) {
        e[(e.PENDING = 0)] = "PENDING";
        e[(e.RESOLVED = 1)] = "RESOLVED";
        e[(e.REJECTED = 2)] = "REJECTED";
      })(FA || (FA = {}));
      class qA {
        constructor(e) {
          qA.prototype.__init.call(this),
            qA.prototype.__init2.call(this),
            qA.prototype.__init3.call(this),
            qA.prototype.__init4.call(this),
            (this._state = FA.PENDING),
            (this._handlers = []);
          try {
            e(this._resolve, this._reject);
          } catch (a_) {
            this._reject(a_);
          }
        }
        then(e, t) {
          return new qA((n, r) => {
            this._handlers.push([
              !1,
              (t) => {
                if (e)
                  try {
                    n(e(t));
                  } catch (a_) {
                    r(a_);
                  }
                else n(t);
              },
              (e) => {
                if (t)
                  try {
                    n(t(e));
                  } catch (a_) {
                    r(a_);
                  }
                else r(e);
              },
            ]),
              this._executeHandlers();
          });
        }
        catch(e) {
          return this.then((e) => e, e);
        }
        finally(e) {
          return new qA((t, n) => {
            let r, s;
            return this.then(
              (t) => {
                (s = !1), (r = t), e && e();
              },
              (t) => {
                (s = !0), (r = t), e && e();
              }
            ).then(() => {
              s ? n(r) : t(r);
            });
          });
        }
        __init() {
          this._resolve = (e) => {
            this._setResult(FA.RESOLVED, e);
          };
        }
        __init2() {
          this._reject = (e) => {
            this._setResult(FA.REJECTED, e);
          };
        }
        __init3() {
          this._setResult = (e, t) => {
            this._state === FA.PENDING &&
              (nA(t)
                ? t.then(this._resolve, this._reject)
                : ((this._state = e),
                  (this._value = t),
                  this._executeHandlers()));
          };
        }
        __init4() {
          this._executeHandlers = () => {
            if (this._state === FA.PENDING) return;
            const e = this._handlers.slice();
            (this._handlers = []),
              e.forEach((e) => {
                e[0] ||
                  (this._state === FA.RESOLVED && e[1](this._value),
                  this._state === FA.REJECTED && e[2](this._value),
                  (e[0] = !0));
              });
          };
        }
      }
      function HA() {
        return WE("globalEventProcessors", () => []);
      }
      function WA(e) {
        HA().push(e);
      }
      function KA(e, t, n) {
        let r =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
        return new qA((s, i) => {
          const o = e[r];
          if (null === t || "function" !== typeof o) s(t);
          else {
            const a = o({ ...t }, n);
            UA &&
              o.id &&
              null === a &&
              pA.log('Event processor "'.concat(o.id, '" dropped event')),
              nA(a)
                ? a.then((t) => KA(e, t, n, r + 1).then(s)).then(null, i)
                : KA(e, a, n, r + 1)
                    .then(s)
                    .then(null, i);
          }
        });
      }
      function zA(e) {
        const t = jA(),
          n = {
            sid: IA(),
            init: !0,
            timestamp: t,
            started: t,
            duration: 0,
            status: "ok",
            errors: 0,
            ignoreDuration: !1,
            toJSON: () =>
              (function (e) {
                return TA({
                  sid: "".concat(e.sid),
                  init: e.init,
                  started: new Date(1e3 * e.started).toISOString(),
                  timestamp: new Date(1e3 * e.timestamp).toISOString(),
                  status: e.status,
                  errors: e.errors,
                  did:
                    "number" === typeof e.did || "string" === typeof e.did
                      ? "".concat(e.did)
                      : void 0,
                  duration: e.duration,
                  abnormal_mechanism: e.abnormal_mechanism,
                  attrs: {
                    release: e.release,
                    environment: e.environment,
                    ip_address: e.ipAddress,
                    user_agent: e.userAgent,
                  },
                });
              })(n),
          };
        return e && GA(n, e), n;
      }
      function GA(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (
          (t.user &&
            (!e.ipAddress &&
              t.user.ip_address &&
              (e.ipAddress = t.user.ip_address),
            e.did ||
              t.did ||
              (e.did = t.user.id || t.user.email || t.user.username)),
          (e.timestamp = t.timestamp || jA()),
          t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism),
          t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration),
          t.sid && (e.sid = 32 === t.sid.length ? t.sid : IA()),
          void 0 !== t.init && (e.init = t.init),
          !e.did && t.did && (e.did = "".concat(t.did)),
          "number" === typeof t.started && (e.started = t.started),
          e.ignoreDuration)
        )
          e.duration = void 0;
        else if ("number" === typeof t.duration) e.duration = t.duration;
        else {
          const t = e.timestamp - e.started;
          e.duration = t >= 0 ? t : 0;
        }
        t.release && (e.release = t.release),
          t.environment && (e.environment = t.environment),
          !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress),
          !e.userAgent && t.userAgent && (e.userAgent = t.userAgent),
          "number" === typeof t.errors && (e.errors = t.errors),
          t.status && (e.status = t.status);
      }
      function JA(e, t) {
        let n = {};
        t
          ? (n = { status: t })
          : "ok" === e.status && (n = { status: "exited" }),
          GA(e, n);
      }
      function QA(e) {
        return e.transaction;
      }
      const YA = 1;
      function XA(e) {
        const { spanId: t, traceId: n } = e.spanContext(),
          {
            data: r,
            op: s,
            parent_span_id: i,
            status: o,
            tags: a,
            origin: c,
          } = ZA(e);
        return TA({
          data: r,
          op: s,
          parent_span_id: i,
          span_id: t,
          status: o,
          tags: a,
          trace_id: n,
          origin: c,
        });
      }
      function ZA(e) {
        return (function (e) {
          return "function" === typeof e.getSpanJSON;
        })(e)
          ? e.getSpanJSON()
          : "function" === typeof e.toJSON
          ? e.toJSON()
          : {};
      }
      function $A(e) {
        const { traceFlags: t } = e.spanContext();
        return Boolean(t & YA);
      }
      function eT(e, t, n) {
        const r = t.getOptions(),
          { publicKey: s } = t.getDsn() || {},
          { segment: i } = (n && n.getUser()) || {},
          o = TA({
            environment: r.environment || KE,
            release: r.release,
            user_segment: i,
            public_key: s,
            trace_id: e,
          });
        return t.emit && t.emit("createDsc", o), o;
      }
      function tT(e) {
        const t = UT();
        if (!t) return {};
        const n = eT(ZA(e).trace_id || "", t, FT()),
          r = QA(e);
        if (!r) return n;
        const s = r && r._frozenDynamicSamplingContext;
        if (s) return s;
        const { sampleRate: i, source: o } = r.metadata;
        null != i && (n.sample_rate = "".concat(i));
        const a = ZA(r);
        return (
          o && "url" !== o && (n.transaction = a.description),
          (n.sampled = String($A(r))),
          t.emit && t.emit("createDsc", n),
          n
        );
      }
      function nT(e, t) {
        const {
          fingerprint: n,
          span: r,
          breadcrumbs: s,
          sdkProcessingMetadata: i,
        } = t;
        !(function (e, t) {
          const {
              extra: n,
              tags: r,
              user: s,
              contexts: i,
              level: o,
              transactionName: a,
            } = t,
            c = TA(n);
          c && Object.keys(c).length && (e.extra = { ...c, ...e.extra });
          const l = TA(r);
          l && Object.keys(l).length && (e.tags = { ...l, ...e.tags });
          const u = TA(s);
          u && Object.keys(u).length && (e.user = { ...u, ...e.user });
          const d = TA(i);
          d && Object.keys(d).length && (e.contexts = { ...d, ...e.contexts });
          o && (e.level = o);
          a && (e.transaction = a);
        })(e, t),
          r &&
            (function (e, t) {
              e.contexts = { trace: XA(t), ...e.contexts };
              const n = QA(t);
              if (n) {
                e.sdkProcessingMetadata = {
                  dynamicSamplingContext: tT(t),
                  ...e.sdkProcessingMetadata,
                };
                const r = ZA(n).description;
                r && (e.tags = { transaction: r, ...e.tags });
              }
            })(e, r),
          (function (e, t) {
            (e.fingerprint = e.fingerprint ? RA(e.fingerprint) : []),
              t && (e.fingerprint = e.fingerprint.concat(t));
            e.fingerprint && !e.fingerprint.length && delete e.fingerprint;
          })(e, n),
          (function (e, t) {
            const n = [...(e.breadcrumbs || []), ...t];
            e.breadcrumbs = n.length ? n : void 0;
          })(e, s),
          (function (e, t) {
            e.sdkProcessingMetadata = { ...e.sdkProcessingMetadata, ...t };
          })(e, i);
      }
      function rT(e, t) {
        const {
          extra: n,
          tags: r,
          user: s,
          contexts: i,
          level: o,
          sdkProcessingMetadata: a,
          breadcrumbs: c,
          fingerprint: l,
          eventProcessors: u,
          attachments: d,
          propagationContext: h,
          transactionName: p,
          span: f,
        } = t;
        sT(e, "extra", n),
          sT(e, "tags", r),
          sT(e, "user", s),
          sT(e, "contexts", i),
          sT(e, "sdkProcessingMetadata", a),
          o && (e.level = o),
          p && (e.transactionName = p),
          f && (e.span = f),
          c.length && (e.breadcrumbs = [...e.breadcrumbs, ...c]),
          l.length && (e.fingerprint = [...e.fingerprint, ...l]),
          u.length && (e.eventProcessors = [...e.eventProcessors, ...u]),
          d.length && (e.attachments = [...e.attachments, ...d]),
          (e.propagationContext = { ...e.propagationContext, ...h });
      }
      function sT(e, t, n) {
        if (n && Object.keys(n).length) {
          e[t] = { ...e[t] };
          for (const r in n)
            Object.prototype.hasOwnProperty.call(n, r) && (e[t][r] = n[r]);
        }
      }
      let iT;
      class oT {
        constructor() {
          (this._notifyingListeners = !1),
            (this._scopeListeners = []),
            (this._eventProcessors = []),
            (this._breadcrumbs = []),
            (this._attachments = []),
            (this._user = {}),
            (this._tags = {}),
            (this._extra = {}),
            (this._contexts = {}),
            (this._sdkProcessingMetadata = {}),
            (this._propagationContext = aT());
        }
        static clone(e) {
          return e ? e.clone() : new oT();
        }
        clone() {
          const e = new oT();
          return (
            (e._breadcrumbs = [...this._breadcrumbs]),
            (e._tags = { ...this._tags }),
            (e._extra = { ...this._extra }),
            (e._contexts = { ...this._contexts }),
            (e._user = this._user),
            (e._level = this._level),
            (e._span = this._span),
            (e._session = this._session),
            (e._transactionName = this._transactionName),
            (e._fingerprint = this._fingerprint),
            (e._eventProcessors = [...this._eventProcessors]),
            (e._requestSession = this._requestSession),
            (e._attachments = [...this._attachments]),
            (e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }),
            (e._propagationContext = { ...this._propagationContext }),
            (e._client = this._client),
            e
          );
        }
        setClient(e) {
          this._client = e;
        }
        getClient() {
          return this._client;
        }
        addScopeListener(e) {
          this._scopeListeners.push(e);
        }
        addEventProcessor(e) {
          return this._eventProcessors.push(e), this;
        }
        setUser(e) {
          return (
            (this._user = e || {
              email: void 0,
              id: void 0,
              ip_address: void 0,
              segment: void 0,
              username: void 0,
            }),
            this._session && GA(this._session, { user: e }),
            this._notifyScopeListeners(),
            this
          );
        }
        getUser() {
          return this._user;
        }
        getRequestSession() {
          return this._requestSession;
        }
        setRequestSession(e) {
          return (this._requestSession = e), this;
        }
        setTags(e) {
          return (
            (this._tags = { ...this._tags, ...e }),
            this._notifyScopeListeners(),
            this
          );
        }
        setTag(e, t) {
          return (
            (this._tags = { ...this._tags, [e]: t }),
            this._notifyScopeListeners(),
            this
          );
        }
        setExtras(e) {
          return (
            (this._extra = { ...this._extra, ...e }),
            this._notifyScopeListeners(),
            this
          );
        }
        setExtra(e, t) {
          return (
            (this._extra = { ...this._extra, [e]: t }),
            this._notifyScopeListeners(),
            this
          );
        }
        setFingerprint(e) {
          return (this._fingerprint = e), this._notifyScopeListeners(), this;
        }
        setLevel(e) {
          return (this._level = e), this._notifyScopeListeners(), this;
        }
        setTransactionName(e) {
          return (
            (this._transactionName = e), this._notifyScopeListeners(), this
          );
        }
        setContext(e, t) {
          return (
            null === t ? delete this._contexts[e] : (this._contexts[e] = t),
            this._notifyScopeListeners(),
            this
          );
        }
        setSpan(e) {
          return (this._span = e), this._notifyScopeListeners(), this;
        }
        getSpan() {
          return this._span;
        }
        getTransaction() {
          const e = this._span;
          return e && e.transaction;
        }
        setSession(e) {
          return (
            e ? (this._session = e) : delete this._session,
            this._notifyScopeListeners(),
            this
          );
        }
        getSession() {
          return this._session;
        }
        update(e) {
          if (!e) return this;
          const t = "function" === typeof e ? e(this) : e;
          if (t instanceof oT) {
            const e = t.getScopeData();
            (this._tags = { ...this._tags, ...e.tags }),
              (this._extra = { ...this._extra, ...e.extra }),
              (this._contexts = { ...this._contexts, ...e.contexts }),
              e.user && Object.keys(e.user).length && (this._user = e.user),
              e.level && (this._level = e.level),
              e.fingerprint.length && (this._fingerprint = e.fingerprint),
              t.getRequestSession() &&
                (this._requestSession = t.getRequestSession()),
              e.propagationContext &&
                (this._propagationContext = e.propagationContext);
          } else if (eA(t)) {
            const t = e;
            (this._tags = { ...this._tags, ...t.tags }),
              (this._extra = { ...this._extra, ...t.extra }),
              (this._contexts = { ...this._contexts, ...t.contexts }),
              t.user && (this._user = t.user),
              t.level && (this._level = t.level),
              t.fingerprint && (this._fingerprint = t.fingerprint),
              t.requestSession && (this._requestSession = t.requestSession),
              t.propagationContext &&
                (this._propagationContext = t.propagationContext);
          }
          return this;
        }
        clear() {
          return (
            (this._breadcrumbs = []),
            (this._tags = {}),
            (this._extra = {}),
            (this._user = {}),
            (this._contexts = {}),
            (this._level = void 0),
            (this._transactionName = void 0),
            (this._fingerprint = void 0),
            (this._requestSession = void 0),
            (this._span = void 0),
            (this._session = void 0),
            this._notifyScopeListeners(),
            (this._attachments = []),
            (this._propagationContext = aT()),
            this
          );
        }
        addBreadcrumb(e, t) {
          const n = "number" === typeof t ? t : 100;
          if (n <= 0) return this;
          const r = { timestamp: MA(), ...e },
            s = this._breadcrumbs;
          return (
            s.push(r),
            (this._breadcrumbs = s.length > n ? s.slice(-n) : s),
            this._notifyScopeListeners(),
            this
          );
        }
        getLastBreadcrumb() {
          return this._breadcrumbs[this._breadcrumbs.length - 1];
        }
        clearBreadcrumbs() {
          return (this._breadcrumbs = []), this._notifyScopeListeners(), this;
        }
        addAttachment(e) {
          return this._attachments.push(e), this;
        }
        getAttachments() {
          return this.getScopeData().attachments;
        }
        clearAttachments() {
          return (this._attachments = []), this;
        }
        getScopeData() {
          const {
            _breadcrumbs: e,
            _attachments: t,
            _contexts: n,
            _tags: r,
            _extra: s,
            _user: i,
            _level: o,
            _fingerprint: a,
            _eventProcessors: c,
            _propagationContext: l,
            _sdkProcessingMetadata: u,
            _transactionName: d,
            _span: h,
          } = this;
          return {
            breadcrumbs: e,
            attachments: t,
            contexts: n,
            tags: r,
            extra: s,
            user: i,
            level: o,
            fingerprint: a || [],
            eventProcessors: c,
            propagationContext: l,
            sdkProcessingMetadata: u,
            transactionName: d,
            span: h,
          };
        }
        applyToEvent(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : [];
          nT(e, this.getScopeData());
          return KA([...n, ...HA(), ...this._eventProcessors], e, t);
        }
        setSDKProcessingMetadata(e) {
          return (
            (this._sdkProcessingMetadata = {
              ...this._sdkProcessingMetadata,
              ...e,
            }),
            this
          );
        }
        setPropagationContext(e) {
          return (this._propagationContext = e), this;
        }
        getPropagationContext() {
          return this._propagationContext;
        }
        captureException(e, t) {
          const n = t && t.event_id ? t.event_id : IA();
          if (!this._client)
            return (
              pA.warn(
                "No client configured on scope - will not capture exception!"
              ),
              n
            );
          const r = new Error("Sentry syntheticException");
          return (
            this._client.captureException(
              e,
              {
                originalException: e,
                syntheticException: r,
                ...t,
                event_id: n,
              },
              this
            ),
            n
          );
        }
        captureMessage(e, t, n) {
          const r = n && n.event_id ? n.event_id : IA();
          if (!this._client)
            return (
              pA.warn(
                "No client configured on scope - will not capture message!"
              ),
              r
            );
          const s = new Error(e);
          return (
            this._client.captureMessage(
              e,
              t,
              {
                originalException: e,
                syntheticException: s,
                ...n,
                event_id: r,
              },
              this
            ),
            r
          );
        }
        captureEvent(e, t) {
          const n = t && t.event_id ? t.event_id : IA();
          return this._client
            ? (this._client.captureEvent(e, { ...t, event_id: n }, this), n)
            : (pA.warn(
                "No client configured on scope - will not capture event!"
              ),
              n);
        }
        _notifyScopeListeners() {
          this._notifyingListeners ||
            ((this._notifyingListeners = !0),
            this._scopeListeners.forEach((e) => {
              e(this);
            }),
            (this._notifyingListeners = !1));
        }
      }
      function aT() {
        return { traceId: IA(), spanId: IA().substring(16) };
      }
      const cT = "7.116.0",
        lT = parseFloat(cT),
        uT = 100;
      class dT {
        constructor(e, t, n) {
          let r,
            s,
            i =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : lT;
          (this._version = i),
            t ? (r = t) : ((r = new oT()), r.setClient(e)),
            n ? (s = n) : ((s = new oT()), s.setClient(e)),
            (this._stack = [{ scope: r }]),
            e && this.bindClient(e),
            (this._isolationScope = s);
        }
        isOlderThan(e) {
          return this._version < e;
        }
        bindClient(e) {
          const t = this.getStackTop();
          (t.client = e),
            t.scope.setClient(e),
            e && e.setupIntegrations && e.setupIntegrations();
        }
        pushScope() {
          const e = this.getScope().clone();
          return (
            this.getStack().push({ client: this.getClient(), scope: e }), e
          );
        }
        popScope() {
          return !(this.getStack().length <= 1) && !!this.getStack().pop();
        }
        withScope(e) {
          const t = this.pushScope();
          let n;
          try {
            n = e(t);
          } catch (a_) {
            throw (this.popScope(), a_);
          }
          return nA(n)
            ? n.then(
                (e) => (this.popScope(), e),
                (e) => {
                  throw (this.popScope(), e);
                }
              )
            : (this.popScope(), n);
        }
        getClient() {
          return this.getStackTop().client;
        }
        getScope() {
          return this.getStackTop().scope;
        }
        getIsolationScope() {
          return this._isolationScope;
        }
        getStack() {
          return this._stack;
        }
        getStackTop() {
          return this._stack[this._stack.length - 1];
        }
        captureException(e, t) {
          const n = (this._lastEventId = t && t.event_id ? t.event_id : IA()),
            r = new Error("Sentry syntheticException");
          return (
            this.getScope().captureException(e, {
              originalException: e,
              syntheticException: r,
              ...t,
              event_id: n,
            }),
            n
          );
        }
        captureMessage(e, t, n) {
          const r = (this._lastEventId = n && n.event_id ? n.event_id : IA()),
            s = new Error(e);
          return (
            this.getScope().captureMessage(e, t, {
              originalException: e,
              syntheticException: s,
              ...n,
              event_id: r,
            }),
            r
          );
        }
        captureEvent(e, t) {
          const n = t && t.event_id ? t.event_id : IA();
          return (
            e.type || (this._lastEventId = n),
            this.getScope().captureEvent(e, { ...t, event_id: n }),
            n
          );
        }
        lastEventId() {
          return this._lastEventId;
        }
        addBreadcrumb(e, t) {
          const { scope: n, client: r } = this.getStackTop();
          if (!r) return;
          const { beforeBreadcrumb: s = null, maxBreadcrumbs: i = uT } =
            (r.getOptions && r.getOptions()) || {};
          if (i <= 0) return;
          const o = { timestamp: MA(), ...e },
            a = s ? hA(() => s(o, t)) : o;
          null !== a &&
            (r.emit && r.emit("beforeAddBreadcrumb", a, t),
            n.addBreadcrumb(a, i));
        }
        setUser(e) {
          this.getScope().setUser(e), this.getIsolationScope().setUser(e);
        }
        setTags(e) {
          this.getScope().setTags(e), this.getIsolationScope().setTags(e);
        }
        setExtras(e) {
          this.getScope().setExtras(e), this.getIsolationScope().setExtras(e);
        }
        setTag(e, t) {
          this.getScope().setTag(e, t), this.getIsolationScope().setTag(e, t);
        }
        setExtra(e, t) {
          this.getScope().setExtra(e, t),
            this.getIsolationScope().setExtra(e, t);
        }
        setContext(e, t) {
          this.getScope().setContext(e, t),
            this.getIsolationScope().setContext(e, t);
        }
        configureScope(e) {
          const { scope: t, client: n } = this.getStackTop();
          n && e(t);
        }
        run(e) {
          const t = pT(this);
          try {
            e(this);
          } finally {
            pT(t);
          }
        }
        getIntegration(e) {
          const t = this.getClient();
          if (!t) return null;
          try {
            return t.getIntegration(e);
          } catch (n) {
            return (
              UA &&
                pA.warn(
                  "Cannot retrieve integration ".concat(
                    e.id,
                    " from the current Hub"
                  )
                ),
              null
            );
          }
        }
        startTransaction(e, t) {
          const n = this._callExtensionMethod("startTransaction", e, t);
          if (UA && !n) {
            this.getClient()
              ? pA.warn(
                  "Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n"
                )
              : pA.warn(
                  "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'"
                );
          }
          return n;
        }
        traceHeaders() {
          return this._callExtensionMethod("traceHeaders");
        }
        captureSession() {
          if (arguments.length > 0 && void 0 !== arguments[0] && arguments[0])
            return this.endSession();
          this._sendSessionUpdate();
        }
        endSession() {
          const e = this.getStackTop().scope,
            t = e.getSession();
          t && JA(t), this._sendSessionUpdate(), e.setSession();
        }
        startSession(e) {
          const { scope: t, client: n } = this.getStackTop(),
            { release: r, environment: s = KE } = (n && n.getOptions()) || {},
            { userAgent: i } = qE.navigator || {},
            o = zA({
              release: r,
              environment: s,
              user: t.getUser(),
              ...(i && { userAgent: i }),
              ...e,
            }),
            a = t.getSession && t.getSession();
          return (
            a && "ok" === a.status && GA(a, { status: "exited" }),
            this.endSession(),
            t.setSession(o),
            o
          );
        }
        shouldSendDefaultPii() {
          const e = this.getClient(),
            t = e && e.getOptions();
          return Boolean(t && t.sendDefaultPii);
        }
        _sendSessionUpdate() {
          const { scope: e, client: t } = this.getStackTop(),
            n = e.getSession();
          n && t && t.captureSession && t.captureSession(n);
        }
        _callExtensionMethod(e) {
          const t = hT().__SENTRY__;
          if (t && t.extensions && "function" === typeof t.extensions[e]) {
            for (
              var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), s = 1;
              s < n;
              s++
            )
              r[s - 1] = arguments[s];
            return t.extensions[e].apply(this, r);
          }
          UA &&
            pA.warn(
              "Extension method ".concat(
                e,
                " couldn't be found, doing nothing."
              )
            );
        }
      }
      function hT() {
        return (
          (qE.__SENTRY__ = qE.__SENTRY__ || { extensions: {}, hub: void 0 }), qE
        );
      }
      function pT(e) {
        const t = hT(),
          n = yT(t);
        return bT(t, e), n;
      }
      function fT() {
        const e = hT();
        if (e.__SENTRY__ && e.__SENTRY__.acs) {
          const t = e.__SENTRY__.acs.getCurrentHub();
          if (t) return t;
        }
        return gT(e);
      }
      function mT() {
        return fT().getIsolationScope();
      }
      function gT() {
        let e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : hT();
        return (vT(e) && !yT(e).isOlderThan(lT)) || bT(e, new dT()), yT(e);
      }
      function vT(e) {
        return !!(e && e.__SENTRY__ && e.__SENTRY__.hub);
      }
      function yT(e) {
        return WE("hub", () => new dT(), e);
      }
      function bT(e, t) {
        if (!e) return !1;
        return ((e.__SENTRY__ = e.__SENTRY__ || {}).hub = t), !0;
      }
      const wT = 50,
        ST = /\(error: (.*)\)/,
        _T = /captureMessage|captureException/;
      function ET() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        const r = t.sort((e, t) => e[0] - t[0]).map((e) => e[1]);
        return function (e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          const n = [],
            s = e.split("\n");
          for (let i = t; i < s.length; i++) {
            const e = s[i];
            if (e.length > 1024) continue;
            const t = ST.test(e) ? e.replace(ST, "$1") : e;
            if (!t.match(/\S*Error: /)) {
              for (const e of r) {
                const r = e(t);
                if (r) {
                  n.push(r);
                  break;
                }
              }
              if (n.length >= wT) break;
            }
          }
          return (function (e) {
            if (!e.length) return [];
            const t = Array.from(e);
            /sentryWrapped/.test(t[t.length - 1].function || "") && t.pop();
            t.reverse(),
              _T.test(t[t.length - 1].function || "") &&
                (t.pop(), _T.test(t[t.length - 1].function || "") && t.pop());
            return t.slice(0, wT).map((e) => ({
              ...e,
              filename: e.filename || t[t.length - 1].filename,
              function: e.function || "?",
            }));
          })(n);
        };
      }
      const AT = "<anonymous>";
      function TT(e) {
        try {
          return (e && "function" === typeof e && e.name) || AT;
        } catch (a_) {
          return AT;
        }
      }
      function PT(e) {
        let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : 100,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : 1 / 0;
        try {
          return CT("", e, t, n);
        } catch (r) {
          return { ERROR: "**non-serializable** (".concat(r, ")") };
        }
      }
      function IT(e) {
        let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : 102400;
        const r = PT(e, t);
        return (function (e) {
          return (function (e) {
            return ~-encodeURI(e).split(/%..|./).length;
          })(JSON.stringify(e));
        })(r) > n
          ? IT(e, t - 1, n)
          : r;
      }
      function CT(e, t) {
        let r =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : 1 / 0,
          s =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : 1 / 0,
          i =
            arguments.length > 4 && void 0 !== arguments[4]
              ? arguments[4]
              : (function () {
                  const e = "function" === typeof WeakSet,
                    t = e ? new WeakSet() : [];
                  return [
                    function (n) {
                      if (e) return !!t.has(n) || (t.add(n), !1);
                      for (let e = 0; e < t.length; e++)
                        if (t[e] === n) return !0;
                      return t.push(n), !1;
                    },
                    function (n) {
                      if (e) t.delete(n);
                      else
                        for (let e = 0; e < t.length; e++)
                          if (t[e] === n) {
                            t.splice(e, 1);
                            break;
                          }
                    },
                  ];
                })();
        const [o, a] = i;
        if (
          null == t ||
          (["number", "boolean", "string"].includes(typeof t) &&
            ("number" !== typeof (c = t) || c === c))
        )
          return t;
        var c;
        const l = (function (e, t) {
          try {
            if ("domain" === e && t && "object" === typeof t && t._events)
              return "[Domain]";
            if ("domainEmitter" === e) return "[DomainEmitter]";
            if ("undefined" !== typeof n.g && t === n.g) return "[Global]";
            if ("undefined" !== typeof window && t === window)
              return "[Window]";
            if ("undefined" !== typeof document && t === document)
              return "[Document]";
            if (sA(t)) return "[VueViewModel]";
            if (
              (function (e) {
                return (
                  eA(e) &&
                  "nativeEvent" in e &&
                  "preventDefault" in e &&
                  "stopPropagation" in e
                );
              })(t)
            )
              return "[SyntheticEvent]";
            if ("number" === typeof t && t !== t) return "[NaN]";
            if ("function" === typeof t)
              return "[Function: ".concat(TT(t), "]");
            if ("symbol" === typeof t) return "[".concat(String(t), "]");
            if ("bigint" === typeof t)
              return "[BigInt: ".concat(String(t), "]");
            const r = (function (e) {
              const t = Object.getPrototypeOf(e);
              return t ? t.constructor.name : "null prototype";
            })(t);
            return /^HTML(\w*)Element$/.test(r)
              ? "[HTMLElement: ".concat(r, "]")
              : "[object ".concat(r, "]");
          } catch (r) {
            return "**non-serializable** (".concat(r, ")");
          }
        })(e, t);
        if (!l.startsWith("[object ")) return l;
        if (t.__sentry_skip_normalization__) return t;
        const u =
          "number" === typeof t.__sentry_override_normalization_depth__
            ? t.__sentry_override_normalization_depth__
            : r;
        if (0 === u) return l.replace("object ", "");
        if (o(t)) return "[Circular ~]";
        const d = t;
        if (d && "function" === typeof d.toJSON)
          try {
            return CT("", d.toJSON(), u - 1, s, i);
          } catch (m) {}
        const h = Array.isArray(t) ? [] : {};
        let p = 0;
        const f = _A(t);
        for (const n in f) {
          if (!Object.prototype.hasOwnProperty.call(f, n)) continue;
          if (p >= s) {
            h[n] = "[MaxProperties ~]";
            break;
          }
          const e = f[n];
          (h[n] = CT(n, e, u - 1, s, i)), p++;
        }
        return a(t), h;
      }
      function kT(e, t, n, r, s, i) {
        const { normalizeDepth: o = 3, normalizeMaxBreadth: a = 1e3 } = e,
          c = {
            ...t,
            event_id: t.event_id || n.event_id || IA(),
            timestamp: t.timestamp || MA(),
          },
          l = n.integrations || e.integrations.map((e) => e.name);
        !(function (e, t) {
          const {
            environment: n,
            release: r,
            dist: s,
            maxValueLength: i = 250,
          } = t;
          "environment" in e || (e.environment = "environment" in t ? n : KE);
          void 0 === e.release && void 0 !== r && (e.release = r);
          void 0 === e.dist && void 0 !== s && (e.dist = s);
          e.message && (e.message = fA(e.message, i));
          const o = e.exception && e.exception.values && e.exception.values[0];
          o && o.value && (o.value = fA(o.value, i));
          const a = e.request;
          a && a.url && (a.url = fA(a.url, i));
        })(c, e),
          (function (e, t) {
            t.length > 0 &&
              ((e.sdk = e.sdk || {}),
              (e.sdk.integrations = [...(e.sdk.integrations || []), ...t]));
          })(c, l),
          void 0 === t.type &&
            (function (e, t) {
              const n = qE._sentryDebugIds;
              if (!n) return;
              let r;
              const s = OT.get(t);
              s ? (r = s) : ((r = new Map()), OT.set(t, r));
              const i = Object.keys(n).reduce((e, s) => {
                let i;
                const o = r.get(s);
                o ? (i = o) : ((i = t(s)), r.set(s, i));
                for (let t = i.length - 1; t >= 0; t--) {
                  const r = i[t];
                  if (r.filename) {
                    e[r.filename] = n[s];
                    break;
                  }
                }
                return e;
              }, {});
              try {
                e.exception.values.forEach((e) => {
                  e.stacktrace.frames.forEach((e) => {
                    e.filename && (e.debug_id = i[e.filename]);
                  });
                });
              } catch (a_) {}
            })(c, e.stackParser);
        const u = (function (e, t) {
          if (!t) return e;
          const n = e ? e.clone() : new oT();
          return n.update(t), n;
        })(r, n.captureContext);
        n.mechanism && xA(c, n.mechanism);
        const d = s && s.getEventProcessors ? s.getEventProcessors() : [],
          h = (iT || (iT = new oT()), iT).getScopeData();
        if (i) {
          rT(h, i.getScopeData());
        }
        if (u) {
          rT(h, u.getScopeData());
        }
        const p = [...(n.attachments || []), ...h.attachments];
        p.length && (n.attachments = p), nT(c, h);
        return KA([...d, ...HA(), ...h.eventProcessors], c, n).then(
          (e) => (
            e &&
              (function (e) {
                const t = {};
                try {
                  e.exception.values.forEach((e) => {
                    e.stacktrace.frames.forEach((e) => {
                      e.debug_id &&
                        (e.abs_path
                          ? (t[e.abs_path] = e.debug_id)
                          : e.filename && (t[e.filename] = e.debug_id),
                        delete e.debug_id);
                    });
                  });
                } catch (a_) {}
                if (0 === Object.keys(t).length) return;
                (e.debug_meta = e.debug_meta || {}),
                  (e.debug_meta.images = e.debug_meta.images || []);
                const n = e.debug_meta.images;
                Object.keys(t).forEach((e) => {
                  n.push({ type: "sourcemap", code_file: e, debug_id: t[e] });
                });
              })(e),
            "number" === typeof o && o > 0
              ? (function (e, t, n) {
                  if (!e) return null;
                  const r = {
                    ...e,
                    ...(e.breadcrumbs && {
                      breadcrumbs: e.breadcrumbs.map((e) => ({
                        ...e,
                        ...(e.data && { data: PT(e.data, t, n) }),
                      })),
                    }),
                    ...(e.user && { user: PT(e.user, t, n) }),
                    ...(e.contexts && { contexts: PT(e.contexts, t, n) }),
                    ...(e.extra && { extra: PT(e.extra, t, n) }),
                  };
                  e.contexts &&
                    e.contexts.trace &&
                    r.contexts &&
                    ((r.contexts.trace = e.contexts.trace),
                    e.contexts.trace.data &&
                      (r.contexts.trace.data = PT(
                        e.contexts.trace.data,
                        t,
                        n
                      )));
                  e.spans &&
                    (r.spans = e.spans.map((e) => {
                      const r = ZA(e).data;
                      return r && (e.data = PT(r, t, n)), e;
                    }));
                  return r;
                })(e, o, a)
              : e
          )
        );
      }
      const OT = new WeakMap();
      function xT(e) {
        if (e)
          return (function (e) {
            return e instanceof oT || "function" === typeof e;
          })(e) ||
            (function (e) {
              return Object.keys(e).some((e) => NT.includes(e));
            })(e)
            ? { captureContext: e }
            : e;
      }
      const NT = [
        "user",
        "level",
        "extra",
        "contexts",
        "tags",
        "fingerprint",
        "requestSession",
        "propagationContext",
      ];
      function RT(e, t) {
        return fT().captureException(e, xT(t));
      }
      function DT(e, t) {
        const n = "string" === typeof t ? t : void 0,
          r = "string" !== typeof t ? { captureContext: t } : void 0;
        return fT().captureMessage(e, n, r);
      }
      function MT(e, t) {
        return fT().captureEvent(e, t);
      }
      function jT(e, t) {
        fT().addBreadcrumb(e, t);
      }
      function LT() {
        const e = fT();
        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
          n[r] = arguments[r];
        if (2 === n.length) {
          const [t, r] = n;
          return t
            ? e.withScope(() => ((e.getStackTop().scope = t), r(t)))
            : e.withScope(r);
        }
        return e.withScope(n[0]);
      }
      function UT() {
        return fT().getClient();
      }
      function FT() {
        return fT().getScope();
      }
      function BT(e) {
        const t = UT(),
          n = mT(),
          r = FT(),
          { release: s, environment: i = KE } = (t && t.getOptions()) || {},
          { userAgent: o } = qE.navigator || {},
          a = zA({
            release: s,
            environment: i,
            user: r.getUser() || n.getUser(),
            ...(o && { userAgent: o }),
            ...e,
          }),
          c = n.getSession();
        return (
          c && "ok" === c.status && GA(c, { status: "exited" }),
          VT(),
          n.setSession(a),
          r.setSession(a),
          a
        );
      }
      function VT() {
        const e = mT(),
          t = FT(),
          n = t.getSession() || e.getSession();
        n && JA(n), qT(), e.setSession(), t.setSession();
      }
      function qT() {
        const e = mT(),
          t = FT(),
          n = UT(),
          r = t.getSession() || e.getSession();
        r && n && n.captureSession && n.captureSession(r);
      }
      function HT() {
        arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
          ? VT()
          : qT();
      }
      const WT = [];
      function KT(e) {
        const t = e.defaultIntegrations || [],
          n = e.integrations;
        let r;
        t.forEach((e) => {
          e.isDefaultInstance = !0;
        }),
          (r = Array.isArray(n)
            ? [...t, ...n]
            : "function" === typeof n
            ? RA(n(t))
            : t);
        const s = (function (e) {
            const t = {};
            return (
              e.forEach((e) => {
                const { name: n } = e,
                  r = t[n];
                (r && !r.isDefaultInstance && e.isDefaultInstance) ||
                  (t[n] = e);
              }),
              Object.keys(t).map((e) => t[e])
            );
          })(r),
          i = (function (e, t) {
            for (let n = 0; n < e.length; n++) if (!0 === t(e[n])) return n;
            return -1;
          })(s, (e) => "Debug" === e.name);
        if (-1 !== i) {
          const [e] = s.splice(i, 1);
          s.push(e);
        }
        return s;
      }
      function zT(e, t) {
        for (const n of t) n && n.afterAllSetup && n.afterAllSetup(e);
      }
      function GT(e, t, n) {
        if (n[t.name])
          UA &&
            pA.log(
              "Integration skipped because it was already installed: ".concat(
                t.name
              )
            );
        else {
          if (
            ((n[t.name] = t),
            -1 === WT.indexOf(t.name) && (t.setupOnce(WA, fT), WT.push(t.name)),
            t.setup && "function" === typeof t.setup && t.setup(e),
            e.on && "function" === typeof t.preprocessEvent)
          ) {
            const n = t.preprocessEvent.bind(t);
            e.on("preprocessEvent", (t, r) => n(t, r, e));
          }
          if (e.addEventProcessor && "function" === typeof t.processEvent) {
            const n = t.processEvent.bind(t),
              r = Object.assign((t, r) => n(t, r, e), { id: t.name });
            e.addEventProcessor(r);
          }
          UA && pA.log("Integration installed: ".concat(t.name));
        }
      }
      function JT(e, t) {
        return Object.assign(
          function () {
            return t(...arguments);
          },
          { id: e }
        );
      }
      const QT = {},
        YT = {};
      function XT(e, t) {
        (QT[e] = QT[e] || []), QT[e].push(t);
      }
      function ZT(e, t) {
        YT[e] || (t(), (YT[e] = !0));
      }
      function $T(e, t) {
        const n = e && QT[e];
        if (n)
          for (const r of n)
            try {
              r(t);
            } catch (a_) {
              lA &&
                pA.error(
                  "Error while triggering instrumentation handler.\nType: "
                    .concat(e, "\nName: ")
                    .concat(TT(r), "\nError:"),
                  a_
                );
            }
      }
      function eP(e) {
        const t = "console";
        XT(t, e), ZT(t, tP);
      }
      function tP() {
        "console" in qE &&
          uA.forEach(function (e) {
            e in qE.console &&
              yA(qE.console, e, function (t) {
                return (
                  (dA[e] = t),
                  function () {
                    for (
                      var t = arguments.length, n = new Array(t), r = 0;
                      r < t;
                      r++
                    )
                      n[r] = arguments[r];
                    $T("console", { args: n, level: e });
                    const s = dA[e];
                    s && s.apply(qE.console, n);
                  }
                );
              });
          });
      }
      const nP = ["fatal", "error", "warning", "log", "info", "debug"];
      function rP(e) {
        return "warn" === e ? "warning" : nP.includes(e) ? e : "log";
      }
      const sP = "CaptureConsole",
        iP = function () {
          const e =
            (arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : {}
            ).levels || uA;
          return {
            name: sP,
            setupOnce() {},
            setup(t) {
              "console" in qE &&
                eP((n) => {
                  let { args: r, level: s } = n;
                  UT() === t &&
                    e.includes(s) &&
                    (function (e, t) {
                      const n = { level: rP(t), extra: { arguments: e } };
                      LT((r) => {
                        if (
                          (r.addEventProcessor(
                            (e) => (
                              (e.logger = "console"),
                              xA(e, { handled: !1, type: "console" }),
                              e
                            )
                          ),
                          "assert" === t && !1 === e[0])
                        ) {
                          const t = "Assertion failed: ".concat(
                            mA(e.slice(1), " ") || "console.assert"
                          );
                          return (
                            r.setExtra("arguments", e.slice(1)), void DT(t, n)
                          );
                        }
                        const s = e.find((e) => e instanceof Error);
                        if ("error" === t && s) return void RT(s, n);
                        DT(mA(e, " "), n);
                      });
                    })(r, s);
                });
            },
          };
        };
      JT(sP, iP);
      const oP = [
          /^Script error\.?$/,
          /^Javascript error: Script error\.? on line 0$/,
          /^ResizeObserver loop completed with undelivered notifications.$/,
          /^Cannot redefine property: googletag$/,
        ],
        aP = [
          /^.*\/healthcheck$/,
          /^.*\/healthy$/,
          /^.*\/live$/,
          /^.*\/ready$/,
          /^.*\/heartbeat$/,
          /^.*\/health$/,
          /^.*\/healthz$/,
        ],
        cP = "InboundFilters",
        lP = function () {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          return {
            name: cP,
            setupOnce() {},
            processEvent(t, n, r) {
              const s = r.getOptions(),
                i = (function () {
                  let e =
                      arguments.length > 0 && void 0 !== arguments[0]
                        ? arguments[0]
                        : {},
                    t =
                      arguments.length > 1 && void 0 !== arguments[1]
                        ? arguments[1]
                        : {};
                  return {
                    allowUrls: [...(e.allowUrls || []), ...(t.allowUrls || [])],
                    denyUrls: [...(e.denyUrls || []), ...(t.denyUrls || [])],
                    ignoreErrors: [
                      ...(e.ignoreErrors || []),
                      ...(t.ignoreErrors || []),
                      ...(e.disableErrorDefaults ? [] : oP),
                    ],
                    ignoreTransactions: [
                      ...(e.ignoreTransactions || []),
                      ...(t.ignoreTransactions || []),
                      ...(e.disableTransactionDefaults ? [] : aP),
                    ],
                    ignoreInternal:
                      void 0 === e.ignoreInternal || e.ignoreInternal,
                  };
                })(e, s);
              return (function (e, t) {
                if (
                  t.ignoreInternal &&
                  (function (e) {
                    try {
                      return "SentryError" === e.exception.values[0].type;
                    } catch (a_) {}
                    return !1;
                  })(e)
                )
                  return (
                    UA &&
                      pA.warn(
                        "Event dropped due to being internal Sentry Error.\nEvent: ".concat(
                          kA(e)
                        )
                      ),
                    !0
                  );
                if (
                  (function (e, t) {
                    if (e.type || !t || !t.length) return !1;
                    return (function (e) {
                      const t = [];
                      e.message && t.push(e.message);
                      let n;
                      try {
                        n = e.exception.values[e.exception.values.length - 1];
                      } catch (a_) {}
                      n &&
                        n.value &&
                        (t.push(n.value),
                        n.type &&
                          t.push("".concat(n.type, ": ").concat(n.value)));
                      UA &&
                        0 === t.length &&
                        pA.error(
                          "Could not extract message for event ".concat(kA(e))
                        );
                      return t;
                    })(e).some((e) => vA(e, t));
                  })(e, t.ignoreErrors)
                )
                  return (
                    UA &&
                      pA.warn(
                        "Event dropped due to being matched by `ignoreErrors` option.\nEvent: ".concat(
                          kA(e)
                        )
                      ),
                    !0
                  );
                if (
                  (function (e, t) {
                    if ("transaction" !== e.type || !t || !t.length) return !1;
                    const n = e.transaction;
                    return !!n && vA(n, t);
                  })(e, t.ignoreTransactions)
                )
                  return (
                    UA &&
                      pA.warn(
                        "Event dropped due to being matched by `ignoreTransactions` option.\nEvent: ".concat(
                          kA(e)
                        )
                      ),
                    !0
                  );
                if (
                  (function (e, t) {
                    if (!t || !t.length) return !1;
                    const n = uP(e);
                    return !!n && vA(n, t);
                  })(e, t.denyUrls)
                )
                  return (
                    UA &&
                      pA.warn(
                        "Event dropped due to being matched by `denyUrls` option.\nEvent: "
                          .concat(kA(e), ".\nUrl: ")
                          .concat(uP(e))
                      ),
                    !0
                  );
                if (
                  !(function (e, t) {
                    if (!t || !t.length) return !0;
                    const n = uP(e);
                    return !n || vA(n, t);
                  })(e, t.allowUrls)
                )
                  return (
                    UA &&
                      pA.warn(
                        "Event dropped due to not being matched by `allowUrls` option.\nEvent: "
                          .concat(kA(e), ".\nUrl: ")
                          .concat(uP(e))
                      ),
                    !0
                  );
                return !1;
              })(t, i)
                ? null
                : t;
            },
          };
        };
      JT(cP, lP);
      function uP(e) {
        try {
          let t;
          try {
            t = e.exception.values[0].stacktrace.frames;
          } catch (a_) {}
          return t
            ? (function () {
                let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : [];
                for (let t = e.length - 1; t >= 0; t--) {
                  const n = e[t];
                  if (
                    n &&
                    "<anonymous>" !== n.filename &&
                    "[native code]" !== n.filename
                  )
                    return n.filename || null;
                }
                return null;
              })(t)
            : null;
        } catch (t) {
          return (
            UA && pA.error("Cannot extract url for event ".concat(kA(e))), null
          );
        }
      }
      let dP;
      const hP = "FunctionToString",
        pP = new WeakMap(),
        fP = () => ({
          name: hP,
          setupOnce() {
            dP = Function.prototype.toString;
            try {
              Function.prototype.toString = function () {
                const e = SA(this),
                  t = pP.has(UT()) && void 0 !== e ? e : this;
                for (
                  var n = arguments.length, r = new Array(n), s = 0;
                  s < n;
                  s++
                )
                  r[s] = arguments[s];
                return dP.apply(t, r);
              };
            } catch (a_) {}
          },
          setup(e) {
            pP.set(e, !0);
          },
        });
      JT(hP, fP);
      function mP(e, t) {
        !0 === t.debug &&
          (UA
            ? pA.enable()
            : hA(() => {
                console.warn(
                  "[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."
                );
              }));
        FT().update(t.initialScope);
        const n = new e(t);
        !(function (e) {
          const t = fT().getStackTop();
          (t.client = e), t.scope.setClient(e);
        })(n),
          (function (e) {
            e.init ? e.init() : e.setupIntegrations && e.setupIntegrations();
          })(n);
      }
      const gP = HE();
      function vP() {
        if (!("fetch" in gP)) return !1;
        try {
          return (
            new Headers(),
            new Request("http://www.example.com"),
            new Response(),
            !0
          );
        } catch (a_) {
          return !1;
        }
      }
      function yP(e) {
        return (
          e &&
          /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString())
        );
      }
      const bP = HE();
      const wP = qE;
      let SP;
      function _P(e) {
        const t = "history";
        XT(t, e), ZT(t, EP);
      }
      function EP() {
        if (
          !(function () {
            const e = bP.chrome,
              t = e && e.app && e.app.runtime,
              n =
                "history" in bP &&
                !!bP.history.pushState &&
                !!bP.history.replaceState;
            return !t && n;
          })()
        )
          return;
        const e = wP.onpopstate;
        function t(e) {
          return function () {
            for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
              n[r] = arguments[r];
            const s = n.length > 2 ? n[2] : void 0;
            if (s) {
              const e = SP,
                t = String(s);
              SP = t;
              $T("history", { from: e, to: t });
            }
            return e.apply(this, n);
          };
        }
        (wP.onpopstate = function () {
          const t = wP.location.href,
            n = SP;
          SP = t;
          if (($T("history", { from: n, to: t }), e))
            try {
              for (
                var r = arguments.length, s = new Array(r), i = 0;
                i < r;
                i++
              )
                s[i] = arguments[i];
              return e.apply(this, s);
            } catch (o) {}
        }),
          yA(wP.history, "pushState", t),
          yA(wP.history, "replaceState", t);
      }
      const AP =
        /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
      function TP(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        const {
          host: n,
          path: r,
          pass: s,
          port: i,
          projectId: o,
          protocol: a,
          publicKey: c,
        } = e;
        return (
          ""
            .concat(a, "://")
            .concat(c)
            .concat(t && s ? ":".concat(s) : "") +
          "@"
            .concat(n)
            .concat(i ? ":".concat(i) : "", "/")
            .concat(r ? "".concat(r, "/") : r)
            .concat(o)
        );
      }
      function PP(e) {
        return {
          protocol: e.protocol,
          publicKey: e.publicKey || "",
          pass: e.pass || "",
          host: e.host,
          port: e.port || "",
          path: e.path || "",
          projectId: e.projectId,
        };
      }
      function IP(e) {
        const t =
          "string" === typeof e
            ? (function (e) {
                const t = AP.exec(e);
                if (!t)
                  return void hA(() => {
                    console.error("Invalid Sentry Dsn: ".concat(e));
                  });
                const [n, r, s = "", i, o = "", a] = t.slice(1);
                let c = "",
                  l = a;
                const u = l.split("/");
                if (
                  (u.length > 1 &&
                    ((c = u.slice(0, -1).join("/")), (l = u.pop())),
                  l)
                ) {
                  const e = l.match(/^\d+/);
                  e && (l = e[0]);
                }
                return PP({
                  host: i,
                  pass: s,
                  path: c,
                  projectId: l,
                  port: o,
                  protocol: n,
                  publicKey: r,
                });
              })(e)
            : PP(e);
        if (
          t &&
          (function (e) {
            if (!lA) return !0;
            const { port: t, projectId: n, protocol: r } = e;
            return (
              !["protocol", "publicKey", "host", "projectId"].find(
                (t) =>
                  !e[t] &&
                  (pA.error("Invalid Sentry Dsn: ".concat(t, " missing")), !0)
              ) &&
              (n.match(/^\d+$/)
                ? (function (e) {
                    return "http" === e || "https" === e;
                  })(r)
                  ? !t ||
                    !isNaN(parseInt(t, 10)) ||
                    (pA.error("Invalid Sentry Dsn: Invalid port ".concat(t)),
                    !1)
                  : (pA.error(
                      "Invalid Sentry Dsn: Invalid protocol ".concat(r)
                    ),
                    !1)
                : (pA.error("Invalid Sentry Dsn: Invalid projectId ".concat(n)),
                  !1))
            );
          })(t)
        )
          return t;
      }
      function CP(e) {
        return [
          e,
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
        ];
      }
      function kP(e, t) {
        const [n, r] = e;
        return [n, [...r, t]];
      }
      function OP(e, t) {
        const n = e[1];
        for (const r of n) {
          if (t(r, r[0].type)) return !0;
        }
        return !1;
      }
      function xP(e, t) {
        return (t || new TextEncoder()).encode(e);
      }
      function NP(e, t) {
        const [n, r] = e;
        let s = JSON.stringify(n);
        function i(e) {
          "string" === typeof s
            ? (s = "string" === typeof e ? s + e : [xP(s, t), e])
            : s.push("string" === typeof e ? xP(e, t) : e);
        }
        for (const o of r) {
          const [e, t] = o;
          if (
            (i("\n".concat(JSON.stringify(e), "\n")),
            "string" === typeof t || t instanceof Uint8Array)
          )
            i(t);
          else {
            let e;
            try {
              e = JSON.stringify(t);
            } catch (a_) {
              e = JSON.stringify(PT(t));
            }
            i(e);
          }
        }
        return "string" === typeof s
          ? s
          : (function (e) {
              const t = e.reduce((e, t) => e + t.length, 0),
                n = new Uint8Array(t);
              let r = 0;
              for (const s of e) n.set(s, r), (r += s.length);
              return n;
            })(s);
      }
      function RP(e, t) {
        const n = "string" === typeof e.data ? xP(e.data, t) : e.data;
        return [
          TA({
            type: "attachment",
            length: n.length,
            filename: e.filename,
            content_type: e.contentType,
            attachment_type: e.attachmentType,
          }),
          n,
        ];
      }
      const DP = {
        session: "session",
        sessions: "session",
        attachment: "attachment",
        transaction: "transaction",
        event: "error",
        client_report: "internal",
        user_report: "default",
        profile: "profile",
        replay_event: "replay",
        replay_recording: "replay",
        check_in: "monitor",
        feedback: "feedback",
        span: "span",
        statsd: "metric_bucket",
      };
      function MP(e) {
        return DP[e];
      }
      function jP(e) {
        if (!e || !e.sdk) return;
        const { name: t, version: n } = e.sdk;
        return { name: t, version: n };
      }
      class LP extends Error {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : "warn";
          super(e),
            (this.message = e),
            (this.name = new.target.prototype.constructor.name),
            Object.setPrototypeOf(this, new.target.prototype),
            (this.logLevel = t);
        }
      }
      const UP = "7";
      function FP(e) {
        const t = e.protocol ? "".concat(e.protocol, ":") : "",
          n = e.port ? ":".concat(e.port) : "";
        return ""
          .concat(t, "//")
          .concat(e.host)
          .concat(n)
          .concat(e.path ? "/".concat(e.path) : "", "/api/");
      }
      function BP(e, t) {
        return (function (e) {
          return Object.keys(e)
            .map((t) =>
              ""
                .concat(encodeURIComponent(t), "=")
                .concat(encodeURIComponent(e[t]))
            )
            .join("&");
        })({
          sentry_key: e.publicKey,
          sentry_version: UP,
          ...(t && { sentry_client: "".concat(t.name, "/").concat(t.version) }),
        });
      }
      function VP(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const n = "string" === typeof t ? t : t.tunnel,
          r = "string" !== typeof t && t._metadata ? t._metadata.sdk : void 0;
        return (
          n ||
          ""
            .concat(
              (function (e) {
                return "".concat(FP(e)).concat(e.projectId, "/envelope/");
              })(e),
              "?"
            )
            .concat(BP(e, r))
        );
      }
      function qP(e, t, n, r) {
        const s = jP(n),
          i = e.type && "replay_event" !== e.type ? e.type : "event";
        !(function (e, t) {
          t &&
            ((e.sdk = e.sdk || {}),
            (e.sdk.name = e.sdk.name || t.name),
            (e.sdk.version = e.sdk.version || t.version),
            (e.sdk.integrations = [
              ...(e.sdk.integrations || []),
              ...(t.integrations || []),
            ]),
            (e.sdk.packages = [
              ...(e.sdk.packages || []),
              ...(t.packages || []),
            ]));
        })(e, n && n.sdk);
        const o = (function (e, t, n, r) {
          const s =
            e.sdkProcessingMetadata &&
            e.sdkProcessingMetadata.dynamicSamplingContext;
          return {
            event_id: e.event_id,
            sent_at: new Date().toISOString(),
            ...(t && { sdk: t }),
            ...(!!n && r && { dsn: TP(r) }),
            ...(s && { trace: TA({ ...s }) }),
          };
        })(e, s, r, t);
        delete e.sdkProcessingMetadata;
        return CP(o, [[{ type: i }, e]]);
      }
      function HP(e, t, n, r) {
        const s = { sent_at: new Date().toISOString() };
        n && n.sdk && (s.sdk = { name: n.sdk.name, version: n.sdk.version }),
          r && t && (s.dsn = TP(t));
        const i = (function (e) {
          const t = (function (e) {
              let t = "";
              for (const n of e) {
                const e = Object.entries(n.tags),
                  r =
                    e.length > 0
                      ? "|#".concat(
                          e
                            .map((e) => {
                              let [t, n] = e;
                              return "".concat(t, ":").concat(n);
                            })
                            .join(",")
                        )
                      : "";
                t += ""
                  .concat(n.name, "@")
                  .concat(n.unit, ":")
                  .concat(n.metric, "|")
                  .concat(n.metricType)
                  .concat(r, "|T")
                  .concat(n.timestamp, "\n");
              }
              return t;
            })(e),
            n = { type: "statsd", length: t.length };
          return [n, t];
        })(e);
        return CP(s, [i]);
      }
      const WP = "Not capturing exception because it's already been captured.";
      class KP {
        constructor(e) {
          if (
            ((this._options = e),
            (this._integrations = {}),
            (this._integrationsInitialized = !1),
            (this._numProcessing = 0),
            (this._outcomes = {}),
            (this._hooks = {}),
            (this._eventProcessors = []),
            e.dsn
              ? (this._dsn = IP(e.dsn))
              : UA && pA.warn("No DSN provided, client will not send events."),
            this._dsn)
          ) {
            const t = VP(this._dsn, e);
            this._transport = e.transport({
              tunnel: this._options.tunnel,
              recordDroppedEvent: this.recordDroppedEvent.bind(this),
              ...e.transportOptions,
              url: t,
            });
          }
        }
        captureException(e, t, n) {
          if (NA(e)) return void (UA && pA.log(WP));
          let r = t && t.event_id;
          return (
            this._process(
              this.eventFromException(e, t)
                .then((e) => this._captureEvent(e, t, n))
                .then((e) => {
                  r = e;
                })
            ),
            r
          );
        }
        captureMessage(e, t, n, r) {
          let s = n && n.event_id;
          const i = ZE(e) ? e : String(e),
            o = $E(e)
              ? this.eventFromMessage(i, t, n)
              : this.eventFromException(e, n);
          return (
            this._process(
              o
                .then((e) => this._captureEvent(e, n, r))
                .then((e) => {
                  s = e;
                })
            ),
            s
          );
        }
        captureEvent(e, t, n) {
          if (t && t.originalException && NA(t.originalException))
            return void (UA && pA.log(WP));
          let r = t && t.event_id;
          const s = (e.sdkProcessingMetadata || {}).capturedSpanScope;
          return (
            this._process(
              this._captureEvent(e, t, s || n).then((e) => {
                r = e;
              })
            ),
            r
          );
        }
        captureSession(e) {
          "string" !== typeof e.release
            ? UA &&
              pA.warn(
                "Discarded session because of missing or non-string release"
              )
            : (this.sendSession(e), GA(e, { init: !1 }));
        }
        getDsn() {
          return this._dsn;
        }
        getOptions() {
          return this._options;
        }
        getSdkMetadata() {
          return this._options._metadata;
        }
        getTransport() {
          return this._transport;
        }
        flush(e) {
          const t = this._transport;
          return t
            ? (this.metricsAggregator && this.metricsAggregator.flush(),
              this._isClientDoneProcessing(e).then((n) =>
                t.flush(e).then((e) => n && e)
              ))
            : BA(!0);
        }
        close(e) {
          return this.flush(e).then(
            (e) => (
              (this.getOptions().enabled = !1),
              this.metricsAggregator && this.metricsAggregator.close(),
              e
            )
          );
        }
        getEventProcessors() {
          return this._eventProcessors;
        }
        addEventProcessor(e) {
          this._eventProcessors.push(e);
        }
        setupIntegrations(e) {
          ((e && !this._integrationsInitialized) ||
            (this._isEnabled() && !this._integrationsInitialized)) &&
            this._setupIntegrations();
        }
        init() {
          this._isEnabled() && this._setupIntegrations();
        }
        getIntegrationById(e) {
          return this.getIntegrationByName(e);
        }
        getIntegrationByName(e) {
          return this._integrations[e];
        }
        getIntegration(e) {
          try {
            return this._integrations[e.id] || null;
          } catch (t) {
            return (
              UA &&
                pA.warn(
                  "Cannot retrieve integration ".concat(
                    e.id,
                    " from the current Client"
                  )
                ),
              null
            );
          }
        }
        addIntegration(e) {
          const t = this._integrations[e.name];
          GT(this, e, this._integrations), t || zT(this, [e]);
        }
        sendEvent(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.emit("beforeSendEvent", e, t);
          let n = qP(
            e,
            this._dsn,
            this._options._metadata,
            this._options.tunnel
          );
          for (const s of t.attachments || [])
            n = kP(
              n,
              RP(
                s,
                this._options.transportOptions &&
                  this._options.transportOptions.textEncoder
              )
            );
          const r = this._sendEnvelope(n);
          r && r.then((t) => this.emit("afterSendEvent", e, t), null);
        }
        sendSession(e) {
          const t = (function (e, t, n, r) {
            const s = jP(n);
            return CP(
              {
                sent_at: new Date().toISOString(),
                ...(s && { sdk: s }),
                ...(!!r && t && { dsn: TP(t) }),
              },
              [
                "aggregates" in e
                  ? [{ type: "sessions" }, e]
                  : [{ type: "session" }, e.toJSON()],
              ]
            );
          })(e, this._dsn, this._options._metadata, this._options.tunnel);
          this._sendEnvelope(t);
        }
        recordDroppedEvent(e, t, n) {
          if (this._options.sendClientReports) {
            const n = "".concat(e, ":").concat(t);
            UA && pA.log('Adding outcome: "'.concat(n, '"')),
              (this._outcomes[n] = this._outcomes[n] + 1 || 1);
          }
        }
        captureAggregateMetrics(e) {
          UA &&
            pA.log(
              "Flushing aggregated metrics, number of metrics: ".concat(
                e.length
              )
            );
          const t = HP(
            e,
            this._dsn,
            this._options._metadata,
            this._options.tunnel
          );
          this._sendEnvelope(t);
        }
        on(e, t) {
          this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(t);
        }
        emit(e) {
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          this._hooks[e] && this._hooks[e].forEach((e) => e(...n));
        }
        _setupIntegrations() {
          const { integrations: e } = this._options;
          (this._integrations = (function (e, t) {
            const n = {};
            return (
              t.forEach((t) => {
                t && GT(e, t, n);
              }),
              n
            );
          })(this, e)),
            zT(this, e),
            (this._integrationsInitialized = !0);
        }
        _updateSessionFromEvent(e, t) {
          let n = !1,
            r = !1;
          const s = t.exception && t.exception.values;
          if (s) {
            r = !0;
            for (const e of s) {
              const t = e.mechanism;
              if (t && !1 === t.handled) {
                n = !0;
                break;
              }
            }
          }
          const i = "ok" === e.status;
          ((i && 0 === e.errors) || (i && n)) &&
            (GA(e, {
              ...(n && { status: "crashed" }),
              errors: e.errors || Number(r || n),
            }),
            this.captureSession(e));
        }
        _isClientDoneProcessing(e) {
          return new qA((t) => {
            let n = 0;
            const r = setInterval(() => {
              0 == this._numProcessing
                ? (clearInterval(r), t(!0))
                : ((n += 1), e && n >= e && (clearInterval(r), t(!1)));
            }, 1);
          });
        }
        _isEnabled() {
          return !1 !== this.getOptions().enabled && void 0 !== this._transport;
        }
        _prepareEvent(e, t, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : mT();
          const s = this.getOptions(),
            i = Object.keys(this._integrations);
          return (
            !t.integrations && i.length > 0 && (t.integrations = i),
            this.emit("preprocessEvent", e, t),
            kT(s, e, t, n, this, r).then((e) => {
              if (null === e) return e;
              const t = {
                ...r.getPropagationContext(),
                ...(n ? n.getPropagationContext() : void 0),
              };
              if (!(e.contexts && e.contexts.trace) && t) {
                const { traceId: r, spanId: s, parentSpanId: i, dsc: o } = t;
                e.contexts = {
                  trace: { trace_id: r, span_id: s, parent_span_id: i },
                  ...e.contexts,
                };
                const a = o || eT(r, this, n);
                e.sdkProcessingMetadata = {
                  dynamicSamplingContext: a,
                  ...e.sdkProcessingMetadata,
                };
              }
              return e;
            })
          );
        }
        _captureEvent(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0;
          return this._processEvent(e, t, n).then(
            (e) => e.event_id,
            (e) => {
              if (UA) {
                const t = e;
                "log" === t.logLevel ? pA.log(t.message) : pA.warn(t);
              }
            }
          );
        }
        _processEvent(e, t, n) {
          const r = this.getOptions(),
            { sampleRate: s } = r,
            i = GP(e),
            o = zP(e),
            a = e.type || "error",
            c = "before send for type `".concat(a, "`");
          if (o && "number" === typeof s && Math.random() > s)
            return (
              this.recordDroppedEvent("sample_rate", "error", e),
              VA(
                new LP(
                  "Discarding event because it's not included in the random sample (sampling rate = ".concat(
                    s,
                    ")"
                  ),
                  "log"
                )
              )
            );
          const l = "replay_event" === a ? "replay" : a,
            u = (e.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
          return this._prepareEvent(e, t, n, u)
            .then((n) => {
              if (null === n)
                throw (
                  (this.recordDroppedEvent("event_processor", l, e),
                  new LP(
                    "An event processor returned `null`, will not send event.",
                    "log"
                  ))
                );
              if (t.data && !0 === t.data.__sentry__) return n;
              const s = (function (e, t, n) {
                const { beforeSend: r, beforeSendTransaction: s } = e;
                if (zP(t) && r) return r(t, n);
                if (GP(t) && s) return s(t, n);
                return t;
              })(r, n, t);
              return (function (e, t) {
                const n = "".concat(t, " must return `null` or a valid event.");
                if (nA(e))
                  return e.then(
                    (e) => {
                      if (!eA(e) && null !== e) throw new LP(n);
                      return e;
                    },
                    (e) => {
                      throw new LP("".concat(t, " rejected with ").concat(e));
                    }
                  );
                if (!eA(e) && null !== e) throw new LP(n);
                return e;
              })(s, c);
            })
            .then((r) => {
              if (null === r)
                throw (
                  (this.recordDroppedEvent("before_send", l, e),
                  new LP(
                    "".concat(c, " returned `null`, will not send event."),
                    "log"
                  ))
                );
              const s = n && n.getSession();
              !i && s && this._updateSessionFromEvent(s, r);
              const o = r.transaction_info;
              if (i && o && r.transaction !== e.transaction) {
                const e = "custom";
                r.transaction_info = { ...o, source: e };
              }
              return this.sendEvent(r, t), r;
            })
            .then(null, (e) => {
              if (e instanceof LP) throw e;
              throw (
                (this.captureException(e, {
                  data: { __sentry__: !0 },
                  originalException: e,
                }),
                new LP(
                  "Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ".concat(
                    e
                  )
                ))
              );
            });
        }
        _process(e) {
          this._numProcessing++,
            e.then(
              (e) => (this._numProcessing--, e),
              (e) => (this._numProcessing--, e)
            );
        }
        _sendEnvelope(e) {
          if (
            (this.emit("beforeEnvelope", e),
            this._isEnabled() && this._transport)
          )
            return this._transport.send(e).then(null, (e) => {
              UA && pA.error("Error while sending event:", e);
            });
          UA && pA.error("Transport disabled");
        }
        _clearOutcomes() {
          const e = this._outcomes;
          return (
            (this._outcomes = {}),
            Object.keys(e).map((t) => {
              const [n, r] = t.split(":");
              return { reason: n, category: r, quantity: e[t] };
            })
          );
        }
      }
      function zP(e) {
        return void 0 === e.type;
      }
      function GP(e) {
        return "transaction" === e.type;
      }
      const JP = "undefined" === typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
      function QP(e, t) {
        const n = XP(e, t),
          r = { type: t && t.name, value: $P(t) };
        return (
          n.length && (r.stacktrace = { frames: n }),
          void 0 === r.type &&
            "" === r.value &&
            (r.value = "Unrecoverable error caught"),
          r
        );
      }
      function YP(e, t) {
        return { exception: { values: [QP(e, t)] } };
      }
      function XP(e, t) {
        const n = t.stacktrace || t.stack || "",
          r = (function (e) {
            if (e) {
              if ("number" === typeof e.framesToPop) return e.framesToPop;
              if (ZP.test(e.message)) return 1;
            }
            return 0;
          })(t);
        try {
          return e(n, r);
        } catch (a_) {}
        return [];
      }
      const ZP = /Minified React error #\d+;/i;
      function $P(e) {
        const t = e && e.message;
        return t
          ? t.error && "string" === typeof t.error.message
            ? t.error.message
            : t
          : "No error message";
      }
      function eI(e, t, n, r, s) {
        let i;
        if (QE(t) && t.error) {
          return YP(e, t.error);
        }
        if (YE(t) || JE(t, "DOMException")) {
          const s = t;
          if ("stack" in t) i = YP(e, t);
          else {
            const t = s.name || (YE(s) ? "DOMError" : "DOMException"),
              o = s.message ? "".concat(t, ": ").concat(s.message) : t;
            (i = tI(e, o, n, r)), OA(i, o);
          }
          return (
            "code" in s &&
              (i.tags = { ...i.tags, "DOMException.code": "".concat(s.code) }),
            i
          );
        }
        if (GE(t)) return YP(e, t);
        if (eA(t) || tA(t)) {
          return (
            (i = (function (e, t, n, r) {
              const s = UT(),
                i = s && s.getOptions().normalizeDepth,
                o = {
                  exception: {
                    values: [
                      {
                        type: tA(t)
                          ? t.constructor.name
                          : r
                          ? "UnhandledRejection"
                          : "Error",
                        value: nI(t, { isUnhandledRejection: r }),
                      },
                    ],
                  },
                  extra: { __serialized__: IT(t, i) },
                };
              if (n) {
                const t = XP(e, n);
                t.length && (o.exception.values[0].stacktrace = { frames: t });
              }
              return o;
            })(e, t, n, s)),
            xA(i, { synthetic: !0 }),
            i
          );
        }
        return (
          (i = tI(e, t, n, r)),
          OA(i, "".concat(t), void 0),
          xA(i, { synthetic: !0 }),
          i
        );
      }
      function tI(e, t, n, r) {
        const s = {};
        if (r && n) {
          const r = XP(e, n);
          r.length &&
            (s.exception = {
              values: [{ value: t, stacktrace: { frames: r } }],
            });
        }
        if (ZE(t)) {
          const {
            __sentry_template_string__: e,
            __sentry_template_values__: n,
          } = t;
          return (s.logentry = { message: e, params: n }), s;
        }
        return (s.message = t), s;
      }
      function nI(e, t) {
        let { isUnhandledRejection: n } = t;
        const r = (function (e) {
            let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : 40;
            const n = Object.keys(_A(e));
            if ((n.sort(), !n.length)) return "[object has no keys]";
            if (n[0].length >= t) return fA(n[0], t);
            for (let r = n.length; r > 0; r--) {
              const e = n.slice(0, r).join(", ");
              if (!(e.length > t)) return r === n.length ? e : fA(e, t);
            }
            return "";
          })(e),
          s = n ? "promise rejection" : "exception";
        if (QE(e))
          return "Event `ErrorEvent` captured as "
            .concat(s, " with message `")
            .concat(e.message, "`");
        if (tA(e)) {
          const t = (function (e) {
            try {
              const t = Object.getPrototypeOf(e);
              return t ? t.constructor.name : void 0;
            } catch (a_) {}
          })(e);
          return "Event `"
            .concat(t, "` (type=")
            .concat(e.type, ") captured as ")
            .concat(s);
        }
        return "Object captured as ".concat(s, " with keys: ").concat(r);
      }
      const rI = qE;
      let sI = 0;
      function iI() {
        return sI > 0;
      }
      function oI(e) {
        let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          n = arguments.length > 2 ? arguments[2] : void 0;
        if ("function" !== typeof e) return e;
        try {
          const t = e.__sentry_wrapped__;
          if (t) return t;
          if (SA(e)) return e;
        } catch (a_) {
          return e;
        }
        const r = function () {
          const r = Array.prototype.slice.call(arguments);
          try {
            n && "function" === typeof n && n.apply(this, arguments);
            const s = r.map((e) => oI(e, t));
            return e.apply(this, s);
          } catch (s) {
            throw (
              (sI++,
              setTimeout(() => {
                sI--;
              }),
              LT((e) => {
                e.addEventProcessor(
                  (e) => (
                    t.mechanism && (OA(e, void 0, void 0), xA(e, t.mechanism)),
                    (e.extra = { ...e.extra, arguments: r }),
                    e
                  )
                ),
                  RT(s);
              }),
              s)
            );
          }
        };
        try {
          for (const t in e)
            Object.prototype.hasOwnProperty.call(e, t) && (r[t] = e[t]);
        } catch (s) {}
        wA(r, e), bA(e, "__sentry_wrapped__", r);
        try {
          Object.getOwnPropertyDescriptor(r, "name").configurable &&
            Object.defineProperty(r, "name", { get: () => e.name });
        } catch (s) {}
        return r;
      }
      class aI extends KP {
        constructor(e) {
          !(function (e, t) {
            let n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : [t],
              r =
                arguments.length > 3 && void 0 !== arguments[3]
                  ? arguments[3]
                  : "npm";
            const s = e._metadata || {};
            s.sdk ||
              (s.sdk = {
                name: "sentry.javascript.".concat(t),
                packages: n.map((e) => ({
                  name: "".concat(r, ":@sentry/").concat(e),
                  version: cT,
                })),
                version: cT,
              }),
              (e._metadata = s);
          })(e, "browser", ["browser"], rI.SENTRY_SDK_SOURCE || "npm"),
            super(e),
            e.sendClientReports &&
              rI.document &&
              rI.document.addEventListener("visibilitychange", () => {
                "hidden" === rI.document.visibilityState &&
                  this._flushOutcomes();
              });
        }
        eventFromException(e, t) {
          return (function (e, t, n, r) {
            const s = eI(e, t, (n && n.syntheticException) || void 0, r);
            return (
              xA(s),
              (s.level = "error"),
              n && n.event_id && (s.event_id = n.event_id),
              BA(s)
            );
          })(this._options.stackParser, e, t, this._options.attachStacktrace);
        }
        eventFromMessage(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : "info",
            n = arguments.length > 2 ? arguments[2] : void 0;
          return (function (e, t) {
            let n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : "info",
              r = arguments.length > 3 ? arguments[3] : void 0,
              s = arguments.length > 4 ? arguments[4] : void 0;
            const i = tI(e, t, (r && r.syntheticException) || void 0, s);
            return (
              (i.level = n), r && r.event_id && (i.event_id = r.event_id), BA(i)
            );
          })(
            this._options.stackParser,
            e,
            t,
            n,
            this._options.attachStacktrace
          );
        }
        captureUserFeedback(e) {
          if (!this._isEnabled())
            return void (
              JP && pA.warn("SDK not enabled, will not capture user feedback.")
            );
          const t = (function (e, t) {
            let { metadata: n, tunnel: r, dsn: s } = t;
            const i = {
                event_id: e.event_id,
                sent_at: new Date().toISOString(),
                ...(n &&
                  n.sdk && {
                    sdk: { name: n.sdk.name, version: n.sdk.version },
                  }),
                ...(!!r && !!s && { dsn: TP(s) }),
              },
              o = (function (e) {
                return [{ type: "user_report" }, e];
              })(e);
            return CP(i, [o]);
          })(e, {
            metadata: this.getSdkMetadata(),
            dsn: this.getDsn(),
            tunnel: this.getOptions().tunnel,
          });
          this._sendEnvelope(t);
        }
        _prepareEvent(e, t, n) {
          return (
            (e.platform = e.platform || "javascript"),
            super._prepareEvent(e, t, n)
          );
        }
        _flushOutcomes() {
          const e = this._clearOutcomes();
          if (0 === e.length) return void (JP && pA.log("No outcomes to send"));
          if (!this._dsn)
            return void (
              JP && pA.log("No dsn provided, will not send outcomes")
            );
          JP && pA.log("Sending outcomes:", e);
          const t =
            ((n = e),
            CP((r = this._options.tunnel && TP(this._dsn)) ? { dsn: r } : {}, [
              [
                { type: "client_report" },
                { timestamp: s || MA(), discarded_events: n },
              ],
            ]));
          var n, r, s;
          this._sendEnvelope(t);
        }
      }
      const cI = qE,
        lI = 1e3;
      let uI, dI, hI;
      function pI() {
        if (!cI.document) return;
        const e = $T.bind(null, "dom"),
          t = fI(e, !0);
        cI.document.addEventListener("click", t, !1),
          cI.document.addEventListener("keypress", t, !1),
          ["EventTarget", "Node"].forEach((t) => {
            const n = cI[t] && cI[t].prototype;
            n &&
              n.hasOwnProperty &&
              n.hasOwnProperty("addEventListener") &&
              (yA(n, "addEventListener", function (t) {
                return function (n, r, s) {
                  if ("click" === n || "keypress" == n)
                    try {
                      const r = this,
                        i = (r.__sentry_instrumentation_handlers__ =
                          r.__sentry_instrumentation_handlers__ || {}),
                        o = (i[n] = i[n] || { refCount: 0 });
                      if (!o.handler) {
                        const r = fI(e);
                        (o.handler = r), t.call(this, n, r, s);
                      }
                      o.refCount++;
                    } catch (a_) {}
                  return t.call(this, n, r, s);
                };
              }),
              yA(n, "removeEventListener", function (e) {
                return function (t, n, r) {
                  if ("click" === t || "keypress" == t)
                    try {
                      const n = this,
                        s = n.__sentry_instrumentation_handlers__ || {},
                        i = s[t];
                      i &&
                        (i.refCount--,
                        i.refCount <= 0 &&
                          (e.call(this, t, i.handler, r),
                          (i.handler = void 0),
                          delete s[t]),
                        0 === Object.keys(s).length &&
                          delete n.__sentry_instrumentation_handlers__);
                    } catch (a_) {}
                  return e.call(this, t, n, r);
                };
              }));
          });
      }
      function fI(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        return (n) => {
          if (!n || n._sentryCaptured) return;
          const r = (function (e) {
            try {
              return e.target;
            } catch (a_) {
              return null;
            }
          })(n);
          if (
            (function (e, t) {
              return (
                "keypress" === e &&
                (!t ||
                  !t.tagName ||
                  ("INPUT" !== t.tagName &&
                    "TEXTAREA" !== t.tagName &&
                    !t.isContentEditable))
              );
            })(n.type, r)
          )
            return;
          bA(n, "_sentryCaptured", !0),
            r && !r._sentryId && bA(r, "_sentryId", IA());
          const s = "keypress" === n.type ? "input" : n.type;
          if (
            !(function (e) {
              if (e.type !== dI) return !1;
              try {
                if (!e.target || e.target._sentryId !== hI) return !1;
              } catch (a_) {}
              return !0;
            })(n)
          ) {
            e({ event: n, name: s, global: t }),
              (dI = n.type),
              (hI = r ? r._sentryId : void 0);
          }
          clearTimeout(uI),
            (uI = cI.setTimeout(() => {
              (hI = void 0), (dI = void 0);
            }, lI));
        };
      }
      const mI = qE,
        gI = "__sentry_xhr_v3__";
      function vI() {
        if (!mI.XMLHttpRequest) return;
        const e = XMLHttpRequest.prototype;
        yA(e, "open", function (e) {
          return function () {
            const t = Date.now();
            for (var n = arguments.length, r = new Array(n), s = 0; s < n; s++)
              r[s] = arguments[s];
            const i = XE(r[0]) ? r[0].toUpperCase() : void 0,
              o = (function (e) {
                if (XE(e)) return e;
                try {
                  return e.toString();
                } catch (t) {}
                return;
              })(r[1]);
            if (!i || !o) return e.apply(this, r);
            (this[gI] = { method: i, url: o, request_headers: {} }),
              "POST" === i &&
                o.match(/sentry_key/) &&
                (this.__sentry_own_request__ = !0);
            const a = () => {
              const e = this[gI];
              if (e && 4 === this.readyState) {
                try {
                  e.status_code = this.status;
                } catch (a_) {}
                $T("xhr", {
                  args: [i, o],
                  endTimestamp: Date.now(),
                  startTimestamp: t,
                  xhr: this,
                });
              }
            };
            return (
              "onreadystatechange" in this &&
              "function" === typeof this.onreadystatechange
                ? yA(this, "onreadystatechange", function (e) {
                    return function () {
                      a();
                      for (
                        var t = arguments.length, n = new Array(t), r = 0;
                        r < t;
                        r++
                      )
                        n[r] = arguments[r];
                      return e.apply(this, n);
                    };
                  })
                : this.addEventListener("readystatechange", a),
              yA(this, "setRequestHeader", function (e) {
                return function () {
                  for (
                    var t = arguments.length, n = new Array(t), r = 0;
                    r < t;
                    r++
                  )
                    n[r] = arguments[r];
                  const [s, i] = n,
                    o = this[gI];
                  return (
                    o &&
                      XE(s) &&
                      XE(i) &&
                      (o.request_headers[s.toLowerCase()] = i),
                    e.apply(this, n)
                  );
                };
              }),
              e.apply(this, r)
            );
          };
        }),
          yA(e, "send", function (e) {
            return function () {
              const t = this[gI];
              for (
                var n = arguments.length, r = new Array(n), s = 0;
                s < n;
                s++
              )
                r[s] = arguments[s];
              if (!t) return e.apply(this, r);
              void 0 !== r[0] && (t.body = r[0]);
              return (
                $T("xhr", {
                  args: [t.method, t.url],
                  startTimestamp: Date.now(),
                  xhr: this,
                }),
                e.apply(this, r)
              );
            };
          });
      }
      function yI() {
        (function () {
          if ("string" === typeof EdgeRuntime) return !0;
          if (!vP()) return !1;
          if (yP(gP.fetch)) return !0;
          let e = !1;
          const t = gP.document;
          if (t && "function" === typeof t.createElement)
            try {
              const n = t.createElement("iframe");
              (n.hidden = !0),
                t.head.appendChild(n),
                n.contentWindow &&
                  n.contentWindow.fetch &&
                  (e = yP(n.contentWindow.fetch)),
                t.head.removeChild(n);
            } catch (n) {
              lA &&
                pA.warn(
                  "Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",
                  n
                );
            }
          return e;
        })() &&
          yA(qE, "fetch", function (e) {
            return function () {
              for (
                var t = arguments.length, n = new Array(t), r = 0;
                r < t;
                r++
              )
                n[r] = arguments[r];
              const { method: s, url: i } = (function (e) {
                  if (0 === e.length) return { method: "GET", url: "" };
                  if (2 === e.length) {
                    const [t, n] = e;
                    return {
                      url: wI(t),
                      method: bI(n, "method")
                        ? String(n.method).toUpperCase()
                        : "GET",
                    };
                  }
                  const t = e[0];
                  return {
                    url: wI(t),
                    method: bI(t, "method")
                      ? String(t.method).toUpperCase()
                      : "GET",
                  };
                })(n),
                o = {
                  args: n,
                  fetchData: { method: s, url: i },
                  startTimestamp: Date.now(),
                };
              return (
                $T("fetch", { ...o }),
                e.apply(qE, n).then(
                  (e) => (
                    $T("fetch", {
                      ...o,
                      endTimestamp: Date.now(),
                      response: e,
                    }),
                    e
                  ),
                  (e) => {
                    throw (
                      ($T("fetch", {
                        ...o,
                        endTimestamp: Date.now(),
                        error: e,
                      }),
                      e)
                    );
                  }
                )
              );
            };
          });
      }
      function bI(e, t) {
        return !!e && "object" === typeof e && !!e[t];
      }
      function wI(e) {
        return "string" === typeof e
          ? e
          : e
          ? bI(e, "url")
            ? e.url
            : e.toString
            ? e.toString()
            : ""
          : "";
      }
      function SI(e) {
        if (!e) return {};
        const t = e.match(
          /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/
        );
        if (!t) return {};
        const n = t[6] || "",
          r = t[8] || "";
        return {
          host: t[4],
          path: t[5],
          protocol: t[2],
          search: n,
          hash: r,
          relative: t[5] + n + r,
        };
      }
      const _I = 1024,
        EI = "Breadcrumbs",
        AI = function () {
          const e = {
            console: !0,
            dom: !0,
            fetch: !0,
            history: !0,
            sentry: !0,
            xhr: !0,
            ...(arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : {}),
          };
          return {
            name: EI,
            setupOnce() {},
            setup(t) {
              var n;
              e.console &&
                eP(
                  (function (e) {
                    return function (t) {
                      if (UT() !== e) return;
                      const n = {
                        category: "console",
                        data: { arguments: t.args, logger: "console" },
                        level: rP(t.level),
                        message: mA(t.args, " "),
                      };
                      if ("assert" === t.level) {
                        if (!1 !== t.args[0]) return;
                        (n.message = "Assertion failed: ".concat(
                          mA(t.args.slice(1), " ") || "console.assert"
                        )),
                          (n.data.arguments = t.args.slice(1));
                      }
                      jT(n, { input: t.args, level: t.level });
                    };
                  })(t)
                ),
                e.dom &&
                  ((n = (function (e, t) {
                    return function (n) {
                      if (UT() !== e) return;
                      let r,
                        s,
                        i =
                          "object" === typeof t ? t.serializeAttribute : void 0,
                        o =
                          "object" === typeof t &&
                          "number" === typeof t.maxStringLength
                            ? t.maxStringLength
                            : void 0;
                      o &&
                        o > _I &&
                        (JP &&
                          pA.warn(
                            "`dom.maxStringLength` cannot exceed "
                              .concat(_I, ", but a value of ")
                              .concat(o, " was configured. Sentry will use ")
                              .concat(_I, " instead.")
                          ),
                        (o = _I)),
                        "string" === typeof i && (i = [i]);
                      try {
                        const e = n.event,
                          t = (function (e) {
                            return !!e && !!e.target;
                          })(e)
                            ? e.target
                            : e;
                        (r = aA(t, { keyAttrs: i, maxStringLength: o })),
                          (s = (function (e) {
                            if (!iA.HTMLElement) return null;
                            let t = e;
                            for (let n = 0; n < 5; n++) {
                              if (!t) return null;
                              if (
                                t instanceof HTMLElement &&
                                t.dataset.sentryComponent
                              )
                                return t.dataset.sentryComponent;
                              t = t.parentNode;
                            }
                            return null;
                          })(t));
                      } catch (a_) {
                        r = "<unknown>";
                      }
                      if (0 === r.length) return;
                      const a = { category: "ui.".concat(n.name), message: r };
                      s && (a.data = { "ui.component_name": s }),
                        jT(a, {
                          event: n.event,
                          name: n.name,
                          global: n.global,
                        });
                    };
                  })(t, e.dom)),
                  XT("dom", n),
                  ZT("dom", pI)),
                e.xhr &&
                  (function (e) {
                    XT("xhr", e), ZT("xhr", vI);
                  })(
                    (function (e) {
                      return function (t) {
                        if (UT() !== e) return;
                        const { startTimestamp: n, endTimestamp: r } = t,
                          s = t.xhr[gI];
                        if (!n || !r || !s) return;
                        const {
                          method: i,
                          url: o,
                          status_code: a,
                          body: c,
                        } = s;
                        jT(
                          {
                            category: "xhr",
                            data: { method: i, url: o, status_code: a },
                            type: "http",
                          },
                          {
                            xhr: t.xhr,
                            input: c,
                            startTimestamp: n,
                            endTimestamp: r,
                          }
                        );
                      };
                    })(t)
                  ),
                e.fetch &&
                  (function (e) {
                    const t = "fetch";
                    XT(t, e), ZT(t, yI);
                  })(
                    (function (e) {
                      return function (t) {
                        if (UT() !== e) return;
                        const { startTimestamp: n, endTimestamp: r } = t;
                        if (
                          r &&
                          (!t.fetchData.url.match(/sentry_key/) ||
                            "POST" !== t.fetchData.method)
                        )
                          if (t.error) {
                            jT(
                              {
                                category: "fetch",
                                data: t.fetchData,
                                level: "error",
                                type: "http",
                              },
                              {
                                data: t.error,
                                input: t.args,
                                startTimestamp: n,
                                endTimestamp: r,
                              }
                            );
                          } else {
                            const e = t.response;
                            jT(
                              {
                                category: "fetch",
                                data: {
                                  ...t.fetchData,
                                  status_code: e && e.status,
                                },
                                type: "http",
                              },
                              {
                                input: t.args,
                                response: e,
                                startTimestamp: n,
                                endTimestamp: r,
                              }
                            );
                          }
                      };
                    })(t)
                  ),
                e.history &&
                  _P(
                    (function (e) {
                      return function (t) {
                        if (UT() !== e) return;
                        let n = t.from,
                          r = t.to;
                        const s = SI(rI.location.href);
                        let i = n ? SI(n) : void 0;
                        const o = SI(r);
                        (i && i.path) || (i = s),
                          s.protocol === o.protocol &&
                            s.host === o.host &&
                            (r = o.relative),
                          s.protocol === i.protocol &&
                            s.host === i.host &&
                            (n = i.relative),
                          jT({
                            category: "navigation",
                            data: { from: n, to: r },
                          });
                      };
                    })(t)
                  ),
                e.sentry &&
                  t.on &&
                  t.on(
                    "beforeSendEvent",
                    (function (e) {
                      return function (t) {
                        UT() === e &&
                          jT(
                            {
                              category: "sentry.".concat(
                                "transaction" === t.type
                                  ? "transaction"
                                  : "event"
                              ),
                              event_id: t.event_id,
                              level: t.level,
                              message: kA(t),
                            },
                            { event: t }
                          );
                      };
                    })(t)
                  );
            },
          };
        };
      JT(EI, AI);
      const TI = "Dedupe",
        PI = () => {
          let e;
          return {
            name: TI,
            setupOnce() {},
            processEvent(t) {
              if (t.type) return t;
              try {
                if (
                  (function (e, t) {
                    if (!t) return !1;
                    if (
                      (function (e, t) {
                        const n = e.message,
                          r = t.message;
                        if (!n && !r) return !1;
                        if ((n && !r) || (!n && r)) return !1;
                        if (n !== r) return !1;
                        if (!CI(e, t)) return !1;
                        if (!II(e, t)) return !1;
                        return !0;
                      })(e, t)
                    )
                      return !0;
                    if (
                      (function (e, t) {
                        const n = kI(t),
                          r = kI(e);
                        if (!n || !r) return !1;
                        if (n.type !== r.type || n.value !== r.value) return !1;
                        if (!CI(e, t)) return !1;
                        if (!II(e, t)) return !1;
                        return !0;
                      })(e, t)
                    )
                      return !0;
                    return !1;
                  })(t, e)
                )
                  return (
                    JP &&
                      pA.warn(
                        "Event dropped due to being a duplicate of previously captured event."
                      ),
                    null
                  );
              } catch (n) {}
              return (e = t);
            },
          };
        };
      JT(TI, PI);
      function II(e, t) {
        let n = OI(e),
          r = OI(t);
        if (!n && !r) return !0;
        if ((n && !r) || (!n && r)) return !1;
        if (r.length !== n.length) return !1;
        for (let s = 0; s < r.length; s++) {
          const e = r[s],
            t = n[s];
          if (
            e.filename !== t.filename ||
            e.lineno !== t.lineno ||
            e.colno !== t.colno ||
            e.function !== t.function
          )
            return !1;
        }
        return !0;
      }
      function CI(e, t) {
        let n = e.fingerprint,
          r = t.fingerprint;
        if (!n && !r) return !0;
        if ((n && !r) || (!n && r)) return !1;
        try {
          return !(n.join("") !== r.join(""));
        } catch (s) {
          return !1;
        }
      }
      function kI(e) {
        return e.exception && e.exception.values && e.exception.values[0];
      }
      function OI(e) {
        const t = e.exception;
        if (t)
          try {
            return t.values[0].stacktrace.frames;
          } catch (n) {
            return;
          }
      }
      let xI = null;
      function NI() {
        (xI = qE.onerror),
          (qE.onerror = function (e, t, n, r, s) {
            return (
              $T("error", { column: r, error: s, line: n, msg: e, url: t }),
              !(!xI || xI.__SENTRY_LOADER__) && xI.apply(this, arguments)
            );
          }),
          (qE.onerror.__SENTRY_INSTRUMENTED__ = !0);
      }
      let RI = null;
      function DI() {
        (RI = qE.onunhandledrejection),
          (qE.onunhandledrejection = function (e) {
            return (
              $T("unhandledrejection", e),
              !(RI && !RI.__SENTRY_LOADER__) || RI.apply(this, arguments)
            );
          }),
          (qE.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0);
      }
      const MI = "GlobalHandlers",
        jI = function () {
          const e = {
            onerror: !0,
            onunhandledrejection: !0,
            ...(arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : {}),
          };
          return {
            name: MI,
            setupOnce() {
              Error.stackTraceLimit = 50;
            },
            setup(t) {
              e.onerror &&
                (!(function (e) {
                  !(function (e) {
                    const t = "error";
                    XT(t, e), ZT(t, NI);
                  })((t) => {
                    const { stackParser: n, attachStacktrace: r } = FI();
                    if (UT() !== e || iI()) return;
                    const { msg: s, url: i, line: o, column: a, error: c } = t,
                      l =
                        void 0 === c && XE(s)
                          ? (function (e, t, n, r) {
                              const s =
                                /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
                              let i = QE(e) ? e.message : e,
                                o = "Error";
                              const a = i.match(s);
                              a && ((o = a[1]), (i = a[2]));
                              const c = {
                                exception: { values: [{ type: o, value: i }] },
                              };
                              return LI(c, t, n, r);
                            })(s, i, o, a)
                          : LI(eI(n, c || s, void 0, r, !1), i, o, a);
                    (l.level = "error"),
                      MT(l, {
                        originalException: c,
                        mechanism: { handled: !1, type: "onerror" },
                      });
                  });
                })(t),
                UI("onerror")),
                e.onunhandledrejection &&
                  (!(function (e) {
                    !(function (e) {
                      const t = "unhandledrejection";
                      XT(t, e), ZT(t, DI);
                    })((t) => {
                      const { stackParser: n, attachStacktrace: r } = FI();
                      if (UT() !== e || iI()) return;
                      const s = (function (e) {
                          if ($E(e)) return e;
                          const t = e;
                          try {
                            if ("reason" in t) return t.reason;
                            if ("detail" in t && "reason" in t.detail)
                              return t.detail.reason;
                          } catch (n) {}
                          return e;
                        })(t),
                        i = $E(s)
                          ? {
                              exception: {
                                values: [
                                  {
                                    type: "UnhandledRejection",
                                    value:
                                      "Non-Error promise rejection captured with value: ".concat(
                                        String(s)
                                      ),
                                  },
                                ],
                              },
                            }
                          : eI(n, s, void 0, r, !0);
                      (i.level = "error"),
                        MT(i, {
                          originalException: s,
                          mechanism: {
                            handled: !1,
                            type: "onunhandledrejection",
                          },
                        });
                    });
                  })(t),
                  UI("onunhandledrejection"));
            },
          };
        };
      JT(MI, jI);
      function LI(e, t, n, r) {
        const s = (e.exception = e.exception || {}),
          i = (s.values = s.values || []),
          o = (i[0] = i[0] || {}),
          a = (o.stacktrace = o.stacktrace || {}),
          c = (a.frames = a.frames || []),
          l = isNaN(parseInt(r, 10)) ? void 0 : r,
          u = isNaN(parseInt(n, 10)) ? void 0 : n,
          d =
            XE(t) && t.length > 0
              ? t
              : (function () {
                  try {
                    return iA.document.location.href;
                  } catch (e) {
                    return "";
                  }
                })();
        return (
          0 === c.length &&
            c.push({
              colno: l,
              filename: d,
              function: "?",
              in_app: !0,
              lineno: u,
            }),
          e
        );
      }
      function UI(e) {
        JP && pA.log("Global Handler attached: ".concat(e));
      }
      function FI() {
        const e = UT();
        return (
          (e && e.getOptions()) || {
            stackParser: () => [],
            attachStacktrace: !1,
          }
        );
      }
      const BI = "HttpContext",
        VI = () => ({
          name: BI,
          setupOnce() {},
          preprocessEvent(e) {
            if (!rI.navigator && !rI.location && !rI.document) return;
            const t =
                (e.request && e.request.url) ||
                (rI.location && rI.location.href),
              { referrer: n } = rI.document || {},
              { userAgent: r } = rI.navigator || {},
              s = {
                ...(e.request && e.request.headers),
                ...(n && { Referer: n }),
                ...(r && { "User-Agent": r }),
              },
              i = { ...e.request, ...(t && { url: t }), headers: s };
            e.request = i;
          },
        });
      JT(BI, VI);
      function qI(e, t) {
        let n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : 250,
          r = arguments.length > 3 ? arguments[3] : void 0,
          s = arguments.length > 4 ? arguments[4] : void 0,
          i = arguments.length > 5 ? arguments[5] : void 0,
          o = arguments.length > 6 ? arguments[6] : void 0;
        if (
          !i.exception ||
          !i.exception.values ||
          !o ||
          !rA(o.originalException, Error)
        )
          return;
        const a =
          i.exception.values.length > 0
            ? i.exception.values[i.exception.values.length - 1]
            : void 0;
        var c, l;
        a &&
          (i.exception.values =
            ((c = HI(
              e,
              t,
              s,
              o.originalException,
              r,
              i.exception.values,
              a,
              0
            )),
            (l = n),
            c.map((e) => (e.value && (e.value = fA(e.value, l)), e))));
      }
      function HI(e, t, n, r, s, i, o, a) {
        if (i.length >= n + 1) return i;
        let c = [...i];
        if (rA(r[s], Error)) {
          WI(o, a);
          const i = e(t, r[s]),
            l = c.length;
          KI(i, s, l, a), (c = HI(e, t, n, r[s], s, [i, ...c], i, l));
        }
        return (
          Array.isArray(r.errors) &&
            r.errors.forEach((r, i) => {
              if (rA(r, Error)) {
                WI(o, a);
                const l = e(t, r),
                  u = c.length;
                KI(l, "errors[".concat(i, "]"), u, a),
                  (c = HI(e, t, n, r, s, [l, ...c], l, u));
              }
            }),
          c
        );
      }
      function WI(e, t) {
        (e.mechanism = e.mechanism || { type: "generic", handled: !0 }),
          (e.mechanism = {
            ...e.mechanism,
            ...("AggregateError" === e.type && { is_exception_group: !0 }),
            exception_id: t,
          });
      }
      function KI(e, t, n, r) {
        (e.mechanism = e.mechanism || { type: "generic", handled: !0 }),
          (e.mechanism = {
            ...e.mechanism,
            type: "chained",
            source: t,
            exception_id: n,
            parent_id: r,
          });
      }
      const zI = "LinkedErrors",
        GI = function () {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          const t = e.limit || 5,
            n = e.key || "cause";
          return {
            name: zI,
            setupOnce() {},
            preprocessEvent(e, r, s) {
              const i = s.getOptions();
              qI(QP, i.stackParser, i.maxValueLength, n, t, e, r);
            },
          };
        },
        JI =
          (JT(zI, GI),
          [
            "EventTarget",
            "Window",
            "Node",
            "ApplicationCache",
            "AudioTrackList",
            "BroadcastChannel",
            "ChannelMergerNode",
            "CryptoOperation",
            "EventSource",
            "FileReader",
            "HTMLUnknownElement",
            "IDBDatabase",
            "IDBRequest",
            "IDBTransaction",
            "KeyOperation",
            "MediaController",
            "MessagePort",
            "ModalWindow",
            "Notification",
            "SVGElementInstance",
            "Screen",
            "SharedWorker",
            "TextTrack",
            "TextTrackCue",
            "TextTrackList",
            "WebSocket",
            "WebSocketWorker",
            "Worker",
            "XMLHttpRequest",
            "XMLHttpRequestEventTarget",
            "XMLHttpRequestUpload",
          ]),
        QI = "TryCatch",
        YI = function () {
          const e = {
            XMLHttpRequest: !0,
            eventTarget: !0,
            requestAnimationFrame: !0,
            setInterval: !0,
            setTimeout: !0,
            ...(arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : {}),
          };
          return {
            name: QI,
            setupOnce() {
              e.setTimeout && yA(rI, "setTimeout", XI),
                e.setInterval && yA(rI, "setInterval", XI),
                e.requestAnimationFrame && yA(rI, "requestAnimationFrame", ZI),
                e.XMLHttpRequest &&
                  "XMLHttpRequest" in rI &&
                  yA(XMLHttpRequest.prototype, "send", $I);
              const t = e.eventTarget;
              if (t) {
                (Array.isArray(t) ? t : JI).forEach(eC);
              }
            },
          };
        };
      JT(QI, YI);
      function XI(e) {
        return function () {
          for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
            n[r] = arguments[r];
          const s = n[0];
          return (
            (n[0] = oI(s, {
              mechanism: {
                data: { function: TT(e) },
                handled: !1,
                type: "instrument",
              },
            })),
            e.apply(this, n)
          );
        };
      }
      function ZI(e) {
        return function (t) {
          return e.apply(this, [
            oI(t, {
              mechanism: {
                data: { function: "requestAnimationFrame", handler: TT(e) },
                handled: !1,
                type: "instrument",
              },
            }),
          ]);
        };
      }
      function $I(e) {
        return function () {
          const t = this;
          ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(
            (e) => {
              e in t &&
                "function" === typeof t[e] &&
                yA(t, e, function (t) {
                  const n = {
                      mechanism: {
                        data: { function: e, handler: TT(t) },
                        handled: !1,
                        type: "instrument",
                      },
                    },
                    r = SA(t);
                  return r && (n.mechanism.data.handler = TT(r)), oI(t, n);
                });
            }
          );
          for (var n = arguments.length, r = new Array(n), s = 0; s < n; s++)
            r[s] = arguments[s];
          return e.apply(this, r);
        };
      }
      function eC(e) {
        const t = rI,
          n = t[e] && t[e].prototype;
        n &&
          n.hasOwnProperty &&
          n.hasOwnProperty("addEventListener") &&
          (yA(n, "addEventListener", function (t) {
            return function (n, r, s) {
              try {
                "function" === typeof r.handleEvent &&
                  (r.handleEvent = oI(r.handleEvent, {
                    mechanism: {
                      data: {
                        function: "handleEvent",
                        handler: TT(r),
                        target: e,
                      },
                      handled: !1,
                      type: "instrument",
                    },
                  }));
              } catch (i) {}
              return t.apply(this, [
                n,
                oI(r, {
                  mechanism: {
                    data: {
                      function: "addEventListener",
                      handler: TT(r),
                      target: e,
                    },
                    handled: !1,
                    type: "instrument",
                  },
                }),
                s,
              ]);
            };
          }),
          yA(n, "removeEventListener", function (e) {
            return function (t, n, r) {
              const s = n;
              try {
                const n = s && s.__sentry_wrapped__;
                n && e.call(this, t, n, r);
              } catch (a_) {}
              return e.call(this, t, s, r);
            };
          }));
      }
      const tC = "?";
      function nC(e, t, n, r) {
        const s = { filename: e, function: t, in_app: !0 };
        return void 0 !== n && (s.lineno = n), void 0 !== r && (s.colno = r), s;
      }
      const rC =
          /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
        sC = /\((\S*)(?::(\d+))(?::(\d+))\)/,
        iC =
          /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
        oC = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
        aC =
          /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
        cC = ET(
          ...[
            [
              30,
              (e) => {
                const t = rC.exec(e);
                if (t) {
                  if (t[2] && 0 === t[2].indexOf("eval")) {
                    const e = sC.exec(t[2]);
                    e && ((t[2] = e[1]), (t[3] = e[2]), (t[4] = e[3]));
                  }
                  const [e, n] = lC(t[1] || tC, t[2]);
                  return nC(n, e, t[3] ? +t[3] : void 0, t[4] ? +t[4] : void 0);
                }
              },
            ],
            [
              50,
              (e) => {
                const t = iC.exec(e);
                if (t) {
                  if (t[3] && t[3].indexOf(" > eval") > -1) {
                    const e = oC.exec(t[3]);
                    e &&
                      ((t[1] = t[1] || "eval"),
                      (t[3] = e[1]),
                      (t[4] = e[2]),
                      (t[5] = ""));
                  }
                  let e = t[3],
                    n = t[1] || tC;
                  return (
                    ([n, e] = lC(n, e)),
                    nC(e, n, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0)
                  );
                }
              },
            ],
            [
              40,
              (e) => {
                const t = aC.exec(e);
                return t
                  ? nC(t[2], t[1] || tC, +t[3], t[4] ? +t[4] : void 0)
                  : void 0;
              },
            ],
          ]
        ),
        lC = (e, t) => {
          const n = -1 !== e.indexOf("safari-extension"),
            r = -1 !== e.indexOf("safari-web-extension");
          return n || r
            ? [
                -1 !== e.indexOf("@") ? e.split("@")[0] : tC,
                n
                  ? "safari-extension:".concat(t)
                  : "safari-web-extension:".concat(t),
              ]
            : [e, t];
        };
      function uC(e) {
        const t = [];
        function n(e) {
          return t.splice(t.indexOf(e), 1)[0];
        }
        return {
          $: t,
          add: function (r) {
            if (!(void 0 === e || t.length < e))
              return VA(
                new LP("Not adding Promise because buffer limit was reached.")
              );
            const s = r();
            return (
              -1 === t.indexOf(s) && t.push(s),
              s.then(() => n(s)).then(null, () => n(s).then(null, () => {})),
              s
            );
          },
          drain: function (e) {
            return new qA((n, r) => {
              let s = t.length;
              if (!s) return n(!0);
              const i = setTimeout(() => {
                e && e > 0 && n(!1);
              }, e);
              t.forEach((e) => {
                BA(e).then(() => {
                  --s || (clearTimeout(i), n(!0));
                }, r);
              });
            });
          },
        };
      }
      const dC = 6e4;
      function hC(e, t) {
        let { statusCode: n, headers: r } = t,
          s =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : Date.now();
        const i = { ...e },
          o = r && r["x-sentry-rate-limits"],
          a = r && r["retry-after"];
        if (o)
          for (const c of o.trim().split(",")) {
            const [e, t, , , n] = c.split(":", 5),
              r = parseInt(e, 10),
              o = 1e3 * (isNaN(r) ? 60 : r);
            if (t)
              for (const a of t.split(";"))
                ("metric_bucket" === a &&
                  n &&
                  !n.split(";").includes("custom")) ||
                  (i[a] = s + o);
            else i.all = s + o;
          }
        else
          a
            ? (i.all =
                s +
                (function (e) {
                  let t =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : Date.now();
                  const n = parseInt("".concat(e), 10);
                  if (!isNaN(n)) return 1e3 * n;
                  const r = Date.parse("".concat(e));
                  return isNaN(r) ? dC : r - t;
                })(a, s))
            : 429 === n && (i.all = s + 6e4);
        return i;
      }
      const pC = 30;
      function fC(e, t) {
        let n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : uC(e.bufferSize || pC),
          r = {};
        function s(s) {
          const i = [];
          if (
            (OP(s, (t, n) => {
              const s = MP(n);
              if (
                (function (e, t) {
                  let n =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : Date.now();
                  return (
                    (function (e, t) {
                      return e[t] || e.all || 0;
                    })(e, t) > n
                  );
                })(r, s)
              ) {
                const r = mC(t, n);
                e.recordDroppedEvent("ratelimit_backoff", s, r);
              } else i.push(t);
            }),
            0 === i.length)
          )
            return BA();
          const o = CP(s[0], i),
            a = (t) => {
              OP(o, (n, r) => {
                const s = mC(n, r);
                e.recordDroppedEvent(t, MP(r), s);
              });
            };
          return n
            .add(() =>
              t({ body: NP(o, e.textEncoder) }).then(
                (e) => (
                  void 0 !== e.statusCode &&
                    (e.statusCode < 200 || e.statusCode >= 300) &&
                    UA &&
                    pA.warn(
                      "Sentry responded with status code ".concat(
                        e.statusCode,
                        " to sent event."
                      )
                    ),
                  (r = hC(r, e)),
                  e
                ),
                (e) => {
                  throw (a("network_error"), e);
                }
              )
            )
            .then(
              (e) => e,
              (e) => {
                if (e instanceof LP)
                  return (
                    UA &&
                      pA.error("Skipped sending event because buffer is full."),
                    a("queue_overflow"),
                    BA()
                  );
                throw e;
              }
            );
        }
        return (
          (s.__sentry__baseTransport__ = !0),
          { send: s, flush: (e) => n.drain(e) }
        );
      }
      function mC(e, t) {
        if ("event" === t || "transaction" === t)
          return Array.isArray(e) ? e[1] : void 0;
      }
      let gC;
      function vC(e) {
        let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : (function () {
                  if (gC) return gC;
                  if (yP(rI.fetch)) return (gC = rI.fetch.bind(rI));
                  const e = rI.document;
                  let t = rI.fetch;
                  if (e && "function" === typeof e.createElement)
                    try {
                      const n = e.createElement("iframe");
                      (n.hidden = !0), e.head.appendChild(n);
                      const r = n.contentWindow;
                      r && r.fetch && (t = r.fetch), e.head.removeChild(n);
                    } catch (a_) {
                      JP &&
                        pA.warn(
                          "Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",
                          a_
                        );
                    }
                  return (gC = t.bind(rI));
                })(),
          n = 0,
          r = 0;
        return fC(e, function (s) {
          const i = s.body.length;
          (n += i), r++;
          const o = {
            body: s.body,
            method: "POST",
            referrerPolicy: "origin",
            headers: e.headers,
            keepalive: n <= 6e4 && r < 15,
            ...e.fetchOptions,
          };
          try {
            return t(e.url, o).then(
              (e) => (
                (n -= i),
                r--,
                {
                  statusCode: e.status,
                  headers: {
                    "x-sentry-rate-limits": e.headers.get(
                      "X-Sentry-Rate-Limits"
                    ),
                    "retry-after": e.headers.get("Retry-After"),
                  },
                }
              )
            );
          } catch (a_) {
            return (gC = void 0), (n -= i), r--, VA(a_);
          }
        });
      }
      const yC = 4;
      function bC(e) {
        return fC(e, function (t) {
          return new qA((n, r) => {
            const s = new XMLHttpRequest();
            (s.onerror = r),
              (s.onreadystatechange = () => {
                s.readyState === yC &&
                  n({
                    statusCode: s.status,
                    headers: {
                      "x-sentry-rate-limits": s.getResponseHeader(
                        "X-Sentry-Rate-Limits"
                      ),
                      "retry-after": s.getResponseHeader("Retry-After"),
                    },
                  });
              }),
              s.open("POST", e.url);
            for (const t in e.headers)
              Object.prototype.hasOwnProperty.call(e.headers, t) &&
                s.setRequestHeader(t, e.headers[t]);
            s.send(t.body);
          });
        });
      }
      const wC = [lP(), fP(), YI(), AI(), jI(), GI(), PI(), VI()];
      function SC() {
        let e =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        void 0 === e.defaultIntegrations && (e.defaultIntegrations = [...wC]),
          void 0 === e.release &&
            ("string" === typeof __SENTRY_RELEASE__ &&
              (e.release = __SENTRY_RELEASE__),
            rI.SENTRY_RELEASE &&
              rI.SENTRY_RELEASE.id &&
              (e.release = rI.SENTRY_RELEASE.id)),
          void 0 === e.autoSessionTracking && (e.autoSessionTracking = !0),
          void 0 === e.sendClientReports && (e.sendClientReports = !0);
        const t = {
          ...e,
          stackParser:
            ((n = e.stackParser || cC), Array.isArray(n) ? ET(...n) : n),
          integrations: KT(e),
          transport: e.transport || (vP() ? vC : bC),
        };
        var n;
        mP(aI, t),
          e.autoSessionTracking &&
            (function () {
              if ("undefined" === typeof rI.document)
                return void (
                  JP &&
                  pA.warn(
                    "Session tracking in non-browser environment with @sentry/browser is not supported."
                  )
                );
              BT({ ignoreDuration: !0 }),
                HT(),
                _P((e) => {
                  let { from: t, to: n } = e;
                  void 0 !== t && t !== n && (BT({ ignoreDuration: !0 }), HT());
                });
            })();
      }
      function _C(e) {
        !(function (e) {
          fT().setUser(e);
        })(e);
      }
      function EC(e, t, n) {
        if (("prod" !== v_ && console.error(e, t), t instanceof Error)) {
          const r = new Error("".concat(e, " (").concat(t.message, ")"));
          (r.name = t.name), (r.stack = t.stack), RT(r, n);
        } else {
          const r = t
            ? Error(
                "".concat(e, " (non-Error: ").concat(JSON.stringify(t), ")")
              )
            : Error(e);
          (r.framesToPop = 1), RT(r, n);
        }
      }
      const AC = {};
      function TC(e) {
        let t = 1;
        var n, r;
        if (
          e.subCode &&
          ((t = (null !== (n = AC[e.subCode]) && void 0 !== n ? n : 0) + 1),
          (AC[e.subCode] = t),
          (r = t),
          Math.round(Math.log(r - 1) / Math.log(10)) ===
            Math.round(Math.log(r) / Math.log(10)))
        )
          return;
        const s = Error(
          "".concat(e.code, " (").concat(e.message, ") (occ:").concat(t, ")")
        );
        (s.name = "ReplicantError"),
          (s.framesToPop = 1),
          LT((t) => {
            t.setFingerprint(["{{ default }}", e.code, e.subCode || ""]),
              "prod" !== v_ && t.setTag("requestId", e.message),
              RT(s);
          });
      }
      let PC = void 0 === navigator.onLine || navigator.onLine,
        IC = () => {},
        CC = new Promise((e) => {
          IC = e;
        });
      async function kC() {
        window.location.reload();
      }
      async function OC(e, t) {
        await kC();
      }
      void 0 !== window.ononline &&
        (PC && IC(),
        window.addEventListener("offline", () => {
          (PC = !1),
            (CC = new Promise((e) => {
              IC = e;
            }));
        }),
        window.addEventListener("online", () => {
          (PC = !0), IC();
        }));
      const xC = 3;
      async function NC(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        try {
          await e.retryLastRequest();
        } catch (n) {
          if (t >= xC) throw n;
          return !1 === navigator.onLine || !1 === PC
            ? (await new Promise((e) => {
                CC.then(e);
                setTimeout(e, 150);
              }),
              NC(e, t))
            : NC(e, t + 1);
        }
      }
      async function RC(e, t) {
        try {
          await NC(t);
        } catch (a_) {
          await kC();
        }
      }
      function DC(e, t) {
        switch (e.code) {
          case "unknown_error":
          case "replication_error":
          case "authorization_error":
          case "server_error":
            return TC(e), OC(e.message, e.subCode);
          case "network_error":
            return RC(e.message, t);
          case "session_desync_error":
            return (
              fr.pushError("SessionDesyncError", e),
              (async function () {
                await kC();
              })()
            );
          case "version_error":
            return (
              TC(e),
              (async function () {
                await new Promise((e) => setTimeout(e, 2e3)), await kC();
              })()
            );
          default:
            e.code;
            return EC("Unknown replicant error!", e), OC(e.message);
        }
      }
      class MC {
        constructor() {
          (this.events = {}),
            (this.addEventListener = (e, t) => (
              this.events[e] || (this.events[e] = []),
              this.events[e].push(t),
              () => {
                this.events[e] = this.events[e].filter((e) => e !== t);
              }
            )),
            (this.attachEventListener = (e) => (t) =>
              this.addEventListener(e, t)),
            (this.sendEvents = (e) => {
              ("string" === typeof e ? [e] : e).forEach((e) => {
                this.events[e] &&
                  this.events[e].forEach((e) => {
                    e();
                  });
              });
            });
        }
      }
      const jC = {
        type: "logger",
        log(e) {
          this.output("log", e);
        },
        warn(e) {
          this.output("warn", e);
        },
        error(e) {
          this.output("error", e);
        },
        output(e, t) {
          console && console[e] && console[e].apply(console, t);
        },
      };
      class LC {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          this.init(e, t);
        }
        init(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          (this.prefix = t.prefix || "i18next:"),
            (this.logger = e || jC),
            (this.options = t),
            (this.debug = t.debug);
        }
        log() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          return this.forward(t, "log", "", !0);
        }
        warn() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          return this.forward(t, "warn", "", !0);
        }
        error() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          return this.forward(t, "error", "");
        }
        deprecate() {
          for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
          return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
        }
        forward(e, t, n, r) {
          return r && !this.debug
            ? null
            : ("string" === typeof e[0] &&
                (e[0] = "".concat(n).concat(this.prefix, " ").concat(e[0])),
              this.logger[t](e));
        }
        create(e) {
          return new LC(this.logger, {
            prefix: "".concat(this.prefix, ":").concat(e, ":"),
            ...this.options,
          });
        }
        clone(e) {
          return (
            ((e = e || this.options).prefix = e.prefix || this.prefix),
            new LC(this.logger, e)
          );
        }
      }
      var UC = new LC();
      class FC {
        constructor() {
          this.observers = {};
        }
        on(e, t) {
          return (
            e.split(" ").forEach((e) => {
              this.observers[e] || (this.observers[e] = new Map());
              const n = this.observers[e].get(t) || 0;
              this.observers[e].set(t, n + 1);
            }),
            this
          );
        }
        off(e, t) {
          this.observers[e] &&
            (t ? this.observers[e].delete(t) : delete this.observers[e]);
        }
        emit(e) {
          for (
            var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            n[r - 1] = arguments[r];
          if (this.observers[e]) {
            Array.from(this.observers[e].entries()).forEach((e) => {
              let [t, r] = e;
              for (let s = 0; s < r; s++) t(...n);
            });
          }
          if (this.observers["*"]) {
            Array.from(this.observers["*"].entries()).forEach((t) => {
              let [r, s] = t;
              for (let i = 0; i < s; i++) r.apply(r, [e, ...n]);
            });
          }
        }
      }
      function BC() {
        let e, t;
        const n = new Promise((n, r) => {
          (e = n), (t = r);
        });
        return (n.resolve = e), (n.reject = t), n;
      }
      function VC(e) {
        return null == e ? "" : "" + e;
      }
      const qC = /###/g;
      function HC(e, t, n) {
        function r(e) {
          return e && e.indexOf("###") > -1 ? e.replace(qC, ".") : e;
        }
        function s() {
          return !e || "string" === typeof e;
        }
        const i = "string" !== typeof t ? t : t.split(".");
        let o = 0;
        for (; o < i.length - 1; ) {
          if (s()) return {};
          const t = r(i[o]);
          !e[t] && n && (e[t] = new n()),
            (e = Object.prototype.hasOwnProperty.call(e, t) ? e[t] : {}),
            ++o;
        }
        return s() ? {} : { obj: e, k: r(i[o]) };
      }
      function WC(e, t, n) {
        const { obj: r, k: s } = HC(e, t, Object);
        if (void 0 !== r || 1 === t.length) return void (r[s] = n);
        let i = t[t.length - 1],
          o = t.slice(0, t.length - 1),
          a = HC(e, o, Object);
        for (; void 0 === a.obj && o.length; )
          (i = "".concat(o[o.length - 1], ".").concat(i)),
            (o = o.slice(0, o.length - 1)),
            (a = HC(e, o, Object)),
            a &&
              a.obj &&
              "undefined" !== typeof a.obj["".concat(a.k, ".").concat(i)] &&
              (a.obj = void 0);
        a.obj["".concat(a.k, ".").concat(i)] = n;
      }
      function KC(e, t) {
        const { obj: n, k: r } = HC(e, t);
        if (n) return n[r];
      }
      function zC(e, t, n) {
        for (const r in t)
          "__proto__" !== r &&
            "constructor" !== r &&
            (r in e
              ? "string" === typeof e[r] ||
                e[r] instanceof String ||
                "string" === typeof t[r] ||
                t[r] instanceof String
                ? n && (e[r] = t[r])
                : zC(e[r], t[r], n)
              : (e[r] = t[r]));
        return e;
      }
      function GC(e) {
        return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
      }
      var JC = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
      };
      function QC(e) {
        return "string" === typeof e
          ? e.replace(/[&<>"'\/]/g, (e) => JC[e])
          : e;
      }
      const YC = [" ", ",", "?", "!", ";"],
        XC = new (class {
          constructor(e) {
            (this.capacity = e),
              (this.regExpMap = new Map()),
              (this.regExpQueue = []);
          }
          getRegExp(e) {
            const t = this.regExpMap.get(e);
            if (void 0 !== t) return t;
            const n = new RegExp(e);
            return (
              this.regExpQueue.length === this.capacity &&
                this.regExpMap.delete(this.regExpQueue.shift()),
              this.regExpMap.set(e, n),
              this.regExpQueue.push(e),
              n
            );
          }
        })(20);
      function ZC(e, t) {
        let n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ".";
        if (!e) return;
        if (e[t]) return e[t];
        const r = t.split(n);
        let s = e;
        for (let i = 0; i < r.length; ) {
          if (!s || "object" !== typeof s) return;
          let e,
            t = "";
          for (let o = i; o < r.length; ++o)
            if ((o !== i && (t += n), (t += r[o]), (e = s[t]), void 0 !== e)) {
              if (
                ["string", "number", "boolean"].indexOf(typeof e) > -1 &&
                o < r.length - 1
              )
                continue;
              i += o - i + 1;
              break;
            }
          s = e;
        }
        return s;
      }
      function $C(e) {
        return e && e.indexOf("_") > 0 ? e.replace("_", "-") : e;
      }
      class ek extends FC {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : { ns: ["translation"], defaultNS: "translation" };
          super(),
            (this.data = e || {}),
            (this.options = t),
            void 0 === this.options.keySeparator &&
              (this.options.keySeparator = "."),
            void 0 === this.options.ignoreJSONStructure &&
              (this.options.ignoreJSONStructure = !0);
        }
        addNamespaces(e) {
          this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
        }
        removeNamespaces(e) {
          const t = this.options.ns.indexOf(e);
          t > -1 && this.options.ns.splice(t, 1);
        }
        getResource(e, t, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
          const s =
              void 0 !== r.keySeparator
                ? r.keySeparator
                : this.options.keySeparator,
            i =
              void 0 !== r.ignoreJSONStructure
                ? r.ignoreJSONStructure
                : this.options.ignoreJSONStructure;
          let o;
          e.indexOf(".") > -1
            ? (o = e.split("."))
            : ((o = [e, t]),
              n &&
                (Array.isArray(n)
                  ? o.push(...n)
                  : "string" === typeof n && s
                  ? o.push(...n.split(s))
                  : o.push(n)));
          const a = KC(this.data, o);
          return (
            !a &&
              !t &&
              !n &&
              e.indexOf(".") > -1 &&
              ((e = o[0]), (t = o[1]), (n = o.slice(2).join("."))),
            a || !i || "string" !== typeof n
              ? a
              : ZC(this.data && this.data[e] && this.data[e][t], n, s)
          );
        }
        addResource(e, t, n, r) {
          let s =
            arguments.length > 4 && void 0 !== arguments[4]
              ? arguments[4]
              : { silent: !1 };
          const i =
            void 0 !== s.keySeparator
              ? s.keySeparator
              : this.options.keySeparator;
          let o = [e, t];
          n && (o = o.concat(i ? n.split(i) : n)),
            e.indexOf(".") > -1 && ((o = e.split(".")), (r = t), (t = o[1])),
            this.addNamespaces(t),
            WC(this.data, o, r),
            s.silent || this.emit("added", e, t, n, r);
        }
        addResources(e, t, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : { silent: !1 };
          for (const s in n)
            ("string" === typeof n[s] || Array.isArray(n[s])) &&
              this.addResource(e, t, s, n[s], { silent: !0 });
          r.silent || this.emit("added", e, t, n);
        }
        addResourceBundle(e, t, n, r, s) {
          let i =
              arguments.length > 5 && void 0 !== arguments[5]
                ? arguments[5]
                : { silent: !1, skipCopy: !1 },
            o = [e, t];
          e.indexOf(".") > -1 &&
            ((o = e.split(".")), (r = n), (n = t), (t = o[1])),
            this.addNamespaces(t);
          let a = KC(this.data, o) || {};
          i.skipCopy || (n = JSON.parse(JSON.stringify(n))),
            r ? zC(a, n, s) : (a = { ...a, ...n }),
            WC(this.data, o, a),
            i.silent || this.emit("added", e, t, n);
        }
        removeResourceBundle(e, t) {
          this.hasResourceBundle(e, t) && delete this.data[e][t],
            this.removeNamespaces(t),
            this.emit("removed", e, t);
        }
        hasResourceBundle(e, t) {
          return void 0 !== this.getResource(e, t);
        }
        getResourceBundle(e, t) {
          return (
            t || (t = this.options.defaultNS),
            "v1" === this.options.compatibilityAPI
              ? { ...this.getResource(e, t) }
              : this.getResource(e, t)
          );
        }
        getDataByLanguage(e) {
          return this.data[e];
        }
        hasLanguageSomeTranslations(e) {
          const t = this.getDataByLanguage(e);
          return !!((t && Object.keys(t)) || []).find(
            (e) => t[e] && Object.keys(t[e]).length > 0
          );
        }
        toJSON() {
          return this.data;
        }
      }
      var tk = {
        processors: {},
        addPostProcessor(e) {
          this.processors[e.name] = e;
        },
        handle(e, t, n, r, s) {
          return (
            e.forEach((e) => {
              this.processors[e] &&
                (t = this.processors[e].process(t, n, r, s));
            }),
            t
          );
        },
      };
      const nk = {};
      class rk extends FC {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          super(),
            (function (e, t, n) {
              e.forEach((e) => {
                t[e] && (n[e] = t[e]);
              });
            })(
              [
                "resourceStore",
                "languageUtils",
                "pluralResolver",
                "interpolator",
                "backendConnector",
                "i18nFormat",
                "utils",
              ],
              e,
              this
            ),
            (this.options = t),
            void 0 === this.options.keySeparator &&
              (this.options.keySeparator = "."),
            (this.logger = UC.create("translator"));
        }
        changeLanguage(e) {
          e && (this.language = e);
        }
        exists(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : { interpolation: {} };
          if (void 0 === e || null === e) return !1;
          const n = this.resolve(e, t);
          return n && void 0 !== n.res;
        }
        extractFromKey(e, t) {
          let n =
            void 0 !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator;
          void 0 === n && (n = ":");
          const r =
            void 0 !== t.keySeparator
              ? t.keySeparator
              : this.options.keySeparator;
          let s = t.ns || this.options.defaultNS || [];
          const i = n && e.indexOf(n) > -1,
            o =
              !this.options.userDefinedKeySeparator &&
              !t.keySeparator &&
              !this.options.userDefinedNsSeparator &&
              !t.nsSeparator &&
              !(function (e, t, n) {
                (t = t || ""), (n = n || "");
                const r = YC.filter(
                  (e) => t.indexOf(e) < 0 && n.indexOf(e) < 0
                );
                if (0 === r.length) return !0;
                const s = XC.getRegExp(
                  "(".concat(
                    r.map((e) => ("?" === e ? "\\?" : e)).join("|"),
                    ")"
                  )
                );
                let i = !s.test(e);
                if (!i) {
                  const t = e.indexOf(n);
                  t > 0 && !s.test(e.substring(0, t)) && (i = !0);
                }
                return i;
              })(e, n, r);
          if (i && !o) {
            const t = e.match(this.interpolator.nestingRegexp);
            if (t && t.length > 0) return { key: e, namespaces: s };
            const i = e.split(n);
            (n !== r || (n === r && this.options.ns.indexOf(i[0]) > -1)) &&
              (s = i.shift()),
              (e = i.join(r));
          }
          return "string" === typeof s && (s = [s]), { key: e, namespaces: s };
        }
        translate(e, t, n) {
          if (
            ("object" !== typeof t &&
              this.options.overloadTranslationOptionHandler &&
              (t = this.options.overloadTranslationOptionHandler(arguments)),
            "object" === typeof t && (t = { ...t }),
            t || (t = {}),
            void 0 === e || null === e)
          )
            return "";
          Array.isArray(e) || (e = [String(e)]);
          const r =
              void 0 !== t.returnDetails
                ? t.returnDetails
                : this.options.returnDetails,
            s =
              void 0 !== t.keySeparator
                ? t.keySeparator
                : this.options.keySeparator,
            { key: i, namespaces: o } = this.extractFromKey(e[e.length - 1], t),
            a = o[o.length - 1],
            c = t.lng || this.language,
            l =
              t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
          if (c && "cimode" === c.toLowerCase()) {
            if (l) {
              const e = t.nsSeparator || this.options.nsSeparator;
              return r
                ? {
                    res: "".concat(a).concat(e).concat(i),
                    usedKey: i,
                    exactUsedKey: i,
                    usedLng: c,
                    usedNS: a,
                    usedParams: this.getUsedParamsDetails(t),
                  }
                : "".concat(a).concat(e).concat(i);
            }
            return r
              ? {
                  res: i,
                  usedKey: i,
                  exactUsedKey: i,
                  usedLng: c,
                  usedNS: a,
                  usedParams: this.getUsedParamsDetails(t),
                }
              : i;
          }
          const u = this.resolve(e, t);
          let d = u && u.res;
          const h = (u && u.usedKey) || i,
            p = (u && u.exactUsedKey) || i,
            f = Object.prototype.toString.apply(d),
            m =
              void 0 !== t.joinArrays ? t.joinArrays : this.options.joinArrays,
            g = !this.i18nFormat || this.i18nFormat.handleAsObject;
          if (
            g &&
            d &&
            "string" !== typeof d &&
            "boolean" !== typeof d &&
            "number" !== typeof d &&
            ["[object Number]", "[object Function]", "[object RegExp]"].indexOf(
              f
            ) < 0 &&
            ("string" !== typeof m || !Array.isArray(d))
          ) {
            if (!t.returnObjects && !this.options.returnObjects) {
              this.options.returnedObjectHandler ||
                this.logger.warn(
                  "accessing an object - but returnObjects options is not enabled!"
                );
              const e = this.options.returnedObjectHandler
                ? this.options.returnedObjectHandler(h, d, { ...t, ns: o })
                : "key '"
                    .concat(i, " (")
                    .concat(
                      this.language,
                      ")' returned an object instead of string."
                    );
              return r
                ? ((u.res = e),
                  (u.usedParams = this.getUsedParamsDetails(t)),
                  u)
                : e;
            }
            if (s) {
              const e = Array.isArray(d),
                n = e ? [] : {},
                r = e ? p : h;
              for (const i in d)
                if (Object.prototype.hasOwnProperty.call(d, i)) {
                  const e = "".concat(r).concat(s).concat(i);
                  (n[i] = this.translate(e, { ...t, joinArrays: !1, ns: o })),
                    n[i] === e && (n[i] = d[i]);
                }
              d = n;
            }
          } else if (g && "string" === typeof m && Array.isArray(d))
            (d = d.join(m)), d && (d = this.extendTranslation(d, e, t, n));
          else {
            let r = !1,
              o = !1;
            const l = void 0 !== t.count && "string" !== typeof t.count,
              h = rk.hasDefaultValue(t),
              p = l ? this.pluralResolver.getSuffix(c, t.count, t) : "",
              f =
                t.ordinal && l
                  ? this.pluralResolver.getSuffix(c, t.count, { ordinal: !1 })
                  : "",
              m =
                l &&
                !t.ordinal &&
                0 === t.count &&
                this.pluralResolver.shouldUseIntlApi(),
              g =
                (m &&
                  t[
                    "defaultValue".concat(this.options.pluralSeparator, "zero")
                  ]) ||
                t["defaultValue".concat(p)] ||
                t["defaultValue".concat(f)] ||
                t.defaultValue;
            !this.isValidLookup(d) && h && ((r = !0), (d = g)),
              this.isValidLookup(d) || ((o = !0), (d = i));
            const v =
                (t.missingKeyNoValueFallbackToKey ||
                  this.options.missingKeyNoValueFallbackToKey) &&
                o
                  ? void 0
                  : d,
              y = h && g !== d && this.options.updateMissing;
            if (o || r || y) {
              if (
                (this.logger.log(
                  y ? "updateKey" : "missingKey",
                  c,
                  a,
                  i,
                  y ? g : d
                ),
                s)
              ) {
                const e = this.resolve(i, { ...t, keySeparator: !1 });
                e &&
                  e.res &&
                  this.logger.warn(
                    "Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format."
                  );
              }
              let e = [];
              const n = this.languageUtils.getFallbackCodes(
                this.options.fallbackLng,
                t.lng || this.language
              );
              if ("fallback" === this.options.saveMissingTo && n && n[0])
                for (let t = 0; t < n.length; t++) e.push(n[t]);
              else
                "all" === this.options.saveMissingTo
                  ? (e = this.languageUtils.toResolveHierarchy(
                      t.lng || this.language
                    ))
                  : e.push(t.lng || this.language);
              const r = (e, n, r) => {
                const s = h && r !== d ? r : v;
                this.options.missingKeyHandler
                  ? this.options.missingKeyHandler(e, a, n, s, y, t)
                  : this.backendConnector &&
                    this.backendConnector.saveMissing &&
                    this.backendConnector.saveMissing(e, a, n, s, y, t),
                  this.emit("missingKey", e, a, n, d);
              };
              this.options.saveMissing &&
                (this.options.saveMissingPlurals && l
                  ? e.forEach((e) => {
                      const n = this.pluralResolver.getSuffixes(e, t);
                      m &&
                        t[
                          "defaultValue".concat(
                            this.options.pluralSeparator,
                            "zero"
                          )
                        ] &&
                        n.indexOf(
                          "".concat(this.options.pluralSeparator, "zero")
                        ) < 0 &&
                        n.push("".concat(this.options.pluralSeparator, "zero")),
                        n.forEach((n) => {
                          r([e], i + n, t["defaultValue".concat(n)] || g);
                        });
                    })
                  : r(e, i, g));
            }
            (d = this.extendTranslation(d, e, t, u, n)),
              o &&
                d === i &&
                this.options.appendNamespaceToMissingKey &&
                (d = "".concat(a, ":").concat(i)),
              (o || r) &&
                this.options.parseMissingKeyHandler &&
                (d =
                  "v1" !== this.options.compatibilityAPI
                    ? this.options.parseMissingKeyHandler(
                        this.options.appendNamespaceToMissingKey
                          ? "".concat(a, ":").concat(i)
                          : i,
                        r ? d : void 0
                      )
                    : this.options.parseMissingKeyHandler(d));
          }
          return r
            ? ((u.res = d), (u.usedParams = this.getUsedParamsDetails(t)), u)
            : d;
        }
        extendTranslation(e, t, n, r, s) {
          var i = this;
          if (this.i18nFormat && this.i18nFormat.parse)
            e = this.i18nFormat.parse(
              e,
              { ...this.options.interpolation.defaultVariables, ...n },
              n.lng || this.language || r.usedLng,
              r.usedNS,
              r.usedKey,
              { resolved: r }
            );
          else if (!n.skipInterpolation) {
            n.interpolation &&
              this.interpolator.init({
                ...n,
                interpolation: {
                  ...this.options.interpolation,
                  ...n.interpolation,
                },
              });
            const o =
              "string" === typeof e &&
              (n &&
              n.interpolation &&
              void 0 !== n.interpolation.skipOnVariables
                ? n.interpolation.skipOnVariables
                : this.options.interpolation.skipOnVariables);
            let a;
            if (o) {
              const t = e.match(this.interpolator.nestingRegexp);
              a = t && t.length;
            }
            let c = n.replace && "string" !== typeof n.replace ? n.replace : n;
            if (
              (this.options.interpolation.defaultVariables &&
                (c = { ...this.options.interpolation.defaultVariables, ...c }),
              (e = this.interpolator.interpolate(
                e,
                c,
                n.lng || this.language,
                n
              )),
              o)
            ) {
              const t = e.match(this.interpolator.nestingRegexp);
              a < (t && t.length) && (n.nest = !1);
            }
            !n.lng &&
              "v1" !== this.options.compatibilityAPI &&
              r &&
              r.res &&
              (n.lng = r.usedLng),
              !1 !== n.nest &&
                (e = this.interpolator.nest(
                  e,
                  function () {
                    for (
                      var e = arguments.length, r = new Array(e), o = 0;
                      o < e;
                      o++
                    )
                      r[o] = arguments[o];
                    return s && s[0] === r[0] && !n.context
                      ? (i.logger.warn(
                          "It seems you are nesting recursively key: "
                            .concat(r[0], " in key: ")
                            .concat(t[0])
                        ),
                        null)
                      : i.translate(...r, t);
                  },
                  n
                )),
              n.interpolation && this.interpolator.reset();
          }
          const o = n.postProcess || this.options.postProcess,
            a = "string" === typeof o ? [o] : o;
          return (
            void 0 !== e &&
              null !== e &&
              a &&
              a.length &&
              !1 !== n.applyPostProcessor &&
              (e = tk.handle(
                a,
                e,
                t,
                this.options && this.options.postProcessPassResolved
                  ? {
                      i18nResolved: {
                        ...r,
                        usedParams: this.getUsedParamsDetails(n),
                      },
                      ...n,
                    }
                  : n,
                this
              )),
            e
          );
        }
        resolve(e) {
          let t,
            n,
            r,
            s,
            i,
            o =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {};
          return (
            "string" === typeof e && (e = [e]),
            e.forEach((e) => {
              if (this.isValidLookup(t)) return;
              const a = this.extractFromKey(e, o),
                c = a.key;
              n = c;
              let l = a.namespaces;
              this.options.fallbackNS &&
                (l = l.concat(this.options.fallbackNS));
              const u = void 0 !== o.count && "string" !== typeof o.count,
                d =
                  u &&
                  !o.ordinal &&
                  0 === o.count &&
                  this.pluralResolver.shouldUseIntlApi(),
                h =
                  void 0 !== o.context &&
                  ("string" === typeof o.context ||
                    "number" === typeof o.context) &&
                  "" !== o.context,
                p = o.lngs
                  ? o.lngs
                  : this.languageUtils.toResolveHierarchy(
                      o.lng || this.language,
                      o.fallbackLng
                    );
              l.forEach((e) => {
                this.isValidLookup(t) ||
                  ((i = e),
                  !nk["".concat(p[0], "-").concat(e)] &&
                    this.utils &&
                    this.utils.hasLoadedNamespace &&
                    !this.utils.hasLoadedNamespace(i) &&
                    ((nk["".concat(p[0], "-").concat(e)] = !0),
                    this.logger.warn(
                      'key "'
                        .concat(n, '" for languages "')
                        .concat(
                          p.join(", "),
                          '" won\'t get resolved as namespace "'
                        )
                        .concat(i, '" was not yet loaded'),
                      "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"
                    )),
                  p.forEach((n) => {
                    if (this.isValidLookup(t)) return;
                    s = n;
                    const i = [c];
                    if (this.i18nFormat && this.i18nFormat.addLookupKeys)
                      this.i18nFormat.addLookupKeys(i, c, n, e, o);
                    else {
                      let e;
                      u && (e = this.pluralResolver.getSuffix(n, o.count, o));
                      const t = "".concat(this.options.pluralSeparator, "zero"),
                        r = ""
                          .concat(this.options.pluralSeparator, "ordinal")
                          .concat(this.options.pluralSeparator);
                      if (
                        (u &&
                          (i.push(c + e),
                          o.ordinal &&
                            0 === e.indexOf(r) &&
                            i.push(
                              c + e.replace(r, this.options.pluralSeparator)
                            ),
                          d && i.push(c + t)),
                        h)
                      ) {
                        const n = ""
                          .concat(c)
                          .concat(this.options.contextSeparator)
                          .concat(o.context);
                        i.push(n),
                          u &&
                            (i.push(n + e),
                            o.ordinal &&
                              0 === e.indexOf(r) &&
                              i.push(
                                n + e.replace(r, this.options.pluralSeparator)
                              ),
                            d && i.push(n + t));
                      }
                    }
                    let a;
                    for (; (a = i.pop()); )
                      this.isValidLookup(t) ||
                        ((r = a), (t = this.getResource(n, e, a, o)));
                  }));
              });
            }),
            { res: t, usedKey: n, exactUsedKey: r, usedLng: s, usedNS: i }
          );
        }
        isValidLookup(e) {
          return (
            void 0 !== e &&
            !(!this.options.returnNull && null === e) &&
            !(!this.options.returnEmptyString && "" === e)
          );
        }
        getResource(e, t, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
          return this.i18nFormat && this.i18nFormat.getResource
            ? this.i18nFormat.getResource(e, t, n, r)
            : this.resourceStore.getResource(e, t, n, r);
        }
        getUsedParamsDetails() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          const t = [
              "defaultValue",
              "ordinal",
              "context",
              "replace",
              "lng",
              "lngs",
              "fallbackLng",
              "ns",
              "keySeparator",
              "nsSeparator",
              "returnObjects",
              "returnDetails",
              "joinArrays",
              "postProcess",
              "interpolation",
            ],
            n = e.replace && "string" !== typeof e.replace;
          let r = n ? e.replace : e;
          if (
            (n && "undefined" !== typeof e.count && (r.count = e.count),
            this.options.interpolation.defaultVariables &&
              (r = { ...this.options.interpolation.defaultVariables, ...r }),
            !n)
          ) {
            r = { ...r };
            for (const e of t) delete r[e];
          }
          return r;
        }
        static hasDefaultValue(e) {
          const t = "defaultValue";
          for (const n in e)
            if (
              Object.prototype.hasOwnProperty.call(e, n) &&
              t === n.substring(0, 12) &&
              void 0 !== e[n]
            )
              return !0;
          return !1;
        }
      }
      function sk(e) {
        return e.charAt(0).toUpperCase() + e.slice(1);
      }
      class ik {
        constructor(e) {
          (this.options = e),
            (this.supportedLngs = this.options.supportedLngs || !1),
            (this.logger = UC.create("languageUtils"));
        }
        getScriptPartFromCode(e) {
          if (!(e = $C(e)) || e.indexOf("-") < 0) return null;
          const t = e.split("-");
          return 2 === t.length
            ? null
            : (t.pop(),
              "x" === t[t.length - 1].toLowerCase()
                ? null
                : this.formatLanguageCode(t.join("-")));
        }
        getLanguagePartFromCode(e) {
          if (!(e = $C(e)) || e.indexOf("-") < 0) return e;
          const t = e.split("-");
          return this.formatLanguageCode(t[0]);
        }
        formatLanguageCode(e) {
          if ("string" === typeof e && e.indexOf("-") > -1) {
            const t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
            let n = e.split("-");
            return (
              this.options.lowerCaseLng
                ? (n = n.map((e) => e.toLowerCase()))
                : 2 === n.length
                ? ((n[0] = n[0].toLowerCase()),
                  (n[1] = n[1].toUpperCase()),
                  t.indexOf(n[1].toLowerCase()) > -1 &&
                    (n[1] = sk(n[1].toLowerCase())))
                : 3 === n.length &&
                  ((n[0] = n[0].toLowerCase()),
                  2 === n[1].length && (n[1] = n[1].toUpperCase()),
                  "sgn" !== n[0] &&
                    2 === n[2].length &&
                    (n[2] = n[2].toUpperCase()),
                  t.indexOf(n[1].toLowerCase()) > -1 &&
                    (n[1] = sk(n[1].toLowerCase())),
                  t.indexOf(n[2].toLowerCase()) > -1 &&
                    (n[2] = sk(n[2].toLowerCase()))),
              n.join("-")
            );
          }
          return this.options.cleanCode || this.options.lowerCaseLng
            ? e.toLowerCase()
            : e;
        }
        isSupportedCode(e) {
          return (
            ("languageOnly" === this.options.load ||
              this.options.nonExplicitSupportedLngs) &&
              (e = this.getLanguagePartFromCode(e)),
            !this.supportedLngs ||
              !this.supportedLngs.length ||
              this.supportedLngs.indexOf(e) > -1
          );
        }
        getBestMatchFromCodes(e) {
          if (!e) return null;
          let t;
          return (
            e.forEach((e) => {
              if (t) return;
              const n = this.formatLanguageCode(e);
              (this.options.supportedLngs && !this.isSupportedCode(n)) ||
                (t = n);
            }),
            !t &&
              this.options.supportedLngs &&
              e.forEach((e) => {
                if (t) return;
                const n = this.getLanguagePartFromCode(e);
                if (this.isSupportedCode(n)) return (t = n);
                t = this.options.supportedLngs.find((e) =>
                  e === n
                    ? e
                    : e.indexOf("-") < 0 && n.indexOf("-") < 0
                    ? void 0
                    : (e.indexOf("-") > 0 &&
                        n.indexOf("-") < 0 &&
                        e.substring(0, e.indexOf("-")) === n) ||
                      (0 === e.indexOf(n) && n.length > 1)
                    ? e
                    : void 0
                );
              }),
            t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]),
            t
          );
        }
        getFallbackCodes(e, t) {
          if (!e) return [];
          if (
            ("function" === typeof e && (e = e(t)),
            "string" === typeof e && (e = [e]),
            Array.isArray(e))
          )
            return e;
          if (!t) return e.default || [];
          let n = e[t];
          return (
            n || (n = e[this.getScriptPartFromCode(t)]),
            n || (n = e[this.formatLanguageCode(t)]),
            n || (n = e[this.getLanguagePartFromCode(t)]),
            n || (n = e.default),
            n || []
          );
        }
        toResolveHierarchy(e, t) {
          const n = this.getFallbackCodes(
              t || this.options.fallbackLng || [],
              e
            ),
            r = [],
            s = (e) => {
              e &&
                (this.isSupportedCode(e)
                  ? r.push(e)
                  : this.logger.warn(
                      "rejecting language code not found in supportedLngs: ".concat(
                        e
                      )
                    ));
            };
          return (
            "string" === typeof e &&
            (e.indexOf("-") > -1 || e.indexOf("_") > -1)
              ? ("languageOnly" !== this.options.load &&
                  s(this.formatLanguageCode(e)),
                "languageOnly" !== this.options.load &&
                  "currentOnly" !== this.options.load &&
                  s(this.getScriptPartFromCode(e)),
                "currentOnly" !== this.options.load &&
                  s(this.getLanguagePartFromCode(e)))
              : "string" === typeof e && s(this.formatLanguageCode(e)),
            n.forEach((e) => {
              r.indexOf(e) < 0 && s(this.formatLanguageCode(e));
            }),
            r
          );
        }
      }
      let ok = [
          {
            lngs: [
              "ach",
              "ak",
              "am",
              "arn",
              "br",
              "fil",
              "gun",
              "ln",
              "mfe",
              "mg",
              "mi",
              "oc",
              "pt",
              "pt-BR",
              "tg",
              "tl",
              "ti",
              "tr",
              "uz",
              "wa",
            ],
            nr: [1, 2],
            fc: 1,
          },
          {
            lngs: [
              "af",
              "an",
              "ast",
              "az",
              "bg",
              "bn",
              "ca",
              "da",
              "de",
              "dev",
              "el",
              "en",
              "eo",
              "es",
              "et",
              "eu",
              "fi",
              "fo",
              "fur",
              "fy",
              "gl",
              "gu",
              "ha",
              "hi",
              "hu",
              "hy",
              "ia",
              "it",
              "kk",
              "kn",
              "ku",
              "lb",
              "mai",
              "ml",
              "mn",
              "mr",
              "nah",
              "nap",
              "nb",
              "ne",
              "nl",
              "nn",
              "no",
              "nso",
              "pa",
              "pap",
              "pms",
              "ps",
              "pt-PT",
              "rm",
              "sco",
              "se",
              "si",
              "so",
              "son",
              "sq",
              "sv",
              "sw",
              "ta",
              "te",
              "tk",
              "ur",
              "yo",
            ],
            nr: [1, 2],
            fc: 2,
          },
          {
            lngs: [
              "ay",
              "bo",
              "cgg",
              "fa",
              "ht",
              "id",
              "ja",
              "jbo",
              "ka",
              "km",
              "ko",
              "ky",
              "lo",
              "ms",
              "sah",
              "su",
              "th",
              "tt",
              "ug",
              "vi",
              "wo",
              "zh",
            ],
            nr: [1],
            fc: 3,
          },
          {
            lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
            nr: [1, 2, 5],
            fc: 4,
          },
          { lngs: ["ar"], nr: [0, 1, 2, 3, 11, 100], fc: 5 },
          { lngs: ["cs", "sk"], nr: [1, 2, 5], fc: 6 },
          { lngs: ["csb", "pl"], nr: [1, 2, 5], fc: 7 },
          { lngs: ["cy"], nr: [1, 2, 3, 8], fc: 8 },
          { lngs: ["fr"], nr: [1, 2], fc: 9 },
          { lngs: ["ga"], nr: [1, 2, 3, 7, 11], fc: 10 },
          { lngs: ["gd"], nr: [1, 2, 3, 20], fc: 11 },
          { lngs: ["is"], nr: [1, 2], fc: 12 },
          { lngs: ["jv"], nr: [0, 1], fc: 13 },
          { lngs: ["kw"], nr: [1, 2, 3, 4], fc: 14 },
          { lngs: ["lt"], nr: [1, 2, 10], fc: 15 },
          { lngs: ["lv"], nr: [1, 2, 0], fc: 16 },
          { lngs: ["mk"], nr: [1, 2], fc: 17 },
          { lngs: ["mnk"], nr: [0, 1, 2], fc: 18 },
          { lngs: ["mt"], nr: [1, 2, 11, 20], fc: 19 },
          { lngs: ["or"], nr: [2, 1], fc: 2 },
          { lngs: ["ro"], nr: [1, 2, 20], fc: 20 },
          { lngs: ["sl"], nr: [5, 1, 2, 3], fc: 21 },
          { lngs: ["he", "iw"], nr: [1, 2, 20, 21], fc: 22 },
        ],
        ak = {
          1: function (e) {
            return Number(e > 1);
          },
          2: function (e) {
            return Number(1 != e);
          },
          3: function (e) {
            return 0;
          },
          4: function (e) {
            return Number(
              e % 10 == 1 && e % 100 != 11
                ? 0
                : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20)
                ? 1
                : 2
            );
          },
          5: function (e) {
            return Number(
              0 == e
                ? 0
                : 1 == e
                ? 1
                : 2 == e
                ? 2
                : e % 100 >= 3 && e % 100 <= 10
                ? 3
                : e % 100 >= 11
                ? 4
                : 5
            );
          },
          6: function (e) {
            return Number(1 == e ? 0 : e >= 2 && e <= 4 ? 1 : 2);
          },
          7: function (e) {
            return Number(
              1 == e
                ? 0
                : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20)
                ? 1
                : 2
            );
          },
          8: function (e) {
            return Number(1 == e ? 0 : 2 == e ? 1 : 8 != e && 11 != e ? 2 : 3);
          },
          9: function (e) {
            return Number(e >= 2);
          },
          10: function (e) {
            return Number(1 == e ? 0 : 2 == e ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4);
          },
          11: function (e) {
            return Number(
              1 == e || 11 == e
                ? 0
                : 2 == e || 12 == e
                ? 1
                : e > 2 && e < 20
                ? 2
                : 3
            );
          },
          12: function (e) {
            return Number(e % 10 != 1 || e % 100 == 11);
          },
          13: function (e) {
            return Number(0 !== e);
          },
          14: function (e) {
            return Number(1 == e ? 0 : 2 == e ? 1 : 3 == e ? 2 : 3);
          },
          15: function (e) {
            return Number(
              e % 10 == 1 && e % 100 != 11
                ? 0
                : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20)
                ? 1
                : 2
            );
          },
          16: function (e) {
            return Number(e % 10 == 1 && e % 100 != 11 ? 0 : 0 !== e ? 1 : 2);
          },
          17: function (e) {
            return Number(1 == e || (e % 10 == 1 && e % 100 != 11) ? 0 : 1);
          },
          18: function (e) {
            return Number(0 == e ? 0 : 1 == e ? 1 : 2);
          },
          19: function (e) {
            return Number(
              1 == e
                ? 0
                : 0 == e || (e % 100 > 1 && e % 100 < 11)
                ? 1
                : e % 100 > 10 && e % 100 < 20
                ? 2
                : 3
            );
          },
          20: function (e) {
            return Number(
              1 == e ? 0 : 0 == e || (e % 100 > 0 && e % 100 < 20) ? 1 : 2
            );
          },
          21: function (e) {
            return Number(
              e % 100 == 1
                ? 1
                : e % 100 == 2
                ? 2
                : e % 100 == 3 || e % 100 == 4
                ? 3
                : 0
            );
          },
          22: function (e) {
            return Number(
              1 == e ? 0 : 2 == e ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3
            );
          },
        };
      const ck = ["v1", "v2", "v3"],
        lk = ["v4"],
        uk = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 };
      class dk {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          (this.languageUtils = e),
            (this.options = t),
            (this.logger = UC.create("pluralResolver")),
            (this.options.compatibilityJSON &&
              !lk.includes(this.options.compatibilityJSON)) ||
              ("undefined" !== typeof Intl && Intl.PluralRules) ||
              ((this.options.compatibilityJSON = "v3"),
              this.logger.error(
                "Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling."
              )),
            (this.rules = (function () {
              const e = {};
              return (
                ok.forEach((t) => {
                  t.lngs.forEach((n) => {
                    e[n] = { numbers: t.nr, plurals: ak[t.fc] };
                  });
                }),
                e
              );
            })());
        }
        addRule(e, t) {
          this.rules[e] = t;
        }
        getRule(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (this.shouldUseIntlApi())
            try {
              return new Intl.PluralRules($C("dev" === e ? "en" : e), {
                type: t.ordinal ? "ordinal" : "cardinal",
              });
            } catch (n) {
              return;
            }
          return (
            this.rules[e] ||
            this.rules[this.languageUtils.getLanguagePartFromCode(e)]
          );
        }
        needsPlural(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          const n = this.getRule(e, t);
          return this.shouldUseIntlApi()
            ? n && n.resolvedOptions().pluralCategories.length > 1
            : n && n.numbers.length > 1;
        }
        getPluralFormsOfKey(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return this.getSuffixes(e, n).map((e) => "".concat(t).concat(e));
        }
        getSuffixes(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          const n = this.getRule(e, t);
          return n
            ? this.shouldUseIntlApi()
              ? n
                  .resolvedOptions()
                  .pluralCategories.sort((e, t) => uk[e] - uk[t])
                  .map((e) =>
                    ""
                      .concat(this.options.prepend)
                      .concat(
                        t.ordinal ? "ordinal".concat(this.options.prepend) : ""
                      )
                      .concat(e)
                  )
              : n.numbers.map((n) => this.getSuffix(e, n, t))
            : [];
        }
        getSuffix(e, t) {
          let n =
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          const r = this.getRule(e, n);
          return r
            ? this.shouldUseIntlApi()
              ? ""
                  .concat(this.options.prepend)
                  .concat(
                    n.ordinal ? "ordinal".concat(this.options.prepend) : ""
                  )
                  .concat(r.select(t))
              : this.getSuffixRetroCompatible(r, t)
            : (this.logger.warn("no plural rule found for: ".concat(e)), "");
        }
        getSuffixRetroCompatible(e, t) {
          const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
          let r = e.numbers[n];
          this.options.simplifyPluralSuffix &&
            2 === e.numbers.length &&
            1 === e.numbers[0] &&
            (2 === r ? (r = "plural") : 1 === r && (r = ""));
          const s = () =>
            this.options.prepend && r.toString()
              ? this.options.prepend + r.toString()
              : r.toString();
          return "v1" === this.options.compatibilityJSON
            ? 1 === r
              ? ""
              : "number" === typeof r
              ? "_plural_".concat(r.toString())
              : s()
            : "v2" === this.options.compatibilityJSON ||
              (this.options.simplifyPluralSuffix &&
                2 === e.numbers.length &&
                1 === e.numbers[0])
            ? s()
            : this.options.prepend && n.toString()
            ? this.options.prepend + n.toString()
            : n.toString();
        }
        shouldUseIntlApi() {
          return !ck.includes(this.options.compatibilityJSON);
        }
      }
      function hk(e, t, n) {
        let r =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : ".",
          s =
            !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
          i = (function (e, t, n) {
            const r = KC(e, n);
            return void 0 !== r ? r : KC(t, n);
          })(e, t, n);
        return (
          !i &&
            s &&
            "string" === typeof n &&
            ((i = ZC(e, n, r)), void 0 === i && (i = ZC(t, n, r))),
          i
        );
      }
      class pk {
        constructor() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          (this.logger = UC.create("interpolator")),
            (this.options = e),
            (this.format =
              (e.interpolation && e.interpolation.format) || ((e) => e)),
            this.init(e);
        }
        init() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          e.interpolation || (e.interpolation = { escapeValue: !0 });
          const {
            escape: t,
            escapeValue: n,
            useRawValueToEscape: r,
            prefix: s,
            prefixEscaped: i,
            suffix: o,
            suffixEscaped: a,
            formatSeparator: c,
            unescapeSuffix: l,
            unescapePrefix: u,
            nestingPrefix: d,
            nestingPrefixEscaped: h,
            nestingSuffix: p,
            nestingSuffixEscaped: f,
            nestingOptionsSeparator: m,
            maxReplaces: g,
            alwaysFormat: v,
          } = e.interpolation;
          (this.escape = void 0 !== t ? t : QC),
            (this.escapeValue = void 0 === n || n),
            (this.useRawValueToEscape = void 0 !== r && r),
            (this.prefix = s ? GC(s) : i || "{{"),
            (this.suffix = o ? GC(o) : a || "}}"),
            (this.formatSeparator = c || ","),
            (this.unescapePrefix = l ? "" : u || "-"),
            (this.unescapeSuffix = this.unescapePrefix ? "" : l || ""),
            (this.nestingPrefix = d ? GC(d) : h || GC("$t(")),
            (this.nestingSuffix = p ? GC(p) : f || GC(")")),
            (this.nestingOptionsSeparator = m || ","),
            (this.maxReplaces = g || 1e3),
            (this.alwaysFormat = void 0 !== v && v),
            this.resetRegExp();
        }
        reset() {
          this.options && this.init(this.options);
        }
        resetRegExp() {
          const e = (e, t) =>
            e && e.source === t ? ((e.lastIndex = 0), e) : new RegExp(t, "g");
          (this.regexp = e(
            this.regexp,
            "".concat(this.prefix, "(.+?)").concat(this.suffix)
          )),
            (this.regexpUnescape = e(
              this.regexpUnescape,
              ""
                .concat(this.prefix)
                .concat(this.unescapePrefix, "(.+?)")
                .concat(this.unescapeSuffix)
                .concat(this.suffix)
            )),
            (this.nestingRegexp = e(
              this.nestingRegexp,
              "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix)
            ));
        }
        interpolate(e, t, n, r) {
          let s, i, o;
          const a =
            (this.options &&
              this.options.interpolation &&
              this.options.interpolation.defaultVariables) ||
            {};
          function c(e) {
            return e.replace(/\$/g, "$$$$");
          }
          const l = (e) => {
            if (e.indexOf(this.formatSeparator) < 0) {
              const s = hk(
                t,
                a,
                e,
                this.options.keySeparator,
                this.options.ignoreJSONStructure
              );
              return this.alwaysFormat
                ? this.format(s, void 0, n, { ...r, ...t, interpolationkey: e })
                : s;
            }
            const s = e.split(this.formatSeparator),
              i = s.shift().trim(),
              o = s.join(this.formatSeparator).trim();
            return this.format(
              hk(
                t,
                a,
                i,
                this.options.keySeparator,
                this.options.ignoreJSONStructure
              ),
              o,
              n,
              { ...r, ...t, interpolationkey: i }
            );
          };
          this.resetRegExp();
          const u =
              (r && r.missingInterpolationHandler) ||
              this.options.missingInterpolationHandler,
            d =
              r && r.interpolation && void 0 !== r.interpolation.skipOnVariables
                ? r.interpolation.skipOnVariables
                : this.options.interpolation.skipOnVariables;
          return (
            [
              { regex: this.regexpUnescape, safeValue: (e) => c(e) },
              {
                regex: this.regexp,
                safeValue: (e) => (this.escapeValue ? c(this.escape(e)) : c(e)),
              },
            ].forEach((t) => {
              for (o = 0; (s = t.regex.exec(e)); ) {
                const n = s[1].trim();
                if (((i = l(n)), void 0 === i))
                  if ("function" === typeof u) {
                    const t = u(e, s, r);
                    i = "string" === typeof t ? t : "";
                  } else if (r && Object.prototype.hasOwnProperty.call(r, n))
                    i = "";
                  else {
                    if (d) {
                      i = s[0];
                      continue;
                    }
                    this.logger.warn(
                      "missed to pass in variable "
                        .concat(n, " for interpolating ")
                        .concat(e)
                    ),
                      (i = "");
                  }
                else
                  "string" === typeof i ||
                    this.useRawValueToEscape ||
                    (i = VC(i));
                const a = t.safeValue(i);
                if (
                  ((e = e.replace(s[0], a)),
                  d
                    ? ((t.regex.lastIndex += i.length),
                      (t.regex.lastIndex -= s[0].length))
                    : (t.regex.lastIndex = 0),
                  o++,
                  o >= this.maxReplaces)
                )
                  break;
              }
            }),
            e
          );
        }
        nest(e, t) {
          let n,
            r,
            s,
            i =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
          function o(e, t) {
            const n = this.nestingOptionsSeparator;
            if (e.indexOf(n) < 0) return e;
            const r = e.split(new RegExp("".concat(n, "[ ]*{")));
            let i = "{".concat(r[1]);
            (e = r[0]), (i = this.interpolate(i, s));
            const o = i.match(/'/g),
              a = i.match(/"/g);
            ((o && o.length % 2 === 0 && !a) || a.length % 2 !== 0) &&
              (i = i.replace(/'/g, '"'));
            try {
              (s = JSON.parse(i)), t && (s = { ...t, ...s });
            } catch (a_) {
              return (
                this.logger.warn(
                  "failed parsing options string in nesting for key ".concat(e),
                  a_
                ),
                "".concat(e).concat(n).concat(i)
              );
            }
            return (
              s.defaultValue &&
                s.defaultValue.indexOf(this.prefix) > -1 &&
                delete s.defaultValue,
              e
            );
          }
          for (; (n = this.nestingRegexp.exec(e)); ) {
            let a = [];
            (s = { ...i }),
              (s = s.replace && "string" !== typeof s.replace ? s.replace : s),
              (s.applyPostProcessor = !1),
              delete s.defaultValue;
            let c = !1;
            if (
              -1 !== n[0].indexOf(this.formatSeparator) &&
              !/{.*}/.test(n[1])
            ) {
              const e = n[1].split(this.formatSeparator).map((e) => e.trim());
              (n[1] = e.shift()), (a = e), (c = !0);
            }
            if (
              ((r = t(o.call(this, n[1].trim(), s), s)),
              r && n[0] === e && "string" !== typeof r)
            )
              return r;
            "string" !== typeof r && (r = VC(r)),
              r ||
                (this.logger.warn(
                  "missed to resolve ".concat(n[1], " for nesting ").concat(e)
                ),
                (r = "")),
              c &&
                (r = a.reduce(
                  (e, t) =>
                    this.format(e, t, i.lng, {
                      ...i,
                      interpolationkey: n[1].trim(),
                    }),
                  r.trim()
                )),
              (e = e.replace(n[0], r)),
              (this.regexp.lastIndex = 0);
          }
          return e;
        }
      }
      function fk(e) {
        const t = {};
        return function (n, r, s) {
          const i = r + JSON.stringify(s);
          let o = t[i];
          return o || ((o = e($C(r), s)), (t[i] = o)), o(n);
        };
      }
      class mk {
        constructor() {
          let e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          (this.logger = UC.create("formatter")),
            (this.options = e),
            (this.formats = {
              number: fk((e, t) => {
                const n = new Intl.NumberFormat(e, { ...t });
                return (e) => n.format(e);
              }),
              currency: fk((e, t) => {
                const n = new Intl.NumberFormat(e, { ...t, style: "currency" });
                return (e) => n.format(e);
              }),
              datetime: fk((e, t) => {
                const n = new Intl.DateTimeFormat(e, { ...t });
                return (e) => n.format(e);
              }),
              relativetime: fk((e, t) => {
                const n = new Intl.RelativeTimeFormat(e, { ...t });
                return (e) => n.format(e, t.range || "day");
              }),
              list: fk((e, t) => {
                const n = new Intl.ListFormat(e, { ...t });
                return (e) => n.format(e);
              }),
            }),
            this.init(e);
        }
        init(e) {
          const t = (
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : { interpolation: {} }
          ).interpolation;
          this.formatSeparator = t.formatSeparator
            ? t.formatSeparator
            : t.formatSeparator || ",";
        }
        add(e, t) {
          this.formats[e.toLowerCase().trim()] = t;
        }
        addCached(e, t) {
          this.formats[e.toLowerCase().trim()] = fk(t);
        }
        format(e, t, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
          const s = t.split(this.formatSeparator).reduce((e, t) => {
            const { formatName: s, formatOptions: i } = (function (e) {
              let t = e.toLowerCase().trim();
              const n = {};
              if (e.indexOf("(") > -1) {
                const r = e.split("(");
                t = r[0].toLowerCase().trim();
                const s = r[1].substring(0, r[1].length - 1);
                "currency" === t && s.indexOf(":") < 0
                  ? n.currency || (n.currency = s.trim())
                  : "relativetime" === t && s.indexOf(":") < 0
                  ? n.range || (n.range = s.trim())
                  : s.split(";").forEach((e) => {
                      if (e) {
                        const [t, ...r] = e.split(":"),
                          s = r
                            .join(":")
                            .trim()
                            .replace(/^'+|'+$/g, ""),
                          i = t.trim();
                        n[i] || (n[i] = s),
                          "false" === s && (n[i] = !1),
                          "true" === s && (n[i] = !0),
                          isNaN(s) || (n[i] = parseInt(s, 10));
                      }
                    });
              }
              return { formatName: t, formatOptions: n };
            })(t);
            if (this.formats[s]) {
              let t = e;
              try {
                const o =
                    (r &&
                      r.formatParams &&
                      r.formatParams[r.interpolationkey]) ||
                    {},
                  a = o.locale || o.lng || r.locale || r.lng || n;
                t = this.formats[s](e, a, { ...i, ...r, ...o });
              } catch (o) {
                this.logger.warn(o);
              }
              return t;
            }
            return (
              this.logger.warn("there was no format function for ".concat(s)), e
            );
          }, e);
          return s;
        }
      }
      class gk extends FC {
        constructor(e, t, n) {
          let r =
            arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
          super(),
            (this.backend = e),
            (this.store = t),
            (this.services = n),
            (this.languageUtils = n.languageUtils),
            (this.options = r),
            (this.logger = UC.create("backendConnector")),
            (this.waitingReads = []),
            (this.maxParallelReads = r.maxParallelReads || 10),
            (this.readingCalls = 0),
            (this.maxRetries = r.maxRetries >= 0 ? r.maxRetries : 5),
            (this.retryTimeout = r.retryTimeout >= 1 ? r.retryTimeout : 350),
            (this.state = {}),
            (this.queue = []),
            this.backend &&
              this.backend.init &&
              this.backend.init(n, r.backend, r);
        }
        queueLoad(e, t, n, r) {
          const s = {},
            i = {},
            o = {},
            a = {};
          return (
            e.forEach((e) => {
              let r = !0;
              t.forEach((t) => {
                const o = "".concat(e, "|").concat(t);
                !n.reload && this.store.hasResourceBundle(e, t)
                  ? (this.state[o] = 2)
                  : this.state[o] < 0 ||
                    (1 === this.state[o]
                      ? void 0 === i[o] && (i[o] = !0)
                      : ((this.state[o] = 1),
                        (r = !1),
                        void 0 === i[o] && (i[o] = !0),
                        void 0 === s[o] && (s[o] = !0),
                        void 0 === a[t] && (a[t] = !0)));
              }),
                r || (o[e] = !0);
            }),
            (Object.keys(s).length || Object.keys(i).length) &&
              this.queue.push({
                pending: i,
                pendingCount: Object.keys(i).length,
                loaded: {},
                errors: [],
                callback: r,
              }),
            {
              toLoad: Object.keys(s),
              pending: Object.keys(i),
              toLoadLanguages: Object.keys(o),
              toLoadNamespaces: Object.keys(a),
            }
          );
        }
        loaded(e, t, n) {
          const r = e.split("|"),
            s = r[0],
            i = r[1];
          t && this.emit("failedLoading", s, i, t),
            n &&
              this.store.addResourceBundle(s, i, n, void 0, void 0, {
                skipCopy: !0,
              }),
            (this.state[e] = t ? -1 : 2);
          const o = {};
          this.queue.forEach((n) => {
            !(function (e, t, n, r) {
              const { obj: s, k: i } = HC(e, t, Object);
              (s[i] = s[i] || []),
                r && (s[i] = s[i].concat(n)),
                r || s[i].push(n);
            })(n.loaded, [s], i),
              (function (e, t) {
                void 0 !== e.pending[t] &&
                  (delete e.pending[t], e.pendingCount--);
              })(n, e),
              t && n.errors.push(t),
              0 !== n.pendingCount ||
                n.done ||
                (Object.keys(n.loaded).forEach((e) => {
                  o[e] || (o[e] = {});
                  const t = n.loaded[e];
                  t.length &&
                    t.forEach((t) => {
                      void 0 === o[e][t] && (o[e][t] = !0);
                    });
                }),
                (n.done = !0),
                n.errors.length ? n.callback(n.errors) : n.callback());
          }),
            this.emit("loaded", o),
            (this.queue = this.queue.filter((e) => !e.done));
        }
        read(e, t, n) {
          let r =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : 0,
            s =
              arguments.length > 4 && void 0 !== arguments[4]
                ? arguments[4]
                : this.retryTimeout,
            i = arguments.length > 5 ? arguments[5] : void 0;
          if (!e.length) return i(null, {});
          if (this.readingCalls >= this.maxParallelReads)
            return void this.waitingReads.push({
              lng: e,
              ns: t,
              fcName: n,
              tried: r,
              wait: s,
              callback: i,
            });
          this.readingCalls++;
          const o = (o, a) => {
              if ((this.readingCalls--, this.waitingReads.length > 0)) {
                const e = this.waitingReads.shift();
                this.read(e.lng, e.ns, e.fcName, e.tried, e.wait, e.callback);
              }
              o && a && r < this.maxRetries
                ? setTimeout(() => {
                    this.read.call(this, e, t, n, r + 1, 2 * s, i);
                  }, s)
                : i(o, a);
            },
            a = this.backend[n].bind(this.backend);
          if (2 !== a.length) return a(e, t, o);
          try {
            const n = a(e, t);
            n && "function" === typeof n.then
              ? n.then((e) => o(null, e)).catch(o)
              : o(null, n);
          } catch (c) {
            o(c);
          }
        }
        prepareLoading(e, t) {
          let n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {},
            r = arguments.length > 3 ? arguments[3] : void 0;
          if (!this.backend)
            return (
              this.logger.warn(
                "No backend was added via i18next.use. Will not load resources."
              ),
              r && r()
            );
          "string" === typeof e &&
            (e = this.languageUtils.toResolveHierarchy(e)),
            "string" === typeof t && (t = [t]);
          const s = this.queueLoad(e, t, n, r);
          if (!s.toLoad.length) return s.pending.length || r(), null;
          s.toLoad.forEach((e) => {
            this.loadOne(e);
          });
        }
        load(e, t, n) {
          this.prepareLoading(e, t, {}, n);
        }
        reload(e, t, n) {
          this.prepareLoading(e, t, { reload: !0 }, n);
        }
        loadOne(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
          const n = e.split("|"),
            r = n[0],
            s = n[1];
          this.read(r, s, "read", void 0, void 0, (n, i) => {
            n &&
              this.logger.warn(
                ""
                  .concat(t, "loading namespace ")
                  .concat(s, " for language ")
                  .concat(r, " failed"),
                n
              ),
              !n &&
                i &&
                this.logger.log(
                  ""
                    .concat(t, "loaded namespace ")
                    .concat(s, " for language ")
                    .concat(r),
                  i
                ),
              this.loaded(e, n, i);
          });
        }
        saveMissing(e, t, n, r, s) {
          let i =
              arguments.length > 5 && void 0 !== arguments[5]
                ? arguments[5]
                : {},
            o =
              arguments.length > 6 && void 0 !== arguments[6]
                ? arguments[6]
                : () => {};
          if (
            this.services.utils &&
            this.services.utils.hasLoadedNamespace &&
            !this.services.utils.hasLoadedNamespace(t)
          )
            this.logger.warn(
              'did not save key "'
                .concat(n, '" as the namespace "')
                .concat(t, '" was not yet loaded'),
              "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"
            );
          else if (void 0 !== n && null !== n && "" !== n) {
            if (this.backend && this.backend.create) {
              const c = { ...i, isUpdate: s },
                l = this.backend.create.bind(this.backend);
              if (l.length < 6)
                try {
                  let s;
                  (s = 5 === l.length ? l(e, t, n, r, c) : l(e, t, n, r)),
                    s && "function" === typeof s.then
                      ? s.then((e) => o(null, e)).catch(o)
                      : o(null, s);
                } catch (a) {
                  o(a);
                }
              else l(e, t, n, r, o, c);
            }
            e && e[0] && this.store.addResource(e[0], t, n, r);
          }
        }
      }
      function vk() {
        return {
          debug: !1,
          initImmediate: !0,
          ns: ["translation"],
          defaultNS: ["translation"],
          fallbackLng: ["dev"],
          fallbackNS: !1,
          supportedLngs: !1,
          nonExplicitSupportedLngs: !1,
          load: "all",
          preload: !1,
          simplifyPluralSuffix: !0,
          keySeparator: ".",
          nsSeparator: ":",
          pluralSeparator: "_",
          contextSeparator: "_",
          partialBundledLanguages: !1,
          saveMissing: !1,
          updateMissing: !1,
          saveMissingTo: "fallback",
          saveMissingPlurals: !0,
          missingKeyHandler: !1,
          missingInterpolationHandler: !1,
          postProcess: !1,
          postProcessPassResolved: !1,
          returnNull: !1,
          returnEmptyString: !0,
          returnObjects: !1,
          joinArrays: !1,
          returnedObjectHandler: !1,
          parseMissingKeyHandler: !1,
          appendNamespaceToMissingKey: !1,
          appendNamespaceToCIMode: !1,
          overloadTranslationOptionHandler: function (e) {
            let t = {};
            if (
              ("object" === typeof e[1] && (t = e[1]),
              "string" === typeof e[1] && (t.defaultValue = e[1]),
              "string" === typeof e[2] && (t.tDescription = e[2]),
              "object" === typeof e[2] || "object" === typeof e[3])
            ) {
              const n = e[3] || e[2];
              Object.keys(n).forEach((e) => {
                t[e] = n[e];
              });
            }
            return t;
          },
          interpolation: {
            escapeValue: !0,
            format: (e) => e,
            prefix: "{{",
            suffix: "}}",
            formatSeparator: ",",
            unescapePrefix: "-",
            nestingPrefix: "$t(",
            nestingSuffix: ")",
            nestingOptionsSeparator: ",",
            maxReplaces: 1e3,
            skipOnVariables: !0,
          },
        };
      }
      function yk(e) {
        return (
          "string" === typeof e.ns && (e.ns = [e.ns]),
          "string" === typeof e.fallbackLng &&
            (e.fallbackLng = [e.fallbackLng]),
          "string" === typeof e.fallbackNS && (e.fallbackNS = [e.fallbackNS]),
          e.supportedLngs &&
            e.supportedLngs.indexOf("cimode") < 0 &&
            (e.supportedLngs = e.supportedLngs.concat(["cimode"])),
          e
        );
      }
      function bk() {}
      class wk extends FC {
        constructor() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t = arguments.length > 1 ? arguments[1] : void 0;
          var n;
          if (
            (super(),
            (this.options = yk(e)),
            (this.services = {}),
            (this.logger = UC),
            (this.modules = { external: [] }),
            (n = this),
            Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(
              (e) => {
                "function" === typeof n[e] && (n[e] = n[e].bind(n));
              }
            ),
            t && !this.isInitialized && !e.isClone)
          ) {
            if (!this.options.initImmediate) return this.init(e, t), this;
            setTimeout(() => {
              this.init(e, t);
            }, 0);
          }
        }
        init() {
          var e = this;
          let t =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            n = arguments.length > 1 ? arguments[1] : void 0;
          (this.isInitializing = !0),
            "function" === typeof t && ((n = t), (t = {})),
            !t.defaultNS &&
              !1 !== t.defaultNS &&
              t.ns &&
              ("string" === typeof t.ns
                ? (t.defaultNS = t.ns)
                : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
          const r = vk();
          function s(e) {
            return e ? ("function" === typeof e ? new e() : e) : null;
          }
          if (
            ((this.options = { ...r, ...this.options, ...yk(t) }),
            "v1" !== this.options.compatibilityAPI &&
              (this.options.interpolation = {
                ...r.interpolation,
                ...this.options.interpolation,
              }),
            void 0 !== t.keySeparator &&
              (this.options.userDefinedKeySeparator = t.keySeparator),
            void 0 !== t.nsSeparator &&
              (this.options.userDefinedNsSeparator = t.nsSeparator),
            !this.options.isClone)
          ) {
            let t;
            this.modules.logger
              ? UC.init(s(this.modules.logger), this.options)
              : UC.init(null, this.options),
              this.modules.formatter
                ? (t = this.modules.formatter)
                : "undefined" !== typeof Intl && (t = mk);
            const n = new ik(this.options);
            this.store = new ek(this.options.resources, this.options);
            const i = this.services;
            (i.logger = UC),
              (i.resourceStore = this.store),
              (i.languageUtils = n),
              (i.pluralResolver = new dk(n, {
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix,
              })),
              !t ||
                (this.options.interpolation.format &&
                  this.options.interpolation.format !==
                    r.interpolation.format) ||
                ((i.formatter = s(t)),
                i.formatter.init(i, this.options),
                (this.options.interpolation.format = i.formatter.format.bind(
                  i.formatter
                ))),
              (i.interpolator = new pk(this.options)),
              (i.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this),
              }),
              (i.backendConnector = new gk(
                s(this.modules.backend),
                i.resourceStore,
                i,
                this.options
              )),
              i.backendConnector.on("*", function (t) {
                for (
                  var n = arguments.length,
                    r = new Array(n > 1 ? n - 1 : 0),
                    s = 1;
                  s < n;
                  s++
                )
                  r[s - 1] = arguments[s];
                e.emit(t, ...r);
              }),
              this.modules.languageDetector &&
                ((i.languageDetector = s(this.modules.languageDetector)),
                i.languageDetector.init &&
                  i.languageDetector.init(
                    i,
                    this.options.detection,
                    this.options
                  )),
              this.modules.i18nFormat &&
                ((i.i18nFormat = s(this.modules.i18nFormat)),
                i.i18nFormat.init && i.i18nFormat.init(this)),
              (this.translator = new rk(this.services, this.options)),
              this.translator.on("*", function (t) {
                for (
                  var n = arguments.length,
                    r = new Array(n > 1 ? n - 1 : 0),
                    s = 1;
                  s < n;
                  s++
                )
                  r[s - 1] = arguments[s];
                e.emit(t, ...r);
              }),
              this.modules.external.forEach((e) => {
                e.init && e.init(this);
              });
          }
          if (
            ((this.format = this.options.interpolation.format),
            n || (n = bk),
            this.options.fallbackLng &&
              !this.services.languageDetector &&
              !this.options.lng)
          ) {
            const e = this.services.languageUtils.getFallbackCodes(
              this.options.fallbackLng
            );
            e.length > 0 && "dev" !== e[0] && (this.options.lng = e[0]);
          }
          this.services.languageDetector ||
            this.options.lng ||
            this.logger.warn(
              "init: no languageDetector is used and no lng is defined"
            );
          [
            "getResource",
            "hasResourceBundle",
            "getResourceBundle",
            "getDataByLanguage",
          ].forEach((t) => {
            this[t] = function () {
              return e.store[t](...arguments);
            };
          });
          [
            "addResource",
            "addResources",
            "addResourceBundle",
            "removeResourceBundle",
          ].forEach((t) => {
            this[t] = function () {
              return e.store[t](...arguments), e;
            };
          });
          const i = BC(),
            o = () => {
              const e = (e, t) => {
                (this.isInitializing = !1),
                  this.isInitialized &&
                    !this.initializedStoreOnce &&
                    this.logger.warn(
                      "init: i18next is already initialized. You should call init just once!"
                    ),
                  (this.isInitialized = !0),
                  this.options.isClone ||
                    this.logger.log("initialized", this.options),
                  this.emit("initialized", this.options),
                  i.resolve(t),
                  n(e, t);
              };
              if (
                this.languages &&
                "v1" !== this.options.compatibilityAPI &&
                !this.isInitialized
              )
                return e(null, this.t.bind(this));
              this.changeLanguage(this.options.lng, e);
            };
          return (
            this.options.resources || !this.options.initImmediate
              ? o()
              : setTimeout(o, 0),
            i
          );
        }
        loadResources(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : bk;
          const n = "string" === typeof e ? e : this.language;
          if (
            ("function" === typeof e && (t = e),
            !this.options.resources || this.options.partialBundledLanguages)
          ) {
            if (
              n &&
              "cimode" === n.toLowerCase() &&
              (!this.options.preload || 0 === this.options.preload.length)
            )
              return t();
            const e = [],
              r = (t) => {
                if (!t) return;
                if ("cimode" === t) return;
                this.services.languageUtils
                  .toResolveHierarchy(t)
                  .forEach((t) => {
                    "cimode" !== t && e.indexOf(t) < 0 && e.push(t);
                  });
              };
            if (n) r(n);
            else {
              this.services.languageUtils
                .getFallbackCodes(this.options.fallbackLng)
                .forEach((e) => r(e));
            }
            this.options.preload && this.options.preload.forEach((e) => r(e)),
              this.services.backendConnector.load(e, this.options.ns, (e) => {
                e ||
                  this.resolvedLanguage ||
                  !this.language ||
                  this.setResolvedLanguage(this.language),
                  t(e);
              });
          } else t(null);
        }
        reloadResources(e, t, n) {
          const r = BC();
          return (
            e || (e = this.languages),
            t || (t = this.options.ns),
            n || (n = bk),
            this.services.backendConnector.reload(e, t, (e) => {
              r.resolve(), n(e);
            }),
            r
          );
        }
        use(e) {
          if (!e)
            throw new Error(
              "You are passing an undefined module! Please check the object you are passing to i18next.use()"
            );
          if (!e.type)
            throw new Error(
              "You are passing a wrong module! Please check the object you are passing to i18next.use()"
            );
          return (
            "backend" === e.type && (this.modules.backend = e),
            ("logger" === e.type || (e.log && e.warn && e.error)) &&
              (this.modules.logger = e),
            "languageDetector" === e.type &&
              (this.modules.languageDetector = e),
            "i18nFormat" === e.type && (this.modules.i18nFormat = e),
            "postProcessor" === e.type && tk.addPostProcessor(e),
            "formatter" === e.type && (this.modules.formatter = e),
            "3rdParty" === e.type && this.modules.external.push(e),
            this
          );
        }
        setResolvedLanguage(e) {
          if (e && this.languages && !(["cimode", "dev"].indexOf(e) > -1))
            for (let t = 0; t < this.languages.length; t++) {
              const e = this.languages[t];
              if (
                !(["cimode", "dev"].indexOf(e) > -1) &&
                this.store.hasLanguageSomeTranslations(e)
              ) {
                this.resolvedLanguage = e;
                break;
              }
            }
        }
        changeLanguage(e, t) {
          var n = this;
          this.isLanguageChangingTo = e;
          const r = BC();
          this.emit("languageChanging", e);
          const s = (e) => {
              (this.language = e),
                (this.languages =
                  this.services.languageUtils.toResolveHierarchy(e)),
                (this.resolvedLanguage = void 0),
                this.setResolvedLanguage(e);
            },
            i = (e, i) => {
              i
                ? (s(i),
                  this.translator.changeLanguage(i),
                  (this.isLanguageChangingTo = void 0),
                  this.emit("languageChanged", i),
                  this.logger.log("languageChanged", i))
                : (this.isLanguageChangingTo = void 0),
                r.resolve(function () {
                  return n.t(...arguments);
                }),
                t &&
                  t(e, function () {
                    return n.t(...arguments);
                  });
            },
            o = (t) => {
              e || t || !this.services.languageDetector || (t = []);
              const n =
                "string" === typeof t
                  ? t
                  : this.services.languageUtils.getBestMatchFromCodes(t);
              n &&
                (this.language || s(n),
                this.translator.language || this.translator.changeLanguage(n),
                this.services.languageDetector &&
                  this.services.languageDetector.cacheUserLanguage &&
                  this.services.languageDetector.cacheUserLanguage(n)),
                this.loadResources(n, (e) => {
                  i(e, n);
                });
            };
          return (
            e ||
            !this.services.languageDetector ||
            this.services.languageDetector.async
              ? !e &&
                this.services.languageDetector &&
                this.services.languageDetector.async
                ? 0 === this.services.languageDetector.detect.length
                  ? this.services.languageDetector.detect().then(o)
                  : this.services.languageDetector.detect(o)
                : o(e)
              : o(this.services.languageDetector.detect()),
            r
          );
        }
        getFixedT(e, t, n) {
          var r = this;
          const s = function (e, t) {
            let i;
            if ("object" !== typeof t) {
              for (
                var o = arguments.length,
                  a = new Array(o > 2 ? o - 2 : 0),
                  c = 2;
                c < o;
                c++
              )
                a[c - 2] = arguments[c];
              i = r.options.overloadTranslationOptionHandler([e, t].concat(a));
            } else i = { ...t };
            (i.lng = i.lng || s.lng),
              (i.lngs = i.lngs || s.lngs),
              (i.ns = i.ns || s.ns),
              (i.keyPrefix = i.keyPrefix || n || s.keyPrefix);
            const l = r.options.keySeparator || ".";
            let u;
            return (
              (u =
                i.keyPrefix && Array.isArray(e)
                  ? e.map((e) => "".concat(i.keyPrefix).concat(l).concat(e))
                  : i.keyPrefix
                  ? "".concat(i.keyPrefix).concat(l).concat(e)
                  : e),
              r.t(u, i)
            );
          };
          return (
            "string" === typeof e ? (s.lng = e) : (s.lngs = e),
            (s.ns = t),
            (s.keyPrefix = n),
            s
          );
        }
        t() {
          return this.translator && this.translator.translate(...arguments);
        }
        exists() {
          return this.translator && this.translator.exists(...arguments);
        }
        setDefaultNamespace(e) {
          this.options.defaultNS = e;
        }
        hasLoadedNamespace(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          if (!this.isInitialized)
            return (
              this.logger.warn(
                "hasLoadedNamespace: i18next was not initialized",
                this.languages
              ),
              !1
            );
          if (!this.languages || !this.languages.length)
            return (
              this.logger.warn(
                "hasLoadedNamespace: i18n.languages were undefined or empty",
                this.languages
              ),
              !1
            );
          const n = t.lng || this.resolvedLanguage || this.languages[0],
            r = !!this.options && this.options.fallbackLng,
            s = this.languages[this.languages.length - 1];
          if ("cimode" === n.toLowerCase()) return !0;
          const i = (e, t) => {
            const n =
              this.services.backendConnector.state["".concat(e, "|").concat(t)];
            return -1 === n || 2 === n;
          };
          if (t.precheck) {
            const e = t.precheck(this, i);
            if (void 0 !== e) return e;
          }
          return (
            !!this.hasResourceBundle(n, e) ||
            !(
              this.services.backendConnector.backend &&
              (!this.options.resources || this.options.partialBundledLanguages)
            ) ||
            !(!i(n, e) || (r && !i(s, e)))
          );
        }
        loadNamespaces(e, t) {
          const n = BC();
          return this.options.ns
            ? ("string" === typeof e && (e = [e]),
              e.forEach((e) => {
                this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
              }),
              this.loadResources((e) => {
                n.resolve(), t && t(e);
              }),
              n)
            : (t && t(), Promise.resolve());
        }
        loadLanguages(e, t) {
          const n = BC();
          "string" === typeof e && (e = [e]);
          const r = this.options.preload || [],
            s = e.filter(
              (e) =>
                r.indexOf(e) < 0 &&
                this.services.languageUtils.isSupportedCode(e)
            );
          return s.length
            ? ((this.options.preload = r.concat(s)),
              this.loadResources((e) => {
                n.resolve(), t && t(e);
              }),
              n)
            : (t && t(), Promise.resolve());
        }
        dir(e) {
          if (
            (e ||
              (e =
                this.resolvedLanguage ||
                (this.languages && this.languages.length > 0
                  ? this.languages[0]
                  : this.language)),
            !e)
          )
            return "rtl";
          const t =
            (this.services && this.services.languageUtils) || new ik(vk());
          return [
            "ar",
            "shu",
            "sqr",
            "ssh",
            "xaa",
            "yhd",
            "yud",
            "aao",
            "abh",
            "abv",
            "acm",
            "acq",
            "acw",
            "acx",
            "acy",
            "adf",
            "ads",
            "aeb",
            "aec",
            "afb",
            "ajp",
            "apc",
            "apd",
            "arb",
            "arq",
            "ars",
            "ary",
            "arz",
            "auz",
            "avl",
            "ayh",
            "ayl",
            "ayn",
            "ayp",
            "bbz",
            "pga",
            "he",
            "iw",
            "ps",
            "pbt",
            "pbu",
            "pst",
            "prp",
            "prd",
            "ug",
            "ur",
            "ydd",
            "yds",
            "yih",
            "ji",
            "yi",
            "hbo",
            "men",
            "xmn",
            "fa",
            "jpr",
            "peo",
            "pes",
            "prs",
            "dv",
            "sam",
            "ckb",
          ].indexOf(t.getLanguagePartFromCode(e)) > -1 ||
            e.toLowerCase().indexOf("-arab") > 1
            ? "rtl"
            : "ltr";
        }
        static createInstance() {
          return new wk(
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            arguments.length > 1 ? arguments[1] : void 0
          );
        }
        cloneInstance() {
          let e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : {},
            t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : bk;
          const n = e.forkResourceStore;
          n && delete e.forkResourceStore;
          const r = { ...this.options, ...e, isClone: !0 },
            s = new wk(r);
          (void 0 === e.debug && void 0 === e.prefix) ||
            (s.logger = s.logger.clone(e));
          return (
            ["store", "services", "language"].forEach((e) => {
              s[e] = this[e];
            }),
            (s.services = { ...this.services }),
            (s.services.utils = {
              hasLoadedNamespace: s.hasLoadedNamespace.bind(s),
            }),
            n &&
              ((s.store = new ek(this.store.data, r)),
              (s.services.resourceStore = s.store)),
            (s.translator = new rk(s.services, r)),
            s.translator.on("*", function (e) {
              for (
                var t = arguments.length,
                  n = new Array(t > 1 ? t - 1 : 0),
                  r = 1;
                r < t;
                r++
              )
                n[r - 1] = arguments[r];
              s.emit(e, ...n);
            }),
            s.init(r, t),
            (s.translator.options = r),
            (s.translator.backendConnector.services.utils = {
              hasLoadedNamespace: s.hasLoadedNamespace.bind(s),
            }),
            s
          );
        }
        toJSON() {
          return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage,
          };
        }
      }
      const Sk = wk.createInstance();
      Sk.createInstance = wk.createInstance;
      Sk.createInstance,
        Sk.dir,
        Sk.init,
        Sk.loadResources,
        Sk.reloadResources,
        Sk.use,
        Sk.changeLanguage,
        Sk.getFixedT;
      const _k = Sk.t;
      Sk.exists,
        Sk.setDefaultNamespace,
        Sk.hasLoadedNamespace,
        Sk.loadNamespaces,
        Sk.loadLanguages;
      n(844);
      Object.create(null);
      const Ek = {};
      function Ak() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
          t[n] = arguments[n];
        ("string" === typeof t[0] && Ek[t[0]]) ||
          ("string" === typeof t[0] && (Ek[t[0]] = new Date()),
          (function () {
            if (console && console.warn) {
              for (
                var e = arguments.length, t = new Array(e), n = 0;
                n < e;
                n++
              )
                t[n] = arguments[n];
              "string" === typeof t[0] &&
                (t[0] = "react-i18next:: ".concat(t[0])),
                console.warn(...t);
            }
          })(...t));
      }
      const Tk = (e, t) => () => {
        if (e.isInitialized) t();
        else {
          const n = () => {
            setTimeout(() => {
              e.off("initialized", n);
            }, 0),
              t();
          };
          e.on("initialized", n);
        }
      };
      function Pk(e, t, n) {
        e.loadNamespaces(t, Tk(e, n));
      }
      function Ik(e, t, n, r) {
        "string" === typeof n && (n = [n]),
          n.forEach((t) => {
            e.options.ns.indexOf(t) < 0 && e.options.ns.push(t);
          }),
          e.loadLanguages(t, Tk(e, r));
      }
      const Ck =
          /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
        kk = {
          "&amp;": "&",
          "&#38;": "&",
          "&lt;": "<",
          "&#60;": "<",
          "&gt;": ">",
          "&#62;": ">",
          "&apos;": "'",
          "&#39;": "'",
          "&quot;": '"',
          "&#34;": '"',
          "&nbsp;": " ",
          "&#160;": " ",
          "&copy;": "\xa9",
          "&#169;": "\xa9",
          "&reg;": "\xae",
          "&#174;": "\xae",
          "&hellip;": "\u2026",
          "&#8230;": "\u2026",
          "&#x2F;": "/",
          "&#47;": "/",
        },
        Ok = (e) => kk[e];
      let xk,
        Nk = {
          bindI18n: "languageChanged",
          bindI18nStore: "",
          transEmptyNodeValue: "",
          transSupportBasicHtmlNodes: !0,
          transWrapTextNodes: "",
          transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
          useSuspense: !0,
          unescape: (e) => e.replace(Ck, Ok),
        };
      const Rk = {
          type: "3rdParty",
          init(e) {
            !(function () {
              let e =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : {};
              Nk = { ...Nk, ...e };
            })(e.options.react),
              (function (e) {
                xk = e;
              })(e);
          },
        },
        Dk = (0, o.createContext)();
      class Mk {
        constructor() {
          this.usedNamespaces = {};
        }
        addUsedNamespaces(e) {
          e.forEach((e) => {
            this.usedNamespaces[e] || (this.usedNamespaces[e] = !0);
          });
        }
        getUsedNamespaces() {
          return Object.keys(this.usedNamespaces);
        }
      }
      function jk(e, t, n, r) {
        return e.getFixedT(t, n, r);
      }
      function Lk(e) {
        let t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const { i18n: n } = t,
          { i18n: r, defaultNS: s } = (0, o.useContext)(Dk) || {},
          i = n || r || xk;
        if ((i && !i.reportNamespaces && (i.reportNamespaces = new Mk()), !i)) {
          Ak(
            "You will need to pass in an i18next instance by using initReactI18next"
          );
          const e = (e, t) =>
              "string" === typeof t
                ? t
                : t &&
                  "object" === typeof t &&
                  "string" === typeof t.defaultValue
                ? t.defaultValue
                : Array.isArray(e)
                ? e[e.length - 1]
                : e,
            t = [e, {}, !1];
          return (t.t = e), (t.i18n = {}), (t.ready = !1), t;
        }
        i.options.react &&
          void 0 !== i.options.react.wait &&
          Ak(
            "It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour."
          );
        const a = { ...Nk, ...i.options.react, ...t },
          { useSuspense: c, keyPrefix: l } = a;
        let u = e || s || (i.options && i.options.defaultNS);
        (u = "string" === typeof u ? [u] : u || ["translation"]),
          i.reportNamespaces.addUsedNamespaces &&
            i.reportNamespaces.addUsedNamespaces(u);
        const d =
            (i.isInitialized || i.initializedStoreOnce) &&
            u.every((e) =>
              (function (e, t) {
                let n =
                  arguments.length > 2 && void 0 !== arguments[2]
                    ? arguments[2]
                    : {};
                return t.languages && t.languages.length
                  ? void 0 !== t.options.ignoreJSONStructure
                    ? t.hasLoadedNamespace(e, {
                        lng: n.lng,
                        precheck: (t, r) => {
                          if (
                            n.bindI18n &&
                            n.bindI18n.indexOf("languageChanging") > -1 &&
                            t.services.backendConnector.backend &&
                            t.isLanguageChangingTo &&
                            !r(t.isLanguageChangingTo, e)
                          )
                            return !1;
                        },
                      })
                    : (function (e, t) {
                        let n =
                          arguments.length > 2 && void 0 !== arguments[2]
                            ? arguments[2]
                            : {};
                        const r = t.languages[0],
                          s = !!t.options && t.options.fallbackLng,
                          i = t.languages[t.languages.length - 1];
                        if ("cimode" === r.toLowerCase()) return !0;
                        const o = (e, n) => {
                          const r =
                            t.services.backendConnector.state[
                              "".concat(e, "|").concat(n)
                            ];
                          return -1 === r || 2 === r;
                        };
                        return (
                          !(
                            n.bindI18n &&
                            n.bindI18n.indexOf("languageChanging") > -1 &&
                            t.services.backendConnector.backend &&
                            t.isLanguageChangingTo &&
                            !o(t.isLanguageChangingTo, e)
                          ) &&
                          (!!t.hasResourceBundle(r, e) ||
                            !(
                              t.services.backendConnector.backend &&
                              (!t.options.resources ||
                                t.options.partialBundledLanguages)
                            ) ||
                            !(!o(r, e) || (s && !o(i, e))))
                        );
                      })(e, t, n)
                  : (Ak("i18n.languages were undefined or empty", t.languages),
                    !0);
              })(e, i, a)
            ),
          h = (function (e, t, n, r) {
            return (0, o.useCallback)(jk(e, t, n, r), [e, t, n, r]);
          })(i, t.lng || null, "fallback" === a.nsMode ? u : u[0], l),
          p = () => h,
          f = () => jk(i, t.lng || null, "fallback" === a.nsMode ? u : u[0], l),
          [m, g] = (0, o.useState)(p);
        let v = u.join();
        t.lng && (v = "".concat(t.lng).concat(v));
        const y = ((e, t) => {
            const n = (0, o.useRef)();
            return (
              (0, o.useEffect)(() => {
                n.current = t ? n.current : e;
              }, [e, t]),
              n.current
            );
          })(v),
          b = (0, o.useRef)(!0);
        (0, o.useEffect)(() => {
          const { bindI18n: e, bindI18nStore: n } = a;
          function r() {
            b.current && g(f);
          }
          return (
            (b.current = !0),
            d ||
              c ||
              (t.lng
                ? Ik(i, t.lng, u, () => {
                    b.current && g(f);
                  })
                : Pk(i, u, () => {
                    b.current && g(f);
                  })),
            d && y && y !== v && b.current && g(f),
            e && i && i.on(e, r),
            n && i && i.store.on(n, r),
            () => {
              (b.current = !1),
                e && i && e.split(" ").forEach((e) => i.off(e, r)),
                n && i && n.split(" ").forEach((e) => i.store.off(e, r));
            }
          );
        }, [i, v]),
          (0, o.useEffect)(() => {
            b.current && d && g(p);
          }, [i, l, d]);
        const w = [m, i, d];
        if (((w.t = m), (w.i18n = i), (w.ready = d), d)) return w;
        if (!d && !c) return w;
        throw new Promise((e) => {
          t.lng ? Ik(i, t.lng, u, () => e()) : Pk(i, u, () => e());
        });
      }
      function Uk(e) {
        return (
          (Uk =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e &&
                    "function" == typeof Symbol &&
                    e.constructor === Symbol &&
                    e !== Symbol.prototype
                    ? "symbol"
                    : typeof e;
                }),
          Uk(e)
        );
      }
      function Fk() {
        return (
          "function" === typeof XMLHttpRequest ||
          "object" ===
            ("undefined" === typeof XMLHttpRequest
              ? "undefined"
              : Uk(XMLHttpRequest))
        );
      }
      const Bk = n.p + "static/media/getFetch.c4cca45e22bc1b2c7d0d.cjs";
      var Vk,
        qk,
        Hk,
        Wk = n.t(Bk);
      function Kk(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(e);
          t &&
            (r = r.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function zk(e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = null != arguments[t] ? arguments[t] : {};
          t % 2
            ? Kk(Object(n), !0).forEach(function (t) {
                Gk(e, t, n[t]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : Kk(Object(n)).forEach(function (t) {
                Object.defineProperty(
                  e,
                  t,
                  Object.getOwnPropertyDescriptor(n, t)
                );
              });
        }
        return e;
      }
      function Gk(e, t, n) {
        return (
          (t = (function (e) {
            var t = (function (e, t) {
              if ("object" != Jk(e) || !e) return e;
              var n = e[Symbol.toPrimitive];
              if (void 0 !== n) {
                var r = n.call(e, t || "default");
                if ("object" != Jk(r)) return r;
                throw new TypeError(
                  "@@toPrimitive must return a primitive value."
                );
              }
              return ("string" === t ? String : Number)(e);
            })(e, "string");
            return "symbol" == Jk(t) ? t : t + "";
          })(t)),
          t in e
            ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[t] = n),
          e
        );
      }
      function Jk(e) {
        return (
          (Jk =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e &&
                    "function" == typeof Symbol &&
                    e.constructor === Symbol &&
                    e !== Symbol.prototype
                    ? "symbol"
                    : typeof e;
                }),
          Jk(e)
        );
      }
      "function" === typeof fetch &&
        (Vk =
          "undefined" !== typeof global && global.fetch
            ? global.fetch
            : "undefined" !== typeof window && window.fetch
            ? window.fetch
            : fetch),
        Fk() &&
          ("undefined" !== typeof global && global.XMLHttpRequest
            ? (qk = global.XMLHttpRequest)
            : "undefined" !== typeof window &&
              window.XMLHttpRequest &&
              (qk = window.XMLHttpRequest)),
        "function" === typeof ActiveXObject &&
          ("undefined" !== typeof global && global.ActiveXObject
            ? (Hk = global.ActiveXObject)
            : "undefined" !== typeof window &&
              window.ActiveXObject &&
              (Hk = window.ActiveXObject)),
        Vk || !Wk || qk || Hk || (Vk = Bk || Wk),
        "function" !== typeof Vk && (Vk = void 0);
      var Qk = function (e, t) {
          if (t && "object" === Jk(t)) {
            var n = "";
            for (var r in t)
              n += "&" + encodeURIComponent(r) + "=" + encodeURIComponent(t[r]);
            if (!n) return e;
            e = e + (-1 !== e.indexOf("?") ? "&" : "?") + n.slice(1);
          }
          return e;
        },
        Yk = function (e, t, n, r) {
          var s = function (e) {
            if (!e.ok) return n(e.statusText || "Error", { status: e.status });
            e.text()
              .then(function (t) {
                n(null, { status: e.status, data: t });
              })
              .catch(n);
          };
          if (r) {
            var i = r(e, t);
            if (i instanceof Promise) return void i.then(s).catch(n);
          }
          "function" === typeof fetch
            ? fetch(e, t).then(s).catch(n)
            : Vk(e, t).then(s).catch(n);
        },
        Xk = !1;
      const Zk = function (e, t, n, r) {
        return (
          "function" === typeof n && ((r = n), (n = void 0)),
          (r = r || function () {}),
          Vk && 0 !== t.indexOf("file:")
            ? (function (e, t, n, r) {
                e.queryStringParams && (t = Qk(t, e.queryStringParams));
                var s = zk(
                  {},
                  "function" === typeof e.customHeaders
                    ? e.customHeaders()
                    : e.customHeaders
                );
                "undefined" === typeof window &&
                  "undefined" !== typeof global &&
                  "undefined" !== typeof global.process &&
                  global.process.versions &&
                  global.process.versions.node &&
                  (s["User-Agent"] = "i18next-http-backend (node/"
                    .concat(global.process.version, "; ")
                    .concat(global.process.platform, " ")
                    .concat(global.process.arch, ")")),
                  n && (s["Content-Type"] = "application/json");
                var i =
                    "function" === typeof e.requestOptions
                      ? e.requestOptions(n)
                      : e.requestOptions,
                  o = zk(
                    {
                      method: n ? "POST" : "GET",
                      body: n ? e.stringify(n) : void 0,
                      headers: s,
                    },
                    Xk ? {} : i
                  ),
                  a =
                    "function" === typeof e.alternateFetch &&
                    e.alternateFetch.length >= 1
                      ? e.alternateFetch
                      : void 0;
                try {
                  Yk(t, o, r, a);
                } catch (a_) {
                  if (
                    !i ||
                    0 === Object.keys(i).length ||
                    !a_.message ||
                    a_.message.indexOf("not implemented") < 0
                  )
                    return r(a_);
                  try {
                    Object.keys(i).forEach(function (e) {
                      delete o[e];
                    }),
                      Yk(t, o, r, a),
                      (Xk = !0);
                  } catch (c) {
                    r(c);
                  }
                }
              })(e, t, n, r)
            : Fk() || "function" === typeof ActiveXObject
            ? (function (e, t, n, r) {
                n && "object" === Jk(n) && (n = Qk("", n).slice(1)),
                  e.queryStringParams && (t = Qk(t, e.queryStringParams));
                try {
                  var s;
                  (s = qk ? new qk() : new Hk("MSXML2.XMLHTTP.3.0")).open(
                    n ? "POST" : "GET",
                    t,
                    1
                  ),
                    e.crossDomain ||
                      s.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
                    (s.withCredentials = !!e.withCredentials),
                    n &&
                      s.setRequestHeader(
                        "Content-Type",
                        "application/x-www-form-urlencoded"
                      ),
                    s.overrideMimeType &&
                      s.overrideMimeType("application/json");
                  var i = e.customHeaders;
                  if ((i = "function" === typeof i ? i() : i))
                    for (var o in i) s.setRequestHeader(o, i[o]);
                  (s.onreadystatechange = function () {
                    s.readyState > 3 &&
                      r(s.status >= 400 ? s.statusText : null, {
                        status: s.status,
                        data: s.responseText,
                      });
                  }),
                    s.send(n);
                } catch (a_) {
                  console && console.log(a_);
                }
              })(e, t, n, r)
            : void r(new Error("No fetch and no xhr implementation found!"))
        );
      };
      function $k(e) {
        return (
          ($k =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e &&
                    "function" == typeof Symbol &&
                    e.constructor === Symbol &&
                    e !== Symbol.prototype
                    ? "symbol"
                    : typeof e;
                }),
          $k(e)
        );
      }
      function eO(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var r = Object.getOwnPropertySymbols(e);
          t &&
            (r = r.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable;
            })),
            n.push.apply(n, r);
        }
        return n;
      }
      function tO(e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = null != arguments[t] ? arguments[t] : {};
          t % 2
            ? eO(Object(n), !0).forEach(function (t) {
                rO(e, t, n[t]);
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n))
            : eO(Object(n)).forEach(function (t) {
                Object.defineProperty(
                  e,
                  t,
                  Object.getOwnPropertyDescriptor(n, t)
                );
              });
        }
        return e;
      }
      function nO(e, t) {
        for (var n = 0; n < t.length; n++) {
          var r = t[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(e, sO(r.key), r);
        }
      }
      function rO(e, t, n) {
        return (
          (t = sO(t)) in e
            ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[t] = n),
          e
        );
      }
      function sO(e) {
        var t = (function (e, t) {
          if ("object" != $k(e) || !e) return e;
          var n = e[Symbol.toPrimitive];
          if (void 0 !== n) {
            var r = n.call(e, t || "default");
            if ("object" != $k(r)) return r;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === t ? String : Number)(e);
        })(e, "string");
        return "symbol" == $k(t) ? t : t + "";
      }
      var iO = (function () {
        return (
          (e = function e(t) {
            var n =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : {},
              r =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {};
            !(function (e, t) {
              if (!(e instanceof t))
                throw new TypeError("Cannot call a class as a function");
            })(this, e),
              (this.services = t),
              (this.options = n),
              (this.allOptions = r),
              (this.type = "backend"),
              this.init(t, n, r);
          }),
          (t = [
            {
              key: "init",
              value: function (e) {
                var t = this,
                  n =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : {},
                  r =
                    arguments.length > 2 && void 0 !== arguments[2]
                      ? arguments[2]
                      : {};
                if (
                  ((this.services = e),
                  (this.options = tO(
                    tO(
                      tO(
                        {},
                        {
                          loadPath: "/locales/{{lng}}/{{ns}}.json",
                          addPath: "/locales/add/{{lng}}/{{ns}}",
                          parse: function (e) {
                            return JSON.parse(e);
                          },
                          stringify: JSON.stringify,
                          parsePayload: function (e, t, n) {
                            return rO({}, t, n || "");
                          },
                          parseLoadPayload: function (e, t) {},
                          request: Zk,
                          reloadInterval: "undefined" === typeof window && 36e5,
                          customHeaders: {},
                          queryStringParams: {},
                          crossDomain: !1,
                          withCredentials: !1,
                          overrideMimeType: !1,
                          requestOptions: {
                            mode: "cors",
                            credentials: "same-origin",
                            cache: "default",
                          },
                        }
                      ),
                      this.options || {}
                    ),
                    n
                  )),
                  (this.allOptions = r),
                  this.services && this.options.reloadInterval)
                ) {
                  var s = setInterval(function () {
                    return t.reload();
                  }, this.options.reloadInterval);
                  "object" === $k(s) &&
                    "function" === typeof s.unref &&
                    s.unref();
                }
              },
            },
            {
              key: "readMulti",
              value: function (e, t, n) {
                this._readAny(e, e, t, t, n);
              },
            },
            {
              key: "read",
              value: function (e, t, n) {
                this._readAny([e], e, [t], t, n);
              },
            },
            {
              key: "_readAny",
              value: function (e, t, n, r, s) {
                var i,
                  o = this,
                  a = this.options.loadPath;
                "function" === typeof this.options.loadPath &&
                  (a = this.options.loadPath(e, n)),
                  (a = (function (e) {
                    return !!e && "function" === typeof e.then;
                  })((i = a))
                    ? i
                    : Promise.resolve(i)).then(function (i) {
                    if (!i) return s(null, {});
                    var a = o.services.interpolator.interpolate(i, {
                      lng: e.join("+"),
                      ns: n.join("+"),
                    });
                    o.loadUrl(a, s, t, r);
                  });
              },
            },
            {
              key: "loadUrl",
              value: function (e, t, n, r) {
                var s = this,
                  i = "string" === typeof n ? [n] : n,
                  o = "string" === typeof r ? [r] : r,
                  a = this.options.parseLoadPayload(i, o);
                this.options.request(this.options, e, a, function (i, o) {
                  if (o && ((o.status >= 500 && o.status < 600) || !o.status))
                    return t(
                      "failed loading " + e + "; status code: " + o.status,
                      !0
                    );
                  if (o && o.status >= 400 && o.status < 500)
                    return t(
                      "failed loading " + e + "; status code: " + o.status,
                      !1
                    );
                  if (
                    !o &&
                    i &&
                    i.message &&
                    i.message.indexOf("Failed to fetch") > -1
                  )
                    return t("failed loading " + e + ": " + i.message, !0);
                  if (i) return t(i, !1);
                  var a, c;
                  try {
                    a =
                      "string" === typeof o.data
                        ? s.options.parse(o.data, n, r)
                        : o.data;
                  } catch (a_) {
                    c = "failed parsing " + e + " to json";
                  }
                  if (c) return t(c, !1);
                  t(null, a);
                });
              },
            },
            {
              key: "create",
              value: function (e, t, n, r, s) {
                var i = this;
                if (this.options.addPath) {
                  "string" === typeof e && (e = [e]);
                  var o = this.options.parsePayload(t, n, r),
                    a = 0,
                    c = [],
                    l = [];
                  e.forEach(function (n) {
                    var r = i.options.addPath;
                    "function" === typeof i.options.addPath &&
                      (r = i.options.addPath(n, t));
                    var u = i.services.interpolator.interpolate(r, {
                      lng: n,
                      ns: t,
                    });
                    i.options.request(i.options, u, o, function (t, n) {
                      (a += 1),
                        c.push(t),
                        l.push(n),
                        a === e.length && "function" === typeof s && s(c, l);
                    });
                  });
                }
              },
            },
            {
              key: "reload",
              value: function () {
                var e = this,
                  t = this.services,
                  n = t.backendConnector,
                  r = t.languageUtils,
                  s = t.logger,
                  i = n.language;
                if (!i || "cimode" !== i.toLowerCase()) {
                  var o = [],
                    a = function (e) {
                      r.toResolveHierarchy(e).forEach(function (e) {
                        o.indexOf(e) < 0 && o.push(e);
                      });
                    };
                  a(i),
                    this.allOptions.preload &&
                      this.allOptions.preload.forEach(function (e) {
                        return a(e);
                      }),
                    o.forEach(function (t) {
                      e.allOptions.ns.forEach(function (e) {
                        n.read(t, e, "read", null, null, function (r, i) {
                          r &&
                            s.warn(
                              "loading namespace "
                                .concat(e, " for language ")
                                .concat(t, " failed"),
                              r
                            ),
                            !r &&
                              i &&
                              s.log(
                                "loaded namespace "
                                  .concat(e, " for language ")
                                  .concat(t),
                                i
                              ),
                            n.loaded("".concat(t, "|").concat(e), r, i);
                        });
                      });
                    });
                }
              },
            },
          ]),
          t && nO(e.prototype, t),
          n && nO(e, n),
          Object.defineProperty(e, "prototype", { writable: !1 }),
          e
        );
        var e, t, n;
      })();
      iO.type = "backend";
      const oO = iO,
        { slice: aO, forEach: cO } = [];
      const lO = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/,
        uO = {
          create(e, t, n, r) {
            let s =
              arguments.length > 4 && void 0 !== arguments[4]
                ? arguments[4]
                : { path: "/", sameSite: "strict" };
            n &&
              ((s.expires = new Date()),
              s.expires.setTime(s.expires.getTime() + 60 * n * 1e3)),
              r && (s.domain = r),
              (document.cookie = ((e, t, n) => {
                const r = n || {};
                r.path = r.path || "/";
                const s = encodeURIComponent(t);
                let i = "".concat(e, "=").concat(s);
                if (r.maxAge > 0) {
                  const e = r.maxAge - 0;
                  if (Number.isNaN(e))
                    throw new Error("maxAge should be a Number");
                  i += "; Max-Age=".concat(Math.floor(e));
                }
                if (r.domain) {
                  if (!lO.test(r.domain))
                    throw new TypeError("option domain is invalid");
                  i += "; Domain=".concat(r.domain);
                }
                if (r.path) {
                  if (!lO.test(r.path))
                    throw new TypeError("option path is invalid");
                  i += "; Path=".concat(r.path);
                }
                if (r.expires) {
                  if ("function" !== typeof r.expires.toUTCString)
                    throw new TypeError("option expires is invalid");
                  i += "; Expires=".concat(r.expires.toUTCString());
                }
                if (
                  (r.httpOnly && (i += "; HttpOnly"),
                  r.secure && (i += "; Secure"),
                  r.sameSite)
                )
                  switch (
                    "string" === typeof r.sameSite
                      ? r.sameSite.toLowerCase()
                      : r.sameSite
                  ) {
                    case !0:
                      i += "; SameSite=Strict";
                      break;
                    case "lax":
                      i += "; SameSite=Lax";
                      break;
                    case "strict":
                      i += "; SameSite=Strict";
                      break;
                    case "none":
                      i += "; SameSite=None";
                      break;
                    default:
                      throw new TypeError("option sameSite is invalid");
                  }
                return i;
              })(e, encodeURIComponent(t), s));
          },
          read(e) {
            const t = "".concat(e, "="),
              n = document.cookie.split(";");
            for (let r = 0; r < n.length; r++) {
              let e = n[r];
              for (; " " === e.charAt(0); ) e = e.substring(1, e.length);
              if (0 === e.indexOf(t)) return e.substring(t.length, e.length);
            }
            return null;
          },
          remove(e) {
            this.create(e, "", -1);
          },
        };
      var dO = {
          name: "cookie",
          lookup(e) {
            let { lookupCookie: t } = e;
            if (t && "undefined" !== typeof document)
              return uO.read(t) || void 0;
          },
          cacheUserLanguage(e, t) {
            let {
              lookupCookie: n,
              cookieMinutes: r,
              cookieDomain: s,
              cookieOptions: i,
            } = t;
            n && "undefined" !== typeof document && uO.create(n, e, r, s, i);
          },
        },
        hO = {
          name: "querystring",
          lookup(e) {
            let t,
              { lookupQuerystring: n } = e;
            if ("undefined" !== typeof window) {
              var r;
              let { search: e } = window.location;
              !window.location.search &&
                (null === (r = window.location.hash) || void 0 === r
                  ? void 0
                  : r.indexOf("?")) > -1 &&
                (e = window.location.hash.substring(
                  window.location.hash.indexOf("?")
                ));
              const s = e.substring(1).split("&");
              for (let r = 0; r < s.length; r++) {
                const e = s[r].indexOf("=");
                if (e > 0) {
                  s[r].substring(0, e) === n && (t = s[r].substring(e + 1));
                }
              }
            }
            return t;
          },
        };
      let pO = null;
      const fO = () => {
        if (null !== pO) return pO;
        try {
          pO = "undefined" !== window && null !== window.localStorage;
          const e = "i18next.translate.boo";
          window.localStorage.setItem(e, "foo"),
            window.localStorage.removeItem(e);
        } catch (a_) {
          pO = !1;
        }
        return pO;
      };
      var mO = {
        name: "localStorage",
        lookup(e) {
          let { lookupLocalStorage: t } = e;
          if (t && fO()) return window.localStorage.getItem(t) || void 0;
        },
        cacheUserLanguage(e, t) {
          let { lookupLocalStorage: n } = t;
          n && fO() && window.localStorage.setItem(n, e);
        },
      };
      let gO = null;
      const vO = () => {
        if (null !== gO) return gO;
        try {
          gO = "undefined" !== window && null !== window.sessionStorage;
          const e = "i18next.translate.boo";
          window.sessionStorage.setItem(e, "foo"),
            window.sessionStorage.removeItem(e);
        } catch (a_) {
          gO = !1;
        }
        return gO;
      };
      var yO = {
          name: "sessionStorage",
          lookup(e) {
            let { lookupSessionStorage: t } = e;
            if (t && vO()) return window.sessionStorage.getItem(t) || void 0;
          },
          cacheUserLanguage(e, t) {
            let { lookupSessionStorage: n } = t;
            n && vO() && window.sessionStorage.setItem(n, e);
          },
        },
        bO = {
          name: "navigator",
          lookup(e) {
            const t = [];
            if ("undefined" !== typeof navigator) {
              const { languages: e, userLanguage: n, language: r } = navigator;
              if (e) for (let s = 0; s < e.length; s++) t.push(e[s]);
              n && t.push(n), r && t.push(r);
            }
            return t.length > 0 ? t : void 0;
          },
        },
        wO = {
          name: "htmlTag",
          lookup(e) {
            let t,
              { htmlTag: n } = e;
            const r =
              n ||
              ("undefined" !== typeof document
                ? document.documentElement
                : null);
            return (
              r &&
                "function" === typeof r.getAttribute &&
                (t = r.getAttribute("lang")),
              t
            );
          },
        },
        SO = {
          name: "path",
          lookup(e) {
            var t;
            let { lookupFromPathIndex: n } = e;
            if ("undefined" === typeof window) return;
            const r = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
            if (!Array.isArray(r)) return;
            return null === (t = r["number" === typeof n ? n : 0]) ||
              void 0 === t
              ? void 0
              : t.replace("/", "");
          },
        },
        _O = {
          name: "subdomain",
          lookup(e) {
            var t;
            let { lookupFromSubdomainIndex: n } = e;
            const r = "number" === typeof n ? n + 1 : 1,
              s =
                "undefined" !== typeof window &&
                (null === (t = window.location) ||
                void 0 === t ||
                null === (t = t.hostname) ||
                void 0 === t
                  ? void 0
                  : t.match(
                      /^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i
                    ));
            if (s) return s[r];
          },
        };
      class EO {
        constructor(e) {
          let t =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          (this.type = "languageDetector"),
            (this.detectors = {}),
            this.init(e, t);
        }
        init(e) {
          let t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
          (this.services = e || { languageUtils: {} }),
            (this.options = (function (e) {
              return (
                cO.call(aO.call(arguments, 1), (t) => {
                  if (t) for (const n in t) void 0 === e[n] && (e[n] = t[n]);
                }),
                e
              );
            })(t, this.options || {}, {
              order: [
                "querystring",
                "cookie",
                "localStorage",
                "sessionStorage",
                "navigator",
                "htmlTag",
              ],
              lookupQuerystring: "lng",
              lookupCookie: "i18next",
              lookupLocalStorage: "i18nextLng",
              lookupSessionStorage: "i18nextLng",
              caches: ["localStorage"],
              excludeCacheFor: ["cimode"],
              convertDetectedLanguage: (e) => e,
            })),
            "string" === typeof this.options.convertDetectedLanguage &&
              this.options.convertDetectedLanguage.indexOf("15897") > -1 &&
              (this.options.convertDetectedLanguage = (e) =>
                e.replace("-", "_")),
            this.options.lookupFromUrlIndex &&
              (this.options.lookupFromPathIndex =
                this.options.lookupFromUrlIndex),
            (this.i18nOptions = n),
            this.addDetector(dO),
            this.addDetector(hO),
            this.addDetector(mO),
            this.addDetector(yO),
            this.addDetector(bO),
            this.addDetector(wO),
            this.addDetector(SO),
            this.addDetector(_O);
        }
        addDetector(e) {
          return (this.detectors[e.name] = e), this;
        }
        detect(e) {
          e || (e = this.options.order);
          let t = [];
          return (
            e.forEach((e) => {
              if (this.detectors[e]) {
                let n = this.detectors[e].lookup(this.options);
                n && "string" === typeof n && (n = [n]), n && (t = t.concat(n));
              }
            }),
            (t = t.map((e) => this.options.convertDetectedLanguage(e))),
            this.services.languageUtils.getBestMatchFromCodes
              ? t
              : t.length > 0
              ? t[0]
              : null
          );
        }
        cacheUserLanguage(e, t) {
          t || (t = this.options.caches),
            t &&
              ((this.options.excludeCacheFor &&
                this.options.excludeCacheFor.indexOf(e) > -1) ||
                t.forEach((t) => {
                  this.detectors[t] &&
                    this.detectors[t].cacheUserLanguage(e, this.options);
                }));
        }
      }
      (EO.type = "languageDetector"),
        Sk.use(oO)
          .use(EO)
          .use(Rk)
          .init({
            backend: { loadPath: "/locales/{{lng}}/{{ns}}.json" },
            fallbackLng: "en",
            debug: !0,
            interpolation: { escapeValue: !0 },
          });
      const AO = Sk,
        TO = (e) => {
          let { id: t, listener: n } = e;
          const [r, s] = (0, o.useState)(0);
          (0, o.useEffect)(() => {
            if (!n) return;
            return n(() => {
              console.log("Re-render ".concat(t)), s(r + 1);
            });
          }, [r, n]);
        };
      let PO = (function (e) {
        return (
          (e.onMyTeamUpdate = "onMyTeamUpdate"),
          (e.onGameStateUpdate = "onGameStateUpdate"),
          (e.onRocketmanChange = "onRocktmanStart"),
          (e.onAppReady = "onAppReady"),
          (e.onBuffBought = "onBuffBought"),
          (e.onAdEnergyRewardChange = "onAdEnergyRewardUpdate"),
          e
        );
      })({});
      const IO = "local" === v_ ? new ic() : new cc();
      const CO = new (class extends MC {
        get playerTeam() {
          return this._playerTeam;
        }
        get energyLimit() {
          var e;
          return (
            (null === (e = this.player) || void 0 === e
              ? void 0
              : e.energyLimit) || 0
          );
        }
        get league() {
          return Wb(this.state);
        }
        get botEarnings() {
          return this._botEarnings;
        }
        get inviteDrawerDuration() {
          return this._inviteDrawerDuration;
        }
        get playerBalance() {
          return this.state.balance;
        }
        get isFirstSession() {
          var e, t;
          return (
            Boolean(
              null === (e = this.player) || void 0 === e
                ? void 0
                : e.isFirstSession
            ) &&
            500 ===
              (null === (t = this.player) || void 0 === t ? void 0 : t.score)
          );
        }
        get adEnergyRewardAvailable() {
          return this._adEnergyRewardAvailable;
        }
        get bonus() {
          var e;
          if (
            !this.isRocketmanActive ||
            !this.player ||
            null === (e = this.player) ||
            void 0 === e ||
            !e.rocketmanDuration
          )
            return;
          return {
            timeLeft:
              this.player.lastRocketmanStart +
              this.player.rocketmanDuration -
              this.now(),
            multiplier: this.player.rocketmanMultiplier,
          };
        }
        get state() {
          var e;
          return {
            ...(null === (e = this.replicant) || void 0 === e
              ? void 0
              : e.state),
            isReady: this.isReady,
          };
        }
        constructor(e) {
          var t;
          super(),
            (t = this),
            (this.playerId = e),
            (this.events = Object.keys(PO).reduce(
              (e, t) => ({ ...e, [t]: [] }),
              {}
            )),
            (this.isRocketmanActive = !1),
            (this.components = void 0),
            (this._playerTeam = void 0),
            (this.player = void 0),
            (this._botEarnings = void 0),
            (this._inviteDrawerDuration = 0),
            (this._adEnergyRewardAvailable = !1),
            (this.isReady = !1),
            (this.trackedTaps = 0),
            (this.interval = void 0),
            (this.adEnergyRewardTimeoutId = null),
            (this._nextView = void 0),
            (this.ads = void 0),
            (this.showingAd = !1),
            (this.resolveReplicantClient = void 0),
            (this.replicantClientPromise = new Promise((e) => {
              this.resolveReplicantClient = e;
            })),
            (this.replicant = void 0),
            (this.now = () => this.replicant.now()),
            (this.initWebApp = () => {
              Telegram.WebApp.expand(),
                Telegram.WebApp.setHeaderColor("#000000"),
                Telegram.WebApp.setBackgroundColor("#000000"),
                Telegram.WebApp.ready(),
                (Telegram.WebApp.isClosingConfirmationEnabled = !0),
                setTimeout(() => {
                  Telegram.WebApp.BackButton.onClick(() => {
                    this.closeAllPages(), Telegram.WebApp.BackButton.hide();
                  });
                }, 1e3);
            }),
            (this.initGame = async () => {
              var e, t, n, r, s, i, o;
              await IO.initializeAsync({
                amplitudeKey: b_.amplitudeKey,
                amplitudeTimeZone: b_.amplitudeTimeZone,
                appID: "gemz-coin",
                disableAutomaticTosPopup: !0,
                shortName: "gemz-coin-telegram",
                version: "2.8.0",
                revenueCurrency: "USD",
              }),
                _C({ id: IO.playerID, username: IO.playerName }),
                this.initWebApp();
              const a = {};
              if (IO instanceof cc && Telegram.WebApp.initData) {
                const e = Telegram.WebApp.initData.split("&");
                for (const t of e) {
                  const [e, n] = t.split("=");
                  a[e] = n;
                }
                this.playerId = IO.playerID;
              }
              (this.replicant = b_.replicant.offlineMode
                ? await (async function (e, t, n) {
                    var r, s, i, o, a, c;
                    let { kvStore: l, ...u } = n;
                    u.debug && Xl.level(Jl.debug), ay(u.platform);
                    const d =
                        null !== (r = u && u.latency) && void 0 !== r ? r : 0,
                      h = u && u.storageOverride,
                      p = u && u.createResponseOverride,
                      f = null !== (s = u.fetcher) && void 0 !== s ? s : xy,
                      m = {
                        ...u,
                        endpoint: "browser://",
                        signature: "",
                        fetchOverride: sy({
                          fetcher: f,
                          platform: u.platform,
                          config: e,
                          latency: d,
                          storageOverride: h,
                          errorReporter:
                            null === (i = u.devOpts) || void 0 === i
                              ? void 0
                              : i.errorReporter,
                          postAnalytics:
                            null !==
                              (o =
                                null === (a = u.devOpts) || void 0 === a
                                  ? void 0
                                  : a.postAnalytics) && void 0 !== o
                              ? o
                              : cy(f),
                          responseOverride: p,
                          dateNow:
                            null === (c = u.devOpts) || void 0 === c
                              ? void 0
                              : c.dateNow,
                          storageKeyPrefix: u.storageKeyPrefix,
                        }),
                        devOpts: u.devOpts,
                      },
                      { replicant: g } = await Oy({
                        config: e,
                        id: t,
                        options: m,
                        keyValueStorePrefetchKeys:
                          null === l || void 0 === l ? void 0 : l.prefetchKeys,
                        internalKeyValueStorePrefetchKeys:
                          null === l || void 0 === l
                            ? void 0
                            : l.prefetchInternalKeys,
                      });
                    return g;
                  })(c_, g_.playerId, { platform: "mock" })
                : await (async function (e, t, n) {
                    let { kvStore: r, ...s } = n;
                    if (
                      (s.debug && Xl.level(Jl.debug), "mock" === ay(s.platform))
                    )
                      throw new Error(
                        "Cannot create an online replicant with platform set to mock."
                      );
                    const { replicant: i } = await Oy({
                      config: e,
                      id: t,
                      options: s,
                      keyValueStorePrefetchKeys:
                        null === r || void 0 === r ? void 0 : r.prefetchKeys,
                      internalKeyValueStorePrefetchKeys:
                        null === r || void 0 === r
                          ? void 0
                          : r.prefetchInternalKeys,
                    });
                    return i;
                  })(c_, IO.playerID, {
                    endpoint: b_.replicant.endpoint,
                    platform: "web",
                    telegramAuthorizationData: a,
                  })),
                this.replicant.setOnError((e) => DC(e, this.replicant)),
                this.resolveReplicantClient(this.replicant),
                await this.replicantClientPromise,
                await IO.loadStorage();
              const l = a.start_param;
              let u =
                null === (e = Telegram) ||
                void 0 === e ||
                null === (t = e.WebApp) ||
                void 0 === t ||
                null === (n = t.initDataUnsafe) ||
                void 0 === n
                  ? void 0
                  : n.user;
              const d = {};
              if (this.replicant.state.first_interaction) {
                const e = DS(l);
                0,
                  await this.replicant.invoke.handleFirstEntry({
                    referrer: e,
                    telegramUser: u,
                  }),
                  (d.username = this.replicant.state.username);
              }
              if (
                (u && (d.isPremium = Boolean(u.is_premium)),
                {
                  NODE_ENV: "production",
                  PUBLIC_URL: "",
                  WDS_SOCKET_HOST: void 0,
                  WDS_SOCKET_PATH: void 0,
                  WDS_SOCKET_PORT: void 0,
                  FAST_REFRESH: !0,
                  REACT_APP_STAGE: "prod",
                  REACT_APP_ENV: "prod",
                  REACT_APP_APP_VERSION: "2.8.0",
                }.REACT_APP_IS_DEVELOPMENT &&
                  (function (e) {
                    c((t) => {
                      t.configureDebugPanel(e);
                    });
                  })({ replicant: this.replicant, ui: F_ }),
                "ANON" === this.playerId)
              )
                throw new Error("Trying to initialise game without playerId");
              const h = (function () {
                var e, t, n;
                const r =
                  null === (e = Telegram) ||
                  void 0 === e ||
                  null === (t = e.WebApp) ||
                  void 0 === t ||
                  null === (n = t.initDataUnsafe) ||
                  void 0 === n
                    ? void 0
                    : n.user;
                return (
                  (null === r || void 0 === r ? void 0 : r.language_code) ||
                  "en"
                );
              })();
              fr.setUserProperties({
                friendCount:
                  null !== (r = this.replicant.state.friends.length) &&
                  void 0 !== r
                    ? r
                    : 0,
                league: Wb(this.replicant.state),
                score: this.replicant.state.score,
                balance: this.replicant.state.balance,
                displayedLocale: h,
                ...d,
              });
              const p = g_.payload;
              this.track("SessionStart", {
                notificationType:
                  (null === p || void 0 === p ? void 0 : p.feature) ||
                  (null === p ||
                  void 0 === p ||
                  null === (s = p.notif) ||
                  void 0 === s
                    ? void 0
                    : s.type),
                notificationKey:
                  null === p ||
                  void 0 === p ||
                  null === (i = p.notif) ||
                  void 0 === i
                    ? void 0
                    : i.key,
                notificationMedia:
                  null === p ||
                  void 0 === p ||
                  null === (o = p.notif) ||
                  void 0 === o
                    ? void 0
                    : o.media,
              });
              const f = await j_.startSession();
              1 === IO.storage.entry.count &&
                !f.player.isFirstSession &&
                IO.storage.assign((e) => (e.entry.count = 2)),
                await IO.startGameAsync(),
                "local" === v_ &&
                  ((IO.playerID = this.playerId),
                  (IO.playerName = "Player ".concat(this.playerId))),
                this.initLanguage(h),
                (this._botEarnings = f.botEarnings),
                (this._inviteDrawerDuration = f.inviteDrawerDuration),
                this.setPlayer(f.player, !0),
                this.setPlayerTeam(f.team),
                (this.isReady = !0),
                this.sendEvents(PO.onGameStateUpdate),
                this.sendEvents(PO.onAppReady),
                (this.interval = setInterval(() => {
                  this.onSecondElapsed();
                }, 1e3)),
                await (function () {
                  var e;
                  if ("local" === v_ && IO.didCallSendEntryFinalAnalytics)
                    return Promise.resolve();
                  const t =
                      null !== (e = IO.entryData) && void 0 !== e ? e : {},
                    n = {
                      $subFeature: t.$subFeature,
                      sourceSelectionCount: t.selectionCount,
                    };
                  return IO.sendEntryFinalAnalytics(
                    n,
                    {
                      $firstEntrySourceRealtimeIsPurchaser: !1,
                      $firstEntrySourceRealtimeLTV: 0,
                    },
                    {
                      $lastEntryIsPurchaser: !1,
                      $lastEntryLTV: 0,
                      $lastEntrySourceRealtimeIsPurchaser: !1,
                      $lastEntrySourceRealtimeLTV: 0,
                    }
                  );
                })();
            }),
            (this.track = (e, t) => {
              fr.pushEvent(e, t);
            }),
            (this.setUserProperties = (e) => {
              fr.setUserProperties(e);
            }),
            (this.onTap = () => {
              if (!this.player)
                return void console.error("Cannot do taps without player set");
              if (this.state.energy <= 0)
                return (
                  console.warn("Run out of energy"),
                  void this.components.OutOfEnergy.show()
                );
              this.replicant.invoke.tap();
              const e = zb(this.state, this.now());
              this.sendEvents(PO.onGameStateUpdate), Dy(e, Boolean(this.bonus));
            }),
            (this.joinTeam = async (e) => {
              const t = await j_.joinTeam(this.playerId, e);
              this.track("JoinTeam", { teamId: e }),
                this.setPlayerTeam(t.team),
                this.setPlayer(t.player),
                this.sendEvents(PO.onMyTeamUpdate),
                this.closeAllPages();
            }),
            (this.leaveTeam = async () => {
              const e = this.replicant.state.team_id || "",
                t = await j_.leaveTeam(this.playerId);
              this.track("LeaveTeam", { teamId: e }),
                this.setPlayerTeam(void 0),
                this.setPlayer(t.player),
                this.sendEvents(PO.onMyTeamUpdate),
                this.closeAllPages();
            }),
            (this.closeAllPages = () => {
              if (
                (Object.values(this.components).forEach((e) => e.hide()),
                this._nextView)
              ) {
                const e = this._nextView;
                (this._nextView = void 0), this.components[e].show();
              }
            }),
            (this.onSecondElapsed = () => {
              this.sendEvents(PO.onGameStateUpdate),
                this.bonus && this.bonus.timeLeft <= 0 && this.setRocketman(!1);
            }),
            (this.setPlayer = function (e) {
              (t.player = e),
                !t.isRocketmanActive &&
                  e.rocketmanMultiplier > 1 &&
                  t.setRocketman(!0),
                t.replicantClientPromise
                  .then((e) => {
                    const n = Zb(e.state, t.now());
                    n <= 0
                      ? t.setAdEnergyRewardAvailable(!0)
                      : (t.setAdEnergyRewardAvailable(!1),
                        null !== t.adEnergyRewardTimeoutId &&
                          clearTimeout(t.adEnergyRewardTimeoutId),
                        (t.adEnergyRewardTimeoutId = setTimeout(() => {
                          t.setAdEnergyRewardAvailable(!0),
                            (t.adEnergyRewardTimeoutId = null);
                        }, n)));
                  })
                  .catch((e) => {
                    console.warn(
                      "error while checking for ad energy reward:",
                      e
                    );
                  });
            }),
            (this.setPlayerTeam = (e) => {
              (this._playerTeam = e), this.sendEvents(PO.onMyTeamUpdate);
            }),
            (this.setRocketman = (e) => {
              (this.isRocketmanActive = e),
                this.sendEvents(PO.onRocketmanChange);
            }),
            (this.setAdEnergyRewardAvailable = function (e) {
              ((arguments.length > 1 &&
                void 0 !== arguments[1] &&
                arguments[1]) ||
                e !== t._adEnergyRewardAvailable) &&
                ((t._adEnergyRewardAvailable = e),
                t.sendEvents(PO.onAdEnergyRewardChange));
            }),
            (this.buyBooster = async (e) => {
              const t = await j_.buyBooster(this.playerId, e);
              return (
                CO.components.Toast.setData(_k(BE[e].name)),
                this.setPlayer(t.player, !0),
                this.components.Shop.fetch(),
                CO.components.Toast.show(!1),
                t.player.balance
              );
            }),
            (this.buyBuff = async (e) => {
              const t = await j_.buyBuff(this.playerId, e);
              CO.components.Toast.setData(_k(BE[e].name)),
                this.closeAllPages(),
                this.setPlayer(t.player, !0),
                this.components.Shop.fetch(),
                CO.components.Toast.show(!1);
            }),
            (this.getFriends = () => L_.getFriends(this.playerId)),
            (this.onBackNavigateTo = (e) => {
              this._nextView = e;
            }),
            (this.showAd = async () => {
              this.showingAd ||
                ((this.showingAd = !0),
                this.ads
                  .show()
                  .then(async (e) => {
                    const t = await j_.giveAdReward(this.playerId);
                    this.setPlayer(t, !0);
                  })
                  .catch((e) => {
                    e.error &&
                      alert(
                        "Oops! No ads available at the moment.\nTry again later"
                      );
                  })
                  .finally(() => {
                    this.showingAd = !1;
                  }));
            }),
            (this.showLeagueLeaderboad = () => {
              this.components.LeaguePage.fetch(this.league),
                this.components.LeaguePage.show();
            }),
            (this.ads = window.Adsgram.init({ blockId: b_.adBlockId })),
            this.ads.load(),
            (function () {
              if ("local" === v_) return;
              SC({
                dsn: Dw.sentryDNS,
                autoSessionTracking: !0,
                integrations: [iP({ levels: ["error"] })],
                environment: "".concat(v_, "-client"),
                beforeBreadcrumb: (e) => {
                  var t, n, r, s, i, o;
                  if (
                    "http" === e.type &&
                    "https://api.amplitude.com" ===
                      (null === (t = e.data) || void 0 === t ? void 0 : t.url)
                  )
                    return null;
                  if (
                    "console" === e.category &&
                    (null !==
                      (n =
                        null === (r = e.message) || void 0 === r
                          ? void 0
                          : r.length) && void 0 !== n
                      ? n
                      : 0) > 1e3
                  )
                    e.data || (e.data = {}),
                      (e.data.arguments = []),
                      (e.message =
                        (null === (o = e.message) || void 0 === o
                          ? void 0
                          : o.substr(0, 997)) + "...");
                  else if (
                    "http" === e.type &&
                    (null === (s = e.data) ||
                    void 0 === s ||
                    null === (i = s.url) ||
                    void 0 === i
                      ? void 0
                      : i.length) > 1e3
                  ) {
                    var a;
                    e.data || (e.data = {}),
                      (e.data.url =
                        (null === (a = e.data.url) || void 0 === a
                          ? void 0
                          : a.substr(0, 997)) + "...");
                  }
                  return e;
                },
              });
            })(),
            this.initGame()
              .then(() => {
                if (
                  !this.replicant.state.profile.photo ||
                  (this.replicant.state.profile.photo.includes(Qy) &&
                    this.replicant.state.profile.photoLastChecked <
                      Date.now() - 864e5) ||
                  this.replicant.state.profile.photoLastUpdated <
                    Date.now() - 6048e5
                )
                  return "local" === v_
                    ? Promise.resolve()
                    : this.replicant.invoke.setProfilePicture();
              })
              .catch(
                async (e) => (
                  fr.pushError("AppInitFailed", e),
                  EC("AppInitFailed", e),
                  await new Promise((e) => setTimeout(e, 3e3)),
                  Promise.reject(e)
                )
              ),
            (this.components = {
              Leaderboard: new B_("Leaderboard", this, j_.leaderboard, {
                onOpen: () => {
                  this.track("OpenLeaderboard", {});
                },
              }),
              Friends: new B_("Friends", this, this.getFriends, {
                onOpen: () => {
                  this.track("OpenFriendPage", {});
                },
              }),
              JoinTeam: new B_("JoinTeam", this, j_.listTeams, {
                onOpen: () => {
                  this.track("OpenLeaderboard", {});
                },
              }),
              TeamPage: new B_("TeamPage", this, j_.getTeam, {
                onOpen: () => {
                  this.track("OpenTeamPage", {});
                },
                onClose: () => {
                  this.components.TeamPage.setData(void 0);
                },
                onFetchComplete: () => {
                  var e, t;
                  this.playerTeam &&
                    (null === (e = this.playerTeam) || void 0 === e
                      ? void 0
                      : e.id) ===
                      (null === (t = this.components.TeamPage.data) ||
                      void 0 === t
                        ? void 0
                        : t.id) &&
                    this.setPlayerTeam(this.components.TeamPage.data);
                },
              }),
              Shop: new B_("Shop", this, () => j_.getShop(this.playerId)),
              Toast: new B_("Toast", this, async () => {}),
              OutOfEnergy: new B_("OutOfEnergy", this, async () => {}),
              Maintenance: new B_("Maintenance", this, async () => {}, {
                onOpen: () => {
                  this.track("OpenMaintenancePage", {});
                },
              }),
              Earn: new B_("Earn", this, this.getFriends, {
                onOpen: () => {
                  this.track("OpenEarnPage", {});
                },
                onClose: () => {},
              }),
              LeaguePage: new B_("LeaguePage", this, j_.getLeagueLeaderboard, {
                onOpen: () => {
                  this.track("OpenLeaguePage", {});
                },
              }),
              ModalComponent: new B_("ModalComponent", this, async () => ({
                queue: [],
              })),
            });
        }
        get invoke() {
          return this.replicant.invoke;
        }
        get asyncGetters() {
          return this.replicant.asyncGetters;
        }
        initLanguage(e) {
          var t, n;
          "control" !==
            (null === (t = this.replicant) ||
            void 0 === t ||
            null === (n = t.state.ruleset.abTests[Ky]) ||
            void 0 === n
              ? void 0
              : n.bucketId) && AO.changeLanguage(e);
        }
        trackTaps(e) {
          return (this.trackedTaps += e), this.trackedTaps;
        }
        getShareUrl(e) {
          const t = vS(e),
            n = encodeURIComponent(t),
            r = encodeURIComponent(
              (function (e, t) {
                var n;
                const r = tw(t, "Bronze");
                let s;
                switch (
                  null === (n = e.ruleset.abTests[Hy]) || void 0 === n
                    ? void 0
                    : n.bucketId
                ) {
                  case "miner":
                    s =
                      "\nPlay with me, become a miner extraordinaire, and prepare for the future of crypto!\n\ud83e\ude99+"
                        .concat(
                          Ob(r.regular),
                          " coins as a first-time gift.\n\ud83d\udd25+"
                        )
                        .concat(
                          Ob(r.premium),
                          " coins if you have Telegram Premium.\n\n"
                        );
                    break;
                  case "teamfun":
                    s =
                      "\nJoin my team in gemz, choose the best investments, and earn while having fun together.\n\ud83e\ude99+"
                        .concat(
                          Ob(r.regular),
                          " coins as a first-time gift.\n\ud83d\udd25+"
                        )
                        .concat(
                          Ob(r.premium),
                          " coins if you have Telegram Premium.\n\n"
                        );
                    break;
                  case "teamcrypto":
                    s =
                      "\nJoin my team in gemz, the future crypto sensation, and earn coins.\n\ud83e\ude99+"
                        .concat(
                          Ob(r.regular),
                          " coins as a first-time gift.\n\ud83d\udd25+"
                        )
                        .concat(
                          Ob(r.premium),
                          " coins if you have Telegram Premium.\n\n"
                        );
                    break;
                  default:
                    s = "\nPlay gemz with me and earn coins!\n\ud83c\udfc6+"
                      .concat(
                        Ob(r.regular),
                        " coins as a first-time bonus\n\ud83d\udc8e+"
                      )
                      .concat(
                        Ob(r.premium),
                        " coins if you have Telegram Premium\n\n"
                      );
                }
                return s;
              })(this.replicant.state, this.now())
            );
          return "https://t.me/share/url?url=".concat(n, "&text=").concat(r);
        }
      })(g_.playerId);
      !(function (e) {
        !(function (e) {
          e.replicantClientPromise.then(async (t) => {
            e.gcinstant.setExchangeRates(t.extras.getExchangeRates());
          });
        })(e),
          (function (e) {
            e.replicantClientPromise.then(async (t) => {
              const n = t.getGeolocation();
              n && e.gcinstant.setCountry(n.country);
            });
          })(e),
          (function (e) {
            let t;
            e.replicantClientPromise.then((e) => {
              t = e;
            });
            const n = dc(() => t, e.analytics);
            e.gcinstant.setDataCodec(n);
          })(e),
          (function (e) {
            if (e.getPlatformStorage) return;
            let t;
            e.replicantClientPromise.then((e) => {
              t = e;
            });
            const n =
              ((r = () => {
                if (!t) throw Error("Replicant client is not initialized");
                return t;
              }),
              {
                load: async () => r().state.gcinstant.platformStorage,
                save: async (e) => {
                  const t = r();
                  t.invoke.internalSetPlatformStorage(e), await t.flush();
                },
              });
            var r;
            e.gcinstant.storage.setStorageAdapter(n);
          })(e),
          (function (e) {
            e.replicantClientPromise.then(async (t) => {
              e.gcinstant.setTime && e.gcinstant.setTime(t.now());
            });
          })(e),
          "fb" === e.gcinstant.platformID &&
            (function (e) {
              const { gcinstant: t, replicantClientPromise: n } = e;
              let r;
              n.then((e) => {
                r = e;
              });
              let s = lc();
              t.beforeContextSwitch(() => {
                r &&
                  t.setSessionData({
                    ...r.getChatbotSessionData(),
                    eventId: s,
                    eventType: "CONTEXT_SWITCH",
                  });
              }),
                t.afterContextSwitch(() => {
                  var e;
                  r &&
                    (t.setSessionData(r.getChatbotSessionData()),
                    (null == (e = r.extras) ? void 0 : e.afterContextSwitch) &&
                      (r.extras
                        .afterContextSwitch({ contextSwitchEventId: s })
                        .catch((e) =>
                          console.error(
                            "Replicant after context switch hook request failed:",
                            e
                          )
                        ),
                      (s = lc())));
                });
            })(e),
          ("line" !== e.gcinstant.platformID &&
            "web" !== e.gcinstant.platformID) ||
            (function (e) {
              const {
                analytics: t,
                gcinstant: n,
                replicantClientPromise: r,
              } = e;
              if ("line" !== n.platformID && "web" !== n.platformID)
                throw Error("Invalid platform: " + n.platformID);
              const s = r.then(async (e) => {
                if ("line" !== e.platform) return null;
                const t = e.asyncGetters.lineIsSubscribedToChatbot;
                return t
                  ? t()
                  : (console.error(
                      "No lineIsSubscribedToChatbot async getter found in configuration - make sure to extend Replicant configuration with extendReplicantConfigForAnalytics"
                    ),
                    null);
              });
              n.beforeStartGameAsync(async function () {
                try {
                  const e = await s;
                  if (null === e) return;
                  (n.isSubscribedToBot = e),
                    t.setUserProperties({ isSubscribed: e });
                  const r = !e;
                  (n.canSubscribeToBot = r),
                    t.setUserProperties({ canSubscribeBot: r });
                } catch {}
              });
            })(e),
          "line" === e.gcinstant.platformID && uc(e),
          "web" === e.gcinstant.platformID &&
            (function (e) {
              if ("web" !== e.gcinstant.platformID)
                throw new Error(
                  "Invalid platform: ".concat(e.gcinstant.platformID)
                );
              const t = e.gcinstant;
              e.replicantClientPromise.then((e) => {
                if (!e.invoke.internalSetWebPushSubscription)
                  throw new Error(
                    "No internalSetWebPushSubscription action found. Did you forget to call extendReplicantConfigForAnalytics?"
                  );
                const n = e;
                t.setPushSubscriptionChangedListener(async (e) => {
                  await n.invoke.internalSetWebPushSubscription({
                    pushSubscription: null == e ? void 0 : e.toJSON(),
                  });
                });
              });
            })(e),
          (function (e) {
            const {
              gcinstant: t,
              replicantClientPromise: n,
              getPlatformStorage: r,
            } = e;
            let s;
            n.then((e) => {
              var t;
              (null == (t = e.asyncGetters) ? void 0 : t.getEntryTimestamps)
                ? (s = e)
                : console.error(
                    "Replicant async getter `getEntryTimestamps` is undefined. Extend Replicant configuration with `extendReplicantConfigForAnalytics`."
                  );
            }),
              t.setEntryTimestampsGetter(async (e) => {
                if (!s) return {};
                const t = s.friends.getFriendsStates();
                if (e.every((e) => t[e]))
                  return Promise.resolve(
                    Aa(e, (e) => {
                      var n;
                      const s = t[e].state;
                      return r
                        ? r(s)
                        : null == (n = s.gcinstant)
                        ? void 0
                        : n.platformStorage;
                    })
                  );
                if ("function" !== typeof s.asyncGetters.getEntryTimestamps)
                  throw Error(
                    "asyncGetters.getEntryTimestamps is not a function"
                  );
                return s.asyncGetters.getEntryTimestamps(e);
              });
          })(e),
          (function (e) {
            e.replicantClientPromise.then((t) => {
              if (
                !t.extras.getLastReceivedChatbotMessagePayload ||
                !e.gcinstant.setLastReceivedChatbotMessagePayload
              )
                return;
              const n = t.extras.getLastReceivedChatbotMessagePayload();
              n && e.gcinstant.setLastReceivedChatbotMessagePayload(n);
            });
          })(e),
          (function (e) {
            e.replicantClientPromise.then(async (t) => {
              if (t.abTests && e.gcinstant.setExternalABTestsSource) {
                await e.gcinstant.waitForEntryAnalytics();
                try {
                  e.gcinstant.setExternalABTestsSource(t.abTests);
                } catch {}
              }
            });
          })(e),
          (async function (e) {
            const { analytics: t, replicantClientPromise: n } = e;
            await n.then((e) => {
              e.extras.setActionAnalyticsCallback((e) => {
                e.forEach((e) => {
                  let {
                    eventType: n,
                    eventProperties: r,
                    userProperties: s,
                  } = e;
                  t.setUserProperties(s), t.pushEvent(n, r);
                });
              });
            });
          })(e);
      })({
        analytics: fr,
        gcinstant: IO,
        replicantClientPromise: CO.replicantClientPromise,
      });
      const kO = dc(() => CO.replicant, fr, {
        generatePayloadKey: () => Ub(CO.replicant.userId),
      });
      IO.setDataCodec(kO);
      var OO = n(579);
      const xO = { 1: FE.medal_gold, 2: FE.medal_silver, 3: FE.medal_bronze },
        NO = (e) => {
          let { rank: t } = e;
          return (0, OO.jsx)("div", {
            className: "rank",
            children: t
              ? t > 3
                ? (0, OO.jsxs)("p", {
                    className: "rank-label",
                    children: ["#", t],
                  })
                : (0, OO.jsx)("img", { src: xO[t] })
              : null,
          });
        };
      const RO = (e, t, n) => (1 === e ? t : n || "".concat(t, "s")),
        DO = (e) => (void 0 === e ? "" : e.toLocaleString()),
        MO = [
          [1e3, "K"],
          [1e6, "M"],
          [1e9, "B"],
          [1e12, "T"],
        ],
        jO = (e) => {
          if (e < 1e3) return e.toString();
          let t = 0,
            n = "";
          for (const [i, o] of MO) {
            if (e < i) break;
            (t = i), (n = o);
          }
          if (0 === t) return e.toString();
          const r = e / t,
            s = r === Math.round(r) ? r : r.toFixed(1);
          return "".concat(s).concat(n);
        },
        LO = () => {
          TO({
            id: "TeamPage",
            listener: CO.attachEventListener(PO.onMyTeamUpdate),
          });
          const { t: e } = Lk(),
            { playerTeam: t, state: n } = CO,
            r = () => {
              CO.components.JoinTeam.show();
            },
            [s, i] = (0, o.useState)(!1);
          return (
            (0, o.useEffect)(() => {
              n.team_id
                ? CO.replicant.asyncGetters
                    .getTeamWithMembers({ teamId: n.team_id })
                    .then((e) =>
                      e && e.score < 0
                        ? CO.replicant.invoke.getTeamWithMembersWithScoreFix({
                            teamId: e.id,
                          })
                        : e
                    )
                    .then((e) => {
                      CO.setPlayerTeam(e), i(!0);
                    })
                : i(!0);
            }, []),
            s
              ? t
                ? (0, OO.jsx)("div", {
                    className: "team-button",
                    children: (0, OO.jsxs)("div", {
                      id: "my-team",
                      className: "btn btn-clicker my-team",
                      onClick: () => {
                        t &&
                          (CO.components.TeamPage.fetch(t.id),
                          CO.components.TeamPage.show());
                      },
                      children: [
                        (0, OO.jsx)("div", {
                          className: "img",
                          children: (0, OO.jsx)("img", {
                            src: t.photo || FE.friends,
                            alt: t.name,
                          }),
                        }),
                        (0, OO.jsxs)("div", {
                          className: "text",
                          children: [
                            (0, OO.jsx)("div", {
                              className: "name-label",
                              children: t.name,
                            }),
                            (0, OO.jsxs)("div", {
                              className: "score",
                              children: [
                                (0, OO.jsx)("img", {
                                  src: FE.coin,
                                  alt: "Team Points",
                                }),
                                (0, OO.jsx)("div", {
                                  className: "points",
                                  children: jO(t.score),
                                }),
                              ],
                            }),
                          ],
                        }),
                        (0, OO.jsx)("div", {
                          className: "rank",
                          children: (0, OO.jsx)(NO, {
                            rank:
                              (null === t || void 0 === t ? void 0 : t.rank) ||
                              3,
                          }),
                        }),
                      ],
                    }),
                  })
                : (0, OO.jsx)("div", {
                    className: "team-button",
                    children: (0, OO.jsx)("div", {
                      id: "join-team",
                      className: "btn btn-clicker join-team",
                      onClick: r,
                      children: e("team_join_button"),
                    }),
                  })
              : (0, OO.jsx)("div", {
                  className: "team-button",
                  children: (0, OO.jsx)("div", {
                    id: "join-team",
                    className: "btn-clicker join-team",
                    children: (0, OO.jsx)("div", {
                      className: "join-team-loading",
                      children: e("loading"),
                    }),
                  }),
                })
          );
        },
        UO = () => {
          const { bonus: e } = CO;
          return e
            ? (0, OO.jsx)("div", {
                className: "astronaut-c",
                children: (0, OO.jsxs)("div", {
                  className: "astronaut",
                  children: [
                    (0, OO.jsx)("img", {
                      className: "char",
                      src: FE.astronaut.char,
                    }),
                    (0, OO.jsx)("div", {
                      className: "flame-c",
                      children: (0, OO.jsx)("span", { className: "flame" }),
                    }),
                  ],
                }),
              })
            : null;
        };
      function FO() {
        return !/Mobi|Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
          navigator.userAgent
        );
      }
      function BO() {
        return "unknown" !== window.Telegram.WebApp.platform;
      }
      const VO = () => {
          TO({
            id: "ClickerContent",
            listener: CO.attachEventListener(PO.onGameStateUpdate),
          });
          const { t: e } = Lk(),
            t = e(CO.league.toLowerCase()),
            { state: n, bonus: r } = CO,
            [s, i] = (0, o.useState)(!1),
            a = () => {
              !(function () {
                const e = jy(),
                  t = Ry();
                if (e && t) {
                  const n = e.cloneNode(!0);
                  t.append(n),
                    setTimeout(() => {
                      n.remove();
                    }, 500);
                }
              })(),
                CO.onTap(),
                Telegram.WebApp.HapticFeedback.impactOccurred("heavy"),
                i(!0),
                setTimeout(() => i(!1), 100);
            },
            c = r
              ? (function (e) {
                  const t = Math.floor((e / 1e3) % 60),
                    n = "".concat(t < 10 ? "0".concat(t) : t);
                  return "0:".concat(n);
                })(r.timeLeft)
              : void 0,
            l = r ? __.Purple : __.Blue;
          return (0, OO.jsxs)("section", {
            className: "clicker-content",
            children: [
              (0, OO.jsxs)("div", {
                className: "scoreboard",
                children: [
                  c &&
                    (0, OO.jsx)("div", {
                      className: "timer",
                      children: ""
                        .concat(e("clicker_boost_time_left"), " ")
                        .concat(c),
                    }),
                  (0, OO.jsxs)("div", {
                    className: "points",
                    children: [
                      (0, OO.jsx)("img", {
                        className: "points-icon",
                        src: FE.coin,
                        alt: "",
                      }),
                      (0, OO.jsx)("div", {
                        id: "point",
                        className: "points-label",
                        children: DO(n.balance),
                      }),
                    ],
                  }),
                  (0, OO.jsxs)("div", {
                    className: "league",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "league-icon",
                        children: (0, OO.jsx)("img", {
                          src: FE.league[CO.league],
                          alt: "",
                        }),
                      }),
                      (0, OO.jsx)("div", {
                        className: "league-label",
                        onClick: CO.showLeagueLeaderboad,
                        children: t,
                      }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                id: "coin-container",
                className: "coin-container",
                children: [
                  (0, OO.jsx)("div", { className: "bg-radial ".concat(l) }),
                  (0, OO.jsxs)("div", {
                    id: "coin",
                    className: "coin ".concat(s && "btn-animate"),
                    onTouchStart: a,
                    ...(FO() ? { onClick: a } : {}),
                    children: [
                      (0, OO.jsx)("div", { className: "hitbox" }),
                      (0, OO.jsx)("img", {
                        className: "gem-circle",
                        src: FE.btn_clicker_circle,
                        alt: "",
                      }),
                      (0, OO.jsx)("img", {
                        className: "gem-icon",
                        src: FE.league[CO.league],
                        alt: "",
                      }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsx)("div", {
                id: "ripple-templates",
                children: (0, OO.jsx)("div", {
                  className: "ripple-circles",
                  children: (0, OO.jsx)("div", {
                    className: "ripple-circle-1",
                  }),
                }),
              }),
            ],
          });
        },
        qO = () => {
          TO({
            id: "ClickerContent",
            listener: CO.attachEventListener(PO.onGameStateUpdate),
          });
          const { t: e } = Lk(),
            { energyLimit: t, state: n } = CO,
            r = (function (e, t) {
              const n = Vb(e),
                r = qb(e),
                s = t - e.last_energy_refresh,
                i = e.energy + (r * s) / 1e3;
              return Math.min(n, Math.round(i));
            })(n, CO.now()),
            s = "".concat((100 * r) / t, "%");
          return (0, OO.jsxs)("footer", {
            children: [
              (0, OO.jsxs)("div", {
                className: "progress-info",
                children: [
                  (0, OO.jsxs)("div", {
                    className: "progress-info-label",
                    children: [
                      (0, OO.jsxs)("span", {
                        className: "p-1",
                        children: [e("clicker_footer_energy"), " "],
                      }),
                      (0, OO.jsx)("span", { className: "p-2", children: r }),
                      (0, OO.jsx)("span", {
                        className: "p-1",
                        children: " / ",
                      }),
                      (0, OO.jsx)("span", { className: "p-3", children: t }),
                    ],
                  }),
                  (0, OO.jsxs)("div", {
                    className: "progress-bar",
                    children: [
                      (0, OO.jsx)("div", { className: "progress-bar-bg" }),
                      (0, OO.jsx)("div", {
                        className: "progress-bar-value",
                        style: { width: s },
                      }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "clicker-footer-buttons",
                children: [
                  (0, OO.jsxs)("div", {
                    className: "btn btn-clicker footer",
                    onClick: () => {
                      CO.components.Friends.show();
                    },
                    children: [
                      (0, OO.jsx)("img", { src: FE.friends }),
                      (0, OO.jsx)("div", {
                        className: "label",
                        children: e("clicker_footer_friends"),
                      }),
                    ],
                  }),
                  (0, OO.jsxs)("div", {
                    className: "btn btn-clicker footer",
                    onClick: () => {
                      CO.components.Shop.show();
                    },
                    children: [
                      (0, OO.jsx)("img", { src: FE.booster }),
                      (0, OO.jsx)("div", {
                        className: "label",
                        children: e("clicker_footer_boosts"),
                      }),
                    ],
                  }),
                  (0, OO.jsxs)("div", {
                    className: "btn btn-clicker footer",
                    onClick: () => {
                      CO.components.Earn.show();
                    },
                    children: [
                      (0, OO.jsx)("img", { src: FE.earn }),
                      (0, OO.jsx)("div", {
                        className: "label",
                        children: e("clicker_footer_earn"),
                      }),
                    ],
                  }),
                ],
              }),
            ],
          });
        },
        HO = () => (
          TO({
            id: "Clicker",
            listener: CO.attachEventListener(PO.onRocketmanChange),
          }),
          (0, OO.jsxs)("main", {
            style: {
              paddingTop: BO() ? "0" : "16px",
              paddingBottom: BO() ? "32px" : "16px",
            },
            children: [
              (0, OO.jsx)(LO, {}),
              (0, OO.jsx)(UO, {}),
              (0, OO.jsx)(VO, {}),
              (0, OO.jsx)(qO, {}),
            ],
          })
        ),
        WO = (0, o.createContext)(null),
        KO = { didCatch: !1, error: null };
      class zO extends o.Component {
        constructor(e) {
          super(e),
            (this.resetErrorBoundary = this.resetErrorBoundary.bind(this)),
            (this.state = KO);
        }
        static getDerivedStateFromError(e) {
          return { didCatch: !0, error: e };
        }
        resetErrorBoundary() {
          const { error: e } = this.state;
          if (null !== e) {
            for (
              var t, n, r = arguments.length, s = new Array(r), i = 0;
              i < r;
              i++
            )
              s[i] = arguments[i];
            null === (t = (n = this.props).onReset) ||
              void 0 === t ||
              t.call(n, { args: s, reason: "imperative-api" }),
              this.setState(KO);
          }
        }
        componentDidCatch(e, t) {
          var n, r;
          null === (n = (r = this.props).onError) ||
            void 0 === n ||
            n.call(r, e, t);
        }
        componentDidUpdate(e, t) {
          const { didCatch: n } = this.state,
            { resetKeys: r } = this.props;
          var s, i;
          n &&
            null !== t.error &&
            (function () {
              let e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : [],
                t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : [];
              return (
                e.length !== t.length || e.some((e, n) => !Object.is(e, t[n]))
              );
            })(e.resetKeys, r) &&
            (null === (s = (i = this.props).onReset) ||
              void 0 === s ||
              s.call(i, { next: r, prev: e.resetKeys, reason: "keys" }),
            this.setState(KO));
        }
        render() {
          const {
              children: e,
              fallbackRender: t,
              FallbackComponent: n,
              fallback: r,
            } = this.props,
            { didCatch: s, error: i } = this.state;
          let a = e;
          if (s) {
            const e = { error: i, resetErrorBoundary: this.resetErrorBoundary };
            if ("function" === typeof t) a = t(e);
            else if (n) a = (0, o.createElement)(n, e);
            else {
              if (null !== r && !(0, o.isValidElement)(r)) throw i;
              a = r;
            }
          }
          return (0, o.createElement)(
            WO.Provider,
            {
              value: {
                didCatch: s,
                error: i,
                resetErrorBoundary: this.resetErrorBoundary,
              },
            },
            a
          );
        }
      }
      const GO = () => {
          if (BO()) return null;
          return (0, OO.jsx)("div", {
            className: "button-back",
            onClick: () => {
              console.warn(">>> click on back button"), CO.closeAllPages();
            },
            children: (0, OO.jsx)("img", { src: FE.button_arrow_back }),
          });
        },
        JO = (e) => {
          let {
            children: t,
            id: n,
            visible: r,
            showInstantly: s,
            preventClosing: i,
          } = e;
          const [a, c] = (0, o.useState)(!1);
          !a && r && c(!0),
            (0, o.useEffect)(() => {
              r && !i && Telegram.WebApp.BackButton.show();
            }, [r]);
          let l = r ? "slide-up" : "slide-down";
          return (
            s && (l = ""),
            (0, OO.jsx)("div", {
              id: n,
              className: "modal "
                .concat(n, " ")
                .concat(!a && "hide", " ")
                .concat(l),
              style: { paddingTop: 0, paddingBottom: BO() ? "32px" : "16px" },
              children: (0, OO.jsxs)("div", {
                className: "modal-page ".concat(n),
                children: [(0, OO.jsx)(GO, {}), t],
              }),
            })
          );
        },
        QO = (e) => {
          let {
            teamId: t,
            name: n,
            members: r,
            score: s,
            image: i,
            rank: o,
          } = e;
          const { t: a } = Lk();
          return (0, OO.jsxs)("div", {
            className: "card leaderboard",
            onClick: () => {
              CO.components.TeamPage.fetch(t),
                CO.components.TeamPage.show(),
                CO.onBackNavigateTo("Leaderboard");
            },
            children: [
              (0, OO.jsxs)("div", {
                className: "card-left",
                children: [
                  (0, OO.jsx)(NO, { rank: o }),
                  (0, OO.jsx)("div", {
                    className: "image",
                    children: (0, OO.jsx)("img", { src: i || FE.friends }),
                  }),
                  (0, OO.jsxs)("div", {
                    className: "info",
                    children: [
                      (0, OO.jsx)("div", { className: "name", children: n }),
                      (0, OO.jsx)("div", {
                        className: "users",
                        children: a("team_members_count", { count: r }),
                      }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "score",
                children: [
                  (0, OO.jsx)("div", { className: "text", children: jO(s) }),
                  (0, OO.jsx)("div", {
                    className: "icon",
                    children: (0, OO.jsx)("img", { src: FE.coin }),
                  }),
                ],
              }),
            ],
          });
        },
        YO = (e) => {
          let {
            image: t,
            blur: n,
            intensity: r = 1,
            size: s,
            noGlow: i = !1,
          } = e;
          return (0, OO.jsxs)("div", {
            className: "modal-header-icon",
            children: [
              (0, OO.jsx)("img", {
                src: t,
                className: "glow",
                style: {
                  width: s ? "".concat(s, "px") : "unset",
                  height: s ? "".concat(s, "px") : "unset",
                  filter: "blur("
                    .concat(n, "px) saturate(")
                    .concat(10 * r, ") brightness(")
                    .concat(2 * r, ")"),
                  display: i ? "none" : "initial",
                },
              }),
              (0, OO.jsx)("img", {
                src: t,
                style: {
                  width: s ? "".concat(s, "px") : "unset",
                  height: s ? "".concat(s, "px") : "unset",
                },
              }),
            ],
          });
        },
        XO = () => {
          TO({
            id: "LeaderboardPage",
            listener: CO.components.Leaderboard.attachEventListener(),
          });
          const { t: e } = Lk(),
            {
              data: t,
              loading: n,
              visible: r,
              fetch: s,
            } = CO.components.Leaderboard;
          return (
            (0, o.useEffect)(() => {
              r && s();
            }, [r]),
            (0, OO.jsxs)(JO, {
              id: "modal-leaderboard",
              visible: r,
              children: [
                (0, OO.jsxs)("div", {
                  className: "modal-header leaderboard",
                  children: [
                    (0, OO.jsx)(YO, { image: FE.king, blur: 60 }),
                    (0, OO.jsx)("div", {
                      className: "modal-header-title",
                      children: e("leaderboard_title"),
                    }),
                  ],
                }),
                n
                  ? (0, OO.jsx)("p", {
                      className: "loading-label fixed",
                      children: e("loading"),
                    })
                  : (0, OO.jsx)("div", {
                      className: "team-list leaderboard",
                      children: (t || []).map((e, t) =>
                        (0, OO.jsx)(
                          QO,
                          {
                            teamId: e.id,
                            name: e.name,
                            members: e.members,
                            score: e.score,
                            rank: e.rank,
                            image: e.photo,
                          },
                          e.id + t
                        )
                      ),
                    }),
              ],
            })
          );
        },
        ZO = (e) => {
          let {
            username: t,
            contribution: n,
            picture: r,
            team: s,
            score: i,
            league: o,
          } = e;
          return (0, OO.jsxs)("div", {
            className: "card friend",
            children: [
              (0, OO.jsxs)("div", {
                className: "card-left",
                children: [
                  (0, OO.jsx)("div", {
                    className: "image",
                    children: (0, OO.jsx)("img", {
                      src: r || FE.mock_portrait,
                    }),
                  }),
                  (0, OO.jsxs)("div", {
                    className: "info",
                    children: [
                      (0, OO.jsx)("div", { className: "name", children: t }),
                      (0, OO.jsxs)("div", {
                        className: "friend-card-special-info",
                        children: [
                          (0, OO.jsxs)("div", {
                            className: "friend-rank",
                            children: [
                              (0, OO.jsx)("div", {
                                className: "friend-rank-icon",
                                children: (0, OO.jsx)("img", {
                                  src: FE.league[o],
                                }),
                              }),
                              (0, OO.jsx)("div", {
                                className: "friend-rank-label",
                                children: o,
                              }),
                            ],
                          }),
                          (0, OO.jsx)("div", { className: "separator" }),
                          (0, OO.jsx)("div", {
                            className: "friend-bonus",
                            children: "+".concat(n),
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "score",
                children: [
                  (0, OO.jsx)("div", { className: "text", children: jO(i) }),
                  (0, OO.jsx)("div", {
                    className: "icon",
                    children: (0, OO.jsx)("img", { src: FE.coin }),
                  }),
                ],
              }),
            ],
          });
        },
        $O = (e) => {
          let { children: t, className: n, visible: r, onClose: s } = e;
          const [i, a] = (0, o.useState)(!1);
          return (
            (0, o.useEffect)(() => {
              r && a(!0);
            }, [r]),
            (0, OO.jsx)("div", {
              className: "modal-drawer "
                .concat(n, " ")
                .concat(r ? "slide-up" : "slide-down", " ")
                .concat(!i && "hide"),
              children: (0, OO.jsxs)("div", {
                className: "modal-drawer-box",
                style: { paddingBottom: BO() ? "36px" : "24px" },
                children: [
                  (0, OO.jsx)("img", {
                    className: "modal-drawer-button-close",
                    src: FE.button_x,
                    onClick: s,
                  }),
                  t,
                ],
              }),
            })
          );
        };
      function ex(e) {
        return {
          $realtimeIsPurchaser: !1,
          $realtimeLTV: 0,
          ...e,
          ...IO.getPlatformPayloadData(),
        };
      }
      function tx(e) {
        var t;
        const n = ex({ ...e.data, $channel: "INVITE" });
        fr.pushEvent("TrackInviteAsync", n);
        const { $key: r } = kO.encode(n);
        if (!r) throw Error("Missing $key property in encoded payload");
        const s = null !== (t = e.url) && void 0 !== t ? t : CO.getShareUrl(r);
        Telegram.WebApp.openTelegramLink(s);
      }
      const nx = (e) => {
          var t, n;
          let { caption: r, feature: s, subFeature: i } = e;
          const [a, c] = (0, o.useState)(!1),
            l =
              null === (t = CO.replicant) ||
              void 0 === t ||
              null === (n = t.state.ruleset.abTests[qy]) ||
              void 0 === n
                ? void 0
                : n.bucketId,
            u = "btn btn-normal btn-invite ".concat(
              "active" !== l ? "" : "short"
            );
          return (0, OO.jsxs)("div", {
            className: "buttons-invite",
            children: [
              (0, OO.jsx)("div", {
                className: u,
                onClick: () => {
                  CO.track("PressInvite", { page: s }),
                    tx({ data: { feature: s, $subFeature: i } });
                },
                children: r,
              }),
              "active" === l &&
                (0, OO.jsxs)("div", {
                  className: "btn btn-normal btn-copy",
                  onClick: () => {
                    CO.track("CopyInviteLink", { page: s });
                    const e = (function (e) {
                      const t = ex({ ...e.data, $channel: "LINK" });
                      fr.pushEvent("TrackInviteCopyAsync", t);
                      const { $key: n } = kO.encode(t);
                      return vS(n);
                    })({ data: { feature: s, $subFeature: i } });
                    (async (e) => {
                      try {
                        await navigator.clipboard.writeText(e);
                      } catch {
                        var t = document.createElement("input");
                        (t.style.display = "none"),
                          document.body.appendChild(t),
                          t.setAttribute("id", "dummy_id"),
                          (document.getElementById("dummy_id").value = e),
                          t.select(),
                          document.execCommand("copy"),
                          document.body.removeChild(t);
                      }
                    })(e),
                      setTimeout(() => {
                        c(!0), setTimeout(() => c(!1), 900);
                      }, 250);
                  },
                  children: [
                    (0, OO.jsx)("img", { src: FE.copy }),
                    a &&
                      (0, OO.jsxs)("div", {
                        className: "copy-success",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "copy-success-icon",
                            children: (0, OO.jsx)("img", {
                              src: FE.copy_success,
                            }),
                          }),
                          (0, OO.jsx)("div", {
                            className: "copy-success-text",
                            children: "Copied!",
                          }),
                        ],
                      }),
                  ],
                }),
            ],
          });
        },
        rx = (e) =>
          (0, OO.jsxs)("div", {
            className: "friends-bonus-item",
            children: [
              (0, OO.jsx)("div", {
                className: "league-icon",
                children: (0, OO.jsx)("img", { src: FE.league[e.league] }),
              }),
              (0, OO.jsx)("div", {
                className: "league-rank",
                children: e.league,
              }),
              (0, OO.jsxs)("div", {
                className: "bonus-yellow",
                children: ["+", DO(e.regular)],
              }),
              (0, OO.jsxs)("div", {
                className: "bonus-yellow",
                children: ["+", DO(e.premium)],
              }),
            ],
          }),
        sx = (e) => {
          let { visible: t, onClose: n } = e;
          const r = tw(CO.now(), "Bronze"),
            s = tw(CO.now(), "Silver"),
            i = tw(CO.now(), "Gold"),
            o = tw(CO.now(), "Platinum"),
            a = tw(CO.now(), "Diamond");
          return (0, OO.jsxs)($O, {
            className: "friends-details",
            visible: t,
            onClose: n,
            children: [
              (0, OO.jsxs)("div", {
                className: "friends-details-header",
                children: [
                  (0, OO.jsx)("div", {
                    className: "friends-details-icon",
                    children: (0, OO.jsx)("img", { src: FE.friends }),
                  }),
                  (0, OO.jsx)("div", {
                    className: "friends-details-title",
                    children: "Friends level\nup bonus",
                  }),
                ],
              }),
              (0, OO.jsxs)(OO.Fragment, {
                children: [
                  (0, OO.jsxs)("div", {
                    className: "friends-bonus-list-header",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "friends-bonus-list-header-label levelup",
                        children: "Level up",
                      }),
                      (0, OO.jsx)("div", {
                        className: "friends-bonus-list-header-label",
                        children: "Regular",
                      }),
                      (0, OO.jsx)("div", {
                        className: "friends-bonus-list-header-label",
                        children: "Premium",
                      }),
                    ],
                  }),
                  (0, OO.jsxs)("div", {
                    className: "friends-bonus-list",
                    children: [
                      (0, OO.jsx)(rx, {
                        league: S_.Bronze,
                        regular: r.regular,
                        premium: r.premium,
                      }),
                      (0, OO.jsx)(rx, {
                        league: S_.Silver,
                        regular: s.regular,
                        premium: s.premium,
                      }),
                      (0, OO.jsx)(rx, {
                        league: S_.Gold,
                        regular: i.regular,
                        premium: i.premium,
                      }),
                      (0, OO.jsx)(rx, {
                        league: S_.Platinum,
                        regular: o.regular,
                        premium: o.premium,
                      }),
                      (0, OO.jsx)(rx, {
                        league: S_.Diamond,
                        regular: a.regular,
                        premium: a.premium,
                      }),
                    ],
                  }),
                  (0, OO.jsx)("div", {
                    className: "footer-buttons",
                    children: (0, OO.jsx)(nx, {
                      caption: "Invite Friend",
                      feature: "friend",
                      subFeature: "friend_details",
                    }),
                  }),
                ],
              }),
            ],
          });
        },
        ix = () => {
          TO({
            id: "app",
            listener: CO.components.Friends.attachEventListener(),
          });
          const { t: e } = Lk(),
            {
              data: t,
              loading: n,
              visible: r,
              fetch: s,
            } = CO.components.Friends;
          (0, o.useEffect)(() => {
            r && s();
          }, [r]);
          const [i, a] = (0, o.useState)(!1),
            c = (t || []).length,
            l = tw(CO.now(), "Bronze");
          return (0, OO.jsxs)(JO, {
            id: "friends",
            visible: r,
            children: [
              (0, OO.jsxs)("div", {
                className: "friends-header",
                children: [
                  (0, OO.jsx)("div", {
                    className: "friends-title",
                    children:
                      1 === c
                        ? e("friends_count_one")
                        : e("friends_count", { count: c }),
                  }),
                  (0, OO.jsx)("div", {
                    className: "friends-subtitle",
                    children: e("friends_subtitle"),
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "friends-cta",
                onClick: () => {
                  a(!0);
                },
                children: [
                  (0, OO.jsxs)("div", {
                    className: "friend-cta-item",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "icon-1",
                        children: (0, OO.jsx)("img", { src: FE.coin }),
                      }),
                      (0, OO.jsxs)("div", {
                        className: "info-1",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "title",
                            children: e("friends_info_title"),
                          }),
                          (0, OO.jsxs)("div", {
                            className: "info-2",
                            children: [
                              (0, OO.jsx)("div", {
                                className: "icon-2",
                                children: (0, OO.jsx)("img", { src: FE.coin }),
                              }),
                              (0, OO.jsx)("div", {
                                className: "info-3",
                                children: (0, OO.jsx)("span", {
                                  children: e("friends_info_subtitle", {
                                    amount: DO(l.regular),
                                  }),
                                }),
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  (0, OO.jsx)("div", { className: "separator" }),
                  (0, OO.jsxs)("div", {
                    className: "friend-cta-item",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "icon-1",
                        children: (0, OO.jsx)("img", {
                          src: FE.telegram_premium,
                        }),
                      }),
                      (0, OO.jsxs)("div", {
                        className: "info-1",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "title",
                            children: e("friends_info_premium_title"),
                          }),
                          (0, OO.jsxs)("div", {
                            className: "info-2",
                            children: [
                              (0, OO.jsx)("div", {
                                className: "icon-2",
                                children: (0, OO.jsx)("img", { src: FE.coin }),
                              }),
                              (0, OO.jsx)("div", {
                                className: "info-3",
                                children: e("friends_info_premium_subtitle", {
                                  amount: DO(l.premium),
                                }),
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  (0, OO.jsx)("div", {
                    className: "opendetails",
                    children: e("friends_open_details"),
                  }),
                ],
              }),
              n
                ? (0, OO.jsx)("p", {
                    className: "loading-label",
                    children: e("loading"),
                  })
                : (0, OO.jsxs)(OO.Fragment, {
                    children: [
                      (0, OO.jsx)("div", {
                        className: "footer-buttons",
                        children: (0, OO.jsx)(nx, {
                          caption: e("friends_invite_button"),
                          feature: "friend",
                          subFeature: "friend_page",
                        }),
                      }),
                      (0, OO.jsx)("div", {
                        className: "team-list friends",
                        children: (t || []).map((e, t) =>
                          (0, OO.jsx)(ZO, { ...e }, e.username + t)
                        ),
                      }),
                    ],
                  }),
              (0, OO.jsx)(sx, {
                visible: i,
                onClose: () => {
                  a(!1);
                },
              }),
            ],
          });
        },
        ox = (e) => {
          let { teamId: t, name: n, members: r, score: s, image: i } = e;
          const { t: o } = Lk();
          return (0, OO.jsxs)("div", {
            className: "card team",
            onClick: () => {
              CO.components.TeamPage.fetch(t),
                CO.components.TeamPage.show(),
                CO.onBackNavigateTo("JoinTeam");
            },
            children: [
              (0, OO.jsxs)("div", {
                className: "card-left",
                children: [
                  (0, OO.jsx)("div", {
                    className: "image",
                    children: (0, OO.jsx)("img", { src: i || FE.friends }),
                  }),
                  (0, OO.jsxs)("div", {
                    className: "info",
                    children: [
                      (0, OO.jsx)("div", { className: "name", children: n }),
                      (0, OO.jsx)("div", {
                        className: "users",
                        children: o("team_members_count", { count: r }),
                      }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "score",
                children: [
                  (0, OO.jsx)("div", { className: "text", children: jO(s) }),
                  (0, OO.jsx)("div", {
                    className: "icon",
                    children: (0, OO.jsx)("img", { src: FE.coin }),
                  }),
                ],
              }),
            ],
          });
        },
        ax = (e) => {
          let { canAffordCreate: t, visible: n, onClose: r, onCreate: s } = e;
          const { t: i } = Lk();
          return (0, OO.jsxs)($O, {
            className: "createTeam-details",
            visible: n,
            onClose: r,
            children: [
              (0, OO.jsxs)("div", {
                className: "createTeam-details-header",
                children: [
                  (0, OO.jsx)("div", {
                    className: "createTeam-details-icon",
                    children: (0, OO.jsx)("img", {
                      src: FE.astronauts_create_team,
                    }),
                  }),
                  (0, OO.jsx)("div", {
                    className: "createTeam-details-title",
                    children: i("team_create_title"),
                  }),
                  (0, OO.jsx)("div", {
                    className: "createTeam-details-subtitle",
                    children: i("team_create_subtitle"),
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "createTeam-details-body",
                children: [
                  (0, OO.jsx)("div", {
                    className: "createTeam-details-body-value-icon",
                    children: (0, OO.jsx)("img", { src: FE.coin }),
                  }),
                  (0, OO.jsx)("div", {
                    className: "createTeam-details-body-value-label",
                    children: DO(cw),
                  }),
                  (0, OO.jsxs)("div", {
                    className: "createTeam-details-body-perteam",
                    children: ["/ ", i("team_create_per_team")],
                  }),
                ],
              }),
              (0, OO.jsx)("div", {
                className: "footer-buttons",
                children: (0, OO.jsx)("div", {
                  className: "btn btn-normal ".concat(!t && "disabled"),
                  onClick: s,
                  children: i("team_create_button"),
                }),
              }),
            ],
          });
        },
        cx = () => {
          TO({
            id: "TeamList-1",
            listener: CO.components.JoinTeam.attachEventListener(),
          }),
            TO({
              id: "TeamList-2",
              listener: CO.attachEventListener(PO.onMyTeamUpdate),
            });
          const { t: e } = Lk(),
            { playerTeam: t, playerBalance: n } = CO,
            {
              data: r,
              loading: s,
              visible: i,
              fetch: a,
            } = CO.components.JoinTeam,
            c = n >= cw;
          (0, o.useEffect)(() => {
            i && a();
          }, [i]);
          const [l, u] = (0, o.useState)(!1);
          return (0, OO.jsxs)(JO, {
            id: "modal-team-list",
            visible: i,
            children: [
              (0, OO.jsxs)("div", {
                className: "modal-header jointeam",
                children: [
                  (0, OO.jsx)(YO, {
                    image: FE.astronauts,
                    blur: 70,
                    intensity: 0.4,
                  }),
                  (0, OO.jsx)("div", {
                    className: "modal-header-title",
                    children: e("team_join_title"),
                  }),
                  (0, OO.jsx)("div", {
                    className: "modal-header-subtitle",
                    children: e("team_join_subtitle"),
                  }),
                ],
              }),
              s
                ? (0, OO.jsx)("p", {
                    className: "loading-label fixed",
                    children: e("loading"),
                  })
                : (0, OO.jsxs)(OO.Fragment, {
                    children: [
                      !t &&
                        (0, OO.jsxs)("div", {
                          className: "footer-buttons vertical",
                          children: [
                            (0, OO.jsx)(nx, {
                              caption: e("team_invite_button"),
                              feature: "team",
                              subFeature: "team_join",
                            }),
                            (0, OO.jsx)("div", {
                              className: "btn btn-inverse",
                              onClick: () => {
                                u(!0);
                              },
                              children: e("team_create_button"),
                            }),
                          ],
                        }),
                      (0, OO.jsx)("div", {
                        className: "team-list",
                        children: (r || []).map((e, t) =>
                          (0, OO.jsx)(
                            ox,
                            {
                              teamId: e.id,
                              name: e.name,
                              members: e.members,
                              score: e.score,
                              image: e.photo,
                            },
                            e.id + t
                          )
                        ),
                      }),
                    ],
                  }),
              (0, OO.jsx)(ax, {
                canAffordCreate: c,
                visible: l,
                onClose: () => {
                  u(!1);
                },
                onCreate: () => {
                  u(!1),
                    c &&
                      (tx({
                        url: "https://t.me/".concat(
                          Dw.botName,
                          "?start=create_team"
                        ),
                        data: { feature: "team", $subFeature: "team_create" },
                      }),
                      setTimeout(() => {
                        Telegram.WebApp.close();
                      }));
                },
              }),
            ],
          });
        },
        lx = (e) => {
          let { rank: t, image: n, name: r, score: s, contribution: i } = e;
          return (0, OO.jsxs)("div", {
            className: "card team-member",
            children: [
              (0, OO.jsxs)("div", {
                className: "card-left",
                children: [
                  (0, OO.jsx)(NO, { rank: t }),
                  (0, OO.jsx)("div", {
                    className: "image",
                    children: (0, OO.jsx)("img", { src: n || FE.friends }),
                  }),
                  (0, OO.jsx)("div", {
                    className: "info",
                    children: (0, OO.jsx)("div", {
                      className: "name",
                      children: r,
                    }),
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "score",
                children: [
                  (0, OO.jsx)("div", { className: "text", children: jO(s) }),
                  (0, OO.jsx)("div", {
                    className: "icon",
                    children: (0, OO.jsx)("img", { src: FE.coin }),
                  }),
                ],
              }),
            ],
          });
        },
        ux = () => {
          TO({
            id: "TeamPage",
            listener: CO.components.TeamPage.attachEventListener(),
          }),
            TO({
              id: "TeamPage",
              listener: CO.attachEventListener(PO.onMyTeamUpdate),
            });
          const { t: e } = Lk(),
            {
              data: t,
              visible: n,
              loading: r,
              fetch: s,
            } = CO.components.TeamPage,
            { playerTeam: i } = CO,
            o = !Boolean(i),
            a = t,
            c = i && i.id === (null === t || void 0 === t ? void 0 : t.id);
          return (0, OO.jsx)(JO, {
            id: "modal-team-page",
            visible: n,
            children: (0, OO.jsx)("div", {
              className: "team-page",
              children: (0, OO.jsxs)(OO.Fragment, {
                children: [
                  (0, OO.jsxs)("div", {
                    className: "modal-header teampage",
                    children: [
                      (0, OO.jsx)(YO, {
                        image:
                          (null === a || void 0 === a ? void 0 : a.photo) ||
                          FE.friends,
                        size: 100,
                        blur: 60,
                      }),
                      (0, OO.jsxs)("div", {
                        className: "modal-header-title",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "modal-header-title-name",
                            children:
                              null === a || void 0 === a ? void 0 : a.name,
                          }),
                          (0, OO.jsx)("div", {
                            className: "modal-header-title-share",
                            onClick: () => {
                              tx({
                                url:
                                  (null === a || void 0 === a
                                    ? void 0
                                    : a.inviteLink) || "",
                                data: {
                                  feature: "team",
                                  $subFeature: "team_share",
                                },
                              });
                            },
                            children: (0, OO.jsx)("img", { src: FE.share }),
                          }),
                        ],
                      }),
                      (0, OO.jsxs)("div", {
                        className: "modal-header-subtitle",
                        children: [
                          (0, OO.jsx)(NO, {
                            rank: null === a || void 0 === a ? void 0 : a.rank,
                          }),
                          (0, OO.jsx)("div", {
                            className: "modal-header-subtitle-rank",
                            children: "Rank #".concat(
                              null === a || void 0 === a ? void 0 : a.rank
                            ),
                          }),
                        ],
                      }),
                    ],
                  }),
                  (0, OO.jsxs)("div", {
                    className: "team-page-info",
                    children: [
                      (0, OO.jsxs)("div", {
                        className: "team-page-info-item",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "icon",
                            children: (0, OO.jsx)("img", { src: FE.coin }),
                          }),
                          (0, OO.jsxs)("div", {
                            className: "value",
                            children: [
                              DO(null === a || void 0 === a ? void 0 : a.score),
                              (0, OO.jsx)("div", {
                                className: "label",
                                children: e("team_total_earned"),
                              }),
                            ],
                          }),
                        ],
                      }),
                      (0, OO.jsx)("div", {
                        className: "team-page-info-separator",
                      }),
                      (0, OO.jsxs)("div", {
                        className: "team-page-info-item",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "icon",
                            children: (0, OO.jsx)("img", { src: FE.friends }),
                          }),
                          (0, OO.jsxs)("div", {
                            className: "value",
                            children: [
                              null === a || void 0 === a ? void 0 : a.members,
                              (0, OO.jsx)("div", {
                                className: "label",
                                children: e("team_members"),
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  i &&
                    (0, OO.jsx)("div", {
                      className: "tp-invite-info",
                      children: (0, OO.jsxs)("div", {
                        className: "tp-invite-text",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "title",
                            children: e("team_invite_title"),
                          }),
                          (0, OO.jsx)("img", { src: FE.coin }),
                          (0, OO.jsx)("div", {
                            className: "subtitle",
                            children: e("team_invite_subtitle", {
                              amount: DO(tw(CO.now(), "Bronze").regular),
                            }),
                          }),
                        ],
                      }),
                    }),
                  (0, OO.jsxs)("div", {
                    className: "footer-buttons vertical",
                    children: [
                      o &&
                        (0, OO.jsxs)(OO.Fragment, {
                          children: [
                            (0, OO.jsx)(nx, {
                              caption: e("team_invite_button"),
                              feature: "team",
                              subFeature: "team_invite",
                            }),
                            (0, OO.jsx)("div", {
                              className: "btn btn-inverse",
                              id: "tp-join",
                              onClick: async () => {
                                t &&
                                  (await CO.joinTeam(t.id), CO.closeAllPages());
                              },
                              children: e("team_join_button"),
                            }),
                          ],
                        }),
                      c &&
                        (0, OO.jsxs)(OO.Fragment, {
                          children: [
                            (0, OO.jsx)(nx, {
                              caption: e("team_invite_button"),
                              feature: "team",
                              subFeature: "team_invite",
                            }),
                            (0, OO.jsx)("div", {
                              className: "btn btn-inverse",
                              id: "tp-leave",
                              onClick: () => {
                                i && CO.leaveTeam();
                              },
                              children: e("team_leave_button"),
                            }),
                          ],
                        }),
                    ],
                  }),
                  (0, OO.jsx)("div", {
                    className: "team-list teampage",
                    children: (
                      (null === a || void 0 === a ? void 0 : a.players) || []
                    ).map((e, t) =>
                      (0, OO.jsx)(
                        lx,
                        {
                          rank: e.rank,
                          image: e.photo || "",
                          name: e.name,
                          score: e.score,
                          contribution: 0,
                        },
                        e.name + t
                      )
                    ),
                  }),
                ],
              }),
            }),
          });
        },
        dx = (e) => {
          let {
            booster: t,
            price: n,
            level: r,
            maxedOut: s,
            onClick: i,
            disabled: o,
          } = e;
          const { t: a } = Lk(),
            { name: c, image: l } = BE[t],
            u = t === E_.AutoTap;
          return (0, OO.jsxs)("div", {
            className: "booster-card ".concat(o && "disabled"),
            onClick: () => {
              o || i(t);
            },
            children: [
              (0, OO.jsxs)("div", {
                className: "booster-card-left",
                children: [
                  (0, OO.jsx)("img", {
                    className: "booster-card-icon",
                    src: l,
                  }),
                  (0, OO.jsxs)("div", {
                    className: "booster-card-info",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "booster-card-info-title",
                        children: a(c),
                      }),
                      (0, OO.jsxs)("div", {
                        className: "booster-card-info-points",
                        children: [
                          (0, OO.jsx)("img", {
                            className: "booster-card-info-points-icon",
                            src: FE.coin,
                          }),
                          u
                            ? (0, OO.jsx)("div", {
                                className: "booster-card-info-points-value",
                                children: DO(n),
                              })
                            : (0, OO.jsxs)("div", {
                                className: "booster-card-info-points-value-ctn",
                                children: [
                                  (0, OO.jsx)("div", {
                                    className: "booster-card-info-points-value",
                                    children: s
                                      ? a("booster_card_maxed_out")
                                      : DO(n),
                                  }),
                                  (0, OO.jsx)("li", {}),
                                  (0, OO.jsxs)("div", {
                                    className: "level",
                                    children: [a("booster_card_level"), " ", r],
                                  }),
                                ],
                              }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsx)("img", {
                className: "booster-card-arrow",
                src: FE.button_arrow_right,
              }),
            ],
          });
        },
        hx = (e) => {
          let {
            booster: t,
            listing: n,
            visible: r,
            onClose: s,
            onBuyBooster: i,
          } = e;
          const { t: o } = Lk(),
            { image: a, name: c, desc: l, effect: u } = BE[t];
          return (0, OO.jsxs)($O, {
            className: "booster-details",
            visible: r,
            onClose: s,
            children: [
              (0, OO.jsxs)("div", {
                className: "booster-details-layout",
                children: [
                  (0, OO.jsxs)("div", {
                    className: "booster-details-header",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "booster-details-icon",
                        children: (0, OO.jsx)("img", { src: a }),
                      }),
                      (0, OO.jsx)("div", {
                        className: "booster-details-title",
                        children: o(c),
                      }),
                      (0, OO.jsx)("div", {
                        className: "booster-details-subtitle",
                        children: o(l),
                      }),
                    ],
                  }),
                  (0, OO.jsxs)("div", {
                    className: "booster-details-body",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "booster-details-effect",
                        children: o(u),
                      }),
                      (0, OO.jsxs)("div", {
                        className: "booster-details-points",
                        children: [
                          (0, OO.jsx)("img", {
                            className: "booster-details-points-icon",
                            src: FE.coin,
                          }),
                          (0, OO.jsx)("div", {
                            className: "booster-details-points-value",
                            children: 0 === n.price ? "Free" : DO(n.price),
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsx)("div", {
                className: "footer-buttons",
                children: (0, OO.jsx)("div", {
                  className: "btn btn-normal",
                  onClick: () => {
                    s(),
                      t !== A_.AutoBotReward &&
                        t !== A_.AutoBotFirstSession &&
                        (console.warn(">>> buying booster", t),
                        Object.values(E_).includes(t)
                          ? i && i(t)
                          : CO.buyBuff(t));
                  },
                  children: o("get_button"),
                }),
              }),
            ],
          });
        };
      let px = 0;
      const fx = () => {
          TO({
            id: "shop",
            listener: CO.components.Shop.attachEventListener(),
          });
          const { t: e } = Lk(),
            { data: t, loading: n, visible: r, fetch: s } = CO.components.Shop,
            { playerBalance: i } = CO,
            [a, c] = (0, o.useState)(i);
          (0, o.useEffect)(() => {
            c(i);
          }, [i]),
            (0, o.useEffect)(() => {
              r && s();
            }, [r]);
          const l = (0, o.useMemo)(
              () =>
                t
                  ? Object.keys(t.boosters).map((e) => ({
                      booster: e,
                      ...t.boosters[e],
                    }))
                  : [],
              [t]
            ),
            [u, d] = (0, o.useState)(!1),
            [h, p] = (0, o.useState)(null),
            f = (e) => {
              t && (p({ booster: e, listing: t.boosters[e] }), d(!0));
            },
            m = (e) => () => {
              p({ booster: e, listing: { price: 0, level: 0, maxedOut: !1 } }),
                d(!0);
            },
            g = {
              available:
                (null === t || void 0 === t
                  ? void 0
                  : t.buffs[A_.Rocketman].available) || 0,
              max:
                (null === t || void 0 === t
                  ? void 0
                  : t.buffs[A_.Rocketman].maxUses) || 3,
            },
            v =
              (null === t || void 0 === t
                ? void 0
                : t.buffs[A_.FullEnergy].timeLeft) || 1,
            y = Math.ceil(v / 1e3 / 60 / 60),
            b =
              (null === t || void 0 === t
                ? void 0
                : t.buffs[A_.Rocketman].timeLeft) || 1,
            w = Math.ceil(b / 1e3 / 60 / 60),
            S = a < 1e9 ? DO(a) : jO(a);
          return (0, OO.jsxs)(JO, {
            id: "modal-shop",
            visible: r,
            children: [
              (0, OO.jsx)("div", {
                className: "shop-header",
                children: (0, OO.jsxs)("div", {
                  className: "points-shop",
                  children: [
                    (0, OO.jsx)("img", {
                      className: "points-shop-icon",
                      src: FE.coin,
                    }),
                    (0, OO.jsx)("div", {
                      className: "points-shop-label",
                      children: S,
                    }),
                  ],
                }),
              }),
              (0, OO.jsxs)("div", {
                className: "shop-daily-boosts-container",
                children: [
                  (0, OO.jsx)("div", {
                    className: "shop-subtitle",
                    children: e("shop_free_daily_boosts"),
                  }),
                  (0, OO.jsx)("div", {
                    className: "shop-daily-boosts",
                    children: (0, OO.jsxs)("div", {
                      className: "daily-items",
                      children: [
                        (0, OO.jsxs)("div", {
                          className: "daily-item ".concat(
                            g.available <= 0 && "disabled"
                          ),
                          onClick: m(A_.Rocketman),
                          children: [
                            (0, OO.jsx)("img", {
                              className: "daily-icon",
                              src: FE.boosters.Rocketman,
                            }),
                            (0, OO.jsxs)("div", {
                              className: "daily-info",
                              children: [
                                (0, OO.jsx)("div", {
                                  className: "daily-info-title",
                                  children: e("shop_rocket"),
                                }),
                                (0, OO.jsxs)("div", {
                                  className: "daily-info-subtitle",
                                  children: [
                                    g.available,
                                    "/",
                                    g.max,
                                    w > 0
                                      ? " in "
                                          .concat(w, " ")
                                          .concat(RO(w, e("hour"), e("hours")))
                                      : "",
                                  ],
                                }),
                              ],
                            }),
                          ],
                        }),
                        (0, OO.jsxs)("div", {
                          className: "daily-item ".concat(v > 0 && "disabled"),
                          onClick: m(A_.FullEnergy),
                          children: [
                            (0, OO.jsx)("img", {
                              className: "daily-icon",
                              src: FE.boosters.FullEnergy,
                            }),
                            (0, OO.jsxs)("div", {
                              className: "daily-info",
                              children: [
                                (0, OO.jsx)("div", {
                                  className: "daily-info-title",
                                  children: e("shop_full_energy"),
                                }),
                                (0, OO.jsx)("div", {
                                  className: "daily-info-subtitle",
                                  children:
                                    y > 0
                                      ? "in "
                                          .concat(y, " ")
                                          .concat(RO(y, e("hour"), e("hours")))
                                      : e("shop_available"),
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "shop-list-container",
                children: [
                  (0, OO.jsx)("div", {
                    className: "shop-subtitle",
                    children: e("shop_boosters"),
                  }),
                  (0, OO.jsx)("div", {
                    className: "shop-list",
                    children: l.map((e, t) =>
                      (0, OO.jsx)(
                        dx,
                        {
                          onClick: f,
                          disabled: e.price > i || e.maxedOut,
                          ...e,
                        },
                        e.booster + t
                      )
                    ),
                  }),
                ],
              }),
              h &&
                (0, OO.jsx)(hx, {
                  ...h,
                  visible: u,
                  onClose: () => {
                    d(!1);
                  },
                  onBuyBooster: async (e) => {
                    const t = await CO.buyBooster(e),
                      n = (a - t) / 20;
                    px = a;
                    const r = setInterval(() => {
                      px <= t
                        ? (clearInterval(r), c(t), s(), (px = 0))
                        : ((px -= n), c(px));
                    }, 50);
                  },
                }),
            ],
          });
        },
        mx = () => {
          TO({
            id: "TeamPage",
            listener: CO.components.Toast.attachEventListener(),
          });
          const { t: e } = Lk(),
            { visible: t, data: n } = CO.components.Toast,
            [r, s] = (0, o.useState)(!1),
            [i, a] = (0, o.useState)(!1);
          return (
            (0, o.useEffect)(() => {
              t && a(!0);
            }, [t]),
            (0, o.useEffect)(() => {
              t &&
                (s(!0),
                setTimeout(() => {
                  s(!1), CO.components.Toast.hide();
                }, 2e3));
            }, [t]),
            (0, OO.jsxs)("div", {
              className: "toast-ctn slide-"
                .concat(r ? "up" : "down", " ")
                .concat(!i && "hide"),
              children: [
                (0, OO.jsx)("b", { children: n }),
                " ",
                e("toast_purchased_successfully"),
              ],
            })
          );
        },
        gx = () => {
          TO({
            id: "DrawerOutOfEnergy",
            listener: CO.components.OutOfEnergy.attachEventListener(),
          }),
            TO({
              id: "DrawerOutOfEnergy:adEnergyReward",
              listener: CO.attachEventListener(PO.onAdEnergyRewardChange),
            });
          const { t: e } = Lk(),
            { visible: t } = CO.components.OutOfEnergy,
            { adEnergyRewardAvailable: n } = CO,
            r = () => {
              CO.components.OutOfEnergy.hide();
            };
          return (0, OO.jsxs)($O, {
            className: "drawer-outofenergy",
            visible: t,
            onClose: r,
            children: [
              (0, OO.jsxs)("div", {
                className: "drawer-outofenergy-header",
                children: [
                  (0, OO.jsx)("div", {
                    className: "drawer-outofenergy-icon",
                    children: (0, OO.jsx)("img", {
                      src: FE.astronaut_outofenergy,
                    }),
                  }),
                  (0, OO.jsx)("div", {
                    className: "drawer-outofenergy-title",
                    children: e("drawer_out_energy_title"),
                  }),
                  (0, OO.jsx)("div", {
                    className: "drawer-outofenergy-subtitle",
                    children: e("drawer_out_energy_subtitle"),
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "footer-buttons",
                children: [
                  (0, OO.jsx)("div", {
                    className: "btn btn-inverse",
                    onClick: () => {
                      CO.components.Shop.show();
                    },
                    children: e("drawer_out_energy_visit_store"),
                  }),
                  (0, OO.jsx)("div", {
                    className: "btn btn-normal ".concat(n ? "" : "disabled"),
                    onClick: () => {
                      n && (r(), CO.showAd());
                    },
                    children: e("drawer_out_energy_watch_ad"),
                  }),
                ],
              }),
            ],
          });
        };
      var vx = n(82);
      function yx(e) {
        let { expiryTimestamp: t, onExpire: n } = e;
        const { seconds: r, minutes: s } = (0, vx.useTimer)({
          expiryTimestamp: t,
          onExpire: n,
        });
        function i(e) {
          return e < 10 ? "0".concat(e) : e;
        }
        return (0, OO.jsxs)(OO.Fragment, {
          children: [
            (0, OO.jsx)("span", { children: i(s) }),
            ":",
            (0, OO.jsx)("span", { children: i(r) }),
          ],
        });
      }
      const bx = (e) => {
          let {
            id: t,
            image: n,
            title: r,
            score: s,
            disabled: i,
            onClick: a,
            claimed: c,
            timer: l,
          } = e;
          const [u, d] = (0, o.useState)(!!l),
            [h, p] = (0, o.useState)();
          return (
            (0, o.useEffect)(() => {
              if (l) {
                const e = new Date();
                e.setMilliseconds(e.getMilliseconds() + l), p(e), d(!0);
              }
            }, [l]),
            (0, OO.jsxs)("div", {
              className: "earn-card ".concat(i && "disabled"),
              onClick: () => {
                i || a(t);
              },
              children: [
                (0, OO.jsx)("img", { className: "earn-card-icon", src: n }),
                (0, OO.jsxs)("div", {
                  className: "earn-card-info",
                  children: [
                    (0, OO.jsx)("div", {
                      className: "earn-card-info-title",
                      children: r,
                    }),
                    !u &&
                      (0, OO.jsxs)("div", {
                        className: "earn-card-info-points",
                        children: [
                          (0, OO.jsx)("img", {
                            className: "earn-card-info-points-icon",
                            src: FE.coin,
                          }),
                          (0, OO.jsx)("div", {
                            className: "earn-card-info-points-value",
                            children: s,
                          }),
                        ],
                      }),
                    u &&
                      h &&
                      (0, OO.jsx)("div", {
                        className: "earn-card-info-points",
                        children: (0, OO.jsxs)("div", {
                          className: "earn-card-info-points-value",
                          children: [
                            "Checking ",
                            (0, OO.jsx)(yx, {
                              expiryTimestamp: h,
                              onExpire: () => d(!1),
                            }),
                          ],
                        }),
                      }),
                  ],
                }),
                c
                  ? (0, OO.jsx)("img", {
                      className: "earn-card-arrow",
                      src: FE.earn_check,
                    })
                  : (0, OO.jsx)("img", {
                      className: "earn-card-arrow",
                      src: FE.button_arrow_right,
                    }),
              ],
            })
          );
        },
        wx = {
          "5_friends": {
            title: "earn_invite_5",
            subtitle: DO(15e4),
            earningKey: { earningKey: "inviteFriends5" },
            quest_name: "5_friends",
            onPostErrorClick: () =>
              tx({
                data: { feature: "invite_5_friends", $subFeature: "earn_page" },
              }),
          },
          "10_friends": {
            title: "earn_invite_10",
            subtitle: DO(3e5),
            earningKey: { earningKey: "inviteFriends10" },
            quest_name: "10_friends",
            onPostErrorClick: () =>
              tx({
                data: {
                  feature: "invite_10_friends",
                  $subFeature: "earn_page",
                },
              }),
          },
          "100_friends": {
            title: "earn_invite_100",
            subtitle: DO(3e6),
            earningKey: { earningKey: "inviteFriends100" },
            quest_name: "100_friends",
            onPostErrorClick: () =>
              tx({
                data: {
                  feature: "invite_100_friends",
                  $subFeature: "earn_page",
                },
              }),
          },
          default: {
            title: "",
            subtitle: "",
            earningKey: { earningKey: "inviteFriends5" },
            quest_name: "",
            onPostErrorClick: void 0,
          },
        },
        Sx = (e) => {
          let { onClose: t, id: n = "default" } = e;
          const { t: r } = Lk(),
            { invoke: s, track: i } = CO,
            {
              title: a,
              subtitle: c,
              earningKey: l,
              quest_name: u,
              onPostErrorClick: d,
            } = wx[n],
            [h, p] = (0, o.useState)(!1),
            [f, m] = (0, o.useState)(""),
            g = () => {
              m(""), p(!1), t();
            };
          return (0, OO.jsxs)($O, {
            className: "drawer-earncheck",
            visible: "default" !== n,
            onClose: g,
            children: [
              (0, OO.jsxs)("div", {
                className: "drawer-earncheck-header",
                children: [
                  (0, OO.jsx)("div", {
                    className: "drawer-earncheck-icon",
                    children: (0, OO.jsx)("img", { src: FE.friends }),
                  }),
                  (0, OO.jsx)("div", {
                    className: "drawer-earncheck-title",
                    children: r(a),
                  }),
                  (0, OO.jsxs)("div", {
                    className: "score",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "icon",
                        children: (0, OO.jsx)("img", { src: FE.coin }),
                      }),
                      (0, OO.jsx)("div", { className: "text", children: c }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsx)("div", {
                className: "footer-buttons",
                children: (0, OO.jsx)("div", {
                  className: "btn btn-normal",
                  onClick: async () => {
                    h ||
                      (f
                        ? null === d || void 0 === d || d()
                        : (p(!0),
                          s
                            .claimEarning(l)
                            .then(() => {
                              i("quest_complete", { quest_name: u }),
                                setTimeout(g, 500);
                            })
                            .catch((e) => {
                              m(e.message);
                            })
                            .finally(() => {
                              p(!1);
                            })));
                  },
                  children: h ? "..." : f || "Check",
                }),
              }),
            ],
          });
        },
        _x = () => {
          TO({ id: "app", listener: CO.components.Earn.attachEventListener() });
          const { t: e } = Lk(),
            { state: t, invoke: n, track: r } = CO,
            { visible: s, fetch: i, rerender: a } = CO.components.Earn,
            [c, l] = (0, o.useState)(!1);
          (0, o.useEffect)(() => {
            var e, t;
            "with-buttons" ===
              (null === (e = CO.replicant) ||
              void 0 === e ||
              null === (t = e.state.ruleset.abTests[zy]) ||
              void 0 === t
                ? void 0
                : t.bucketId) && l(!0);
          }, [CO.state.isReady]);
          const [u, d] = (0, o.useState)(0),
            [h, p] = (0, o.useState)(t.earnings.followOnYoutube);
          (0, o.useEffect)(() => {
            if (t.followOnYoutubeTimestamp) {
              const e = CO.now() - t.followOnYoutubeTimestamp;
              t.followOnYoutubeTimestamp && e < vb ? (d(vb - e), p(!1)) : p(!0);
            } else p(!1);
          }, [t.followOnYoutubeTimestamp]);
          const [f, m] = (0, o.useState)(),
            g = rw(t),
            v = g ? DO(g) : e("come_back_tomorrow");
          (0, o.useEffect)(() => {
            s && i();
          }, [s]);
          const y = (e) => {
              var t, s;
              switch (e) {
                case w_.InviteBonus:
                  CO.components.Friends.show(), CO.onBackNavigateTo("Earn");
                  break;
                case w_.FollowX:
                  null ===
                    (t = window.open("https://x.com/gemzfun", "_blank")) ||
                    void 0 === t ||
                    t.focus(),
                    n.claimEarning({ earningKey: "followOnX" }).then(() => {
                      r("quest_complete", { quest_name: "follow_x" }), a();
                    });
                  break;
                case w_.JoinCommunity:
                  Telegram.WebApp.openTelegramLink("https://t.me/gemzfun"),
                    n.claimEarning({ earningKey: "joinCommunity" }).then(() => {
                      r("quest_complete", { quest_name: "join_community" }),
                        a();
                    });
                  break;
                case w_.Invite5:
                  m("5_friends");
                  break;
                case w_.Invite10:
                  m("10_friends");
                  break;
                case w_.Invite100:
                  m("100_friends");
                  break;
                case w_.DailyReward:
                  CO.components.ModalComponent.setData({
                    queue: [
                      {
                        id: "dailyRewardDrawer",
                        condition: () => !0,
                        onClose: () => {
                          a();
                        },
                      },
                    ],
                  }),
                    CO.components.ModalComponent.show(!1);
                  break;
                case w_.JoinYoutube:
                  null ===
                    (s = window.open(
                      "https://www.youtube.com/@gemzfun",
                      "_blank"
                    )) ||
                    void 0 === s ||
                    s.focus(),
                    n.claimYoutubeReward().then(() => {
                      r("quest_complete", { quest_name: "follow_youtube" }),
                        a();
                    });
                  break;
                case w_.JoinAnnouncement:
                  Telegram.WebApp.openTelegramLink(
                    "https://t.me/gemz_announcements"
                  ),
                    n
                      .claimEarning({ earningKey: "joinAnnouncement" })
                      .then(() => {
                        r("quest_complete", {
                          quest_name: "join_announcement",
                        }),
                          a();
                      });
                  break;
                default:
                  console.warn(">>> This should never happen.");
              }
            },
            b = tw(CO.now(), "Bronze");
          return (0, OO.jsxs)(JO, {
            id: "earn",
            visible: s,
            children: [
              (0, OO.jsxs)("div", {
                className: "modal-header earn",
                children: [
                  (0, OO.jsx)(YO, {
                    image: FE.earn_astronaut,
                    blur: 70,
                    intensity: 1,
                  }),
                  (0, OO.jsx)("div", {
                    className: "modal-header-title",
                    children: e("earn"),
                  }),
                ],
              }),
              (0, OO.jsx)(bx, {
                image: FE.earn_inviteBonus,
                id: w_.InviteBonus,
                title: e("earn_invite_bonus"),
                score: e("earn_invite_bonus_amount", { amount: DO(b.premium) }),
                disabled: !1,
                onClick: y,
                claimed: !1,
              }),
              (0, OO.jsx)("div", {
                className: "earn-section-title",
                children: "Daily tasks",
              }),
              (0, OO.jsx)(bx, {
                image: FE.earn_daily_reward,
                id: w_.DailyReward,
                title: "Daily Reward",
                score: "".concat(v),
                disabled: !1,
                onClick: y,
                claimed: !1,
              }),
              (0, OO.jsx)("div", {
                className: "earn-section-title",
                children: e("earn_specials"),
              }),
              (0, OO.jsx)(bx, {
                image: FE.earn_x,
                id: w_.FollowX,
                title: e("earn_follow_x"),
                score: DO(1e4),
                disabled: t.earnings.followOnX,
                onClick: y,
                claimed: t.earnings.followOnX,
              }),
              (0, OO.jsx)(bx, {
                image: FE.earn_community,
                id: w_.JoinCommunity,
                title: e("earn_join_community"),
                score: DO(2e4),
                disabled: t.earnings.joinCommunity,
                onClick: y,
                claimed: t.earnings.joinCommunity,
              }),
              c &&
                (0, OO.jsxs)(OO.Fragment, {
                  children: [
                    (0, OO.jsx)(bx, {
                      image: FE.earn_player,
                      id: w_.JoinYoutube,
                      title: "Follow us on Youtube",
                      score: DO(5e4),
                      disabled: h || (!!u && !h),
                      onClick: y,
                      timer: u,
                      claimed: h,
                    }),
                    (0, OO.jsx)(bx, {
                      image: FE.earn_announcement,
                      id: w_.JoinAnnouncement,
                      title: "Join announcements channel",
                      score: DO(2e4),
                      disabled: t.earnings.joinAnnouncement,
                      onClick: y,
                      claimed: t.earnings.joinAnnouncement,
                    }),
                  ],
                }),
              (0, OO.jsx)("div", {
                className: "earn-section-title",
                children: e("Bonuses"),
              }),
              (0, OO.jsx)(bx, {
                image: FE.earn_invite5,
                id: w_.Invite5,
                title: e("earn_invite_5"),
                score: DO(15e4),
                disabled: !1,
                onClick: y,
                claimed: t.earnings.inviteFriends5,
              }),
              (0, OO.jsx)(bx, {
                image: FE.earn_invite10,
                id: w_.Invite10,
                title: e("earn_invite_10"),
                score: DO(3e5),
                disabled: !1,
                onClick: y,
                claimed: t.earnings.inviteFriends10,
              }),
              (0, OO.jsx)(bx, {
                image: FE.earn_invite100,
                id: w_.Invite100,
                title: e("earn_invite_100"),
                score: DO(3e6),
                disabled: !1,
                onClick: y,
                claimed: t.earnings.inviteFriends100,
              }),
              (0, OO.jsx)(Sx, {
                id: f,
                onClose: () => {
                  m(void 0), a();
                },
              }),
            ],
          });
        },
        Ex = (e) => {
          const { t: t } = Lk(),
            [n, r] = (0, o.useState)(!1);
          return (
            (0, o.useEffect)(() => {
              const t = document.querySelector(".loading-screen");
              null === t ||
                void 0 === t ||
                t.addEventListener("transitionend", () => {
                  e.visible || r(!0);
                });
            }, [e.visible]),
            n
              ? null
              : (0, OO.jsxs)("div", {
                  className: "loading-screen ".concat(
                    e.visible ? "fadein" : "fadeout"
                  ),
                  children: [
                    (0, OO.jsxs)("div", {
                      className: "lds-ripple",
                      children: [
                        (0, OO.jsx)("div", {}),
                        (0, OO.jsx)("div", {}),
                      ],
                    }),
                    (0, OO.jsx)("p", {
                      className: "loading-label",
                      children: t("loading"),
                    }),
                  ],
                })
          );
        },
        Ax = (e) => {
          let { rank: t, image: n, name: r, score: s } = e;
          return (0, OO.jsxs)("div", {
            className: "card team-member",
            children: [
              (0, OO.jsxs)("div", {
                className: "card-left",
                children: [
                  (0, OO.jsx)(NO, { rank: t }),
                  (0, OO.jsx)("div", {
                    className: "image",
                    children: (0, OO.jsx)("img", { src: n || FE.friends }),
                  }),
                  (0, OO.jsx)("div", {
                    className: "info",
                    children: (0, OO.jsx)("div", {
                      className: "name",
                      children: r,
                    }),
                  }),
                ],
              }),
              (0, OO.jsxs)("div", {
                className: "score",
                children: [
                  (0, OO.jsx)("div", { className: "text", children: jO(s) }),
                  (0, OO.jsx)("div", {
                    className: "icon",
                    children: (0, OO.jsx)("img", { src: FE.coin }),
                  }),
                ],
              }),
            ],
          });
        },
        Tx = function (e, t, n) {
          let r,
            s = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
            i = "From ".concat(DO(t));
          return (
            e >= t &&
              e < n &&
              ((i = "".concat(DO(e), " / ").concat(s ? "\u221e" : DO(n))),
              s || (r = (100 * e) / n)),
            { text: i, progressBar: r }
          );
        },
        Px = {
          [S_.Bronze]: {
            left: void 0,
            right: S_.Silver,
            progress: (e) => Tx(e, 0, 2e4),
          },
          [S_.Silver]: {
            left: S_.Bronze,
            right: S_.Gold,
            progress: (e) => Tx(e, 2e4, 2e5),
          },
          [S_.Gold]: {
            left: S_.Silver,
            right: S_.Platinum,
            progress: (e) => Tx(e, 2e5, 2e6),
          },
          [S_.Platinum]: {
            left: S_.Gold,
            right: S_.Diamond,
            progress: (e) => Tx(e, 2e6, 1e7),
          },
          [S_.Diamond]: {
            left: S_.Platinum,
            right: void 0,
            progress: (e) => Tx(e, 1e7, 1 / 0, !0),
          },
        },
        Ix = () => {
          TO({
            id: "LeaderboardPage",
            listener: CO.components.LeaguePage.attachEventListener(),
          });
          const { t: e } = Lk(),
            {
              data: t,
              loading: n,
              visible: r,
              fetch: s,
            } = CO.components.LeaguePage,
            [i, a] = (0, o.useState)(S_.Bronze),
            c = Px[i],
            l = c.progress(CO.state.taps);
          return (0, OO.jsxs)(JO, {
            id: "modal-league",
            visible: r,
            children: [
              (0, OO.jsxs)("div", {
                className: "modal-header leaguepage",
                children: [
                  (0, OO.jsxs)("div", {
                    className: "header-nav",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "btn-left",
                        onClick: () => {
                          const { left: e } = c;
                          e && (s(e), a(e));
                        },
                        children:
                          c.left &&
                          (0, OO.jsx)("img", { src: FE.button_arrow_right }),
                      }),
                      (0, OO.jsxs)("div", {
                        className: "glowing-gem",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "gem-dust",
                            children: (0, OO.jsx)("img", { src: FE.gem_dust }),
                          }),
                          (0, OO.jsx)(YO, {
                            image: FE.league[i],
                            blur: 80,
                            intensity: 2,
                            size: 150,
                          }),
                        ],
                      }),
                      (0, OO.jsx)("div", {
                        className: "btn-right",
                        onClick: () => {
                          const { right: e } = c;
                          e && (s(e), a(e));
                        },
                        children:
                          c.right &&
                          (0, OO.jsx)("img", { src: FE.button_arrow_right }),
                      }),
                    ],
                  }),
                  (0, OO.jsx)("div", {
                    className: "modal-header-title",
                    children: (0, OO.jsxs)("div", {
                      className: "modal-header-title-name",
                      children: [i, " ", e("league_title")],
                    }),
                  }),
                  (0, OO.jsxs)("div", {
                    className: "modal-header-subtitle",
                    children: [
                      (0, OO.jsxs)("div", {
                        className: "progress-label",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "progress-label-icon",
                            children: (0, OO.jsx)("img", { src: FE.finger_up }),
                          }),
                          (0, OO.jsx)("div", {
                            className: "progress-label-text",
                            children: "".concat(l.text),
                          }),
                        ],
                      }),
                      l.progressBar &&
                        (0, OO.jsxs)("div", {
                          className: "progress-bar",
                          children: [
                            (0, OO.jsx)("div", {
                              className: "progress-bar-bg",
                            }),
                            (0, OO.jsx)("div", {
                              className: "progress-bar-value",
                              style: { width: "".concat(l.progressBar, "%") },
                            }),
                          ],
                        }),
                    ],
                  }),
                ],
              }),
              (0, OO.jsx)("hr", {}),
              n
                ? (0, OO.jsx)("p", {
                    className: "loading-label",
                    children: e("loading"),
                  })
                : (0, OO.jsx)("div", {
                    className: "team-list leaguepage",
                    children: (t || []).map((e, t) =>
                      (0, OO.jsx)(
                        Ax,
                        {
                          rank: e.rank,
                          image: e.picture,
                          name: e.username,
                          score: e.score,
                        },
                        t
                      )
                    ),
                  }),
            ],
          });
        };
      var Cx = n(151),
        kx = n.n(Cx);
      const Ox = (e) => {
          var t, n;
          const r = e.show,
            [s, i] = (0, o.useState)({ from: 0.5, to: 0.5 });
          return (
            (0, o.useEffect)(() => {
              const { from: t, to: n } = e.gravity || { from: 0.05, to: 0.5 };
              i({ from: t, to: n });
            }, [e.gravity]),
            (0, OO.jsx)("div", {
              className: "confetti-effect",
              children: (0, OO.jsx)(kx(), {
                run: !0,
                width:
                  null === (t = visualViewport) || void 0 === t
                    ? void 0
                    : t.width,
                height:
                  null === (n = visualViewport) || void 0 === n
                    ? void 0
                    : n.height,
                gravity: r ? s.from : s.to,
                friction: r ? 0.99 : 1,
                numberOfPieces: r ? 80 : 0,
              }),
            })
          );
        },
        xx = (e) => {
          let { isVisible: t, onClose: n } = e;
          const { state: r, invoke: s, track: i } = CO,
            [a, c] = (0, o.useState)(!r.unclaimed_rewards),
            [l, u] = (0, o.useState)(!1),
            [d, h] = (0, o.useState)(nw(r)),
            { t: p } = Lk();
          (0, o.useEffect)(() => {
            h(nw(r));
          }, [r.streak_days, r.unclaimed_rewards]);
          const f = (e) => {
            let t = !1;
            return (
              -1 !== d && e > d && e <= r.streak_days && (t = !0),
              t ? "unclaimed" : e > r.streak_days ? "inactive" : ""
            );
          };
          return (0, OO.jsxs)(OO.Fragment, {
            children: [
              (0, OO.jsxs)($O, {
                className: "drawer-dailyreward",
                visible: t,
                onClose: n,
                children: [
                  (0, OO.jsxs)("div", {
                    className: "drawer-dailyreward-header",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "drawer-dailyreward-icon",
                        children: (0, OO.jsx)("img", {
                          src: FE.earn_daily_reward,
                        }),
                      }),
                      (0, OO.jsx)("div", {
                        className: "drawer-dailyreward-title",
                        children: p("daily_rewards"),
                      }),
                      (0, OO.jsx)("div", {
                        className: "drawer-dailyreward-subtitle",
                        children: p("daily_reward_copy"),
                      }),
                    ],
                  }),
                  (0, OO.jsx)("div", {
                    className: "rewards",
                    children: xb.map((e, t) =>
                      0 === t
                        ? null
                        : (0, OO.jsxs)(
                            "div",
                            {
                              className: "reward-item ".concat(f(t)),
                              children: [
                                (0, OO.jsxs)("div", {
                                  className: "reward-days-counter",
                                  children: [p("day"), " ", t],
                                }),
                                (0, OO.jsx)("div", { className: "coin-bg" }),
                                (0, OO.jsx)("img", {
                                  className: "coin",
                                  src: FE.coin,
                                }),
                                (0, OO.jsx)("div", {
                                  className: "reward-amount",
                                  children: jO(e),
                                }),
                              ],
                            },
                            t
                          )
                    ),
                  }),
                  (0, OO.jsx)("div", {
                    className: "footer-buttons",
                    children: (0, OO.jsx)("div", {
                      className: "btn btn-normal ".concat(
                        !a && r.unclaimed_rewards
                          ? "btn-unclaimed"
                          : r.unclaimed_rewards
                          ? ""
                          : "btn-disabled"
                      ),
                      onClick: async () => {
                        a ||
                          (u(!0),
                          c(!0),
                          await CO.invoke.claimDailyReward().then(() => {
                            c(!1),
                              setTimeout(() => u(!1), 3e3),
                              r.unclaimed_rewards <= 1 &&
                                (c(!0), setTimeout(() => n(), 3e3));
                          }));
                      },
                      children: r.unclaimed_rewards
                        ? p("claim")
                        : p("come_back_tomorrow"),
                    }),
                  }),
                ],
              }),
              (0, OO.jsx)(Ox, { show: l, gravity: { from: 0.3, to: 0.5 } }),
            ],
          });
        },
        Nx = (e) => {
          let { visible: t, onClose: n } = e;
          const { t: r } = Lk();
          return (
            (0, o.useEffect)(() => {
              var e;
              t &&
                (null === (e = CO.replicant) ||
                  void 0 === e ||
                  e.invoke.updateInviteFriendNudge());
            }, [t]),
            (0, OO.jsxs)($O, {
              className: "modal-drawer drawer-details",
              visible: t,
              onClose: n,
              children: [
                (0, OO.jsx)("div", {
                  className: "drawer-layout",
                  children: (0, OO.jsxs)("div", {
                    className: "drawer-header",
                    children: [
                      (0, OO.jsx)("div", {
                        className: "drawer-header-icon",
                        children: (0, OO.jsx)("img", {
                          src: FE.earn_inviteBonus,
                        }),
                      }),
                      (0, OO.jsx)("div", {
                        className: "drawer-header-title",
                        children: r("drawer_invite_friend_title"),
                      }),
                      (0, OO.jsxs)("div", {
                        className: "drawer-header-subtitle",
                        children: [
                          (0, OO.jsx)("div", {
                            className: "text",
                            children: r("drawer_invite_friend_subtitle_1"),
                          }),
                          (0, OO.jsxs)("div", {
                            className: "score",
                            children: [
                              (0, OO.jsx)("div", {
                                className: "icon",
                                children: (0, OO.jsx)("img", { src: FE.coin }),
                              }),
                              (0, OO.jsx)("div", {
                                className: "text",
                                children: "50,000",
                              }),
                            ],
                          }),
                          (0, OO.jsx)("div", {
                            className: "text",
                            children: r("drawer_invite_friend_subtitle_2"),
                          }),
                        ],
                      }),
                    ],
                  }),
                }),
                (0, OO.jsx)("div", {
                  className: "footer-buttons",
                  children: (0, OO.jsx)("div", {
                    className: "btn btn-normal",
                    onClick: () => {
                      CO.track("PressInvite", { page: "drawer_invite_friend" }),
                        tx({
                          data: {
                            feature: "friend",
                            $subFeature: "drawer_invite_friend",
                          },
                        });
                    },
                    children: r("drawer_invite_friend_button"),
                  }),
                }),
              ],
            })
          );
        },
        Rx = () => {
          TO({
            id: "ModalComponent",
            listener: CO.components.ModalComponent.attachEventListener(),
          });
          const { t: e } = Lk(),
            { visible: t, data: n } = CO.components.ModalComponent,
            [r, s] = (0, o.useState)([]),
            [i, a] = (0, o.useState)(void 0);
          function c(e) {
            for (; e.length > 0; ) {
              const t = e.shift();
              if (null !== t && void 0 !== t && t.condition())
                return a(t), void s(e);
            }
            a(void 0);
          }
          if (
            ((0, o.useEffect)(() => {
              if (null !== n && void 0 !== n && n.queue) {
                const e = [...n.queue];
                s(e), c(e);
              }
            }, [n]),
            !t || !i)
          )
            return null;
          function l(e) {
            return (
              (null === i || void 0 === i ? void 0 : i.id) === e &&
              i.condition()
            );
          }
          function u() {
            null !== i && void 0 !== i && i.onClose && i.onClose(), c([...r]);
          }
          return (0, OO.jsxs)("div", {
            className: "modal-component",
            children: [
              (0, OO.jsx)(hx, {
                booster: A_.AutoBotFirstSession,
                visible: l("welcomeDrawer"),
                onClose: u,
                listing: { price: 500, level: 1, maxedOut: !1 },
              }),
              (0, OO.jsx)(hx, {
                booster: A_.AutoBotReward,
                visible: l("autobotDrawer"),
                onClose: u,
                listing: { price: CO.botEarnings || 0, level: 1, maxedOut: !1 },
              }),
              (0, OO.jsx)(xx, {
                isVisible: l("dailyRewardDrawer"),
                onClose: u,
              }),
              (0, OO.jsx)(Nx, { visible: l("inviteDrawer"), onClose: u }),
            ],
          });
        };
      function Dx(e) {
        let { error: t, resetErrorBoundary: n } = e;
        return (
          (0, o.useEffect)(() => {
            console.error("React app crash:", t);
          }, [t]),
          (0, OO.jsxs)("div", {
            className: "error-fallback",
            role: "alert",
            children: [
              (0, OO.jsx)("p", {
                children: "Something went wrong. Please try refreshing.",
              }),
              (null === t || void 0 === t ? void 0 : t.friendlyMessage) &&
                (0, OO.jsxs)("pre", {
                  children: ["Error: ", t.friendlyMessage],
                }),
            ],
          })
        );
      }
      const Mx = BO() ? 100 : 1;
      (document.body.style.overflowY = "hidden"),
        (document.body.style.marginTop = "".concat(Mx, "px")),
        (document.body.style.height = window.innerHeight + Mx + "px"),
        (document.body.style.paddingBottom = "".concat(Mx, "px")),
        window.scrollTo(0, Mx),
        window.addEventListener("touchmove", (e) => e.preventDefault(), {
          passive: !0,
        }),
        document.documentElement.addEventListener("touchmove", () => !0, {
          passive: !1,
        });
      const jx = !1;
      function Lx(e, t) {
        fr.pushError("ReactRenderError", e, {
          componentStack:
            null === t || void 0 === t ? void 0 : t.componentStack,
          digest: null === t || void 0 === t ? void 0 : t.digest,
        }),
          EC("ReactRenderError", e, {
            extra: {
              componentStack:
                null === t || void 0 === t ? void 0 : t.componentStack,
              digest: null === t || void 0 === t ? void 0 : t.digest,
            },
          });
      }
      const Ux = function () {
          TO({ id: "App", listener: CO.attachEventListener(PO.onAppReady) }),
            (0, o.useEffect)(() => {
              jx;
            }, []);
          const e = {
              id: "inviteDrawer",
              condition: () => CO.inviteDrawerDuration > 0,
            },
            t = {
              id: "dailyRewardDrawer",
              condition: () => CO.state.unclaimed_rewards > 0,
            },
            n = { id: "welcomeDrawer", condition: () => CO.isFirstSession },
            r = { id: "autobotDrawer", condition: () => !!CO.botEarnings };
          return (
            (0, o.useEffect)(() => {
              var s, i;
              const o =
                  null === (s = CO.replicant) ||
                  void 0 === s ||
                  null === (i = s.state.ruleset.abTests[Wy]) ||
                  void 0 === i
                    ? void 0
                    : i.bucketId,
                a = [n, r];
              let c = [...a, e];
              "PreInvite" === o
                ? (c = [...a, t, e])
                : "PostInvite" === o && (c = [...a, e, t]),
                CO.components.ModalComponent.setData({ queue: c }),
                CO.components.ModalComponent.show(!1);
            }, [CO.state.isReady, CO.isFirstSession, CO.botEarnings]),
            FO() &&
              !g_.skipQR(0, OO.jsx)("div", {
                className: "disable-dbl-tap-zoom",
                children: (0, OO.jsx)("div", {
                  className: "app-container",
                  children: (0, OO.jsxs)(zO, {
                    FallbackComponent: Dx,
                    onError: Lx,
                    children: [
                      (0, OO.jsx)(Ex, { visible: !CO.state.isReady }),
                      CO.state.isReady &&
                        (0, OO.jsxs)(OO.Fragment, {
                          children: [
                            jx,
                            (0, OO.jsx)(HO, {}),
                            (0, OO.jsx)(cx, {}),
                            (0, OO.jsx)(ux, {}),
                            (0, OO.jsx)(XO, {}),
                            (0, OO.jsx)(ix, {}),
                            (0, OO.jsx)(fx, {}),
                            (0, OO.jsx)(mx, {}),
                            (0, OO.jsx)(_x, {}),
                            (0, OO.jsx)(Ix, {}),
                            (0, OO.jsxs)(OO.Fragment, {
                              children: [
                                (0, OO.jsx)(Rx, {}),
                                (0, OO.jsx)(gx, {}),
                              ],
                            }),
                          ],
                        }),
                    ],
                  }),
                }),
              })
          );
        },
        Fx = (e) => {
          e &&
            e instanceof Function &&
            n
              .e(453)
              .then(n.bind(n, 453))
              .then((t) => {
                let {
                  getCLS: n,
                  getFID: r,
                  getFCP: s,
                  getLCP: i,
                  getTTFB: o,
                } = t;
                n(e), r(e), s(e), i(e), o(e);
              });
        };
      a
        .createRoot(document.getElementById("root"))
        .render((0, OO.jsx)(o.StrictMode, { children: (0, OO.jsx)(Ux, {}) })),
        Fx();
    })();
})();
//# sourceMappingURL=main.1fc1151c.js.map
